import { Component, HostBinding, Input } from "@angular/core";
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
import * as i2 from "./utils/dynamic.directive";
export class ErrorsComponent {
    constructor() { }
    get id() {
        return this.element.id + "_errors";
    }
    get class() {
        return this.element.cssError;
    }
}
ErrorsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: ErrorsComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
ErrorsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.17", type: ErrorsComponent, selector: "'[sv-ng-errors]'", inputs: { element: "element", location: "location" }, host: { properties: { "id": "this.id", "class": "this.class" } }, ngImport: i0, template: "<ng-container *ngFor=\"let error of element.renderedErrors;\">\n  <ng-template [component]=\"{ name: element.survey.questionErrorComponent, data: { element: element, cssClasses: element.cssClasses, error: error } }\"></ng-template>\n</ng-container>\n", directives: [{ type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i2.DynamicComponentDirective, selector: "[component]", inputs: ["component"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: ErrorsComponent, decorators: [{
            type: Component,
            args: [{
                    templateUrl: "./errors.component.html",
                    selector: "'[sv-ng-errors]'"
                }]
        }], ctorParameters: function () { return []; }, propDecorators: { element: [{
                type: Input
            }], location: [{
                type: Input
            }], id: [{
                type: HostBinding,
                args: ["id"]
            }], class: [{
                type: HostBinding,
                args: ["class"]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXJyb3JzLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9lcnJvcnMuY29tcG9uZW50LnRzIiwiLi4vLi4vc3JjL2Vycm9ycy5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLFdBQVcsRUFBRSxLQUFLLEVBQUUsTUFBTSxlQUFlLENBQUM7Ozs7QUFPOUQsTUFBTSxPQUFPLGVBQWU7SUFHMUIsZ0JBQWUsQ0FBQztJQUNoQixJQUF1QixFQUFFO1FBQ3ZCLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxFQUFFLEdBQUcsU0FBUyxDQUFDO0lBQ3JDLENBQUM7SUFDRCxJQUEwQixLQUFLO1FBQzdCLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUM7SUFDL0IsQ0FBQzs7NkdBVFUsZUFBZTtpR0FBZixlQUFlLGdMQ1A1Qiw0UEFHQTs0RkRJYSxlQUFlO2tCQUozQixTQUFTO21CQUFDO29CQUNULFdBQVcsRUFBRSx5QkFBeUI7b0JBQ3RDLFFBQVEsRUFBRSxrQkFBa0I7aUJBQzdCOzBFQUVVLE9BQU87c0JBQWYsS0FBSztnQkFDRyxRQUFRO3NCQUFoQixLQUFLO2dCQUVpQixFQUFFO3NCQUF4QixXQUFXO3VCQUFDLElBQUk7Z0JBR1MsS0FBSztzQkFBOUIsV0FBVzt1QkFBQyxPQUFPIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBIb3N0QmluZGluZywgSW5wdXQgfSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuaW1wb3J0IHsgU3VydmV5RWxlbWVudCB9IGZyb20gXCJzdXJ2ZXktY29yZVwiO1xuXG5AQ29tcG9uZW50KHtcbiAgdGVtcGxhdGVVcmw6IFwiLi9lcnJvcnMuY29tcG9uZW50Lmh0bWxcIixcbiAgc2VsZWN0b3I6IFwiJ1tzdi1uZy1lcnJvcnNdJ1wiXG59KVxuZXhwb3J0IGNsYXNzIEVycm9yc0NvbXBvbmVudCB7XG4gIEBJbnB1dCgpIGVsZW1lbnQhOiBTdXJ2ZXlFbGVtZW50IHwgYW55O1xuICBASW5wdXQoKSBsb2NhdGlvbj86IHN0cmluZztcbiAgY29uc3RydWN0b3IoKSB7fVxuICBASG9zdEJpbmRpbmcoXCJpZFwiKSBnZXQgaWQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50LmlkICsgXCJfZXJyb3JzXCI7XG4gIH1cbiAgQEhvc3RCaW5kaW5nKFwiY2xhc3NcIikgZ2V0IGNsYXNzKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudC5jc3NFcnJvcjtcbiAgfVxufSIsIjxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IGVycm9yIG9mIGVsZW1lbnQucmVuZGVyZWRFcnJvcnM7XCI+XG4gIDxuZy10ZW1wbGF0ZSBbY29tcG9uZW50XT1cInsgbmFtZTogZWxlbWVudC5zdXJ2ZXkucXVlc3Rpb25FcnJvckNvbXBvbmVudCwgZGF0YTogeyBlbGVtZW50OiBlbGVtZW50LCBjc3NDbGFzc2VzOiBlbGVtZW50LmNzc0NsYXNzZXMsIGVycm9yOiBlcnJvciB9IH1cIj48L25nLXRlbXBsYXRlPlxuPC9uZy1jb250YWluZXI+XG4iXX0=