// node_modules/survey-core/fesm/survey-core.js
var DomWindowHelper = class _DomWindowHelper {
  static isAvailable() {
    return "undefined" !== typeof window;
  }
  static isFileReaderAvailable() {
    if (!_DomWindowHelper.isAvailable()) return false;
    return !!window["FileReader"];
  }
  static getLocation() {
    if (!_DomWindowHelper.isAvailable()) return;
    return window.location;
  }
  static getVisualViewport() {
    if (!_DomWindowHelper.isAvailable()) return null;
    return window.visualViewport;
  }
  static getInnerWidth() {
    if (!_DomWindowHelper.isAvailable()) return;
    return window.innerWidth;
  }
  static getInnerHeight() {
    if (!_DomWindowHelper.isAvailable()) return null;
    return window.innerHeight;
  }
  static getWindow() {
    if (!_DomWindowHelper.isAvailable()) return;
    return window;
  }
  static hasOwn(propertyName) {
    if (!_DomWindowHelper.isAvailable()) return;
    return propertyName in window;
  }
  static getSelection() {
    if (_DomWindowHelper.isAvailable() && window.getSelection) {
      return window.getSelection();
    }
  }
  static requestAnimationFrame(callback) {
    if (_DomWindowHelper.isAvailable()) {
      return window.requestAnimationFrame(callback);
    }
  }
  static addEventListener(type, listener) {
    if (!_DomWindowHelper.isAvailable()) return;
    window.addEventListener(type, listener);
  }
  static removeEventListener(type, listener) {
    if (!_DomWindowHelper.isAvailable()) return;
    window.removeEventListener(type, listener);
  }
  static matchMedia(mediaQueryString) {
    if (!_DomWindowHelper.isAvailable() || typeof window.matchMedia === "undefined") return null;
    return window.matchMedia(mediaQueryString);
  }
};
var DomDocumentHelper = class _DomDocumentHelper {
  static isAvailable() {
    return "undefined" !== typeof document;
  }
  static getBody() {
    if (!_DomDocumentHelper.isAvailable()) return;
    return document.body;
  }
  static getDocumentElement() {
    if (!_DomDocumentHelper.isAvailable()) return;
    return document.documentElement;
  }
  static getDocument() {
    if (!_DomDocumentHelper.isAvailable()) return;
    return document;
  }
  static getCookie() {
    if (!_DomDocumentHelper.isAvailable()) return;
    return document.cookie;
  }
  static setCookie(newCookie) {
    if (!_DomDocumentHelper.isAvailable()) return;
    document.cookie = newCookie;
  }
  static activeElementBlur() {
    if (!_DomDocumentHelper.isAvailable()) return;
    const activeElement = document.activeElement;
    if (!!activeElement && !!activeElement.blur) {
      activeElement.blur();
    }
  }
  static createElement(tagName) {
    if (!_DomDocumentHelper.isAvailable()) return;
    return document.createElement(tagName);
  }
  static getComputedStyle(elt) {
    if (!_DomDocumentHelper.isAvailable()) return new CSSStyleDeclaration();
    return document.defaultView.getComputedStyle(elt);
  }
  static addEventListener(type, listener) {
    if (!_DomDocumentHelper.isAvailable()) return;
    document.addEventListener(type, listener);
  }
  static removeEventListener(type, listener) {
    if (!_DomDocumentHelper.isAvailable()) return;
    document.removeEventListener(type, listener);
  }
};
function createDate(reason, val) {
  if (!val) return /* @__PURE__ */ new Date();
  if (!settings.storeUtcDates && typeof val === "string" && isISODateOnly(val)) {
    val += "T00:00:00";
  }
  const d = new Date(val);
  return settings.onDateCreated(d, reason, val);
}
function isISODateOnly(str) {
  if (str.indexOf("T") > 0) return false;
  if (!/\d{4}-\d{2}-\d{2}/.test(str)) return false;
  return !isNaN(new Date(str).getTime());
}
var Helpers = class _Helpers {
  /**
   * A static methods that returns true if a value undefined, null, empty string or empty array.
   * @param value
   */
  static isValueEmpty(value) {
    if (Array.isArray(value) && value.length === 0) return true;
    if (!!value && _Helpers.isValueObject(value) && value.constructor === Object) {
      for (var key in value) {
        if (!_Helpers.isValueEmpty(value[key])) return false;
      }
      return true;
    }
    return !value && value !== 0 && value !== false;
  }
  static isValueUndefined(value) {
    return value === void 0 || value === null || typeof value === "number" && isNaN(value);
  }
  static isArrayContainsEqual(x, y) {
    if (!Array.isArray(x) || !Array.isArray(y)) return false;
    if (x.length !== y.length) return false;
    for (var i = 0; i < x.length; i++) {
      var j = 0;
      for (; j < y.length; j++) {
        if (_Helpers.isTwoValueEquals(x[i], y[j])) break;
      }
      if (j === y.length) return false;
    }
    return true;
  }
  static isArraysEqual(x, y, ignoreOrder = false, caseSensitive, trimStrings) {
    if (!Array.isArray(x) || !Array.isArray(y)) return false;
    if (x.length !== y.length) return false;
    if (ignoreOrder) {
      var xSorted = [];
      var ySorted = [];
      for (var i = 0; i < x.length; i++) {
        xSorted.push(x[i]);
        ySorted.push(y[i]);
      }
      xSorted.sort();
      ySorted.sort();
      x = xSorted;
      y = ySorted;
    }
    for (var i = 0; i < x.length; i++) {
      if (!_Helpers.isTwoValueEquals(x[i], y[i], ignoreOrder, caseSensitive, trimStrings)) return false;
    }
    return true;
  }
  static compareStrings(x, y) {
    const normalize = settings.comparator.normalizeTextCallback;
    if (!!x) x = normalize(x, "compare").trim();
    if (!!y) y = normalize(y, "compare").trim();
    if (!x && !y) return 0;
    if (!x) return -1;
    if (!y) return 1;
    if (x === y) return 0;
    let digitIndex = -1;
    for (let i = 0; i < x.length && i < y.length; i++) {
      if (this.isCharDigit(x[i]) && this.isCharDigit(y[i])) {
        digitIndex = i;
        break;
      }
      if (x[i] !== y[i]) break;
    }
    if (digitIndex > -1) {
      let nX = this.getNumberFromStr(x, digitIndex);
      let nY = this.getNumberFromStr(y, digitIndex);
      if (!Number.isNaN(nX) && !Number.isNaN(nY) && nX !== nY) {
        return nX > nY ? 1 : -1;
      }
    }
    return x > y ? 1 : -1;
  }
  static isTwoValueEquals(x, y, ignoreOrder = false, caseSensitive, trimStrings) {
    if (x === y) return true;
    if (Array.isArray(x) && x.length === 0 && typeof y === "undefined") return true;
    if (Array.isArray(y) && y.length === 0 && typeof x === "undefined") return true;
    if ((x === void 0 || x === null) && y === "") return true;
    if ((y === void 0 || y === null) && x === "") return true;
    if (trimStrings === void 0) trimStrings = settings.comparator.trimStrings;
    if (caseSensitive === void 0) caseSensitive = settings.comparator.caseSensitive;
    if (typeof x === "string" && typeof y === "string") {
      const normalize = settings.comparator.normalizeTextCallback;
      x = normalize(x, "compare");
      y = normalize(y, "compare");
      if (trimStrings) {
        x = x.trim();
        y = y.trim();
      }
      if (!caseSensitive) {
        x = x.toLowerCase();
        y = y.toLowerCase();
      }
      return x === y;
    }
    if (x instanceof Date && y instanceof Date) return x.getTime() == y.getTime();
    if (_Helpers.isConvertibleToNumber(x) && _Helpers.isConvertibleToNumber(y)) {
      if (parseInt(x) === parseInt(y) && parseFloat(x) === parseFloat(y)) {
        return true;
      }
    }
    if (!_Helpers.isValueEmpty(x) && _Helpers.isValueEmpty(y) || _Helpers.isValueEmpty(x) && !_Helpers.isValueEmpty(y)) return false;
    if ((x === true || x === false) && typeof y == "string") {
      return x.toString() === y.toLocaleLowerCase();
    }
    if ((y === true || y === false) && typeof x == "string") {
      return y.toString() === x.toLocaleLowerCase();
    }
    if (!_Helpers.isValueObject(x) && !_Helpers.isValueObject(y)) return x == y;
    if (!_Helpers.isValueObject(x) || !_Helpers.isValueObject(y)) return false;
    if (x["equals"] && y["equals"]) return x.equals(y);
    if (Array.isArray(x) && Array.isArray(y)) {
      return _Helpers.isArraysEqual(x, y, ignoreOrder, caseSensitive, trimStrings);
    }
    for (var p in x) {
      if (!x.hasOwnProperty(p)) continue;
      if (!y.hasOwnProperty(p)) return false;
      if (!this.isTwoValueEquals(x[p], y[p], ignoreOrder, caseSensitive, trimStrings)) return false;
    }
    for (p in y) {
      if (y.hasOwnProperty(p) && !x.hasOwnProperty(p)) return false;
    }
    return true;
  }
  static randomizeArray(array) {
    for (var i = array.length - 1; i > 0; i--) {
      var j = Math.floor(Math.random() * (i + 1));
      var temp = array[i];
      array[i] = array[j];
      array[j] = temp;
    }
    return array;
  }
  static getUnbindValue(value) {
    if (Array.isArray(value)) {
      const res = [];
      for (let i = 0; i < value.length; i++) {
        res.push(_Helpers.getUnbindValue(value[i]));
      }
      return res;
    }
    if (!!value && _Helpers.isValueObject(value) && !(value instanceof Date)) {
      return JSON.parse(JSON.stringify(value));
    }
    return value;
  }
  static createCopy(obj) {
    var res = {};
    if (!obj) return res;
    for (var key in obj) {
      res[key] = obj[key];
    }
    return res;
  }
  static isConvertibleToNumber(value) {
    return value !== void 0 && value !== null && !Array.isArray(value) && !isNaN(value);
  }
  static isValueObject(val, excludeArray) {
    return val instanceof Object && (!excludeArray || !Array.isArray(val));
  }
  static isNumber(value) {
    return !isNaN(this.getNumber(value));
  }
  static getNumber(value) {
    const newValue = _Helpers.getNumberCore(value);
    return settings.parseNumber(value, newValue);
  }
  static getNumberCore(value) {
    if (typeof value == "string") {
      value = value.trim();
      if (!value) return NaN;
      if (value.indexOf("0x") == 0) {
        if (value.length > 32) return NaN;
        return parseInt(value);
      }
      if (value.length > 15 && _Helpers.isDigitsOnly(value)) return NaN;
      if (_Helpers.isStringHasOperator(value)) return NaN;
    }
    value = this.prepareStringToNumber(value);
    const res = parseFloat(value);
    if (isNaN(res) || !isFinite(value)) return NaN;
    return res;
  }
  static isStringHasOperator(str) {
    if (str.lastIndexOf("-") > 0) return false;
    if (str.lastIndexOf("+") > 0) return false;
    const operators = "*^/%";
    for (let i = 0; i < operators.length; i++) {
      if (str.indexOf(operators[i]) > -1) return true;
    }
    return false;
  }
  static prepareStringToNumber(val) {
    if (typeof val !== "string" || !val) return val;
    let i = val.indexOf(",");
    if (i > -1 && val.indexOf(",", i + 1) < 0) {
      return val.replace(",", ".");
    }
    return val;
  }
  static getMaxLength(maxLength, surveyLength) {
    if (maxLength < 0) {
      maxLength = surveyLength;
    }
    return maxLength > 0 ? maxLength : null;
  }
  static getRemainingCharacterCounterText(newValue, maxLength) {
    if (!maxLength || maxLength <= 0 || !settings.showMaxLengthIndicator) {
      return "";
    }
    const value = newValue ? newValue.length : "0";
    return [value, maxLength].join("/");
  }
  static getNumberByIndex(index, startIndexStr, parentIndex) {
    if (index < 0) return "";
    var startIndex = 1;
    var prefix = "";
    var postfix = ".";
    var isNumeric = true;
    var strIndex = "A";
    var str = "";
    const hasDigitFunc = (str2) => {
      if (!str2) return false;
      for (var i = 0; i < str2.length; i++) {
        if (_Helpers.isCharDigit(str2[i])) return true;
      }
      return false;
    };
    if (!!startIndexStr) {
      str = startIndexStr;
      var ind = str.length - 1;
      var hasDigit = hasDigitFunc(str);
      var checkLetter = function() {
        return hasDigit && !_Helpers.isCharDigit(str[ind]) || _Helpers.isCharNotLetterAndDigit(str[ind]);
      };
      while (ind >= 0 && checkLetter()) ind--;
      var newPostfix = "";
      if (ind < str.length - 1) {
        newPostfix = str.substring(ind + 1);
        str = str.substring(0, ind + 1);
      }
      ind = str.length - 1;
      while (ind >= 0) {
        if (checkLetter()) break;
        ind--;
        if (!hasDigit) break;
      }
      strIndex = str.substring(ind + 1);
      prefix = str.substring(0, ind + 1);
      if (parseInt(strIndex)) startIndex = parseInt(strIndex);
      else if (strIndex.length == 1) isNumeric = false;
      if (!!newPostfix || !!prefix) {
        postfix = newPostfix;
      }
    }
    if (parentIndex > -1 && hasDigitFunc(prefix)) {
      prefix = this.getNumberByIndex(parentIndex, prefix);
    }
    if (isNumeric) {
      let val = (index + startIndex).toString();
      while (val.length < strIndex.length) val = "0" + val;
      return prefix + val + postfix;
    }
    return prefix + String.fromCharCode(strIndex.charCodeAt(0) + index) + postfix;
  }
  static isCharNotLetterAndDigit(ch) {
    return ch.toUpperCase() == ch.toLowerCase() && !_Helpers.isCharDigit(ch);
  }
  static isCharDigit(ch) {
    return ch >= "0" && ch <= "9";
  }
  static isDigitsOnly(str) {
    if (!str) return false;
    for (let i = 0; i < str.length; i++) {
      if (!_Helpers.isCharDigit(str[i])) return false;
    }
    return true;
  }
  static getNumberFromStr(str, index) {
    if (!this.isCharDigit(str[index])) return NaN;
    let nStr = "";
    while (index < str.length && this.isCharDigit(str[index])) {
      nStr += str[index];
      index++;
    }
    if (!nStr) return NaN;
    return this.getNumber(nStr);
  }
  static countDecimals(value) {
    if (_Helpers.isNumber(value) && Math.floor(value) !== value) {
      const strs = value.toString().split(".");
      return strs.length > 1 && strs[1].length || 0;
    }
    return 0;
  }
  static correctAfterPlusMinis(a, b, res) {
    const digitsA = _Helpers.countDecimals(a);
    const digitsB = _Helpers.countDecimals(b);
    if (digitsA > 0 || digitsB > 0) {
      const digits = Math.max(digitsA, digitsB);
      res = parseFloat(res.toFixed(digits));
    }
    return res;
  }
  static sumAnyValues(a, b) {
    if (!_Helpers.isNumber(a) || !_Helpers.isNumber(b)) {
      if (Array.isArray(a) && Array.isArray(b)) return [].concat(a).concat(b);
      if (Array.isArray(a) || Array.isArray(b)) {
        const arr = Array.isArray(a) ? a : b;
        const val = arr === a ? b : a;
        if (typeof val === "string") {
          const str = arr.join(", ");
          return arr === a ? str + val : val + str;
        }
        if (typeof val === "number") {
          let res = 0;
          for (var i = 0; i < arr.length; i++) {
            if (typeof arr[i] === "number") {
              res = _Helpers.correctAfterPlusMinis(res, arr[i], res + arr[i]);
            }
          }
          return _Helpers.correctAfterPlusMinis(res, val, res + val);
        }
      }
      return a + b;
    }
    if (typeof a === "string" || typeof b === "string") return a + b;
    return _Helpers.correctAfterPlusMinis(a, b, a + b);
  }
  static correctAfterMultiple(a, b, res) {
    const digits = _Helpers.countDecimals(a) + _Helpers.countDecimals(b);
    if (digits > 0) {
      res = parseFloat(res.toFixed(digits));
    }
    return res;
  }
  static convertArrayValueToObject(src, propName, dest = void 0) {
    const res = new Array();
    if (!src || !Array.isArray(src)) return res;
    for (var i = 0; i < src.length; i++) {
      let item;
      if (Array.isArray(dest)) {
        item = _Helpers.findObjByPropValue(dest, propName, src[i]);
      }
      if (!item) {
        item = {};
        item[propName] = src[i];
      }
      res.push(item);
    }
    return res;
  }
  static findObjByPropValue(arr, propName, val) {
    for (var i = 0; i < arr.length; i++) {
      if (_Helpers.isTwoValueEquals(arr[i][propName], val)) return arr[i];
    }
    return void 0;
  }
  static convertArrayObjectToValue(src, propName) {
    const res = new Array();
    if (!src || !Array.isArray(src)) return res;
    for (var i = 0; i < src.length; i++) {
      const itemVal = !!src[i] ? src[i][propName] : void 0;
      if (!_Helpers.isValueEmpty(itemVal)) res.push(itemVal);
    }
    return res;
  }
  static convertDateToString(date) {
    const toStr = (val) => {
      if (val < 10) return "0" + val.toString();
      return val.toString();
    };
    return date.getFullYear() + "-" + toStr(date.getMonth() + 1) + "-" + toStr(date.getDate());
  }
  static convertDateTimeToString(date) {
    const toStr = (val) => {
      if (val < 10) return "0" + val.toString();
      return val.toString();
    };
    return this.convertDateToString(date) + " " + toStr(date.getHours()) + ":" + toStr(date.getMinutes());
  }
  static convertValToQuestionVal(val, inputType) {
    if (val instanceof Date) {
      if (inputType === "datetime-local") return _Helpers.convertDateTimeToString(val);
      return _Helpers.convertDateToString(val);
    }
    return this.getUnbindValue(val);
  }
  static compareVerions(ver1, ver2) {
    if (!ver1 && !ver2) return 0;
    const ver1Ar = ver1.split(".");
    const ver2Ar = ver2.split(".");
    const len1 = ver1Ar.length;
    const len2 = ver2Ar.length;
    for (let i = 0; i < len1 && i < len2; i++) {
      const str1 = ver1Ar[i];
      const str2 = ver2Ar[i];
      if (str1.length === str2.length) {
        if (str1 !== str2) {
          return str1 < str2 ? -1 : 1;
        }
      } else {
        return str1.length < str2.length ? -1 : 1;
      }
    }
    return len1 === len2 ? 0 : len1 < len2 ? -1 : 1;
  }
  static isUrlYoutubeVideo(url) {
    if (!url) return false;
    const youtubeDomains = ["www.youtube.com", "m.youtube.com", "youtube.com", "youtu.be"];
    url = url.toLowerCase();
    url = url.replace(/^https?:\/\//, "");
    for (let i = 0; i < youtubeDomains.length; i++) {
      if (url.indexOf(youtubeDomains[i] + "/") === 0) return true;
    }
    return false;
  }
};
if (!String.prototype["format"]) {
  String.prototype["format"] = function() {
    var args = arguments;
    return this.replace(/{(\d+)}/g, function(match, number) {
      return typeof args[number] != "undefined" ? args[number] : match;
    });
  };
}
var englishStrings = {
  pagePrevText: "Previous",
  pageNextText: "Next",
  completeText: "Complete",
  previewText: "Preview",
  editText: "Edit",
  startSurveyText: "Start",
  otherItemText: "Other (describe)",
  noneItemText: "None",
  refuseItemText: "Refuse to answer",
  dontKnowItemText: "Don't know",
  selectAllItemText: "Select All",
  deselectAllItemText: "Deselect all",
  progressText: "Page {0} of {1}",
  indexText: "{0} of {1}",
  panelDynamicProgressText: "{0} of {1}",
  panelDynamicTabTextFormat: "Panel {panelIndex}",
  questionsProgressText: "Answered {0}/{1} questions",
  emptySurvey: "The survey doesn't contain any visible elements.",
  completingSurvey: "Thank you for completing the survey",
  completingSurveyBefore: "You have already completed this survey.",
  loadingSurvey: "Loading Survey...",
  placeholder: "Select...",
  ratingOptionsCaption: "Select...",
  value: "value",
  requiredError: "Response required.",
  requiredErrorInPanel: "Response required: answer at least one question.",
  requiredInAllRowsError: "Response required: answer questions in all rows.",
  eachRowUniqueError: "Each row must have a unique value.",
  numericError: "The value should be numeric.",
  minError: "The value should not be less than {0}",
  maxError: "The value should not be greater than {0}",
  textNoDigitsAllow: "Numbers are not allowed.",
  textMinLength: "Please enter at least {0} character(s).",
  textMaxLength: "Please enter no more than {0} character(s).",
  textMinMaxLength: "Please enter at least {0} and no more than {1} characters.",
  minRowCountError: "Please fill in at least {0} row(s).",
  minSelectError: "Please select at least {0} option(s).",
  maxSelectError: "Please select no more than {0} option(s).",
  numericMinMax: "The '{0}' should be at least {1} and at most {2}",
  numericMin: "The '{0}' should be at least {1}",
  numericMax: "The '{0}' should be at most {1}",
  invalidEmail: "Please enter a valid e-mail address.",
  invalidExpression: "The expression: {0} should return 'true'.",
  urlRequestError: "The request returned error '{0}'. {1}",
  urlGetChoicesError: "The request returned empty data or the 'path' property is incorrect",
  exceedMaxSize: "The file size should not exceed {0}.",
  noUploadFilesHandler: "Files cannot be uploaded. Please add a handler for the 'onUploadFiles' event.",
  otherRequiredError: "Response required: enter another value.",
  uploadingFile: "Your file is uploading. Please wait several seconds and try again.",
  loadingFile: "Loading...",
  chooseFile: "Choose file(s)...",
  noFileChosen: "No file selected",
  filePlaceholder: "Drag and drop a file here or click the button below to select a file to upload.",
  confirmDelete: "Are you sure you want to delete this record?",
  keyDuplicationError: "This value should be unique.",
  addColumn: "Add Column",
  addRow: "Add Row",
  removeRow: "Remove",
  noRowsText: "There are no rows.",
  addPanel: "Add new",
  removePanel: "Remove",
  showDetails: "Show Details",
  hideDetails: "Hide Details",
  choices_Item: "item",
  choices_Choice: "Choice option",
  matrix_column: "Column",
  matrix_row: "Row",
  multipletext_itemname: "text",
  savingData: "The results are being saved on the server...",
  savingDataError: "An error occurred and we could not save the results.",
  savingDataSuccess: "The results were saved successfully!",
  savingExceedSize: "Your response exceeds 64KB. Please reduce the size of your file(s) and try again or contact the survey owner.",
  saveAgainButton: "Try again",
  timerMin: "min",
  timerSec: "sec",
  timerSpentAll: "You have spent {0} on this page and {1} in total.",
  timerSpentPage: "You have spent {0} on this page.",
  timerSpentSurvey: "You have spent {0} in total.",
  timerLimitAll: "You have spent {0} of {1} on this page and {2} of {3} in total.",
  timerLimitPage: "You have spent {0} of {1} on this page.",
  timerLimitSurvey: "You have spent {0} of {1} in total.",
  clearCaption: "Clear",
  signaturePlaceHolder: "Sign here",
  signaturePlaceHolderReadOnly: "No signature",
  chooseFileCaption: "Select File",
  takePhotoCaption: "Take Photo",
  photoPlaceholder: "Click the button below to take a photo using the camera.",
  fileOrPhotoPlaceholder: "Drag and drop or select a file to upload or take a photo using the camera.",
  replaceFileCaption: "Replace file",
  removeFileCaption: "Remove this file",
  booleanCheckedLabel: "Yes",
  booleanUncheckedLabel: "No",
  confirmRemoveFile: "Are you sure that you want to remove this file: {0}?",
  confirmRemoveAllFiles: "Are you sure that you want to remove all files?",
  questionTitlePatternText: "Question Title",
  modalCancelButtonText: "Cancel",
  modalApplyButtonText: "Apply",
  filterStringPlaceholder: "Type to search...",
  emptyMessage: "No data to display",
  noEntriesText: "No entries yet.\nClick the button below to add a new entry.",
  noEntriesReadonlyText: "No entries",
  tabTitlePlaceholder: "New Panel",
  more: "More",
  tagboxDoneButtonCaption: "OK",
  selectToRankEmptyRankedAreaText: "All choices are selected for ranking",
  selectToRankEmptyUnrankedAreaText: "Drag choices here to rank them",
  ok: "OK",
  cancel: "Cancel"
};
var surveyLocalization = {
  currentLocaleValue: "",
  defaultLocaleValue: "en",
  locales: {},
  localeNames: {},
  localeNamesInEnglish: {},
  localeDirections: {},
  supportedLocales: [],
  useEnglishNames: false,
  //TODO remove on next week
  get showNamesInEnglish() {
    return this.useEnglishNames;
  },
  set showNamesInEnglish(val) {
    this.useEnglishNames = val;
  },
  setupLocale(localeConfig) {
    const loc = localeConfig.localeCode;
    this.locales[loc] = localeConfig.strings;
    this.localeNames[loc] = localeConfig.nativeName;
    this.localeNamesInEnglish[loc] = localeConfig.englishName;
    if (localeConfig.rtl !== void 0) {
      this.localeDirections[loc] = localeConfig.rtl;
    }
  },
  get currentLocale() {
    return this.currentLocaleValue === this.defaultLocaleValue ? "" : this.currentLocaleValue;
  },
  set currentLocale(val) {
    if (val === "cz") val = "cs";
    this.currentLocaleValue = val;
  },
  get defaultLocale() {
    return this.defaultLocaleValue;
  },
  set defaultLocale(val) {
    if (val === "cz") val = "cs";
    this.defaultLocaleValue = val;
  },
  getLocaleStrings(loc) {
    return this.locales[loc];
  },
  getString: function(strName, locale = null) {
    const locs = new Array();
    const addLocaleCore = (locName) => {
      const strs = this.locales[locName];
      if (!!strs) locs.push(strs);
    };
    const addLocale = (locName) => {
      if (!locName) return;
      addLocaleCore(locName);
      const index = locName.indexOf("-");
      if (index < 1) return;
      locName = locName.substring(0, index);
      addLocaleCore(locName);
    };
    addLocale(locale);
    addLocale(this.currentLocale);
    addLocale(this.defaultLocale);
    if (this.defaultLocale !== "en") {
      addLocaleCore("en");
    }
    for (let i = 0; i < locs.length; i++) {
      const res = locs[i][strName];
      if (res !== void 0) return res;
    }
    return this.onGetExternalString(strName, locale);
  },
  getLocaleName(loc, inEnglish) {
    if (!loc) return "";
    if (inEnglish === void 0) inEnglish = this.showNamesInEnglish;
    const firstNames = inEnglish ? this.localeNamesInEnglish : this.localeNames;
    const secondNames = inEnglish ? this.localeNames : this.localeNamesInEnglish;
    return firstNames[loc] || secondNames[loc] || loc;
  },
  getLocales: function(removeDefaultLoc = false) {
    var res = [];
    res.push("");
    var locs = this.locales;
    if (this.supportedLocales && this.supportedLocales.length > 0) {
      locs = {};
      for (var i = 0; i < this.supportedLocales.length; i++) {
        locs[this.supportedLocales[i]] = true;
      }
    }
    for (var key in locs) {
      if (removeDefaultLoc && key == this.defaultLocale) continue;
      res.push(key);
    }
    var locName = (loc) => {
      return this.getLocaleName(loc).toLowerCase();
    };
    res.sort((a, b) => {
      var str1 = locName(a);
      var str2 = locName(b);
      if (str1 === str2) return 0;
      return str1 < str2 ? -1 : 1;
    });
    return res;
  },
  onGetExternalString: function(name, locale) {
    return void 0;
  }
};
function getLocaleString(strName, locale = null) {
  return surveyLocalization.getString(strName, locale);
}
surveyLocalization.locales["en"] = englishStrings;
surveyLocalization.localeNames["en"] = "english";
function ensureLocString(target, options, key) {
  let locString = target.getLocalizableString(key);
  if (!locString) {
    let defaultStr;
    if (typeof options.localizable === "object" && options.localizable.defaultStr) {
      defaultStr = options.localizable.defaultStr;
    }
    locString = target.createLocalizableString(key, target, true, defaultStr);
    if (typeof options.localizable === "object" && typeof options.localizable.onGetTextCallback === "function") {
      locString.onGetTextCallback = options.localizable.onGetTextCallback;
    }
  }
}
function getLocStringValue(target, options, key) {
  ensureLocString(target, options, key);
  let res = target.getLocalizableStringText(key);
  if (!!res) return res;
  if (typeof options.localizable === "object" && options.localizable.defaultStr) {
    const loc = !!target.getLocale ? target.getLocale() : "";
    return getLocaleString(options.localizable.defaultStr, loc);
  }
  return "";
}
function property(options = {}) {
  return function(target, key) {
    let processComputedUpdater = (obj, val) => {
      if (!!val && typeof val === "object" && val.type === ComputedUpdater.ComputedUpdaterType) {
        Base.startCollectDependencies(() => obj[key] = val.updater(), obj, key);
        const result = val.updater();
        const dependencies = Base.finishCollectDependencies();
        val.setDependencies(dependencies);
        if (obj.dependencies[key]) {
          obj.dependencies[key].dispose();
        }
        obj.dependencies[key] = val;
        return result;
      }
      return val;
    };
    if (!options || !options.localizable) {
      Object.defineProperty(target, key, {
        get: function() {
          let defaultVal = null;
          if (!!options) {
            if (typeof options.getDefaultValue === "function") {
              defaultVal = options.getDefaultValue(this);
            }
            if (options.defaultValue !== void 0) {
              defaultVal = options.defaultValue;
            }
          }
          return this.getPropertyValue(key, defaultVal);
        },
        set: function(val) {
          const newValue = processComputedUpdater(this, val);
          const prevValue = this.getPropertyValue(key);
          if (newValue !== prevValue) {
            this.setPropertyValue(key, newValue);
            if (!!options && options.onSet) {
              options.onSet(newValue, this, prevValue);
            }
          }
        }
      });
    } else {
      Object.defineProperty(target, key, {
        get: function() {
          return getLocStringValue(this, options, key);
        },
        set: function(val) {
          ensureLocString(this, options, key);
          const newValue = processComputedUpdater(this, val);
          this.setLocalizableStringText(key, newValue);
          if (!!options && options.onSet) {
            options.onSet(newValue, this);
          }
        }
      });
      Object.defineProperty(target, typeof options.localizable === "object" && !!options.localizable.name ? options.localizable.name : "loc" + key.charAt(0).toUpperCase() + key.slice(1), {
        get: function() {
          ensureLocString(this, options, key);
          return this.getLocalizableString(key);
        }
      });
    }
  };
}
function ensureArray(target, options, key) {
  target.ensureArray(key, (item, index) => {
    const handler = !!options ? options.onPush : null;
    handler && handler(item, index, target);
  }, (item, index) => {
    const handler = !!options ? options.onRemove : null;
    handler && handler(item, index, target);
  });
}
function propertyArray(options) {
  return function(target, key) {
    Object.defineProperty(target, key, {
      get: function() {
        ensureArray(this, options, key);
        return this.getPropertyValue(key);
      },
      set: function(val) {
        ensureArray(this, options, key);
        const arr = this.getPropertyValue(key);
        if (val === arr) {
          return;
        }
        if (arr) {
          arr.splice(0, arr.length, ...val || []);
        } else {
          this.setPropertyValue(key, val);
        }
        if (!!options && options.onSet) {
          options.onSet(val, this);
        }
      }
    });
  };
}
var JsonObjectProperty = class _JsonObjectProperty {
  constructor(classInfo, name, isRequired = false) {
    this.name = name;
    this.isRequiredValue = false;
    this.isUniqueValue = false;
    this.isSerializable = true;
    this.isLightSerializable = true;
    this.isCustom = false;
    this.isDynamicChoices = false;
    this.isBindable = false;
    this.category = "";
    this.categoryIndex = -1;
    this.visibleIndex = -1;
    this.maxLength = -1;
    this.isArray = false;
    this.classInfoValue = classInfo;
    this.isRequiredValue = isRequired;
    this.idValue = _JsonObjectProperty.Index++;
  }
  get id() {
    return this.idValue;
  }
  get classInfo() {
    return this.classInfoValue;
  }
  get type() {
    return this.typeValue ? this.typeValue : "string";
  }
  set type(value) {
    if (value === "itemvalues") value = "itemvalue[]";
    if (value === "textitems") value = "textitem[]";
    this.typeValue = value;
    if (this.typeValue.indexOf("[]") === this.typeValue.length - 2) {
      this.isArray = true;
      this.className = this.typeValue.substring(0, this.typeValue.length - 2);
    }
  }
  get locationInTable() {
    const res = this.locationInTableValue;
    return !!res ? res : "both";
  }
  set locationInTable(val) {
    if (val === "both") val = void 0;
    this.locationInTableValue = val;
  }
  get showMode() {
    const res = this.locationInTable;
    return res === "detail" ? "form" : res === "column" ? "list" : "";
  }
  set showMode(val) {
    this.locationInTable = val === "form" ? "detail" : val === "list" ? "column" : void 0;
  }
  get isRequired() {
    return this.isRequiredValue;
  }
  set isRequired(val) {
    if (val !== this.isRequired) {
      this.isRequiredValue = val;
      if (!!this.classInfo) {
        this.classInfo.resetAllProperties();
      }
    }
  }
  get isUnique() {
    return this.isUniqueValue;
  }
  set isUnique(val) {
    this.isUniqueValue = val;
  }
  get uniquePropertyName() {
    return this.uniquePropertyValue;
  }
  set uniquePropertyName(val) {
    this.uniquePropertyValue = val;
  }
  isPropertySerializable(obj) {
    if (this.isSerializableFunc) return this.isSerializableFunc(obj);
    return this.isSerializable;
  }
  getDefaultValue(obj) {
    let result = !!this.defaultValueFunc ? this.defaultValueFunc(obj) : this.defaultValueValue;
    if (!!_JsonObjectProperty.getItemValuesDefaultValue && Serializer.isDescendantOf(this.className, "itemvalue")) {
      result = _JsonObjectProperty.getItemValuesDefaultValue(this.defaultValueValue || [], this.className);
    }
    return result;
  }
  get defaultValue() {
    return this.getDefaultValue(void 0);
  }
  set defaultValue(newValue) {
    this.defaultValueValue = newValue;
  }
  isDefaultValue(value) {
    return this.isDefaultValueByObj(void 0, value);
  }
  isDefaultValueByObj(obj, value) {
    if (this.isLocalizable) return value === null || value === void 0;
    const dValue = this.getDefaultValue(obj);
    if (dValue !== void 0) {
      if (typeof dValue !== "object") return dValue === value;
      return Helpers.isTwoValueEquals(value, dValue, false, true, false);
    }
    return value === false && (this.type == "boolean" || this.type == "switch") && !this.defaultValueFunc || value === "" || Helpers.isValueEmpty(value);
  }
  getSerializableValue(obj, storeDefaults) {
    if (!!this.onSerializeValue) return this.onSerializeValue(obj);
    const value = this.getValue(obj);
    if (value === void 0 || value === null) return void 0;
    if (!storeDefaults && this.isDefaultValueByObj(obj, value)) return void 0;
    return value;
  }
  getValue(obj) {
    if (this.onGetValue) {
      obj = this.getOriginalObj(obj);
      return this.onGetValue(obj);
    }
    if (this.serializationProperty && !!obj[this.serializationProperty]) return obj[this.serializationProperty].getJson();
    return obj[this.name];
  }
  getPropertyValue(obj) {
    if (this.isLocalizable) {
      return !!obj[this.serializationProperty] ? obj[this.serializationProperty].text : null;
    }
    return this.getValue(obj);
  }
  get hasToUseSetValue() {
    return this.onSetValue || this.serializationProperty;
  }
  settingValue(obj, value) {
    if (!this.onSettingValue || obj.isLoadingFromJson) return value;
    return this.onSettingValue(obj, value);
  }
  setValue(obj, value, jsonConv) {
    if (this.onSetValue) {
      obj = this.getOriginalObj(obj);
      this.onSetValue(obj, value, jsonConv);
    } else {
      if (this.serializationProperty && !!obj[this.serializationProperty]) obj[this.serializationProperty].setJson(value, true);
      else {
        if (value && typeof value === "string") {
          if (this.type == "number") {
            value = parseInt(value);
          }
          if (this.type == "boolean" || this.type == "switch") {
            value = value.toLowerCase() === "true";
          }
        }
        obj[this.name] = value;
      }
    }
  }
  validateValue(value) {
    const choices = this.choices;
    if (!Array.isArray(choices) || choices.length === 0) return true;
    return choices.indexOf(value) > -1;
  }
  getObjType(objType) {
    if (!this.classNamePart) return objType;
    return objType.replace(this.classNamePart, "");
  }
  /**
   * Depricated, please use getChoices
   */
  get choices() {
    return this.getChoices(null);
  }
  get hasChoices() {
    return !!this.choicesValue || !!this.choicesfunc;
  }
  getChoices(obj, choicesCallback = null) {
    if (this.choicesValue != null) return this.choicesValue;
    if (this.choicesfunc != null) return this.choicesfunc(obj, choicesCallback);
    return null;
  }
  setChoices(value, valueFunc = null) {
    this.choicesValue = value;
    this.choicesfunc = valueFunc;
  }
  getBaseValue() {
    if (!this.baseValue) return "";
    if (typeof this.baseValue == "function") return this.baseValue();
    return this.baseValue;
  }
  setBaseValue(val) {
    this.baseValue = val;
  }
  get readOnly() {
    return this.readOnlyValue != null ? this.readOnlyValue : false;
  }
  set readOnly(val) {
    this.readOnlyValue = val;
  }
  isEnable(obj) {
    if (this.readOnly) return false;
    if (!obj || !this.enableIf) return true;
    return this.enableIf(this.getOriginalObj(obj));
  }
  isVisible(layout, obj = null) {
    let isLayout = !this.layout || !layout || this.layout === layout;
    if (!this.visible || !isLayout) return false;
    if (!!this.visibleIf && !!obj) {
      return this.visibleIf(this.getOriginalObj(obj));
    }
    return true;
  }
  getOriginalObj(obj) {
    if (obj && obj.getOriginalObj) {
      const orjObj = obj.getOriginalObj();
      if (orjObj && Serializer.findProperty(orjObj.getType(), this.name)) {
        return orjObj;
      }
    }
    return obj;
  }
  get visible() {
    return this.visibleValue != null ? this.visibleValue : true;
  }
  set visible(val) {
    this.visibleValue = val;
  }
  isAvailableInVersion(ver) {
    if (!!this.alternativeName || this.oldName) return true;
    return this.isAvailableInVersionCore(ver);
  }
  getSerializedName(ver) {
    if (!this.alternativeName) return this.name;
    return this.isAvailableInVersionCore(ver) ? this.name : this.alternativeName || this.oldName;
  }
  getSerializedProperty(obj, ver) {
    if (!this.oldName || this.isAvailableInVersionCore(ver)) return this;
    if (!obj || !obj.getType) return null;
    return Serializer.findProperty(obj.getType(), this.oldName);
  }
  isAvailableInVersionCore(ver) {
    if (!ver || !this.version) return true;
    return Helpers.compareVerions(this.version, ver) <= 0;
  }
  get isLocalizable() {
    return this.isLocalizableValue != null ? this.isLocalizableValue : false;
  }
  set isLocalizable(val) {
    this.isLocalizableValue = val;
  }
  get dataList() {
    return Array.isArray(this.dataListValue) ? this.dataListValue : [];
  }
  set dataList(val) {
    this.dataListValue = val;
  }
  mergeWith(prop) {
    var valuesNames = _JsonObjectProperty.mergableValues;
    for (var i = 0; i < valuesNames.length; i++) {
      this.mergeValue(prop, valuesNames[i]);
    }
  }
  addDependedProperty(name) {
    if (!this.dependedProperties) {
      this.dependedProperties = [];
    }
    if (this.dependedProperties.indexOf(name) < 0) {
      this.dependedProperties.push(name);
    }
  }
  getDependedProperties() {
    return !!this.dependedProperties ? this.dependedProperties : [];
  }
  schemaType() {
    if (this.className === "choicesByUrl") return void 0;
    if (this.className === "string") return this.className;
    if (!!this.className) return "array";
    if (!!this.baseClassName) return "array";
    if (this.type == "switch") return "boolean";
    if (this.type == "boolean" || this.type == "number") return this.type;
    return "string";
  }
  schemaRef() {
    if (!!this.className) return this.className;
    return void 0;
  }
  mergeValue(prop, valueName) {
    if (this[valueName] == null && prop[valueName] != null) {
      this[valueName] = prop[valueName];
    }
  }
};
JsonObjectProperty.Index = 1;
JsonObjectProperty.mergableValues = ["typeValue", "choicesValue", "baseValue", "readOnlyValue", "visibleValue", "isSerializable", "isLightSerializable", "isCustom", "isBindable", "isUnique", "uniquePropertyName", "isDynamicChoices", "isLocalizableValue", "className", "alternativeName", "oldName", "layout", "version", "classNamePart", "baseClassName", "defaultValue", "defaultValueFunc", "serializationProperty", "onGetValue", "onSetValue", "onSettingValue", "displayName", "category", "categoryIndex", "visibleIndex", "nextToProperty", "overridingProperty", "locationInTable", "dependedProperties", "visibleIf", "enableIf", "onExecuteExpression", "onPropertyEditorUpdate", "maxLength", "maxValue", "minValue", "dataListValue"];
var CustomPropertiesCollection = class _CustomPropertiesCollection {
  static addProperty(className, property2) {
    className = className.toLowerCase();
    var props = _CustomPropertiesCollection.properties;
    if (!props[className]) {
      props[className] = [];
    }
    props[className].push(property2);
  }
  static removeProperty(className, propertyName) {
    className = className.toLowerCase();
    var props = _CustomPropertiesCollection.properties;
    if (!props[className]) return;
    var properties = props[className];
    for (var i = 0; i < properties.length; i++) {
      if (properties[i].name == propertyName) {
        props[className].splice(i, 1);
        break;
      }
    }
  }
  static removeAllProperties(className) {
    className = className.toLowerCase();
    delete _CustomPropertiesCollection.properties[className];
  }
  static addClass(className, parentClassName) {
    className = className.toLowerCase();
    if (parentClassName) {
      parentClassName = parentClassName.toLowerCase();
    }
    _CustomPropertiesCollection.parentClasses[className] = parentClassName;
  }
  static getProperties(className) {
    className = className.toLowerCase();
    var res = [];
    var props = _CustomPropertiesCollection.properties;
    while (className) {
      var properties = props[className];
      if (properties) {
        for (var i = 0; i < properties.length; i++) {
          res.push(properties[i]);
        }
      }
      className = _CustomPropertiesCollection.parentClasses[className];
    }
    return res;
  }
  static createProperties(obj) {
    if (!obj || !obj.getType) return;
    _CustomPropertiesCollection.createPropertiesCore(obj, obj.getType());
  }
  static createPropertiesCore(obj, className) {
    var props = _CustomPropertiesCollection.properties;
    if (props[className]) {
      _CustomPropertiesCollection.createPropertiesInObj(obj, props[className]);
    }
    var parentClass = _CustomPropertiesCollection.parentClasses[className];
    if (parentClass) {
      _CustomPropertiesCollection.createPropertiesCore(obj, parentClass);
    }
  }
  static createPropertiesInObj(obj, properties) {
    for (var i = 0; i < properties.length; i++) {
      _CustomPropertiesCollection.createPropertyInObj(obj, properties[i]);
    }
  }
  static createPropertyInObj(obj, prop) {
    if (_CustomPropertiesCollection.checkIsPropertyExists(obj, prop.name)) return;
    if (!!prop.serializationProperty && _CustomPropertiesCollection.checkIsPropertyExists(obj, prop.serializationProperty)) return;
    if (prop.isLocalizable && prop.serializationProperty && obj.createCustomLocalizableObj) {
      const locStr = obj.createCustomLocalizableObj(prop.name);
      locStr.defaultValue = prop.getDefaultValue(obj);
      var locDesc = {
        get: function() {
          return obj.getLocalizableString(prop.name);
        }
      };
      Object.defineProperty(obj, prop.serializationProperty, locDesc);
      var desc = {
        get: function() {
          return obj.getLocalizableStringText(prop.name);
        },
        set: function(v) {
          obj.setLocalizableStringText(prop.name, v);
        }
      };
      Object.defineProperty(obj, prop.name, desc);
    } else {
      var isArrayProp = prop.isArray || prop.type === "multiplevalues";
      if (typeof obj.createNewArray === "function") {
        if (Serializer.isDescendantOf(prop.className, "itemvalue")) {
          obj.createNewArray(prop.name, function(item) {
            item.locOwner = obj;
            item.ownerPropertyName = prop.name;
          });
          isArrayProp = true;
        } else {
          if (isArrayProp) {
            obj.createNewArray(prop.name);
          }
        }
        if (isArrayProp) {
          const defaultValue = prop.getDefaultValue(obj);
          if (Array.isArray(defaultValue)) {
            obj.setPropertyValue(prop.name, defaultValue);
          }
        }
      }
      if (!!obj.getPropertyValue && !!obj.setPropertyValue) {
        var desc = {
          get: () => {
            if (!!prop.onGetValue) {
              return prop.onGetValue(obj);
            }
            return obj.getPropertyValue(prop.name, void 0);
          },
          set: function(v) {
            if (!!prop.onSetValue) {
              prop.onSetValue(obj, v, null);
            } else {
              obj.setPropertyValue(prop.name, v);
            }
          }
        };
        Object.defineProperty(obj, prop.name, desc);
      }
    }
    if (prop.type === "condition" || prop.type === "expression") {
      if (!!prop.onExecuteExpression) {
        obj.addExpressionProperty(prop.name, prop.onExecuteExpression);
      }
    }
  }
  static checkIsPropertyExists(obj, name) {
    return obj.hasOwnProperty(name) || obj[name];
  }
};
CustomPropertiesCollection.properties = {};
CustomPropertiesCollection.parentClasses = {};
var JsonMetadataClass = class _JsonMetadataClass {
  constructor(name, properties, creator = null, parentName = null) {
    this.name = name;
    this.creator = creator;
    this.parentName = parentName;
    name = name.toLowerCase();
    this.isCustomValue = !creator && name !== "survey";
    if (this.parentName) {
      this.parentName = this.parentName.toLowerCase();
      CustomPropertiesCollection.addClass(name, this.parentName);
      if (!!creator) {
        this.makeParentRegularClass();
      }
    }
    this.properties = new Array();
    for (var i = 0; i < properties.length; i++) {
      this.createProperty(properties[i], this.isCustom);
    }
  }
  //Obsolete
  find(name) {
    for (var i = 0; i < this.properties.length; i++) {
      if (this.properties[i].name == name) return this.properties[i];
    }
    return null;
  }
  findProperty(name) {
    this.fillAllProperties();
    return this.hashProperties[name];
  }
  getAllProperties() {
    this.fillAllProperties();
    return this.allProperties;
  }
  getRequiredProperties() {
    if (!!this.requiredProperties) return this.requiredProperties;
    this.requiredProperties = [];
    const props = this.getAllProperties();
    for (let i = 0; i < props.length; i++) {
      if (props[i].isRequired) this.requiredProperties.push(props[i]);
    }
    return this.requiredProperties;
  }
  resetAllProperties() {
    this.allProperties = void 0;
    this.requiredProperties = void 0;
    this.hashProperties = void 0;
    var childClasses = Serializer.getChildrenClasses(this.name);
    for (var i = 0; i < childClasses.length; i++) {
      childClasses[i].resetAllProperties();
    }
  }
  get isCustom() {
    return this.isCustomValue;
  }
  fillAllProperties() {
    if (!!this.allProperties) return;
    this.allProperties = [];
    this.hashProperties = {};
    const localProperties = {};
    this.properties.forEach((prop) => localProperties[prop.name] = prop);
    const parentClass = !!this.parentName ? Serializer.findClass(this.parentName) : null;
    if (!!parentClass) {
      const parentProperties = parentClass.getAllProperties();
      parentProperties.forEach((prop) => {
        const overridedProp = localProperties[prop.name];
        if (!!overridedProp) {
          overridedProp.mergeWith(prop);
          this.addPropCore(overridedProp);
        } else {
          this.addPropCore(prop);
        }
      });
    }
    this.properties.forEach((prop) => {
      if (!this.hashProperties[prop.name]) {
        this.addPropCore(prop);
      }
    });
  }
  addPropCore(prop) {
    this.allProperties.push(prop);
    this.hashProperties[prop.name] = prop;
    if (!!prop.alternativeName) {
      this.hashProperties[prop.alternativeName] = prop;
    }
  }
  isOverridedProp(propName) {
    return !!this.parentName && !!Serializer.findProperty(this.parentName, propName);
  }
  hasRegularChildClass() {
    if (!this.isCustom) return;
    this.isCustomValue = false;
    for (var i = 0; i < this.properties.length; i++) {
      this.properties[i].isCustom = false;
    }
    CustomPropertiesCollection.removeAllProperties(this.name);
    this.makeParentRegularClass();
  }
  makeParentRegularClass() {
    if (!this.parentName) return;
    const parent = Serializer.findClass(this.parentName);
    if (!!parent) {
      parent.hasRegularChildClass();
    }
  }
  createProperty(propInfo, isCustom = false) {
    var propertyName = typeof propInfo === "string" ? propInfo : propInfo.name;
    if (!propertyName) return;
    var propertyType = null;
    var typeIndex = propertyName.indexOf(_JsonMetadataClass.typeSymbol);
    if (typeIndex > -1) {
      propertyType = propertyName.substring(typeIndex + 1);
      propertyName = propertyName.substring(0, typeIndex);
    }
    var isRequired = this.getIsPropertyNameRequired(propertyName) || !!propInfo.isRequired;
    propertyName = this.getPropertyName(propertyName);
    var prop = new JsonObjectProperty(this, propertyName, isRequired);
    if (propertyType) {
      prop.type = propertyType;
    }
    if (typeof propInfo === "object") {
      if (propInfo.type) {
        prop.type = propInfo.type;
      }
      if (propInfo.default !== void 0) {
        prop.defaultValue = propInfo.default;
      }
      if (propInfo.defaultFunc !== void 0) {
        prop.defaultValueFunc = propInfo.defaultFunc;
      }
      if (!Helpers.isValueEmpty(propInfo.isSerializable)) {
        prop.isSerializable = propInfo.isSerializable;
      }
      if (!Helpers.isValueEmpty(propInfo.isSerializableFunc)) {
        prop.isSerializableFunc = propInfo.isSerializableFunc;
      }
      if (!Helpers.isValueEmpty(propInfo.isLightSerializable)) {
        prop.isLightSerializable = propInfo.isLightSerializable;
      }
      if (!Helpers.isValueEmpty(propInfo.maxLength)) {
        prop.maxLength = propInfo.maxLength;
      }
      if (propInfo.displayName !== void 0) {
        prop.displayName = propInfo.displayName;
      }
      if (!Helpers.isValueEmpty(propInfo.category)) {
        prop.category = propInfo.category;
      }
      if (!Helpers.isValueEmpty(propInfo.categoryIndex)) {
        prop.categoryIndex = propInfo.categoryIndex;
      }
      if (!Helpers.isValueEmpty(propInfo.nextToProperty)) {
        prop.nextToProperty = propInfo.nextToProperty;
      }
      if (!Helpers.isValueEmpty(propInfo.overridingProperty)) {
        prop.overridingProperty = propInfo.overridingProperty;
      }
      if (!Helpers.isValueEmpty(propInfo.visibleIndex)) {
        prop.visibleIndex = propInfo.visibleIndex;
      }
      if (!Helpers.isValueEmpty(propInfo.showMode)) {
        prop.showMode = propInfo.showMode;
      }
      if (!Helpers.isValueEmpty(propInfo.locationInTable)) {
        prop.locationInTable = propInfo.locationInTable;
      }
      if (!Helpers.isValueEmpty(propInfo.maxValue)) {
        prop.maxValue = propInfo.maxValue;
      }
      if (!Helpers.isValueEmpty(propInfo.minValue)) {
        prop.minValue = propInfo.minValue;
      }
      if (!Helpers.isValueEmpty(propInfo.dataList)) {
        prop.dataList = propInfo.dataList;
      }
      if (!Helpers.isValueEmpty(propInfo.isDynamicChoices)) {
        prop.isDynamicChoices = propInfo.isDynamicChoices;
      }
      if (!Helpers.isValueEmpty(propInfo.isBindable)) {
        prop.isBindable = propInfo.isBindable;
      }
      if (!Helpers.isValueEmpty(propInfo.isUnique)) {
        prop.isUnique = propInfo.isUnique;
      }
      if (!Helpers.isValueEmpty(propInfo.uniqueProperty)) {
        prop.uniquePropertyName = propInfo.uniqueProperty;
      }
      if (!Helpers.isValueEmpty(propInfo.isArray)) {
        prop.isArray = propInfo.isArray;
      }
      if (propInfo.visible === true || propInfo.visible === false) {
        prop.visible = propInfo.visible;
      }
      if (!!propInfo.visibleIf) {
        prop.visibleIf = propInfo.visibleIf;
      }
      if (!!propInfo.enableIf) {
        prop.enableIf = propInfo.enableIf;
      }
      if (!!propInfo.onExecuteExpression) {
        prop.onExecuteExpression = propInfo.onExecuteExpression;
      }
      if (!!propInfo.onPropertyEditorUpdate) {
        prop.onPropertyEditorUpdate = propInfo.onPropertyEditorUpdate;
      }
      if (propInfo.readOnly === true) {
        prop.readOnly = true;
      }
      if (propInfo.availableInMatrixColumn === true) {
        prop.availableInMatrixColumn = true;
      }
      if (propInfo.choices) {
        var choicesFunc = typeof propInfo.choices === "function" ? propInfo.choices : null;
        var choicesValue = typeof propInfo.choices !== "function" ? propInfo.choices : null;
        prop.setChoices(choicesValue, choicesFunc);
      }
      if (!!propInfo.baseValue) {
        prop.setBaseValue(propInfo.baseValue);
      }
      if (propInfo.onSerializeValue) {
        prop.onSerializeValue = propInfo.onSerializeValue;
      }
      if (propInfo.onGetValue) {
        prop.onGetValue = propInfo.onGetValue;
      }
      if (propInfo.onSetValue) {
        prop.onSetValue = propInfo.onSetValue;
      }
      if (propInfo.onSettingValue) {
        prop.onSettingValue = propInfo.onSettingValue;
      }
      if (propInfo.isLocalizable) {
        propInfo.serializationProperty = "loc" + prop.name;
      }
      if (propInfo.serializationProperty) {
        prop.serializationProperty = propInfo.serializationProperty;
        if (prop.serializationProperty && prop.serializationProperty.indexOf("loc") == 0) {
          prop.isLocalizable = true;
        }
      }
      if (propInfo.isLocalizable) {
        prop.isLocalizable = propInfo.isLocalizable;
      }
      if (propInfo.className) {
        prop.className = propInfo.className;
      }
      if (propInfo.baseClassName) {
        prop.baseClassName = propInfo.baseClassName;
        prop.isArray = true;
      }
      if (prop.isArray === true) {
        prop.isArray = true;
      }
      if (propInfo.classNamePart) {
        prop.classNamePart = propInfo.classNamePart;
      }
      if (propInfo.alternativeName) {
        prop.alternativeName = propInfo.alternativeName;
      }
      if (propInfo.oldName) {
        prop.oldName = propInfo.oldName;
      }
      if (propInfo.layout) {
        prop.layout = propInfo.layout;
      }
      if (propInfo.version) {
        prop.version = propInfo.version;
      }
      if (propInfo.dependsOn) {
        this.addDependsOnProperties(prop, propInfo.dependsOn);
      }
    }
    this.properties.push(prop);
    if (isCustom && !this.isOverridedProp(prop.name)) {
      prop.isCustom = true;
      CustomPropertiesCollection.addProperty(this.name, prop);
    }
    return prop;
  }
  addDependsOnProperties(prop, dependsOn) {
    const dArray = Array.isArray(dependsOn) ? dependsOn : [dependsOn];
    prop.dependsOn = dArray;
    for (var i = 0; i < dArray.length; i++) {
      this.addDependsOnProperty(prop, dArray[i]);
    }
  }
  addDependsOnProperty(prop, dependsOn) {
    var property2 = this.find(dependsOn);
    if (!property2) {
      property2 = Serializer.findProperty(this.parentName, dependsOn);
    }
    if (!property2) return;
    property2.addDependedProperty(prop.name);
  }
  getIsPropertyNameRequired(propertyName) {
    return propertyName.length > 0 && propertyName[0] == _JsonMetadataClass.requiredSymbol;
  }
  getPropertyName(propertyName) {
    if (!this.getIsPropertyNameRequired(propertyName)) return propertyName;
    propertyName = propertyName.slice(1);
    return propertyName;
  }
};
JsonMetadataClass.requiredSymbol = "!";
JsonMetadataClass.typeSymbol = ":";
var JsonMetadata = class {
  constructor() {
    this.classes = {};
    this.alternativeNames = {};
    this.childrenClasses = {};
    this.dynamicPropsCache = {};
  }
  getObjPropertyValue(obj, name) {
    if (this.isObjWrapper(obj) && this.isNeedUseObjWrapper(obj, name)) {
      const orignalObj = obj.getOriginalObj();
      const prop2 = Serializer.findProperty(orignalObj.getType(), name);
      if (!!prop2) return this.getObjPropertyValueCore(orignalObj, prop2);
    }
    const prop = Serializer.findProperty(obj.getType(), name);
    if (!prop) return obj[name];
    return this.getObjPropertyValueCore(obj, prop);
  }
  setObjPropertyValue(obj, name, val) {
    if (obj[name] === val) return;
    if (!!obj[name] && !!obj[name].setJson) {
      obj[name].setJson(val, true);
    } else {
      if (Array.isArray(val)) {
        const newVal = [];
        for (var i = 0; i < val.length; i++) newVal.push(val[i]);
        val = newVal;
      }
      obj[name] = val;
    }
  }
  getObjPropertyValueCore(obj, prop) {
    if (!prop.isPropertySerializable(obj)) return obj[prop.name];
    if (prop.isLocalizable) {
      if (prop.isArray) return obj[prop.name];
      if (!!prop.serializationProperty) return obj[prop.serializationProperty].text;
    }
    return obj.getPropertyValue(prop.name);
  }
  isObjWrapper(obj) {
    return !!obj.getOriginalObj && !!obj.getOriginalObj();
  }
  isNeedUseObjWrapper(obj, name) {
    if (!obj.getDynamicProperties) return true;
    const props = obj.getDynamicProperties();
    if (!Array.isArray(props)) return false;
    for (let i = 0; i < props.length; i++) {
      if (props[i].name === name) return true;
    }
    return false;
  }
  addClass(name, properties, creator = null, parentName = null) {
    name = name.toLowerCase();
    var metaDataClass = new JsonMetadataClass(name, properties, creator, parentName);
    this.classes[name] = metaDataClass;
    if (parentName) {
      parentName = parentName.toLowerCase();
      var children = this.childrenClasses[parentName];
      if (!children) {
        this.childrenClasses[parentName] = [];
      }
      this.childrenClasses[parentName].push(metaDataClass);
    }
    return metaDataClass;
  }
  removeClass(name) {
    var metaClass = this.findClass(name);
    if (!metaClass) return;
    delete this.classes[metaClass.name];
    if (!!metaClass.parentName) {
      var index = this.childrenClasses[metaClass.parentName].indexOf(metaClass);
      if (index > -1) {
        this.childrenClasses[metaClass.parentName].splice(index, 1);
      }
    }
  }
  overrideClassCreatore(name, creator) {
    this.overrideClassCreator(name, creator);
  }
  overrideClassCreator(name, creator) {
    name = name.toLowerCase();
    var metaDataClass = this.findClass(name);
    if (metaDataClass) {
      metaDataClass.creator = creator;
    }
  }
  getProperties(className) {
    var metaClass = this.findClass(className);
    if (!metaClass) return [];
    return metaClass.getAllProperties();
  }
  getPropertiesByObj(obj) {
    const type = !!obj && !!obj.getType ? obj.getType() : void 0;
    if (!type) return [];
    const props = this.getProperties(type);
    const dynamicProps = this.getDynamicPropertiesByObj(obj);
    for (let i = dynamicProps.length - 1; i >= 0; i--) {
      if (this.findProperty(type, dynamicProps[i].name)) {
        dynamicProps.splice(i, 1);
      }
    }
    if (dynamicProps.length === 0) return props;
    return [].concat(props).concat(dynamicProps);
  }
  addDynamicPropertiesIntoObj(dest, src, props) {
    props.forEach((prop) => {
      this.addDynamicPropertyIntoObj(dest, src, prop.name, false);
      if (prop.serializationProperty) {
        this.addDynamicPropertyIntoObj(dest, src, prop.serializationProperty, true);
      }
      if (prop.alternativeName) {
        this.addDynamicPropertyIntoObj(dest, src, prop.alternativeName, false);
      }
    });
  }
  addDynamicPropertyIntoObj(dest, src, propName, isReadOnly) {
    var desc = {
      configurable: true,
      get: function() {
        return src[propName];
      }
    };
    if (!isReadOnly) {
      desc["set"] = function(v) {
        src[propName] = v;
      };
    }
    Object.defineProperty(dest, propName, desc);
  }
  getDynamicPropertiesByObj(obj, dynamicType = null) {
    if (!obj || !obj.getType) return [];
    if (!!obj.getDynamicProperties) return obj.getDynamicProperties();
    if (!obj.getDynamicType && !dynamicType) return [];
    const dType = !!dynamicType ? dynamicType : obj.getDynamicType();
    return this.getDynamicPropertiesByTypes(obj.getType(), dType);
  }
  getDynamicPropertiesByTypes(objType, dynamicType, invalidNames) {
    if (!dynamicType) return [];
    const cacheType = dynamicType + "-" + objType;
    if (this.dynamicPropsCache[cacheType]) return this.dynamicPropsCache[cacheType];
    var dynamicProps = this.getProperties(dynamicType);
    if (!dynamicProps || dynamicProps.length == 0) return [];
    const hash = {};
    const props = this.getProperties(objType);
    for (var i = 0; i < props.length; i++) {
      hash[props[i].name] = props[i];
    }
    const res = [];
    if (!invalidNames) invalidNames = [];
    for (let i2 = 0; i2 < dynamicProps.length; i2++) {
      const dProp = dynamicProps[i2];
      if (invalidNames.indexOf(dProp.name) < 0 && this.canAddDybamicProp(dProp, hash[dProp.name])) {
        res.push(dProp);
      }
    }
    this.dynamicPropsCache[cacheType] = res;
    return res;
  }
  canAddDybamicProp(dProp, orgProp) {
    if (!orgProp) return true;
    if (dProp === orgProp) return false;
    let classInfo = dProp.classInfo;
    while (classInfo && classInfo.parentName) {
      dProp = this.findProperty(classInfo.parentName, dProp.name);
      if (dProp && dProp === orgProp) return true;
      classInfo = !!dProp ? dProp.classInfo : void 0;
    }
    return false;
  }
  hasOriginalProperty(obj, propName) {
    return !!this.getOriginalProperty(obj, propName);
  }
  getOriginalProperty(obj, propName) {
    var res = this.findProperty(obj.getType(), propName);
    if (!!res) return res;
    if (this.isObjWrapper(obj)) return this.findProperty(obj.getOriginalObj().getType(), propName);
    return null;
  }
  getProperty(className, propertyName) {
    const prop = this.findProperty(className, propertyName);
    if (!prop) return prop;
    const classInfo = this.findClass(className);
    if (prop.classInfo === classInfo) return prop;
    const newProp = new JsonObjectProperty(classInfo, prop.name, prop.isRequired);
    newProp.mergeWith(prop);
    newProp.isArray = prop.isArray;
    classInfo.properties.push(newProp);
    classInfo.resetAllProperties();
    return newProp;
  }
  findProperty(className, propertyName) {
    const cl = this.findClass(className);
    return !!cl ? cl.findProperty(propertyName) : null;
  }
  findProperties(className, propertyNames) {
    var result = new Array();
    const cl = this.findClass(className);
    if (!cl) return result;
    for (var i = 0; i < propertyNames.length; i++) {
      var prop = cl.findProperty(propertyNames[i]);
      if (prop) {
        result.push(prop);
      }
    }
    return result;
  }
  getAllPropertiesByName(propertyName) {
    var res = new Array();
    var classes = this.getAllClasses();
    for (var i = 0; i < classes.length; i++) {
      var classInfo = this.findClass(classes[i]);
      for (var j = 0; j < classInfo.properties.length; j++) {
        if (classInfo.properties[j].name == propertyName) {
          res.push(classInfo.properties[j]);
          break;
        }
      }
    }
    return res;
  }
  getAllClasses() {
    var res = new Array();
    for (var name in this.classes) {
      res.push(name);
    }
    return res;
  }
  createClass(name, json2 = void 0) {
    name = name.toLowerCase();
    var metaDataClass = this.findClass(name);
    if (!metaDataClass) return null;
    if (metaDataClass.creator) return metaDataClass.creator(json2);
    var parentName = metaDataClass.parentName;
    while (parentName) {
      metaDataClass = this.findClass(parentName);
      if (!metaDataClass) return null;
      parentName = metaDataClass.parentName;
      if (metaDataClass.creator) return this.createCustomType(name, metaDataClass.creator, json2);
    }
    return null;
  }
  createCustomType(name, creator, json2 = void 0) {
    name = name.toLowerCase();
    var res = creator(json2);
    var customTypeName = name;
    var customTemplateName = res.getTemplate ? res.getTemplate() : res.getType();
    res.getType = function() {
      return customTypeName;
    };
    res.getTemplate = function() {
      return customTemplateName;
    };
    CustomPropertiesCollection.createProperties(res);
    return res;
  }
  getChildrenClasses(name, canBeCreated = false) {
    name = name.toLowerCase();
    var result = [];
    this.fillChildrenClasses(name, canBeCreated, result);
    return result;
  }
  getRequiredProperties(name) {
    const metaClass = this.findClass(name);
    if (!metaClass) return [];
    const props = metaClass.getRequiredProperties();
    var res = [];
    for (var i = 0; i < props.length; i++) {
      res.push(props[i].name);
    }
    return res;
  }
  addProperties(className, propertiesInfos) {
    className = className.toLowerCase();
    var metaDataClass = this.findClass(className);
    for (var i = 0; i < propertiesInfos.length; i++) {
      this.addCustomPropertyCore(metaDataClass, propertiesInfos[i]);
    }
  }
  addProperty(className, propertyInfo) {
    return this.addCustomPropertyCore(this.findClass(className), propertyInfo);
  }
  addCustomPropertyCore(metaDataClass, propertyInfo) {
    if (!metaDataClass) return null;
    var property2 = metaDataClass.createProperty(propertyInfo, true);
    if (property2) {
      this.clearDynamicPropsCache(metaDataClass);
      metaDataClass.resetAllProperties();
    }
    return property2;
  }
  removeProperty(className, propertyName) {
    var metaDataClass = this.findClass(className);
    if (!metaDataClass) return false;
    var property2 = metaDataClass.find(propertyName);
    if (property2) {
      this.clearDynamicPropsCache(metaDataClass);
      this.removePropertyFromClass(metaDataClass, property2);
      metaDataClass.resetAllProperties();
      CustomPropertiesCollection.removeProperty(metaDataClass.name, propertyName);
    }
  }
  clearDynamicPropsCache(metaDataClass) {
    this.dynamicPropsCache = {};
  }
  removePropertyFromClass(metaDataClass, property2) {
    var index = metaDataClass.properties.indexOf(property2);
    if (index < 0) return;
    metaDataClass.properties.splice(index, 1);
  }
  fillChildrenClasses(name, canBeCreated, result) {
    var children = this.childrenClasses[name];
    if (!children) return;
    for (var i = 0; i < children.length; i++) {
      if (!canBeCreated || children[i].creator) {
        result.push(children[i]);
      }
      this.fillChildrenClasses(children[i].name, canBeCreated, result);
    }
  }
  findClass(name) {
    name = name.toLowerCase();
    var res = this.classes[name];
    if (!res) {
      var newName = this.alternativeNames[name];
      if (!!newName && newName != name) return this.findClass(newName);
    }
    return res;
  }
  isDescendantOf(className, ancestorClassName) {
    if (!className || !ancestorClassName) {
      return false;
    }
    className = className.toLowerCase();
    ancestorClassName = ancestorClassName.toLowerCase();
    var class_ = this.findClass(className);
    if (!class_) {
      return false;
    }
    var parentClass = class_;
    do {
      if (parentClass.name === ancestorClassName) {
        return true;
      }
      parentClass = this.classes[parentClass.parentName];
    } while (!!parentClass);
    return false;
  }
  addAlterNativeClassName(name, alternativeName) {
    this.alternativeNames[alternativeName.toLowerCase()] = name.toLowerCase();
  }
  generateSchema(className = void 0) {
    if (!className) className = "survey";
    var classInfo = this.findClass(className);
    if (!classInfo) return null;
    var res = {
      $schema: "http://json-schema.org/draft-07/schema#",
      title: "SurveyJS Library json schema",
      type: "object",
      properties: {},
      definitions: {
        locstring: this.generateLocStrClass()
      }
    };
    this.generateSchemaProperties(classInfo, res, res.definitions, true);
    return res;
  }
  generateLocStrClass() {
    const props = {};
    const locProp = Serializer.findProperty("survey", "locale");
    if (!!locProp) {
      const choices = locProp.getChoices(null);
      if (Array.isArray(choices)) {
        if (choices.indexOf("en") < 0) {
          choices.splice(0, 0, "en");
        }
        choices.splice(0, 0, "default");
        choices.forEach((l) => {
          if (!!l) {
            props[l] = {
              type: "string"
            };
          }
        });
      }
    }
    return {
      $id: "locstring",
      type: "object",
      properties: props
    };
  }
  generateSchemaProperties(classInfo, classSchema, schemaDef, isRoot) {
    if (!classInfo) return;
    const schemaProperties = classSchema.properties;
    const requiredProps = [];
    if (classInfo.name === "question") {
      schemaProperties.type = {
        type: "string"
      };
      requiredProps.push("type");
    }
    for (let i = 0; i < classInfo.properties.length; i++) {
      const prop = classInfo.properties[i];
      if (prop.isSerializable === false) continue;
      if (!!classInfo.parentName && !!Serializer.findProperty(classInfo.parentName, prop.name)) continue;
      schemaProperties[prop.name] = this.generateSchemaProperty(prop, schemaDef, isRoot);
      if (prop.isRequired) requiredProps.push(prop.name);
    }
    if (requiredProps.length > 0) {
      classSchema.required = requiredProps;
    }
  }
  generateSchemaProperty(prop, schemaDef, isRoot) {
    if (prop.isLocalizable) {
      return {
        oneOf: [{
          "type": "string"
        }, {
          "$ref": this.getChemeRefName("locstring", isRoot)
        }]
      };
    }
    const propType = prop.schemaType();
    const refType = prop.schemaRef();
    var res = {};
    if (!!propType) {
      res.type = propType;
    }
    if (prop.hasChoices) {
      const enumRes = prop.getChoices(null);
      if (Array.isArray(enumRes) && enumRes.length > 0) {
        res.enum = this.getChoicesValues(enumRes);
      }
    }
    if (!!refType) {
      if (propType === "array") {
        if (prop.className === "string") {
          res.items = {
            type: prop.className
          };
        } else {
          res.items = {
            $ref: this.getChemeRefName(prop.className, isRoot)
          };
        }
      } else {
        res["$ref"] = this.getChemeRefName(refType, isRoot);
      }
      this.generateChemaClass(prop.className, schemaDef, false);
    }
    if (!!prop.baseClassName) {
      var usedClasses = this.getChildrenClasses(prop.baseClassName, true);
      if (prop.baseClassName == "question") {
        usedClasses.push(this.findClass("panel"));
      }
      res.items = {
        anyOf: []
      };
      for (var i = 0; i < usedClasses.length; i++) {
        var className = usedClasses[i].name;
        res.items.anyOf.push({
          $ref: this.getChemeRefName(className, isRoot)
        });
        this.generateChemaClass(className, schemaDef, false);
      }
    }
    return res;
  }
  getChemeRefName(className, isRoot) {
    return isRoot ? "#/definitions/" + className : className;
  }
  generateChemaClass(className, schemaDef, isRoot) {
    if (!!schemaDef[className]) return;
    var classInfo = this.findClass(className);
    if (!classInfo) return;
    var hasParent = !!classInfo.parentName && classInfo.parentName != "base";
    if (hasParent) {
      this.generateChemaClass(classInfo.parentName, schemaDef, isRoot);
    }
    const res = {
      type: "object",
      $id: className
    };
    schemaDef[className] = res;
    const chemaProps = {
      properties: {}
    };
    this.generateSchemaProperties(classInfo, chemaProps, schemaDef, isRoot);
    if (hasParent) {
      res.allOf = [{
        $ref: this.getChemeRefName(classInfo.parentName, isRoot)
      }, {
        properties: chemaProps.properties
      }];
    } else {
      res.properties = chemaProps.properties;
    }
    if (Array.isArray(chemaProps.required)) {
      res.required = chemaProps.required;
    }
  }
  getChoicesValues(enumRes) {
    const res = new Array();
    enumRes.forEach((item) => {
      if (typeof item === "object" && item.value !== void 0) {
        res.push(item.value);
      } else {
        res.push(item);
      }
    });
    return res;
  }
};
var JsonError = class {
  constructor(type, message) {
    this.type = type;
    this.message = message;
    this.description = "";
    this.at = -1;
    this.end = -1;
  }
  getFullDescription() {
    return this.message + (this.description ? "\n" + this.description : "");
  }
};
var JsonUnknownPropertyError = class extends JsonError {
  constructor(propertyName, className) {
    super("unknownproperty", "Unknown property in class '" + className + "': '" + propertyName + "'.");
    this.propertyName = propertyName;
    this.className = className;
  }
};
var JsonMissingTypeErrorBase = class extends JsonError {
  constructor(baseClassName, type, message) {
    super(type, message);
    this.baseClassName = baseClassName;
    this.type = type;
    this.message = message;
  }
};
var JsonMissingTypeError = class extends JsonMissingTypeErrorBase {
  constructor(propertyName, baseClassName) {
    super(baseClassName, "missingtypeproperty", "The property type is missing in the object. Please take a look at property: '" + propertyName + "'.");
    this.propertyName = propertyName;
    this.baseClassName = baseClassName;
  }
};
var JsonIncorrectTypeError = class extends JsonMissingTypeErrorBase {
  constructor(propertyName, baseClassName) {
    super(baseClassName, "incorrecttypeproperty", "The property type is incorrect in the object. Please take a look at property: '" + propertyName + "'.");
    this.propertyName = propertyName;
    this.baseClassName = baseClassName;
  }
};
var JsonRequiredPropertyError = class extends JsonError {
  constructor(propertyName, className) {
    super("requiredproperty", "The property '" + propertyName + "' is required in class '" + className + "'.");
    this.propertyName = propertyName;
    this.className = className;
  }
};
var JsonRequiredArrayPropertyError = class extends JsonError {
  constructor(propertyName, className) {
    super("arrayproperty", "The property '" + propertyName + "' should be an array in '" + className + "'.");
    this.propertyName = propertyName;
    this.className = className;
  }
};
var JsonIncorrectPropertyValueError = class extends JsonError {
  constructor(property2, value) {
    super("incorrectvalue", "The property value: '" + value + "' is incorrect for property '" + property2.name + "'.");
    this.property = property2;
    this.value = value;
  }
};
var JsonObject = class _JsonObject {
  constructor() {
    this.errors = new Array();
    this.lightSerializing = false;
  }
  static get metaData() {
    return _JsonObject.metaDataValue;
  }
  toJsonObject(obj, options) {
    return this.toJsonObjectCore(obj, null, options);
  }
  toObject(jsonObj, obj, options) {
    this.toObjectCore(jsonObj, obj, options);
    var error = this.getRequiredError(obj, jsonObj);
    if (!!error) {
      this.addNewError(error, jsonObj, obj);
    }
  }
  toObjectCore(jsonObj, obj, options) {
    if (!jsonObj) return;
    var properties = null;
    var objType = void 0;
    var needAddErrors = true;
    if (obj.getType) {
      objType = obj.getType();
      properties = Serializer.getProperties(objType);
      needAddErrors = !!objType && !Serializer.isDescendantOf(objType, "itemvalue");
    }
    if (!properties) return;
    if (obj.startLoadingFromJson) {
      obj.startLoadingFromJson(jsonObj);
    }
    properties = this.addDynamicProperties(obj, jsonObj, properties);
    this.options = options;
    const processedProps = {};
    processedProps[_JsonObject.typePropertyName] = true;
    const parentProps = {};
    for (var key in jsonObj) {
      this.setPropertyValueToObj(jsonObj, obj, key, properties, processedProps, parentProps, objType, needAddErrors, options);
    }
    this.options = void 0;
    if (obj.endLoadingFromJson) {
      obj.endLoadingFromJson();
    }
  }
  setPropertyValueToObj(jsonObj, obj, key, properties, processedProps, parentProps, objType, needAddErrors, options) {
    if (processedProps[key]) return;
    if (key === _JsonObject.positionPropertyName) {
      obj[key] = jsonObj[key];
      return;
    }
    const property2 = this.findProperty(properties, key);
    if (!property2 && needAddErrors) {
      this.addNewError(new JsonUnknownPropertyError(key.toString(), objType), jsonObj, obj);
    }
    if (property2) {
      const dProps = property2.dependsOn;
      if (Array.isArray(dProps)) {
        parentProps[key] = true;
        dProps.forEach((propKey) => {
          if (!parentProps[propKey]) {
            this.setPropertyValueToObj(jsonObj, obj, propKey, properties, processedProps, parentProps, objType, false, options);
          }
        });
      }
      this.valueToObj(jsonObj[key], obj, property2, jsonObj, options);
      processedProps[key] = true;
    }
  }
  toJsonObjectCore(obj, property2, options) {
    if (!obj || !obj.getType) return obj;
    if (!obj.isSurvey && typeof obj.getData === "function") return obj.getData();
    var result = {};
    if (property2 != null && !property2.className) {
      result[_JsonObject.typePropertyName] = property2.getObjType(obj.getType());
    }
    const storeDefaults = options === true;
    if (!options || options === true) {
      options = {};
    }
    if (storeDefaults) {
      options.storeDefaults = storeDefaults;
    }
    this.propertiesToJson(obj, Serializer.getProperties(obj.getType()), result, options);
    this.propertiesToJson(obj, this.getDynamicProperties(obj), result, options);
    return result;
  }
  getDynamicProperties(obj) {
    return Serializer.getDynamicPropertiesByObj(obj);
  }
  addDynamicProperties(obj, jsonObj, props) {
    if (!obj.getDynamicPropertyName && !obj.getDynamicProperties) return props;
    if (obj.getDynamicPropertyName) {
      const dynamicPropName = obj.getDynamicPropertyName();
      if (!dynamicPropName) return props;
      if (dynamicPropName && jsonObj[dynamicPropName]) {
        obj[dynamicPropName] = jsonObj[dynamicPropName];
      }
    }
    const dynamicProps = this.getDynamicProperties(obj);
    return dynamicProps.length === 0 ? props : [].concat(props).concat(dynamicProps);
  }
  propertiesToJson(obj, properties, json2, options) {
    for (var i = 0; i < properties.length; i++) {
      this.valueToJson(obj, json2, properties[i], options);
    }
  }
  valueToJson(obj, result, prop, options) {
    if (!options) options = {};
    if (!prop.isPropertySerializable(obj) || prop.isLightSerializable === false && this.lightSerializing) return;
    if (options.version && !prop.isAvailableInVersion(options.version)) return;
    this.valueToJsonCore(obj, result, prop, options);
  }
  valueToJsonCore(obj, result, prop, options) {
    const serProp = prop.getSerializedProperty(obj, options.version);
    if (serProp && serProp !== prop) {
      this.valueToJsonCore(obj, result, serProp, options);
      return;
    }
    var value = prop.getSerializableValue(obj, options.storeDefaults);
    if (value === void 0) return;
    if (this.isValueArray(value)) {
      var arrValue = [];
      for (var i = 0; i < value.length; i++) {
        arrValue.push(this.toJsonObjectCore(value[i], prop, options));
      }
      value = arrValue.length > 0 ? arrValue : null;
    } else {
      value = this.toJsonObjectCore(value, prop, options);
    }
    if (value === void 0 || value === null) return;
    const name = prop.getSerializedName(options.version);
    var hasValue = typeof obj["getPropertyValue"] === "function" && obj["getPropertyValue"](name, null) !== null;
    if (options.storeDefaults && hasValue || !prop.isDefaultValueByObj(obj, value)) {
      if (!Serializer.onSerializingProperty || !Serializer.onSerializingProperty(obj, prop, value, result)) {
        result[name] = this.removePosOnValueToJson(prop, value);
      }
    }
  }
  valueToObj(value, obj, property2, jsonObj, options) {
    if (value === null || value === void 0) return;
    this.removePos(property2, value);
    if (property2 != null && property2.hasToUseSetValue) {
      property2.setValue(obj, value, this);
      return;
    }
    if (property2.isArray && !Array.isArray(value) && !!value) {
      value = [value];
      const propName = !!jsonObj && property2.alternativeName && !!jsonObj[property2.alternativeName] ? property2.alternativeName : property2.name;
      this.addNewError(new JsonRequiredArrayPropertyError(propName, obj.getType()), !!jsonObj ? jsonObj : value, obj);
    }
    if (this.isValueArray(value)) {
      this.valueToArray(value, obj, property2.name, property2, options);
      return;
    }
    var newObj = this.createNewObj(value, property2);
    if (newObj.newObj) {
      this.toObjectCore(value, newObj.newObj, options);
      value = newObj.newObj;
    }
    if (!newObj.error) {
      if (property2 != null) {
        property2.setValue(obj, value, this);
        if (!!options && options.validatePropertyValues) {
          if (!property2.validateValue(value)) {
            this.addNewError(new JsonIncorrectPropertyValueError(property2, value), jsonObj, obj);
          }
        }
      } else {
        obj[property2.name] = value;
      }
    }
  }
  removePosOnValueToJson(property2, value) {
    if (!property2.isCustom || !value) return value;
    this.removePosFromObj(value);
    return value;
  }
  removePos(property2, value) {
    if (!property2 || !property2.type || property2.type.indexOf("value") < 0) return;
    this.removePosFromObj(value);
  }
  removePosFromObj(obj) {
    if (!obj || typeof obj.getType === "function") return;
    if (Array.isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
        this.removePosFromObj(obj[i]);
      }
    }
    if (typeof obj !== "object") return;
    if (!!obj[_JsonObject.positionPropertyName]) {
      delete obj[_JsonObject.positionPropertyName];
    }
    for (let key in obj) {
      this.removePosFromObj(obj[key]);
    }
  }
  isValueArray(value) {
    return value && Array.isArray(value);
  }
  createNewObj(value, property2) {
    var result = {
      newObj: null,
      error: null
    };
    const className = this.getClassNameForNewObj(value, property2);
    result.newObj = className ? Serializer.createClass(className, value) : null;
    result.error = this.checkNewObjectOnErrors(result.newObj, value, property2, className);
    return result;
  }
  getClassNameForNewObj(value, property2) {
    var res = property2 != null && property2.className ? property2.className : void 0;
    if (!res) {
      res = value[_JsonObject.typePropertyName];
    }
    if (!res) return res;
    res = res.toLowerCase();
    const classNamePart = property2.classNamePart;
    if (classNamePart && res.indexOf(classNamePart) < 0) {
      res += classNamePart;
    }
    return res;
  }
  checkNewObjectOnErrors(newObj, value, property2, className) {
    var error = null;
    if (newObj) {
      error = this.getRequiredError(newObj, value);
    } else {
      if (property2.baseClassName) {
        if (!className) {
          error = new JsonMissingTypeError(property2.name, property2.baseClassName);
        } else {
          error = new JsonIncorrectTypeError(property2.name, property2.baseClassName);
        }
      }
    }
    if (error) {
      this.addNewError(error, value, newObj);
    }
    return error;
  }
  getRequiredError(obj, jsonValue) {
    if (!obj.getType || typeof obj.getData === "function") return null;
    const metaClass = Serializer.findClass(obj.getType());
    if (!metaClass) return null;
    const props = metaClass.getRequiredProperties();
    if (!Array.isArray(props)) return null;
    for (var i = 0; i < props.length; i++) {
      const prop = props[i];
      if (!Helpers.isValueEmpty(prop.defaultValue)) continue;
      if (!jsonValue[prop.name]) {
        return new JsonRequiredPropertyError(prop.name, obj.getType());
      }
    }
    return null;
  }
  addNewError(error, jsonObj, element) {
    error.jsonObj = jsonObj;
    error.element = element;
    this.errors.push(error);
    if (!jsonObj) return;
    const posObj = jsonObj[_JsonObject.positionPropertyName];
    if (!posObj) return;
    error.at = posObj.start;
    error.end = posObj.end;
  }
  valueToArray(value, obj, key, property2, options) {
    if (obj[key] && !this.isValueArray(obj[key])) return;
    if (obj[key] && value.length > 0) obj[key].splice(0, obj[key].length);
    var valueRes = obj[key] ? obj[key] : [];
    this.addValuesIntoArray(value, valueRes, property2, options);
    if (!obj[key]) obj[key] = valueRes;
  }
  addValuesIntoArray(value, result, property2, options) {
    for (var i = 0; i < value.length; i++) {
      var newValue = this.createNewObj(value[i], property2);
      if (newValue.newObj) {
        if (!!value[i].name) {
          newValue.newObj.name = value[i].name;
        }
        if (!!value[i].valueName) {
          newValue.newObj.valueName = value[i].valueName.toString();
        }
        result.push(newValue.newObj);
        this.toObjectCore(value[i], newValue.newObj, options);
      } else {
        if (!newValue.error) {
          result.push(value[i]);
        }
      }
    }
  }
  findProperty(properties, key) {
    if (!properties) return null;
    for (var i = 0; i < properties.length; i++) {
      var prop = properties[i];
      if (prop.name == key || prop.alternativeName == key) return prop;
    }
    return null;
  }
};
JsonObject.typePropertyName = "type";
JsonObject.positionPropertyName = "pos";
JsonObject.metaDataValue = new JsonMetadata();
var Serializer = JsonObject.metaData;
var surveyBuiltInVarible = "@survey";
var ProcessValue = class {
  constructor() {
    this.values = null;
    this.properties = null;
    this.asyncValues = {};
  }
  getFirstName(text, obj = null) {
    if (!text) return text;
    var res = "";
    if (!!obj) {
      res = this.getFirstPropertyName(text, obj);
      if (!!res) return res;
    }
    for (var i = 0; i < text.length; i++) {
      var ch = text[i];
      if (ch == "." || ch == "[") break;
      res += ch;
    }
    return res;
  }
  hasValue(text, values = null) {
    if (!values) values = this.values;
    var res = this.getValueCore(text, values);
    return res.hasValue;
  }
  getValue(text, values = null) {
    if (!values) values = this.values;
    var res = this.getValueCore(text, values);
    return res.value;
  }
  setValue(obj, text, value) {
    if (!text) return;
    var nonNestedObj = this.getNonNestedObject(obj, text, true);
    if (!nonNestedObj) return;
    obj = nonNestedObj.value;
    text = nonNestedObj.text;
    if (!!obj && !!text) {
      obj[text] = value;
    }
  }
  getValueInfo(valueInfo) {
    if (!!valueInfo.path) {
      valueInfo.value = this.getValueFromPath(valueInfo.path, this.values);
      valueInfo.hasValue = valueInfo.value !== null && !Helpers.isValueEmpty(valueInfo.value);
      if (!valueInfo.hasValue && valueInfo.path.length > 1 && valueInfo.path[valueInfo.path.length - 1] == "length") {
        valueInfo.hasValue = true;
        valueInfo.value = 0;
      }
      return;
    }
    var res = this.getValueCore(valueInfo.name, this.values);
    valueInfo.value = res.value;
    valueInfo.hasValue = res.hasValue;
    valueInfo.path = res.hasValue ? res.path : null;
    valueInfo.sctrictCompare = res.sctrictCompare;
  }
  isAnyKeyChanged(keys, usedNames) {
    for (var i = 0; i < usedNames.length; i++) {
      const name = usedNames[i];
      if (!name) continue;
      const lowerName = name.toLowerCase();
      if (keys.hasOwnProperty(name)) return true;
      if (name !== lowerName && keys.hasOwnProperty(lowerName)) return true;
      var firstName = this.getFirstName(name);
      if (!keys.hasOwnProperty(firstName)) continue;
      if (name === firstName) return true;
      var keyValue = keys[firstName];
      if (keyValue == void 0) continue;
      if (!keyValue.hasOwnProperty("oldValue") || !keyValue.hasOwnProperty("newValue")) return true;
      var v = {};
      v[firstName] = keyValue["oldValue"];
      var oldValue = this.getValue(name, v);
      v[firstName] = keyValue["newValue"];
      var newValue = this.getValue(name, v);
      if (!Helpers.isTwoValueEquals(oldValue, newValue, false, false, false)) return true;
    }
    return false;
  }
  getValueFromPath(path, values) {
    if (path.length === 2 && path[0] === surveyBuiltInVarible) {
      return this.getValueFromSurvey(path[1]);
    }
    var index = 0;
    while (!!values && index < path.length) {
      var ind_name = path[index];
      if (Helpers.isNumber(ind_name) && Array.isArray(values) && ind_name >= values.length) return null;
      values = values[ind_name];
      index++;
    }
    return values;
  }
  getValueCore(text, values) {
    const question = this.getQuestionDirectly(text);
    if (question) {
      return {
        hasValue: true,
        value: question.value,
        path: [text],
        sctrictCompare: question.requireStrictCompare
      };
    }
    const res = this.getValueFromValues(text, values);
    if (!!text && !res.hasValue) {
      const val = this.getValueFromSurvey(text);
      if (val !== void 0) {
        res.hasValue = true;
        res.value = val;
        res.path = [surveyBuiltInVarible, text];
      }
    }
    return res;
  }
  getQuestionDirectly(name) {
    if (!!this.properties && !!this.properties.survey) return this.properties.survey.getQuestionByValueName(name);
    return void 0;
  }
  getValueFromSurvey(name) {
    if (!!this.properties && !!this.properties.survey) return this.properties.survey.getBuiltInVariableValue(name.toLocaleLowerCase());
    return void 0;
  }
  getValueFromValues(text, values) {
    var res = {
      hasValue: false,
      value: null,
      path: null
    };
    var curValue = values;
    if (!curValue && curValue !== 0 && curValue !== false) return res;
    if (text && text.lastIndexOf(".length") > -1 && text.lastIndexOf(".length") === text.length - ".length".length) {
      res.value = 0;
      res.hasValue = true;
    }
    var nonNestedObj = this.getNonNestedObject(curValue, text, false);
    if (!nonNestedObj) return res;
    res.path = nonNestedObj.path;
    res.value = !!nonNestedObj.text ? this.getObjectValue(nonNestedObj.value, nonNestedObj.text) : nonNestedObj.value;
    res.hasValue = !Helpers.isValueEmpty(res.value);
    return res;
  }
  getNonNestedObject(obj, text, createPath) {
    const checkedKeys = new Array();
    let len = 0;
    let res = this.getNonNestedObjectCore(obj, text, createPath, checkedKeys);
    while (!res && len < checkedKeys.length) {
      len = checkedKeys.length;
      res = this.getNonNestedObjectCore(obj, text, createPath, checkedKeys);
    }
    return res;
  }
  getNonNestedObjectCore(obj, text, createPath, checkedKeys) {
    var curName = this.getFirstPropertyName(text, obj, createPath, checkedKeys);
    if (!!curName) {
      checkedKeys.push(curName);
    }
    var path = !!curName ? [curName] : null;
    while (text != curName && !!obj) {
      var isArray = text[0] == "[";
      if (!isArray) {
        if (!curName && text == this.getFirstName(text)) return {
          value: obj,
          text,
          path
        };
        obj = this.getObjectValue(obj, curName);
        if (Helpers.isValueEmpty(obj) && !createPath) return null;
        text = text.substring(curName.length);
      } else {
        var objInArray = this.getObjInArray(obj, text);
        if (!objInArray) return null;
        obj = objInArray.value;
        text = objInArray.text;
        path.push(objInArray.index);
      }
      if (!!text && text[0] == ".") {
        text = text.substring(1);
      }
      curName = this.getFirstPropertyName(text, obj, createPath, checkedKeys);
      if (!!curName) {
        path.push(curName);
      }
    }
    return {
      value: obj,
      text,
      path
    };
  }
  getObjInArray(curValue, text) {
    if (!Array.isArray(curValue)) return null;
    var index = 1;
    var str = "";
    while (index < text.length && text[index] != "]") {
      str += text[index];
      index++;
    }
    text = index < text.length ? text.substring(index + 1) : "";
    index = this.getIntValue(str);
    if (index < 0 || index >= curValue.length) return null;
    return {
      value: curValue[index],
      text,
      index
    };
  }
  getFirstPropertyName(name, obj, createProp = false, checkedKeys = void 0) {
    if (!name) return name;
    if (!obj) obj = {};
    if (obj.hasOwnProperty(name)) return name;
    var nameInLow = name.toLowerCase();
    var A = nameInLow[0];
    var a = A.toUpperCase();
    for (var key in obj) {
      if (Array.isArray(checkedKeys) && checkedKeys.indexOf(key) > -1) continue;
      var first = key[0];
      if (first === a || first === A) {
        var keyName = key.toLowerCase();
        if (keyName == nameInLow) return key;
        if (nameInLow.length <= keyName.length) continue;
        var ch = nameInLow[keyName.length];
        if (ch != "." && ch != "[") continue;
        if (keyName == nameInLow.substring(0, keyName.length)) return key;
      }
    }
    if (createProp && name[0] !== "[") {
      var ind = name.indexOf(".");
      if (ind > -1) {
        name = name.substring(0, ind);
        obj[name] = {};
      }
      return name;
    }
    return "";
  }
  getObjectValue(obj, name) {
    if (!name) return null;
    return obj[name];
  }
  getIntValue(str) {
    if (str == "0" || (str | 0) > 0 && str % 1 == 0) return Number(str);
    return -1;
  }
};
var ConsoleWarnings = class _ConsoleWarnings {
  static disposedObjectChangedProperty(propName, objType) {
    _ConsoleWarnings.warn('An attempt to set a property "' + propName + '" of a disposed object "' + objType + '"');
  }
  static inCorrectQuestionValue(questionName, val) {
    const valStr = JSON.stringify(val, null, 3);
    _ConsoleWarnings.warn("An attempt to assign an incorrect value" + valStr + ' to the following question: "' + questionName + '"');
  }
  static warn(text) {
    console.warn(text);
  }
  static error(text) {
    console.error(text);
  }
};
var FunctionFactory = class {
  constructor() {
    this.functionHash = {};
    this.isAsyncHash = {};
  }
  register(name, func, isAsync = false) {
    this.functionHash[name] = func;
    if (isAsync) this.isAsyncHash[name] = true;
  }
  unregister(name) {
    delete this.functionHash[name];
    delete this.isAsyncHash[name];
  }
  hasFunction(name) {
    return !!this.functionHash[name];
  }
  isAsyncFunction(name) {
    return !!this.isAsyncHash[name];
  }
  clear() {
    this.functionHash = {};
  }
  getAll() {
    var result = [];
    for (var key in this.functionHash) {
      result.push(key);
    }
    return result.sort();
  }
  run(name, params, properties = null, originalParams) {
    var func = this.functionHash[name];
    if (!func) {
      ConsoleWarnings.warn("Unknown function name: " + name);
      return null;
    }
    let classRunner = {
      func
    };
    if (properties) {
      for (var key in properties) {
        classRunner[key] = properties[key];
      }
    }
    return classRunner.func(params, originalParams);
  }
};
FunctionFactory.Instance = new FunctionFactory();
var registerFunction = FunctionFactory.Instance.register;
function getParamsAsArray(value, arr) {
  if (value === void 0 || value === null) return;
  if (Array.isArray(value)) {
    for (var i = 0; i < value.length; i++) {
      getParamsAsArray(value[i], arr);
    }
  } else {
    if (Helpers.isNumber(value)) {
      value = Helpers.getNumber(value);
    }
    arr.push(value);
  }
}
function sum(params) {
  var arr = [];
  getParamsAsArray(params, arr);
  var res = 0;
  for (var i = 0; i < arr.length; i++) {
    res = Helpers.correctAfterPlusMinis(res, arr[i], res + arr[i]);
  }
  return res;
}
FunctionFactory.Instance.register("sum", sum);
function min_max(params, isMin) {
  var arr = [];
  getParamsAsArray(params, arr);
  var res = void 0;
  for (var i = 0; i < arr.length; i++) {
    if (res === void 0) {
      res = arr[i];
    }
    if (isMin) {
      if (res > arr[i]) res = arr[i];
    } else {
      if (res < arr[i]) res = arr[i];
    }
  }
  return res;
}
function min(params) {
  return min_max(params, true);
}
FunctionFactory.Instance.register("min", min);
function max(params) {
  return min_max(params, false);
}
FunctionFactory.Instance.register("max", max);
function count(params) {
  var arr = [];
  getParamsAsArray(params, arr);
  return arr.length;
}
FunctionFactory.Instance.register("count", count);
function avg(params) {
  var arr = [];
  getParamsAsArray(params, arr);
  const res = sum(params);
  return arr.length > 0 ? res / arr.length : 0;
}
FunctionFactory.Instance.register("avg", avg);
function getInArrayParams(params, originalParams) {
  if (params.length < 2 || params.length > 3) return null;
  const arr = params[0];
  if (!arr) return null;
  if (!Array.isArray(arr) && !Array.isArray(Object.keys(arr))) return null;
  const name = params[1];
  if (typeof name !== "string" && !(name instanceof String)) return null;
  let expression = params.length > 2 ? params[2] : void 0;
  if (typeof expression !== "string" && !(expression instanceof String)) {
    expression = void 0;
  }
  if (!expression) {
    const operand = Array.isArray(originalParams) && originalParams.length > 2 ? originalParams[2] : void 0;
    if (operand && !!operand.toString()) {
      expression = operand.toString();
    }
  }
  return {
    data: arr,
    name,
    expression
  };
}
function convertToNumber(val) {
  if (typeof val === "string") return Helpers.isNumber(val) ? Helpers.getNumber(val) : void 0;
  return val;
}
function processItemInArray(item, name, res, func, needToConvert, condition) {
  if (!item || Helpers.isValueEmpty(item[name])) return res;
  if (condition && !condition.run(item)) return res;
  const val = needToConvert ? convertToNumber(item[name]) : 1;
  return func(res, val);
}
function calcInArray(params, originalParams, func, needToConvert = true) {
  var v = getInArrayParams(params, originalParams);
  if (!v) return void 0;
  let condition = !!v.expression ? new ConditionRunner(v.expression) : void 0;
  if (condition && condition.isAsync) {
    condition = void 0;
  }
  var res = void 0;
  if (Array.isArray(v.data)) {
    for (var i = 0; i < v.data.length; i++) {
      res = processItemInArray(v.data[i], v.name, res, func, needToConvert, condition);
    }
  } else {
    for (var key in v.data) {
      res = processItemInArray(v.data[key], v.name, res, func, needToConvert, condition);
    }
  }
  return res;
}
function sumInArray(params, originalParams) {
  var res = calcInArray(params, originalParams, function(res2, val) {
    if (res2 == void 0) res2 = 0;
    if (val == void 0 || val == null) return res2;
    return Helpers.correctAfterPlusMinis(res2, val, res2 + val);
  });
  return res !== void 0 ? res : 0;
}
FunctionFactory.Instance.register("sumInArray", sumInArray);
function minInArray(params, originalParams) {
  return calcInArray(params, originalParams, function(res, val) {
    if (res == void 0) return val;
    if (val == void 0 || val == null) return res;
    return res < val ? res : val;
  });
}
FunctionFactory.Instance.register("minInArray", minInArray);
function maxInArray(params, originalParams) {
  return calcInArray(params, originalParams, function(res, val) {
    if (res == void 0) return val;
    if (val == void 0 || val == null) return res;
    return res > val ? res : val;
  });
}
FunctionFactory.Instance.register("maxInArray", maxInArray);
function countInArray(params, originalParams) {
  var res = calcInArray(params, originalParams, function(res2, val) {
    if (res2 == void 0) res2 = 0;
    if (val == void 0 || val == null) return res2;
    return res2 + 1;
  }, false);
  return res !== void 0 ? res : 0;
}
FunctionFactory.Instance.register("countInArray", countInArray);
function avgInArray(params, originalParams) {
  var count2 = countInArray(params, originalParams);
  if (count2 == 0) return 0;
  return sumInArray(params, originalParams) / count2;
}
FunctionFactory.Instance.register("avgInArray", avgInArray);
function iif(params) {
  if (!params && params.length !== 3) return "";
  return params[0] ? params[1] : params[2];
}
FunctionFactory.Instance.register("iif", iif);
function getDate(params) {
  if (!params && params.length < 1) return null;
  if (!params[0]) return null;
  return createDate("function-getDate", params[0]);
}
FunctionFactory.Instance.register("getDate", getDate);
function dateDiffMonths(date1Param, date2Param, type) {
  if (type === "days") return diffDays([date1Param, date2Param]);
  const date1 = createDate("function-dateDiffMonths", date1Param);
  const date2 = createDate("function-dateDiffMonths", date2Param);
  const age2 = date2.getFullYear() - date1.getFullYear();
  type = type || "years";
  let ageInMonths = age2 * 12 + date2.getMonth() - date1.getMonth();
  if (date2.getDate() < date1.getDate()) {
    ageInMonths -= 1;
  }
  return type === "months" ? ageInMonths : ~~(ageInMonths / 12);
}
function age(params) {
  if (!Array.isArray(params) || params.length < 1 || !params[0]) return null;
  return dateDiffMonths(params[0], void 0, (params.length > 1 ? params[1] : "") || "years");
}
FunctionFactory.Instance.register("age", age);
function dateDiff(params) {
  if (!Array.isArray(params) || params.length < 2 || !params[0] || !params[1]) return null;
  return dateDiffMonths(params[0], params[1], (params.length > 2 ? params[2] : "") || "days");
}
FunctionFactory.Instance.register("dateDiff", dateDiff);
function dateAdd(params) {
  if (!Array.isArray(params) || params.length < 2 || !params[0] || !params[1]) return null;
  const date = createDate("function-dateAdd", params[0]);
  const valToAdd = params[1];
  const interval = params[2] || "days";
  if (interval === "days") {
    date.setDate(date.getDate() + valToAdd);
  }
  if (interval === "months") {
    date.setMonth(date.getMonth() + valToAdd);
  }
  if (interval === "years") {
    date.setFullYear(date.getFullYear() + valToAdd);
  }
  return date;
}
FunctionFactory.Instance.register("dateAdd", dateAdd);
function isContainerReadyCore(container) {
  if (!container) return false;
  var questions = container.questions;
  for (var i = 0; i < questions.length; i++) {
    if (!questions[i].validate(false)) return false;
  }
  return true;
}
function isContainerReady(params) {
  if (!params && params.length < 1) return false;
  if (!params[0] || !this.survey) return false;
  const name = params[0];
  let container = this.survey.getPageByName(name);
  if (!container) container = this.survey.getPanelByName(name);
  if (!container) {
    const question = this.survey.getQuestionByName(name);
    if (!question || !Array.isArray(question.panels)) return false;
    if (params.length > 1) {
      if (params[1] < question.panels.length) {
        container = question.panels[params[1]];
      }
    } else {
      for (let i = 0; i < question.panels.length; i++) {
        if (!isContainerReadyCore(question.panels[i])) return false;
      }
      return true;
    }
  }
  return isContainerReadyCore(container);
}
FunctionFactory.Instance.register("isContainerReady", isContainerReady);
function isDisplayMode() {
  return this.survey && this.survey.isDisplayMode;
}
FunctionFactory.Instance.register("isDisplayMode", isDisplayMode);
function currentDate() {
  return createDate("function-currentDate");
}
FunctionFactory.Instance.register("currentDate", currentDate);
function today(params) {
  var res = createDate("function-today");
  if (settings.localization.useLocalTimeZone) {
    res.setHours(0, 0, 0, 0);
  } else {
    res.setUTCHours(0, 0, 0, 0);
  }
  if (Array.isArray(params) && params.length == 1) {
    res.setDate(res.getDate() + params[0]);
  }
  return res;
}
FunctionFactory.Instance.register("today", today);
function getYear(params) {
  if (params.length !== 1 || !params[0]) return void 0;
  return createDate("function-getYear", params[0]).getFullYear();
}
FunctionFactory.Instance.register("getYear", getYear);
function currentYear() {
  return createDate("function-currentYear").getFullYear();
}
FunctionFactory.Instance.register("currentYear", currentYear);
function diffDays(params) {
  if (!Array.isArray(params) || params.length !== 2) return 0;
  if (!params[0] || !params[1]) return 0;
  const date1 = createDate("function-diffDays", params[0]);
  const date2 = createDate("function-diffDays", params[1]);
  const diffTime = Math.abs(date2 - date1);
  return Math.ceil(diffTime / (1e3 * 60 * 60 * 24));
}
FunctionFactory.Instance.register("diffDays", diffDays);
function dateFromFirstParameterOrToday(name, params) {
  let date = today(void 0);
  if (params && params[0]) {
    date = createDate("function-" + name, params[0]);
  }
  return date;
}
function year(params) {
  let date = dateFromFirstParameterOrToday("year", params);
  return date.getFullYear();
}
FunctionFactory.Instance.register("year", year);
function month(params) {
  let date = dateFromFirstParameterOrToday("month", params);
  return date.getMonth() + 1;
}
FunctionFactory.Instance.register("month", month);
function day(params) {
  let date = dateFromFirstParameterOrToday("day", params);
  return date.getDate();
}
FunctionFactory.Instance.register("day", day);
function weekday(params) {
  let date = dateFromFirstParameterOrToday("weekday", params);
  return date.getDay();
}
FunctionFactory.Instance.register("weekday", weekday);
function getQuestionValueByContext(context, name) {
  if (!context || !name) return void 0;
  let q = context.question;
  while (q && q.parent) {
    const res = q.parent.getQuestionByName(name);
    if (!!res) return res;
    q = q.parentQuestion;
  }
  const keys = ["row", "panel", "survey"];
  for (let i = 0; i < keys.length; i++) {
    const ctx = context[keys[i]];
    if (ctx && ctx.getQuestionByName) {
      const res = ctx.getQuestionByName(name);
      if (res) return res;
    }
  }
  return null;
}
function getDisplayValueReturnResult(q, params) {
  if (params.length > 1 && !Helpers.isValueEmpty(params[1])) return q.getDisplayValue(true, params[1]);
  return q.displayValue;
}
function displayValue(params) {
  const q = getQuestionValueByContext(this, params[0]);
  if (!q) return "";
  if (q.isReady) {
    this.returnResult(getDisplayValueReturnResult(q, params));
  } else {
    const displayValueOnReadyChanged = (sender, options) => {
      if (sender.isReady) {
        sender.onReadyChanged.remove(displayValueOnReadyChanged);
        this.returnResult(getDisplayValueReturnResult(sender, params));
      }
    };
    q.onReadyChanged.add(displayValueOnReadyChanged);
  }
  return void 0;
}
FunctionFactory.Instance.register("displayValue", displayValue, true);
function propertyValue(params) {
  if (params.length !== 2 || !params[0] || !params[1]) return void 0;
  const q = getQuestionValueByContext(this, params[0]);
  return q ? q[params[1]] : void 0;
}
FunctionFactory.Instance.register("propertyValue", propertyValue);
function substring_(params) {
  if (params.length < 2) return "";
  const s = params[0];
  if (!s || typeof s !== "string") return "";
  const start = params[1];
  if (!Helpers.isNumber(start)) return "";
  const end = params.length > 2 ? params[2] : void 0;
  if (!Helpers.isNumber(end)) return s.substring(start);
  return s.substring(start, end);
}
FunctionFactory.Instance.register("substring", substring_);
var Operand = class _Operand {
  constructor() {
    this._id = _Operand.counter++;
  }
  get id() {
    return this._id;
  }
  toString(func = void 0) {
    return "";
  }
  hasFunction() {
    return false;
  }
  hasAsyncFunction() {
    return false;
  }
  addToAsyncList(list) {
  }
  isEqual(op) {
    return !!op && op.getType() === this.getType() && this.isContentEqual(op);
  }
  areOperatorsEquals(op1, op2) {
    return !op1 && !op2 || !!op1 && op1.isEqual(op2);
  }
};
Operand.counter = 1;
var BinaryOperand = class extends Operand {
  constructor(operatorName, left = null, right = null, isArithmeticOp = false) {
    super();
    this.operatorName = operatorName;
    this.left = left;
    this.right = right;
    this.isArithmeticValue = isArithmeticOp;
    if (isArithmeticOp) {
      this.consumer = OperandMaker.binaryFunctions["arithmeticOp"](operatorName);
    } else {
      this.consumer = OperandMaker.binaryFunctions[operatorName];
    }
    if (this.consumer == null) {
      OperandMaker.throwInvalidOperatorError(operatorName);
    }
  }
  get requireStrictCompare() {
    return this.getIsOperandRequireStrict(this.left) || this.getIsOperandRequireStrict(this.right);
  }
  getIsOperandRequireStrict(op) {
    return !!op && op.requireStrictCompare;
  }
  getType() {
    return "binary";
  }
  get isArithmetic() {
    return this.isArithmeticValue;
  }
  get isConjunction() {
    return this.operatorName == "or" || this.operatorName == "and";
  }
  get conjunction() {
    return this.isConjunction ? this.operatorName : "";
  }
  get operator() {
    return this.operatorName;
  }
  get leftOperand() {
    return this.left;
  }
  get rightOperand() {
    return this.right;
  }
  isContentEqual(op) {
    const bOp = op;
    return bOp.operator === this.operator && this.areOperatorsEquals(this.left, bOp.left) && this.areOperatorsEquals(this.right, bOp.right);
  }
  evaluateParam(x, processValue) {
    return x == null ? null : x.evaluate(processValue);
  }
  evaluate(processValue) {
    return this.consumer.call(this, this.evaluateParam(this.left, processValue), this.evaluateParam(this.right, processValue), this.requireStrictCompare);
  }
  toString(func = void 0) {
    if (!!func) {
      var res = func(this);
      if (!!res) return res;
    }
    return "(" + OperandMaker.safeToString(this.left, func) + " " + OperandMaker.operatorToString(this.operatorName) + " " + OperandMaker.safeToString(this.right, func) + ")";
  }
  setVariables(variables) {
    if (this.left != null) this.left.setVariables(variables);
    if (this.right != null) this.right.setVariables(variables);
  }
  hasFunction() {
    return !!this.left && this.left.hasFunction() || !!this.right && this.right.hasFunction();
  }
  hasAsyncFunction() {
    return !!this.left && this.left.hasAsyncFunction() || !!this.right && this.right.hasAsyncFunction();
  }
  addToAsyncList(list) {
    if (!!this.left) this.left.addToAsyncList(list);
    if (!!this.right) this.right.addToAsyncList(list);
  }
};
var UnaryOperand = class extends Operand {
  constructor(expressionValue, operatorName) {
    super();
    this.expressionValue = expressionValue;
    this.operatorName = operatorName;
    this.consumer = OperandMaker.unaryFunctions[operatorName];
    if (this.consumer == null) {
      OperandMaker.throwInvalidOperatorError(operatorName);
    }
  }
  get operator() {
    return this.operatorName;
  }
  get expression() {
    return this.expressionValue;
  }
  getType() {
    return "unary";
  }
  toString(func = void 0) {
    if (!!func) {
      var res = func(this);
      if (!!res) return res;
    }
    return OperandMaker.operatorToString(this.operatorName) + " " + this.expression.toString(func);
  }
  isContentEqual(op) {
    const uOp = op;
    return uOp.operator == this.operator && this.areOperatorsEquals(this.expression, uOp.expression);
  }
  hasFunction() {
    return this.expression.hasFunction();
  }
  hasAsyncFunction() {
    return this.expression.hasAsyncFunction();
  }
  addToAsyncList(list) {
    this.expression.addToAsyncList(list);
  }
  evaluate(processValue) {
    let value = this.expression.evaluate(processValue);
    return this.consumer.call(this, value);
  }
  setVariables(variables) {
    this.expression.setVariables(variables);
  }
};
var ArrayOperand = class extends Operand {
  constructor(values) {
    super();
    this.values = values;
  }
  getType() {
    return "array";
  }
  toString(func = void 0) {
    if (!!func) {
      var res = func(this);
      if (!!res) return res;
    }
    return "[" + this.values.map(function(el) {
      return el.toString(func);
    }).join(", ") + "]";
  }
  evaluate(processValue) {
    return this.values.map(function(el) {
      return el.evaluate(processValue);
    });
  }
  setVariables(variables) {
    this.values.forEach((el) => {
      el.setVariables(variables);
    });
  }
  hasFunction() {
    return this.values.some((operand) => operand.hasFunction());
  }
  hasAsyncFunction() {
    return this.values.some((operand) => operand.hasAsyncFunction());
  }
  addToAsyncList(list) {
    this.values.forEach((operand) => operand.addToAsyncList(list));
  }
  isContentEqual(op) {
    const aOp = op;
    if (aOp.values.length !== this.values.length) return false;
    for (var i = 0; i < this.values.length; i++) {
      if (!aOp.values[i].isEqual(this.values[i])) return false;
    }
    return true;
  }
};
var Const = class extends Operand {
  constructor(value) {
    super();
    this.value = value;
  }
  getType() {
    return "const";
  }
  toString(func = void 0) {
    if (!!func) {
      var res = func(this);
      if (!!res) return res;
    }
    return this.value.toString();
  }
  get correctValue() {
    return this.getCorrectValue(this.value);
  }
  get requireStrictCompare() {
    return false;
  }
  evaluate() {
    return this.getCorrectValue(this.value);
  }
  setVariables(variables) {
  }
  getCorrectValue(value) {
    if (!value || typeof value != "string") return value;
    if (OperandMaker.isBooleanValue(value)) return value.toLowerCase() === "true";
    if (value.length > 1 && this.isQuote(value[0]) && this.isQuote(value[value.length - 1])) return value.substring(1, value.length - 1);
    if (Helpers.isNumber(value)) {
      if (value[0] === "0" && value.indexOf("0x") != 0) {
        const len = value.length;
        const hasPoint = len > 1 && (value[1] === "." || value[1] === ",");
        if (!hasPoint && len > 1 || hasPoint && len < 2) return value;
      }
      return Helpers.getNumber(value);
    }
    return value;
  }
  isContentEqual(op) {
    const cOp = op;
    return cOp.value == this.value;
  }
  isQuote(ch) {
    return ch == "'" || ch == '"';
  }
};
var Variable = class _Variable extends Const {
  static get DisableConversionChar() {
    return settings.expressionDisableConversionChar;
  }
  static set DisableConversionChar(val) {
    settings.expressionDisableConversionChar = val;
  }
  constructor(variableName) {
    super(variableName);
    this.variableName = variableName;
    this.valueInfo = {};
    this.useValueAsItIs = false;
    if (!!this.variableName && this.variableName.length > 1 && this.variableName[0] === _Variable.DisableConversionChar) {
      this.variableName = this.variableName.substring(1);
      this.useValueAsItIs = true;
    }
  }
  get requireStrictCompare() {
    return this.valueInfo.sctrictCompare === true;
  }
  getType() {
    return "variable";
  }
  toString(func = void 0) {
    if (!!func) {
      var res = func(this);
      if (!!res) return res;
    }
    var prefix = this.useValueAsItIs ? _Variable.DisableConversionChar : "";
    return "{" + prefix + this.variableName + "}";
  }
  get variable() {
    return this.variableName;
  }
  evaluate(processValue) {
    this.valueInfo.name = this.variableName;
    processValue.getValueInfo(this.valueInfo);
    return this.valueInfo.hasValue ? this.getCorrectValue(this.valueInfo.value) : null;
  }
  setVariables(variables) {
    variables.push(this.variableName);
  }
  getCorrectValue(value) {
    if (this.useValueAsItIs) return value;
    return super.getCorrectValue(value);
  }
  isContentEqual(op) {
    const vOp = op;
    return vOp.variable == this.variable;
  }
};
var FunctionOperand = class extends Operand {
  constructor(originalValue, parameters) {
    super();
    this.originalValue = originalValue;
    this.parameters = parameters;
    if (Array.isArray(parameters) && parameters.length === 0) {
      this.parameters = new ArrayOperand([]);
    }
  }
  getType() {
    return "function";
  }
  evaluate(processValue) {
    const asyncVal = this.getAsynValue(processValue);
    if (!!asyncVal) return asyncVal.value;
    return this.evaluateCore(processValue);
  }
  evaluateCore(processValue) {
    let properties = processValue.properties;
    if (this.isAsyncFunction) {
      properties = Helpers.createCopy(processValue.properties);
      const id = this.id;
      const asyncValues = processValue.asyncValues;
      const onComplete = processValue.onCompleteAsyncFunc;
      const item = this;
      properties.returnResult = (result) => {
        asyncValues[id] = {
          value: result
        };
        onComplete(item);
      };
    }
    return FunctionFactory.Instance.run(this.originalValue, this.parameters.evaluate(processValue), properties, this.parameters.values);
  }
  toString(func = void 0) {
    if (!!func) {
      var res = func(this);
      if (!!res) return res;
    }
    return this.originalValue + "(" + this.parameters.toString(func) + ")";
  }
  setVariables(variables) {
    this.parameters.setVariables(variables);
  }
  isReady(proccessValue) {
    return !!this.getAsynValue(proccessValue);
  }
  getAsynValue(proccessValue) {
    return proccessValue.asyncValues[this.id];
  }
  hasFunction() {
    return true;
  }
  hasAsyncFunction() {
    return this.isAsyncFunction() || this.parameters.hasAsyncFunction();
  }
  isAsyncFunction() {
    return FunctionFactory.Instance.isAsyncFunction(this.originalValue);
  }
  addToAsyncList(list) {
    let item = void 0;
    if (this.isAsyncFunction()) {
      item = {
        operand: this
      };
    }
    if (this.parameters.hasAsyncFunction()) {
      const children = new Array();
      this.parameters.addToAsyncList(children);
      children.forEach((child) => child.parent = item);
      if (!item) {
        item = {};
      }
      item.children = children;
    }
    if (item) {
      list.push(item);
    }
  }
  isContentEqual(op) {
    const fOp = op;
    return fOp.originalValue == this.originalValue && this.areOperatorsEquals(fOp.parameters, this.parameters);
  }
};
var OperandMaker = class _OperandMaker {
  static throwInvalidOperatorError(op) {
    throw new Error("Invalid operator: '" + op + "'");
  }
  static safeToString(operand, func) {
    return operand == null ? "" : operand.toString(func);
  }
  static toOperandString(value) {
    if (!!value && !Helpers.isNumber(value) && !_OperandMaker.isBooleanValue(value)) value = "'" + value + "'";
    return value;
  }
  static isBooleanValue(value) {
    return !!value && (value.toLowerCase() === "true" || value.toLowerCase() === "false");
  }
  static countDecimals(value) {
    if (Helpers.isNumber(value) && Math.floor(value) !== value) {
      const strs = value.toString().split(".");
      return strs.length > 1 && strs[1].length || 0;
    }
    return 0;
  }
  static plusMinus(a, b, res) {
    const digitsA = _OperandMaker.countDecimals(a);
    const digitsB = _OperandMaker.countDecimals(b);
    if (digitsA > 0 || digitsB > 0) {
      const digits = Math.max(digitsA, digitsB);
      res = parseFloat(res.toFixed(digits));
    }
    return res;
  }
  static isTwoValueEquals(x, y, ignoreOrder = true) {
    if (x === "undefined") x = void 0;
    if (y === "undefined") y = void 0;
    return Helpers.isTwoValueEquals(x, y, ignoreOrder);
  }
  static operatorToString(operatorName) {
    let opStr = _OperandMaker.signs[operatorName];
    return opStr == null ? operatorName : opStr;
  }
  static convertValForDateCompare(val, second) {
    if (second instanceof Date && typeof val === "string") {
      let res = createDate("expression-operand", val);
      res.setHours(0, 0, 0);
      return res;
    }
    return val;
  }
};
OperandMaker.unaryFunctions = {
  empty: function(value) {
    return Helpers.isValueEmpty(value);
  },
  notempty: function(value) {
    return !OperandMaker.unaryFunctions.empty(value);
  },
  negate: function(value) {
    return !value;
  }
};
OperandMaker.binaryFunctions = {
  arithmeticOp(operatorName) {
    const convertForArithmeticOp = (val, second) => {
      if (!Helpers.isValueEmpty(val)) return val;
      if (typeof second === "number") return 0;
      if (typeof val === "string") return val;
      if (typeof second === "string") return "";
      if (Array.isArray(second)) return [];
      return 0;
    };
    return function(a, b) {
      a = convertForArithmeticOp(a, b);
      b = convertForArithmeticOp(b, a);
      let consumer = OperandMaker.binaryFunctions[operatorName];
      return consumer == null ? null : consumer.call(this, a, b);
    };
  },
  and: function(a, b) {
    return a && b;
  },
  or: function(a, b) {
    return a || b;
  },
  plus: function(a, b) {
    return Helpers.sumAnyValues(a, b);
  },
  minus: function(a, b) {
    return Helpers.correctAfterPlusMinis(a, b, a - b);
  },
  mul: function(a, b) {
    return Helpers.correctAfterMultiple(a, b, a * b);
  },
  div: function(a, b) {
    if (!b) return null;
    return a / b;
  },
  mod: function(a, b) {
    if (!b) return null;
    return a % b;
  },
  power: function(a, b) {
    return Math.pow(a, b);
  },
  greater: function(left, right) {
    if (left == null || right == null) return false;
    left = OperandMaker.convertValForDateCompare(left, right);
    right = OperandMaker.convertValForDateCompare(right, left);
    return left > right;
  },
  less: function(left, right) {
    if (left == null || right == null) return false;
    left = OperandMaker.convertValForDateCompare(left, right);
    right = OperandMaker.convertValForDateCompare(right, left);
    return left < right;
  },
  greaterorequal: function(left, right) {
    if (OperandMaker.binaryFunctions.equal(left, right)) return true;
    return OperandMaker.binaryFunctions.greater(left, right);
  },
  lessorequal: function(left, right) {
    if (OperandMaker.binaryFunctions.equal(left, right)) return true;
    return OperandMaker.binaryFunctions.less(left, right);
  },
  equal: function(left, right, strictCompare) {
    left = OperandMaker.convertValForDateCompare(left, right);
    right = OperandMaker.convertValForDateCompare(right, left);
    return OperandMaker.isTwoValueEquals(left, right, strictCompare !== true);
  },
  notequal: function(left, right, strictCompare) {
    return !OperandMaker.binaryFunctions.equal(left, right, strictCompare);
  },
  contains: function(left, right) {
    return OperandMaker.binaryFunctions.containsCore(left, right, true);
  },
  notcontains: function(left, right) {
    if (!left && !Helpers.isValueEmpty(right)) return true;
    return OperandMaker.binaryFunctions.containsCore(left, right, false);
  },
  anyof: function(left, right) {
    if (Helpers.isValueEmpty(left) && Helpers.isValueEmpty(right)) return true;
    if (Helpers.isValueEmpty(left) || !Array.isArray(left) && left.length === 0) return false;
    if (Helpers.isValueEmpty(right)) return true;
    if (!Array.isArray(left)) return OperandMaker.binaryFunctions.contains(right, left);
    if (!Array.isArray(right)) return OperandMaker.binaryFunctions.contains(left, right);
    for (var i = 0; i < right.length; i++) {
      if (OperandMaker.binaryFunctions.contains(left, right[i])) return true;
    }
    return false;
  },
  allof: function(left, right) {
    if (!left && !Helpers.isValueEmpty(right)) return false;
    if (!Array.isArray(right)) return OperandMaker.binaryFunctions.contains(left, right);
    for (var i = 0; i < right.length; i++) {
      if (!OperandMaker.binaryFunctions.contains(left, right[i])) return false;
    }
    return true;
  },
  containsCore: function(left, right, isContains) {
    if (!left && left !== 0 && left !== false) return false;
    if (!left.length) {
      left = left.toString();
      if (typeof right === "string" || right instanceof String) {
        left = left.toUpperCase();
        right = right.toUpperCase();
      }
    }
    if (typeof left === "string" || left instanceof String) {
      if (!right) return false;
      right = right.toString();
      var found = left.indexOf(right) > -1;
      return isContains ? found : !found;
    }
    var rightArray = Array.isArray(right) ? right : [right];
    for (var rIndex = 0; rIndex < rightArray.length; rIndex++) {
      var i = 0;
      right = rightArray[rIndex];
      for (; i < left.length; i++) {
        if (OperandMaker.isTwoValueEquals(left[i], right)) break;
      }
      if (i == left.length) return !isContains;
    }
    return isContains;
  }
};
OperandMaker.signs = {
  less: "<",
  lessorequal: "<=",
  greater: ">",
  greaterorequal: ">=",
  equal: "==",
  notequal: "!=",
  plus: "+",
  minus: "-",
  mul: "*",
  div: "/",
  and: "and",
  or: "or",
  power: "^",
  mod: "%",
  negate: "!"
};
var SyntaxError2 = class _SyntaxError extends Error {
  static buildMessage(expected, found) {
    function hex(ch) {
      return ch.charCodeAt(0).toString(16).toUpperCase();
    }
    function literalEscape(s) {
      return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, (ch) => "\\x0" + hex(ch)).replace(/[\x10-\x1F\x7F-\x9F]/g, (ch) => "\\x" + hex(ch));
    }
    function classEscape(s) {
      return s.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, (ch) => "\\x0" + hex(ch)).replace(/[\x10-\x1F\x7F-\x9F]/g, (ch) => "\\x" + hex(ch));
    }
    function describeExpectation(expectation) {
      switch (expectation.type) {
        case "literal":
          return '"' + literalEscape(expectation.text) + '"';
        case "class":
          const escapedParts = expectation.parts.map((part) => {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        case "any":
          return "any character";
        case "end":
          return "end of input";
        case "other":
          return expectation.description;
      }
    }
    function describeExpected(expected1) {
      const descriptions = expected1.map(describeExpectation);
      let i;
      let j;
      descriptions.sort();
      if (descriptions.length > 0) {
        for (i = 1, j = 1; i < descriptions.length; i++) {
          if (descriptions[i - 1] !== descriptions[i]) {
            descriptions[j] = descriptions[i];
            j++;
          }
        }
        descriptions.length = j;
      }
      switch (descriptions.length) {
        case 1:
          return descriptions[0];
        case 2:
          return descriptions[0] + " or " + descriptions[1];
        default:
          return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
      }
    }
    function describeFound(found1) {
      return found1 ? '"' + literalEscape(found1) + '"' : "end of input";
    }
    return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
  }
  constructor(message, expected, found, location) {
    super();
    this.message = message;
    this.expected = expected;
    this.found = found;
    this.location = location;
    this.name = "SyntaxError";
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, _SyntaxError);
    }
  }
};
function peg$parse(input, options) {
  options = options !== void 0 ? options : {};
  const peg$FAILED = {};
  const peg$startRuleFunctions = {
    Expression: peg$parseExpression
  };
  let peg$startRuleFunction = peg$parseExpression;
  const peg$c0 = function(head, tail) {
    return buildBinaryOperand(head, tail, true);
  };
  const peg$c1 = "||";
  const peg$c2 = peg$literalExpectation("||", false);
  const peg$c3 = "or";
  const peg$c4 = peg$literalExpectation("or", true);
  const peg$c5 = function() {
    return "or";
  };
  const peg$c6 = "&&";
  const peg$c7 = peg$literalExpectation("&&", false);
  const peg$c8 = "and";
  const peg$c9 = peg$literalExpectation("and", true);
  const peg$c10 = function() {
    return "and";
  };
  const peg$c11 = function(head, tail) {
    return buildBinaryOperand(head, tail);
  };
  const peg$c12 = "<=";
  const peg$c13 = peg$literalExpectation("<=", false);
  const peg$c14 = "lessorequal";
  const peg$c15 = peg$literalExpectation("lessorequal", true);
  const peg$c16 = function() {
    return "lessorequal";
  };
  const peg$c17 = ">=";
  const peg$c18 = peg$literalExpectation(">=", false);
  const peg$c19 = "greaterorequal";
  const peg$c20 = peg$literalExpectation("greaterorequal", true);
  const peg$c21 = function() {
    return "greaterorequal";
  };
  const peg$c22 = "==";
  const peg$c23 = peg$literalExpectation("==", false);
  const peg$c24 = "equal";
  const peg$c25 = peg$literalExpectation("equal", true);
  const peg$c26 = function() {
    return "equal";
  };
  const peg$c27 = "=";
  const peg$c28 = peg$literalExpectation("=", false);
  const peg$c29 = "!=";
  const peg$c30 = peg$literalExpectation("!=", false);
  const peg$c31 = "notequal";
  const peg$c32 = peg$literalExpectation("notequal", true);
  const peg$c33 = function() {
    return "notequal";
  };
  const peg$c34 = "<";
  const peg$c35 = peg$literalExpectation("<", false);
  const peg$c36 = "less";
  const peg$c37 = peg$literalExpectation("less", true);
  const peg$c38 = function() {
    return "less";
  };
  const peg$c39 = ">";
  const peg$c40 = peg$literalExpectation(">", false);
  const peg$c41 = "greater";
  const peg$c42 = peg$literalExpectation("greater", true);
  const peg$c43 = function() {
    return "greater";
  };
  const peg$c44 = "+";
  const peg$c45 = peg$literalExpectation("+", false);
  const peg$c46 = function() {
    return "plus";
  };
  const peg$c47 = "-";
  const peg$c48 = peg$literalExpectation("-", false);
  const peg$c49 = function() {
    return "minus";
  };
  const peg$c50 = "*";
  const peg$c51 = peg$literalExpectation("*", false);
  const peg$c52 = function() {
    return "mul";
  };
  const peg$c53 = "/";
  const peg$c54 = peg$literalExpectation("/", false);
  const peg$c55 = function() {
    return "div";
  };
  const peg$c56 = "%";
  const peg$c57 = peg$literalExpectation("%", false);
  const peg$c58 = function() {
    return "mod";
  };
  const peg$c59 = "^";
  const peg$c60 = peg$literalExpectation("^", false);
  const peg$c61 = "power";
  const peg$c62 = peg$literalExpectation("power", true);
  const peg$c63 = function() {
    return "power";
  };
  const peg$c64 = "*=";
  const peg$c65 = peg$literalExpectation("*=", false);
  const peg$c66 = "contains";
  const peg$c67 = peg$literalExpectation("contains", true);
  const peg$c68 = "contain";
  const peg$c69 = peg$literalExpectation("contain", true);
  const peg$c70 = function() {
    return "contains";
  };
  const peg$c71 = "notcontains";
  const peg$c72 = peg$literalExpectation("notcontains", true);
  const peg$c73 = "notcontain";
  const peg$c74 = peg$literalExpectation("notcontain", true);
  const peg$c75 = function() {
    return "notcontains";
  };
  const peg$c76 = "anyof";
  const peg$c77 = peg$literalExpectation("anyof", true);
  const peg$c78 = function() {
    return "anyof";
  };
  const peg$c79 = "allof";
  const peg$c80 = peg$literalExpectation("allof", true);
  const peg$c81 = function() {
    return "allof";
  };
  const peg$c82 = "(";
  const peg$c83 = peg$literalExpectation("(", false);
  const peg$c84 = ")";
  const peg$c85 = peg$literalExpectation(")", false);
  const peg$c86 = function(expr) {
    return expr;
  };
  const peg$c87 = function(name, params) {
    return new FunctionOperand(name, params);
  };
  const peg$c88 = "!";
  const peg$c89 = peg$literalExpectation("!", false);
  const peg$c90 = "negate";
  const peg$c91 = peg$literalExpectation("negate", true);
  const peg$c92 = function(expr) {
    return new UnaryOperand(expr, "negate");
  };
  const peg$c93 = function(expr, op) {
    return new UnaryOperand(expr, op);
  };
  const peg$c94 = "empty";
  const peg$c95 = peg$literalExpectation("empty", true);
  const peg$c96 = function() {
    return "empty";
  };
  const peg$c97 = "notempty";
  const peg$c98 = peg$literalExpectation("notempty", true);
  const peg$c99 = function() {
    return "notempty";
  };
  const peg$c100 = "undefined";
  const peg$c101 = peg$literalExpectation("undefined", false);
  const peg$c102 = "null";
  const peg$c103 = peg$literalExpectation("null", false);
  const peg$c104 = function() {
    return null;
  };
  const peg$c105 = function(value) {
    return new Const(value);
  };
  const peg$c106 = "{";
  const peg$c107 = peg$literalExpectation("{", false);
  const peg$c108 = "}";
  const peg$c109 = peg$literalExpectation("}", false);
  const peg$c110 = function(value) {
    return new Variable(value);
  };
  const peg$c111 = function(value) {
    return value;
  };
  const peg$c112 = "''";
  const peg$c113 = peg$literalExpectation("''", false);
  const peg$c114 = function() {
    return "";
  };
  const peg$c115 = '""';
  const peg$c116 = peg$literalExpectation('""', false);
  const peg$c117 = "'";
  const peg$c118 = peg$literalExpectation("'", false);
  const peg$c119 = function(value) {
    return "'" + value + "'";
  };
  const peg$c120 = '"';
  const peg$c121 = peg$literalExpectation('"', false);
  const peg$c122 = "[";
  const peg$c123 = peg$literalExpectation("[", false);
  const peg$c124 = "]";
  const peg$c125 = peg$literalExpectation("]", false);
  const peg$c126 = function(sequence) {
    return sequence;
  };
  const peg$c127 = ",";
  const peg$c128 = peg$literalExpectation(",", false);
  const peg$c129 = function(expr, tail) {
    if (expr == null) return new ArrayOperand([]);
    var array = [expr];
    if (Array.isArray(tail)) {
      var flatten = flattenArray(tail);
      for (var i = 3; i < flatten.length; i += 4) {
        array.push(flatten[i]);
      }
    }
    return new ArrayOperand(array);
  };
  const peg$c130 = "true";
  const peg$c131 = peg$literalExpectation("true", true);
  const peg$c132 = function() {
    return true;
  };
  const peg$c133 = "false";
  const peg$c134 = peg$literalExpectation("false", true);
  const peg$c135 = function() {
    return false;
  };
  const peg$c136 = "0x";
  const peg$c137 = peg$literalExpectation("0x", false);
  const peg$c138 = function() {
    return parseInt(text(), 16);
  };
  const peg$c139 = /^[\-]/;
  const peg$c140 = peg$classExpectation(["-"], false, false);
  const peg$c141 = function(sign, num) {
    return sign == null ? num : -num;
  };
  const peg$c142 = ".";
  const peg$c143 = peg$literalExpectation(".", false);
  const peg$c144 = function() {
    return parseFloat(text());
  };
  const peg$c145 = function() {
    return parseInt(text(), 10);
  };
  const peg$c146 = "0";
  const peg$c147 = peg$literalExpectation("0", false);
  const peg$c148 = function() {
    return 0;
  };
  const peg$c149 = function(chars) {
    return chars.join("");
  };
  const peg$c150 = "\\'";
  const peg$c151 = peg$literalExpectation("\\'", false);
  const peg$c152 = function() {
    return "'";
  };
  const peg$c153 = '\\"';
  const peg$c154 = peg$literalExpectation('\\"', false);
  const peg$c155 = function() {
    return '"';
  };
  const peg$c156 = /^[^"']/;
  const peg$c157 = peg$classExpectation(['"', "'"], true, false);
  const peg$c158 = function() {
    return text();
  };
  const peg$c159 = /^[^{}]/;
  const peg$c160 = peg$classExpectation(["{", "}"], true, false);
  const peg$c161 = /^[0-9]/;
  const peg$c162 = peg$classExpectation([["0", "9"]], false, false);
  const peg$c163 = /^[1-9]/;
  const peg$c164 = peg$classExpectation([["1", "9"]], false, false);
  const peg$c165 = /^[a-zA-Z_]/;
  const peg$c166 = peg$classExpectation([["a", "z"], ["A", "Z"], "_"], false, false);
  const peg$c167 = peg$otherExpectation("whitespace");
  const peg$c168 = /^[ \t\n\r]/;
  const peg$c169 = peg$classExpectation([" ", "	", "\n", "\r"], false, false);
  let peg$currPos = 0;
  let peg$savedPos = 0;
  const peg$posDetailsCache = [{
    line: 1,
    column: 1
  }];
  let peg$maxFailPos = 0;
  let peg$maxFailExpected = [];
  let peg$silentFails = 0;
  const peg$resultsCache = {};
  let peg$result;
  if (options.startRule !== void 0) {
    if (!(options.startRule in peg$startRuleFunctions)) {
      throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
    }
    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
  }
  function text() {
    return input.substring(peg$savedPos, peg$currPos);
  }
  function peg$literalExpectation(text1, ignoreCase) {
    return {
      type: "literal",
      text: text1,
      ignoreCase
    };
  }
  function peg$classExpectation(parts, inverted, ignoreCase) {
    return {
      type: "class",
      parts,
      inverted,
      ignoreCase
    };
  }
  function peg$endExpectation() {
    return {
      type: "end"
    };
  }
  function peg$otherExpectation(description) {
    return {
      type: "other",
      description
    };
  }
  function peg$computePosDetails(pos) {
    let details = peg$posDetailsCache[pos];
    let p;
    if (details) {
      return details;
    } else {
      p = pos - 1;
      while (!peg$posDetailsCache[p]) {
        p--;
      }
      details = peg$posDetailsCache[p];
      details = {
        line: details.line,
        column: details.column
      };
      while (p < pos) {
        if (input.charCodeAt(p) === 10) {
          details.line++;
          details.column = 1;
        } else {
          details.column++;
        }
        p++;
      }
      peg$posDetailsCache[pos] = details;
      return details;
    }
  }
  function peg$computeLocation(startPos, endPos) {
    const startPosDetails = peg$computePosDetails(startPos);
    const endPosDetails = peg$computePosDetails(endPos);
    return {
      start: {
        offset: startPos,
        line: startPosDetails.line,
        column: startPosDetails.column
      },
      end: {
        offset: endPos,
        line: endPosDetails.line,
        column: endPosDetails.column
      }
    };
  }
  function peg$fail(expected1) {
    if (peg$currPos < peg$maxFailPos) {
      return;
    }
    if (peg$currPos > peg$maxFailPos) {
      peg$maxFailPos = peg$currPos;
      peg$maxFailExpected = [];
    }
    peg$maxFailExpected.push(expected1);
  }
  function peg$buildStructuredError(expected1, found, location1) {
    return new SyntaxError2(SyntaxError2.buildMessage(expected1, found), expected1, found, location1);
  }
  function peg$parseExpression() {
    let s0, s1, s2, s3, s4, s5, s6, s7, s8;
    const key = peg$currPos * 34 + 0;
    const cached = peg$resultsCache[key];
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseLogicOr();
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$currPos;
        s5 = peg$parse_();
        if (s5 !== peg$FAILED) {
          s6 = peg$parseOrSign();
          if (s6 !== peg$FAILED) {
            s7 = peg$parse_();
            if (s7 !== peg$FAILED) {
              s8 = peg$parseLogicOr();
              if (s8 !== peg$FAILED) {
                s5 = [s5, s6, s7, s8];
                s4 = s5;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
        } else {
          peg$currPos = s4;
          s4 = peg$FAILED;
        }
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$currPos;
          s5 = peg$parse_();
          if (s5 !== peg$FAILED) {
            s6 = peg$parseOrSign();
            if (s6 !== peg$FAILED) {
              s7 = peg$parse_();
              if (s7 !== peg$FAILED) {
                s8 = peg$parseLogicOr();
                if (s8 !== peg$FAILED) {
                  s5 = [s5, s6, s7, s8];
                  s4 = s5;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c0(s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0
    };
    return s0;
  }
  function peg$parseOrSign() {
    let s0, s1;
    const key = peg$currPos * 34 + 1;
    const cached = peg$resultsCache[key];
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c1) {
      s1 = peg$c1;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c2);
      }
    }
    if (s1 === peg$FAILED) {
      if (input.substr(peg$currPos, 2).toLowerCase() === peg$c3) {
        s1 = input.substr(peg$currPos, 2);
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c4);
        }
      }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c5();
    }
    s0 = s1;
    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0
    };
    return s0;
  }
  function peg$parseLogicOr() {
    let s0, s1, s2, s3, s4, s5, s6, s7;
    const key = peg$currPos * 34 + 2;
    const cached = peg$resultsCache[key];
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    s0 = peg$currPos;
    s1 = peg$parseLogicAnd();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse_();
      if (s4 !== peg$FAILED) {
        s5 = peg$parseAndSign();
        if (s5 !== peg$FAILED) {
          s6 = peg$parse_();
          if (s6 !== peg$FAILED) {
            s7 = peg$parseLogicAnd();
            if (s7 !== peg$FAILED) {
              s4 = [s4, s5, s6, s7];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseAndSign();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseLogicAnd();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c0(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0
    };
    return s0;
  }
  function peg$parseAndSign() {
    let s0, s1;
    const key = peg$currPos * 34 + 3;
    const cached = peg$resultsCache[key];
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c6) {
      s1 = peg$c6;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c7);
      }
    }
    if (s1 === peg$FAILED) {
      if (input.substr(peg$currPos, 3).toLowerCase() === peg$c8) {
        s1 = input.substr(peg$currPos, 3);
        peg$currPos += 3;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c9);
        }
      }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c10();
    }
    s0 = s1;
    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0
    };
    return s0;
  }
  function peg$parseLogicAnd() {
    let s0, s1, s2, s3, s4, s5, s6, s7;
    const key = peg$currPos * 34 + 4;
    const cached = peg$resultsCache[key];
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    s0 = peg$currPos;
    s1 = peg$parseCompOps();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse_();
      if (s4 !== peg$FAILED) {
        s5 = peg$parseComparableOperators();
        if (s5 !== peg$FAILED) {
          s6 = peg$parse_();
          if (s6 !== peg$FAILED) {
            s7 = peg$parseCompOps();
            if (s7 !== peg$FAILED) {
              s4 = [s4, s5, s6, s7];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseComparableOperators();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseCompOps();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c11(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0
    };
    return s0;
  }
  function peg$parseComparableOperators() {
    let s0, s1;
    const key = peg$currPos * 34 + 5;
    const cached = peg$resultsCache[key];
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c12) {
      s1 = peg$c12;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c13);
      }
    }
    if (s1 === peg$FAILED) {
      if (input.substr(peg$currPos, 11).toLowerCase() === peg$c14) {
        s1 = input.substr(peg$currPos, 11);
        peg$currPos += 11;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c15);
        }
      }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c16();
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c17) {
        s1 = peg$c17;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c18);
        }
      }
      if (s1 === peg$FAILED) {
        if (input.substr(peg$currPos, 14).toLowerCase() === peg$c19) {
          s1 = input.substr(peg$currPos, 14);
          peg$currPos += 14;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c20);
          }
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c21();
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c22) {
          s1 = peg$c22;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c23);
          }
        }
        if (s1 === peg$FAILED) {
          if (input.substr(peg$currPos, 5).toLowerCase() === peg$c24) {
            s1 = input.substr(peg$currPos, 5);
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c25);
            }
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c26();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 61) {
            s1 = peg$c27;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c28);
            }
          }
          if (s1 === peg$FAILED) {
            if (input.substr(peg$currPos, 5).toLowerCase() === peg$c24) {
              s1 = input.substr(peg$currPos, 5);
              peg$currPos += 5;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c25);
              }
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c26();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c29) {
              s1 = peg$c29;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c30);
              }
            }
            if (s1 === peg$FAILED) {
              if (input.substr(peg$currPos, 8).toLowerCase() === peg$c31) {
                s1 = input.substr(peg$currPos, 8);
                peg$currPos += 8;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c32);
                }
              }
            }
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c33();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 60) {
                s1 = peg$c34;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c35);
                }
              }
              if (s1 === peg$FAILED) {
                if (input.substr(peg$currPos, 4).toLowerCase() === peg$c36) {
                  s1 = input.substr(peg$currPos, 4);
                  peg$currPos += 4;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c37);
                  }
                }
              }
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c38();
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 62) {
                  s1 = peg$c39;
                  peg$currPos++;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c40);
                  }
                }
                if (s1 === peg$FAILED) {
                  if (input.substr(peg$currPos, 7).toLowerCase() === peg$c41) {
                    s1 = input.substr(peg$currPos, 7);
                    peg$currPos += 7;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c42);
                    }
                  }
                }
                if (s1 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c43();
                }
                s0 = s1;
              }
            }
          }
        }
      }
    }
    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0
    };
    return s0;
  }
  function peg$parseCompOps() {
    let s0, s1, s2, s3, s4, s5, s6, s7;
    const key = peg$currPos * 34 + 6;
    const cached = peg$resultsCache[key];
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    s0 = peg$currPos;
    s1 = peg$parsePlusMinusOps();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse_();
      if (s4 !== peg$FAILED) {
        s5 = peg$parsePlusMinusSigns();
        if (s5 !== peg$FAILED) {
          s6 = peg$parse_();
          if (s6 !== peg$FAILED) {
            s7 = peg$parsePlusMinusOps();
            if (s7 !== peg$FAILED) {
              s4 = [s4, s5, s6, s7];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          s5 = peg$parsePlusMinusSigns();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parsePlusMinusOps();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c0(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0
    };
    return s0;
  }
  function peg$parsePlusMinusSigns() {
    let s0, s1;
    const key = peg$currPos * 34 + 7;
    const cached = peg$resultsCache[key];
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 43) {
      s1 = peg$c44;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c45);
      }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c46();
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 45) {
        s1 = peg$c47;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c48);
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c49();
      }
      s0 = s1;
    }
    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0
    };
    return s0;
  }
  function peg$parsePlusMinusOps() {
    let s0, s1, s2, s3, s4, s5, s6, s7;
    const key = peg$currPos * 34 + 8;
    const cached = peg$resultsCache[key];
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    s0 = peg$currPos;
    s1 = peg$parseMulDivOps();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse_();
      if (s4 !== peg$FAILED) {
        s5 = peg$parseMulDivSigns();
        if (s5 !== peg$FAILED) {
          s6 = peg$parse_();
          if (s6 !== peg$FAILED) {
            s7 = peg$parseMulDivOps();
            if (s7 !== peg$FAILED) {
              s4 = [s4, s5, s6, s7];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseMulDivSigns();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseMulDivOps();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c0(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0
    };
    return s0;
  }
  function peg$parseMulDivSigns() {
    let s0, s1;
    const key = peg$currPos * 34 + 9;
    const cached = peg$resultsCache[key];
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 42) {
      s1 = peg$c50;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c51);
      }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c52();
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 47) {
        s1 = peg$c53;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c54);
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c55();
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 37) {
          s1 = peg$c56;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c57);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c58();
        }
        s0 = s1;
      }
    }
    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0
    };
    return s0;
  }
  function peg$parseMulDivOps() {
    let s0, s1, s2, s3, s4, s5, s6, s7;
    const key = peg$currPos * 34 + 10;
    const cached = peg$resultsCache[key];
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    s0 = peg$currPos;
    s1 = peg$parseBinaryFuncOp();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse_();
      if (s4 !== peg$FAILED) {
        s5 = peg$parsePowerSigns();
        if (s5 !== peg$FAILED) {
          s6 = peg$parse_();
          if (s6 !== peg$FAILED) {
            s7 = peg$parseBinaryFuncOp();
            if (s7 !== peg$FAILED) {
              s4 = [s4, s5, s6, s7];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          s5 = peg$parsePowerSigns();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseBinaryFuncOp();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c0(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0
    };
    return s0;
  }
  function peg$parsePowerSigns() {
    let s0, s1;
    const key = peg$currPos * 34 + 11;
    const cached = peg$resultsCache[key];
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 94) {
      s1 = peg$c59;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c60);
      }
    }
    if (s1 === peg$FAILED) {
      if (input.substr(peg$currPos, 5).toLowerCase() === peg$c61) {
        s1 = input.substr(peg$currPos, 5);
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c62);
        }
      }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c63();
    }
    s0 = s1;
    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0
    };
    return s0;
  }
  function peg$parseBinaryFuncOp() {
    let s0, s1, s2, s3, s4, s5, s6, s7;
    const key = peg$currPos * 34 + 12;
    const cached = peg$resultsCache[key];
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    s0 = peg$currPos;
    s1 = peg$parseFactor();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse_();
      if (s4 !== peg$FAILED) {
        s5 = peg$parseBinFunctions();
        if (s5 !== peg$FAILED) {
          s6 = peg$parse_();
          if (s6 !== peg$FAILED) {
            s7 = peg$parseFactor();
            if (s7 === peg$FAILED) {
              s7 = null;
            }
            if (s7 !== peg$FAILED) {
              s4 = [s4, s5, s6, s7];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseBinFunctions();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseFactor();
              if (s7 === peg$FAILED) {
                s7 = null;
              }
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c11(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0
    };
    return s0;
  }
  function peg$parseBinFunctions() {
    let s0, s1;
    const key = peg$currPos * 34 + 13;
    const cached = peg$resultsCache[key];
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c64) {
      s1 = peg$c64;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c65);
      }
    }
    if (s1 === peg$FAILED) {
      if (input.substr(peg$currPos, 8).toLowerCase() === peg$c66) {
        s1 = input.substr(peg$currPos, 8);
        peg$currPos += 8;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c67);
        }
      }
      if (s1 === peg$FAILED) {
        if (input.substr(peg$currPos, 7).toLowerCase() === peg$c68) {
          s1 = input.substr(peg$currPos, 7);
          peg$currPos += 7;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c69);
          }
        }
      }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c70();
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 11).toLowerCase() === peg$c71) {
        s1 = input.substr(peg$currPos, 11);
        peg$currPos += 11;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c72);
        }
      }
      if (s1 === peg$FAILED) {
        if (input.substr(peg$currPos, 10).toLowerCase() === peg$c73) {
          s1 = input.substr(peg$currPos, 10);
          peg$currPos += 10;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c74);
          }
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c75();
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 5).toLowerCase() === peg$c76) {
          s1 = input.substr(peg$currPos, 5);
          peg$currPos += 5;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c77);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c78();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5).toLowerCase() === peg$c79) {
            s1 = input.substr(peg$currPos, 5);
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c80);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c81();
          }
          s0 = s1;
        }
      }
    }
    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0
    };
    return s0;
  }
  function peg$parseFactor() {
    let s0, s1, s2, s3, s4, s5;
    const key = peg$currPos * 34 + 14;
    const cached = peg$resultsCache[key];
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 40) {
      s1 = peg$c82;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c83);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseExpression();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 41) {
              s5 = peg$c84;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c85);
              }
            }
            if (s5 === peg$FAILED) {
              s5 = null;
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c86(s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parseFunctionOp();
      if (s0 === peg$FAILED) {
        s0 = peg$parseUnaryFunctionOp();
        if (s0 === peg$FAILED) {
          s0 = peg$parseAtom();
          if (s0 === peg$FAILED) {
            s0 = peg$parseArrayOp();
          }
        }
      }
    }
    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0
    };
    return s0;
  }
  function peg$parseFunctionOp() {
    let s0, s1, s2, s3, s4;
    const key = peg$currPos * 34 + 15;
    const cached = peg$resultsCache[key];
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    s0 = peg$currPos;
    s1 = peg$parseLettersAndDigits();
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 40) {
        s2 = peg$c82;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c83);
        }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parseSequence();
        if (s3 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 41) {
            s4 = peg$c84;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c85);
            }
          }
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c87(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0
    };
    return s0;
  }
  function peg$parseUnaryFunctionOp() {
    let s0, s1, s2, s3;
    const key = peg$currPos * 34 + 16;
    const cached = peg$resultsCache[key];
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 33) {
      s1 = peg$c88;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c89);
      }
    }
    if (s1 === peg$FAILED) {
      if (input.substr(peg$currPos, 6).toLowerCase() === peg$c90) {
        s1 = input.substr(peg$currPos, 6);
        peg$currPos += 6;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c91);
        }
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseExpression();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c92(s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseAtom();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseUnFunctions();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c93(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }
    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0
    };
    return s0;
  }
  function peg$parseUnFunctions() {
    let s0, s1;
    const key = peg$currPos * 34 + 17;
    const cached = peg$resultsCache[key];
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c94) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c95);
      }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c96();
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 8).toLowerCase() === peg$c97) {
        s1 = input.substr(peg$currPos, 8);
        peg$currPos += 8;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c98);
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c99();
      }
      s0 = s1;
    }
    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0
    };
    return s0;
  }
  function peg$parseAtom() {
    let s0, s1, s2, s3, s4;
    const key = peg$currPos * 34 + 18;
    const cached = peg$resultsCache[key];
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      if (input.substr(peg$currPos, 9) === peg$c100) {
        s2 = peg$c100;
        peg$currPos += 9;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c101);
        }
      }
      if (s2 === peg$FAILED) {
        if (input.substr(peg$currPos, 4) === peg$c102) {
          s2 = peg$c102;
          peg$currPos += 4;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c103);
          }
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c104();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseConstValue();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c105(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parse_();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 123) {
            s2 = peg$c106;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c107);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parseValueInput();
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 125) {
                s4 = peg$c108;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c109);
                }
              }
              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c110(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }
    }
    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0
    };
    return s0;
  }
  function peg$parseConstValue() {
    let s0, s1, s2, s3;
    const key = peg$currPos * 34 + 19;
    const cached = peg$resultsCache[key];
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    s0 = peg$currPos;
    s1 = peg$parseLogicValue();
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c111(s1);
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseArithmeticValue();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c111(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseLettersAndDigits();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c111(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c112) {
            s1 = peg$c112;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c113);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c114();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c115) {
              s1 = peg$c115;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c116);
              }
            }
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c114();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 39) {
                s1 = peg$c117;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c118);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$parseAnyInput();
                if (s2 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 39) {
                    s3 = peg$c117;
                    peg$currPos++;
                  } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c118);
                    }
                  }
                  if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c119(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 34) {
                  s1 = peg$c120;
                  peg$currPos++;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c121);
                  }
                }
                if (s1 !== peg$FAILED) {
                  s2 = peg$parseAnyInput();
                  if (s2 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 34) {
                      s3 = peg$c120;
                      peg$currPos++;
                    } else {
                      s3 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c121);
                      }
                    }
                    if (s3 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c119(s2);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              }
            }
          }
        }
      }
    }
    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0
    };
    return s0;
  }
  function peg$parseArrayOp() {
    let s0, s1, s2, s3;
    const key = peg$currPos * 34 + 20;
    const cached = peg$resultsCache[key];
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 91) {
      s1 = peg$c122;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c123);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseSequence();
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 93) {
          s3 = peg$c124;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c125);
          }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c126(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0
    };
    return s0;
  }
  function peg$parseSequence() {
    let s0, s1, s2, s3, s4, s5, s6, s7;
    const key = peg$currPos * 34 + 21;
    const cached = peg$resultsCache[key];
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    s0 = peg$currPos;
    s1 = peg$parseExpression();
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse_();
      if (s4 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 44) {
          s5 = peg$c127;
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c128);
          }
        }
        if (s5 !== peg$FAILED) {
          s6 = peg$parse_();
          if (s6 !== peg$FAILED) {
            s7 = peg$parseExpression();
            if (s7 !== peg$FAILED) {
              s4 = [s4, s5, s6, s7];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s5 = peg$c127;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c128);
            }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseExpression();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c129(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0
    };
    return s0;
  }
  function peg$parseLogicValue() {
    let s0, s1;
    const key = peg$currPos * 34 + 22;
    const cached = peg$resultsCache[key];
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c130) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c131);
      }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c132();
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 5).toLowerCase() === peg$c133) {
        s1 = input.substr(peg$currPos, 5);
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c134);
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c135();
      }
      s0 = s1;
    }
    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0
    };
    return s0;
  }
  function peg$parseArithmeticValue() {
    let s0, s1, s2;
    const key = peg$currPos * 34 + 23;
    const cached = peg$resultsCache[key];
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c136) {
      s1 = peg$c136;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c137);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseDigits();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c138();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (peg$c139.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c140);
        }
      }
      if (s1 === peg$FAILED) {
        s1 = null;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseNumber();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c141(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }
    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0
    };
    return s0;
  }
  function peg$parseNumber() {
    let s0, s1, s2, s3;
    const key = peg$currPos * 34 + 24;
    const cached = peg$resultsCache[key];
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    s0 = peg$currPos;
    s1 = peg$parseDigits();
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 46) {
        s2 = peg$c142;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c143);
        }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parseDigits();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c144();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseNonZeroDigits();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseDigits();
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c145();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 48) {
          s1 = peg$c146;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c147);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c148();
        }
        s0 = s1;
      }
    }
    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0
    };
    return s0;
  }
  function peg$parseValueInput() {
    let s0, s1, s2;
    const key = peg$currPos * 34 + 25;
    const cached = peg$resultsCache[key];
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseValueCharacters();
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parseValueCharacters();
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c149(s1);
    }
    s0 = s1;
    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0
    };
    return s0;
  }
  function peg$parseAnyInput() {
    let s0, s1, s2;
    const key = peg$currPos * 34 + 26;
    const cached = peg$resultsCache[key];
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseAnyCharacters();
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parseAnyCharacters();
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c149(s1);
    }
    s0 = s1;
    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0
    };
    return s0;
  }
  function peg$parseAnyCharacters() {
    let s0, s1;
    const key = peg$currPos * 34 + 27;
    const cached = peg$resultsCache[key];
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c150) {
      s1 = peg$c150;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c151);
      }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c152();
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c153) {
        s1 = peg$c153;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c154);
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c155();
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (peg$c156.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c157);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c158();
        }
        s0 = s1;
      }
    }
    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0
    };
    return s0;
  }
  function peg$parseValueCharacters() {
    let s0, s1;
    const key = peg$currPos * 34 + 28;
    const cached = peg$resultsCache[key];
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    s0 = peg$currPos;
    if (peg$c159.test(input.charAt(peg$currPos))) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c160);
      }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c158();
    }
    s0 = s1;
    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0
    };
    return s0;
  }
  function peg$parseLettersAndDigits() {
    let s0, s1, s2, s3, s4, s5, s6;
    const key = peg$currPos * 34 + 29;
    const cached = peg$resultsCache[key];
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    s0 = peg$currPos;
    s1 = peg$parseLetters();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parseDigits();
      if (s4 !== peg$FAILED) {
        s5 = [];
        s6 = peg$parseLetters();
        while (s6 !== peg$FAILED) {
          s5.push(s6);
          s6 = peg$parseLetters();
        }
        if (s5 !== peg$FAILED) {
          s4 = [s4, s5];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parseDigits();
        if (s4 !== peg$FAILED) {
          s5 = [];
          s6 = peg$parseLetters();
          while (s6 !== peg$FAILED) {
            s5.push(s6);
            s6 = peg$parseLetters();
          }
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c158();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0
    };
    return s0;
  }
  function peg$parseDigits() {
    let s0, s1;
    const key = peg$currPos * 34 + 30;
    const cached = peg$resultsCache[key];
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    s0 = [];
    if (peg$c161.test(input.charAt(peg$currPos))) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c162);
      }
    }
    if (s1 !== peg$FAILED) {
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        if (peg$c161.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c162);
          }
        }
      }
    } else {
      s0 = peg$FAILED;
    }
    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0
    };
    return s0;
  }
  function peg$parseNonZeroDigits() {
    let s0, s1;
    const key = peg$currPos * 34 + 31;
    const cached = peg$resultsCache[key];
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    s0 = [];
    if (peg$c163.test(input.charAt(peg$currPos))) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c164);
      }
    }
    if (s1 !== peg$FAILED) {
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        if (peg$c163.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c164);
          }
        }
      }
    } else {
      s0 = peg$FAILED;
    }
    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0
    };
    return s0;
  }
  function peg$parseLetters() {
    let s0, s1;
    const key = peg$currPos * 34 + 32;
    const cached = peg$resultsCache[key];
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    s0 = [];
    if (peg$c165.test(input.charAt(peg$currPos))) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c166);
      }
    }
    if (s1 !== peg$FAILED) {
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        if (peg$c165.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c166);
          }
        }
      }
    } else {
      s0 = peg$FAILED;
    }
    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0
    };
    return s0;
  }
  function peg$parse_() {
    let s0, s1;
    const key = peg$currPos * 34 + 33;
    const cached = peg$resultsCache[key];
    if (cached) {
      peg$currPos = cached.nextPos;
      return cached.result;
    }
    peg$silentFails++;
    s0 = [];
    if (peg$c168.test(input.charAt(peg$currPos))) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c169);
      }
    }
    while (s1 !== peg$FAILED) {
      s0.push(s1);
      if (peg$c168.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c169);
        }
      }
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c167);
      }
    }
    peg$resultsCache[key] = {
      nextPos: peg$currPos,
      result: s0
    };
    return s0;
  }
  function buildBinaryOperand(head, tail, isArithmeticOp = false) {
    return tail.reduce(function(result, elements) {
      return new BinaryOperand(elements[1], result, elements[3], isArithmeticOp);
    }, head);
  }
  function flattenArray(array) {
    return [].concat.apply([], array);
  }
  peg$result = peg$startRuleFunction();
  if (peg$result !== peg$FAILED && peg$currPos === input.length) {
    return peg$result;
  } else {
    if (peg$result !== peg$FAILED && peg$currPos < input.length) {
      peg$fail(peg$endExpectation());
    }
    throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
  }
}
var parse = peg$parse;
var ConditionsParserError = class {
  constructor(at, code) {
    this.at = at;
    this.code = code;
  }
};
var ConditionsParser = class _ConditionsParser {
  patchExpression(text) {
    return text.replace(/=>/g, ">=").replace(/=</g, "<=").replace(/<>/g, "!=").replace(/equals/g, "equal ").replace(/notequals/g, "notequal ");
  }
  createCondition(text) {
    return this.parseExpression(text);
  }
  parseExpression(text) {
    try {
      var result = _ConditionsParser.parserCache[text];
      if (result === void 0) {
        result = parse(this.patchExpression(text));
        if (!result.hasAsyncFunction()) {
          _ConditionsParser.parserCache[text] = result;
        }
      }
      return result;
    } catch (e) {
      if (e instanceof SyntaxError2) {
        this.conditionError = new ConditionsParserError(e.location.start.offset, e.message);
      }
    }
  }
  get error() {
    return this.conditionError;
  }
};
ConditionsParser.parserCache = {};
var ExpressionExecutorRunner = class {
  constructor(operand, id, onComplete, values, properties) {
    this.operand = operand;
    this.id = id;
    this.onComplete = onComplete;
    this.processValue = new ProcessValue();
    this.processValue.values = values;
    this.processValue.properties = properties;
  }
  run(isAsync) {
    if (!isAsync) return this.runValues();
    this.processValue.values = Helpers.createCopy(this.processValue.values);
    this.processValue.onCompleteAsyncFunc = (op) => {
      const item = this.getAsyncItemByOperand(op, this.asyncFuncList);
      if (item) {
        this.doAsyncFunctionReady(item);
      }
    };
    this.asyncFuncList = new Array();
    this.operand.addToAsyncList(this.asyncFuncList);
    for (var i = 0; i < this.asyncFuncList.length; i++) {
      this.runAsyncItem(this.asyncFuncList[i]);
    }
    return false;
  }
  getAsyncItemByOperand(op, list) {
    if (!Array.isArray(list)) return null;
    for (let i = 0; i < list.length; i++) {
      if (list[i].operand === op) return list[i];
      const res = this.getAsyncItemByOperand(op, list[i].children);
      if (!!res) return res;
    }
    return null;
  }
  runAsyncItem(item) {
    if (item.children) {
      item.children.forEach((child) => this.runAsyncItem(child));
    } else {
      this.runAsyncItemCore(item);
    }
  }
  runAsyncItemCore(item) {
    if (item.operand) {
      item.operand.evaluate(this.processValue);
    } else {
      this.doAsyncFunctionReady(item);
    }
  }
  doAsyncFunctionReady(item) {
    if (item.parent && this.isAsyncChildrenReady(item)) {
      this.runAsyncItemCore(item.parent);
      return;
    }
    for (var i = 0; i < this.asyncFuncList.length; i++) {
      if (!this.isAsyncFuncReady(this.asyncFuncList[i])) return;
    }
    this.runValues();
  }
  isAsyncFuncReady(item) {
    if (item.operand && !item.operand.isReady(this.processValue)) return false;
    return this.isAsyncChildrenReady(item);
  }
  isAsyncChildrenReady(item) {
    if (item.children) {
      for (let i = 0; i < item.children.length; i++) {
        if (!this.isAsyncFuncReady(item.children[i])) return false;
      }
    }
    return true;
  }
  runValues() {
    var res = this.operand.evaluate(this.processValue);
    if (!!this.onComplete) {
      this.onComplete(res, this.id);
    }
    return res;
  }
};
var ExpressionExecutor = class {
  constructor(expression) {
    this.parser = new ConditionsParser();
    this.isAsyncValue = false;
    this.hasFunctionValue = false;
    this.setExpression(expression);
  }
  get expression() {
    return this.expressionValue;
  }
  setExpression(value) {
    if (this.expression === value) return;
    this.expressionValue = value;
    this.operand = this.parser.parseExpression(value);
    this.hasFunctionValue = this.canRun() ? this.operand.hasFunction() : false;
    this.isAsyncValue = this.hasFunction() ? this.operand.hasAsyncFunction() : false;
  }
  getVariables() {
    if (!this.operand) return [];
    var variables = [];
    this.operand.setVariables(variables);
    return variables;
  }
  hasFunction() {
    return this.hasFunctionValue;
  }
  get isAsync() {
    return this.isAsyncValue;
  }
  canRun() {
    return !!this.operand;
  }
  run(values, properties = null, id) {
    if (!this.operand) {
      if (!!this.expression) {
        ConsoleWarnings.warn("Invalid expression: " + this.expression);
      }
      return null;
    }
    const runner = new ExpressionExecutorRunner(this.operand, id, this.onComplete, values, properties);
    return runner.run(this.isAsync);
  }
};
ExpressionExecutor.createExpressionExecutor = (expression) => {
  return new ExpressionExecutor(expression);
};
var ExpressionRunnerBase = class _ExpressionRunnerBase {
  constructor(expression) {
    this.expression = expression;
  }
  get expression() {
    return !!this.expressionExecutor ? this.expressionExecutor.expression : "";
  }
  set expression(value) {
    if (!!this.expressionExecutor && value === this.expression) return;
    this.expressionExecutor = ExpressionExecutor.createExpressionExecutor(value);
    this.expressionExecutor.onComplete = (res, id) => {
      this.doOnComplete(res, id);
    };
    this.variables = void 0;
    this.containsFunc = void 0;
  }
  getVariables() {
    if (this.variables === void 0) {
      this.variables = this.expressionExecutor.getVariables();
    }
    return this.variables;
  }
  hasFunction() {
    if (this.containsFunc === void 0) {
      this.containsFunc = this.expressionExecutor.hasFunction();
    }
    return this.containsFunc;
  }
  get isAsync() {
    return this.expressionExecutor.isAsync;
  }
  canRun() {
    return this.expressionExecutor.canRun();
  }
  runCore(values, properties = null) {
    const id = _ExpressionRunnerBase.IdRunnerCounter++;
    if (this.onBeforeAsyncRun && this.isAsync) {
      this.onBeforeAsyncRun(id);
    }
    return this.expressionExecutor.run(values, properties, id);
  }
  doOnComplete(res, id) {
    if (this.onAfterAsyncRun && this.isAsync) {
      this.onAfterAsyncRun(id);
    }
  }
};
ExpressionRunnerBase.IdRunnerCounter = 1;
var ConditionRunner = class extends ExpressionRunnerBase {
  run(values, properties = null) {
    return this.runCore(values, properties) == true;
  }
  doOnComplete(res, id) {
    if (!!this.onRunComplete) this.onRunComplete(res == true);
    super.doOnComplete(res, id);
  }
};
var ExpressionRunner = class extends ExpressionRunnerBase {
  run(values, properties = null) {
    return this.runCore(values, properties);
  }
  doOnComplete(res, id) {
    if (!!this.onRunComplete) this.onRunComplete(res);
    super.doOnComplete(res, id);
  }
};
var Bindings = class {
  constructor(obj) {
    this.obj = obj;
    this.properties = null;
    this.values = null;
  }
  getType() {
    return "bindings";
  }
  get isSurveyObj() {
    return true;
  }
  getNames() {
    var res = [];
    this.fillProperties();
    for (var i = 0; i < this.properties.length; i++) {
      if (this.properties[i].isVisible("", this.obj)) {
        res.push(this.properties[i].name);
      }
    }
    return res;
  }
  getProperties() {
    var res = [];
    this.fillProperties();
    for (var i = 0; i < this.properties.length; i++) {
      res.push(this.properties[i]);
    }
    return res;
  }
  setBinding(propertyName, valueName) {
    if (!this.values) this.values = {};
    const oldValue = this.getJson();
    if (oldValue === valueName) return;
    if (!!valueName) {
      this.values[propertyName] = valueName;
    } else {
      delete this.values[propertyName];
      if (Object.keys(this.values).length == 0) {
        this.values = null;
      }
    }
    this.onChangedJSON(oldValue);
  }
  clearBinding(propertyName) {
    this.setBinding(propertyName, "");
  }
  isEmpty() {
    if (!this.values) return true;
    for (var key in this.values) return false;
    return true;
  }
  getValueNameByPropertyName(propertyName) {
    if (!this.values) return void 0;
    return this.values[propertyName];
  }
  getPropertiesByValueName(valueName) {
    if (!this.values) return [];
    var res = [];
    for (var key in this.values) {
      if (this.values[key] == valueName) {
        res.push(key);
      }
    }
    return res;
  }
  getJson() {
    if (this.isEmpty()) return void 0;
    var res = {};
    for (var key in this.values) {
      res[key] = this.values[key];
    }
    return res;
  }
  setJson(value, isLoading) {
    const oldValue = this.getJson();
    this.values = null;
    if (!!value) {
      this.values = {};
      for (var key in value) {
        this.values[key] = value[key];
      }
    }
    if (!isLoading) {
      this.onChangedJSON(oldValue);
    }
  }
  fillProperties() {
    if (this.properties !== null) return;
    this.properties = [];
    var objProperties = Serializer.getPropertiesByObj(this.obj);
    for (var i = 0; i < objProperties.length; i++) {
      if (objProperties[i].isBindable) {
        this.properties.push(objProperties[i]);
      }
    }
  }
  onChangedJSON(oldValue) {
    if (this.obj) {
      this.obj.onBindingChanged(oldValue, this.getJson());
    }
  }
};
var Dependencies = class _Dependencies {
  constructor(currentDependency, target, property2) {
    this.currentDependency = currentDependency;
    this.target = target;
    this.property = property2;
    this.dependencies = [];
    this.id = "" + ++_Dependencies.DependenciesCount;
  }
  addDependency(target, property2) {
    if (this.target === target && this.property === property2) return;
    if (this.dependencies.some((dependency) => dependency.obj === target && dependency.prop === property2)) return;
    this.dependencies.push({
      obj: target,
      prop: property2,
      id: this.id
    });
    target.registerPropertyChangedHandlers([property2], this.currentDependency, this.id);
  }
  dispose() {
    this.dependencies.forEach((dependency) => {
      dependency.obj.unregisterPropertyChangedHandlers([dependency.prop], dependency.id);
    });
  }
};
Dependencies.DependenciesCount = 0;
var ComputedUpdater = class _ComputedUpdater {
  constructor(_updater) {
    this._updater = _updater;
    this.dependencies = void 0;
    this.type = _ComputedUpdater.ComputedUpdaterType;
  }
  get updater() {
    return this._updater;
  }
  setDependencies(dependencies) {
    this.clearDependencies();
    this.dependencies = dependencies;
  }
  getDependencies() {
    return this.dependencies;
  }
  clearDependencies() {
    if (this.dependencies) {
      this.dependencies.dispose();
      this.dependencies = void 0;
    }
  }
  dispose() {
    this.clearDependencies();
    this._updater = void 0;
  }
};
ComputedUpdater.ComputedUpdaterType = "__dependency_computed";
var Base = class _Base {
  static finishCollectDependencies() {
    const deps = _Base.currentDependencis;
    _Base.currentDependencis = void 0;
    return deps;
  }
  static startCollectDependencies(updater, target, property2) {
    if (_Base.currentDependencis !== void 0) {
      throw new Error("Attempt to collect nested dependencies. Nested dependencies are not supported.");
    }
    _Base.currentDependencis = new Dependencies(updater, target, property2);
  }
  static collectDependency(target, property2) {
    if (_Base.currentDependencis === void 0) return;
    _Base.currentDependencis.addDependency(target, property2);
  }
  static get commentSuffix() {
    return settings.commentSuffix;
  }
  static set commentSuffix(val) {
    settings.commentSuffix = val;
  }
  static get commentPrefix() {
    return _Base.commentSuffix;
  }
  static set commentPrefix(val) {
    _Base.commentSuffix = val;
  }
  /**
   * Returns `true` if a passed `value` is an empty string, array, or object or if it equals to `undefined` or `null`.
   *
   * @param value A value to be checked.
   * @param trimString *(Optional)* When this parameter is `true`, the method ignores whitespace characters at the beginning and end of a string value. Pass `false` to disable this functionality.
   */
  isValueEmpty(value, trimString = true) {
    if (trimString) {
      value = this.trimValue(value);
    }
    return Helpers.isValueEmpty(value);
  }
  equals(obj) {
    if (!obj) return false;
    if (this.isDisposed || obj.isDisposed) return false;
    if (this.getType() != obj.getType()) return false;
    return this.equalsCore(obj);
  }
  equalsCore(obj) {
    if (this.name !== obj.name) return false;
    return Helpers.isTwoValueEquals(this.toJSON(), obj.toJSON(), false, true, false);
  }
  trimValue(value) {
    if (!!value && (typeof value === "string" || value instanceof String)) return value.trim();
    return value;
  }
  static createPropertiesHash() {
    return {};
  }
  constructor() {
    this.dependencies = {};
    this.propertyHash = _Base.createPropertiesHash();
    this.eventList = [];
    this.isLoadingFromJsonValue = false;
    this.loadingOwner = null;
    this.onPropertyChanged = this.addEvent();
    this.onItemValuePropertyChanged = this.addEvent();
    this.isCreating = true;
    this.animationAllowedLock = 0;
    this.supportOnElementRerenderedEvent = true;
    this.onElementRerenderedEventEnabled = false;
    this._onElementRerendered = new EventBase();
    CustomPropertiesCollection.createProperties(this);
    this.onBaseCreating();
    this.isCreating = false;
  }
  dispose() {
    for (var i = 0; i < this.eventList.length; i++) {
      this.eventList[i].clear();
    }
    this.onPropertyValueChangedCallback = void 0;
    this.isDisposedValue = true;
    Object.keys(this.dependencies).forEach((key) => this.dependencies[key].dispose());
    Object.keys(this.propertyHash).forEach((key) => {
      const propVal = this.getPropertyValueCore(this.propertyHash, key);
      if (!!propVal && propVal.type == ComputedUpdater.ComputedUpdaterType) {
        propVal.dispose();
      }
    });
  }
  get isDisposed() {
    return this.isDisposedValue === true;
  }
  get isSurveyObj() {
    return true;
  }
  addEvent() {
    const res = new EventBase();
    this.eventList.push(res);
    return res;
  }
  onBaseCreating() {
  }
  /**
   * Returns the object type as it is used in the JSON schema.
   */
  getType() {
    return "base";
  }
  /**
   * Use this method to find out if the current object is of a given `typeName` or inherited from it.
   *
   * @param typeName One of the values listed in the [getType()](https://surveyjs.io/form-library/documentation/question#getType) description.
   * @returns `true` if the current object is of a given `typeName` or inherited from it.
   * @see getType
   */
  isDescendantOf(typeName) {
    return Serializer.isDescendantOf(this.getType(), typeName);
  }
  getSurvey(isLive = false) {
    return null;
  }
  /**
   * Returns `true` if the survey is being designed in Survey Creator.
   */
  get isDesignMode() {
    const survey = this.getSurvey();
    return !!survey && survey.isDesignMode;
  }
  /**
   * Returns `true` if the object is included in a survey.
   *
   * This property may return `false`, for example, when you [create a survey model dynamically](https://surveyjs.io/form-library/documentation/design-survey-create-a-simple-survey#create-or-change-a-survey-model-dynamically).
   */
  get inSurvey() {
    return !!this.getSurvey(true);
  }
  get bindings() {
    if (!this.bindingsValue) {
      this.bindingsValue = new Bindings(this);
    }
    return this.bindingsValue;
  }
  isBindingEmpty() {
    return !this.bindingsValue || this.bindingsValue.isEmpty();
  }
  checkBindings(valueName, value) {
  }
  updateBindings(propertyName, value) {
    if (!this.bindingsValue) return;
    var valueName = this.bindings.getValueNameByPropertyName(propertyName);
    if (!!valueName) {
      this.updateBindingValue(valueName, value);
    }
  }
  updateBindingValue(valueName, value) {
  }
  getTemplate() {
    return this.getType();
  }
  /**
   * Returns `true` if the object configuration is being loaded from JSON.
   */
  get isLoadingFromJson() {
    return this.isLoadingFromJsonValue || this.getIsLoadingFromJson();
  }
  getIsLoadingFromJson() {
    if (!!this.loadingOwner && this.loadingOwner.isLoadingFromJson) return true;
    return this.isLoadingFromJsonValue;
  }
  startLoadingFromJson(json2) {
    this.isLoadingFromJsonValue = true;
    this.jsonObj = json2;
  }
  endLoadingFromJson() {
    this.isLoadingFromJsonValue = false;
  }
  /**
   * Returns a JSON object that corresponds to the current SurveyJS object.
   * @see fromJSON
   */
  toJSON(options) {
    return new JsonObject().toJsonObject(this, options);
  }
  /**
   * Assigns a new configuration to the current SurveyJS object. This configuration is taken from a passed JSON object.
   *
   * The JSON object should contain only serializable properties of this SurveyJS object. Event handlers and properties that do not belong to the SurveyJS object are ignored.
   *
   * @param json A JSON object with properties that you want to apply to the current SurveyJS object.
   * @param options An object with configuration options.
   * @param {boolean} options.validatePropertyValues Pass `true` if you want to validate property values. Use the [`jsonErrors`](#jsonErrors) array to access validation errors.
   * @see toJSON
   */
  fromJSON(json2, options) {
    new JsonObject().toObject(json2, this, options);
    this.onSurveyLoad();
  }
  onSurveyLoad() {
  }
  /**
   * Creates a new object that has the same type and properties as the current SurveyJS object.
   */
  clone() {
    var clonedObj = Serializer.createClass(this.getType());
    clonedObj.fromJSON(this.toJSON());
    return clonedObj;
  }
  /**
   * Returns a `JsonObjectProperty` object with metadata about a serializable property that belongs to the current SurveyJS object.
   *
   * If the property is not found, this method returns `null`.
   * @param propName A property name.
   */
  getPropertyByName(propName) {
    const type = this.getType();
    if (!this.classMetaData || this.classMetaData.name !== type) {
      this.classMetaData = Serializer.findClass(type);
    }
    return !!this.classMetaData ? this.classMetaData.findProperty(propName) : null;
  }
  isPropertyVisible(propName) {
    const prop = this.getPropertyByName(propName);
    return !!prop ? prop.isVisible("", this) : false;
  }
  static createProgressInfo() {
    return {
      questionCount: 0,
      answeredQuestionCount: 0,
      requiredQuestionCount: 0,
      requiredAnsweredQuestionCount: 0
    };
  }
  getProgressInfo() {
    return _Base.createProgressInfo();
  }
  localeChanged() {
  }
  locStrsChanged() {
    if (!!this.arraysInfo) {
      for (let key in this.arraysInfo) {
        let item = this.arraysInfo[key];
        if (item && item.isItemValues) {
          var arr = this.getPropertyValue(key);
          if (arr && !!_Base.itemValueLocStrChanged) _Base.itemValueLocStrChanged(arr);
        }
      }
    }
    if (!!this.localizableStrings) {
      for (let key in this.localizableStrings) {
        let item = this.getLocalizableString(key);
        if (item) item.strChanged();
      }
    }
  }
  /**
   * Returns the value of a property with a specified name.
   *
   * If the property is not found or does not have a value, this method returns either `undefined`, `defaultValue` specified in the property configuration, or a value passed as the `defaultValue` parameter.
   *
   * @param name A property name.
   * @param defaultValue *(Optional)* A value to return if the property is not found or does not have a value.
   */
  getPropertyValue(name, defaultValue, calcFunc) {
    const res = this.getPropertyValueWithoutDefault(name);
    if (this.isValueUndefined(res)) {
      const locStr = this.localizableStrings ? this.localizableStrings[name] : void 0;
      if (locStr) return locStr.text;
      if (!this.isValueUndefined(defaultValue)) return defaultValue;
      if (!!calcFunc) {
        const newVal = calcFunc();
        if (newVal !== void 0) {
          if (Array.isArray(newVal)) {
            const array = this.createNewArray(name);
            array.splice(0, 0, ...newVal);
            return array;
          } else {
            this.setPropertyValueDirectly(name, newVal);
            return newVal;
          }
        }
      }
      const propDefaultValue = this.getDefaultPropertyValue(name);
      if (propDefaultValue !== void 0) return propDefaultValue;
    }
    return res;
  }
  isValueUndefined(value) {
    return Helpers.isValueUndefined(value);
  }
  getDefaultPropertyValue(name) {
    const prop = this.getPropertyByName(name);
    if (!prop || prop.isCustom && this.isCreating) return void 0;
    if (!!prop.defaultValueFunc) return prop.defaultValueFunc(this);
    const dValue = prop.getDefaultValue(this);
    if (!this.isValueUndefined(dValue) && !Array.isArray(dValue)) return dValue;
    const locStr = this.localizableStrings ? this.localizableStrings[name] : void 0;
    if (locStr && locStr.localizationName) return this.getLocalizationString(locStr.localizationName);
    if (prop.type == "boolean" || prop.type == "switch") return false;
    if (prop.isCustom && !!prop.onGetValue) return prop.onGetValue(this);
    return void 0;
  }
  hasDefaultPropertyValue(name) {
    return this.getDefaultPropertyValue(name) !== void 0;
  }
  resetPropertyValue(name) {
    const locStr = this.localizableStrings ? this.localizableStrings[name] : void 0;
    if (locStr) {
      this.setLocalizableStringText(name, void 0);
      locStr.clear();
    } else {
      this.setPropertyValue(name, void 0);
    }
  }
  getPropertyValueWithoutDefault(name) {
    return this.getPropertyValueCore(this.propertyHash, name);
  }
  getPropertyValueCore(propertiesHash, name) {
    if (!this.isLoadingFromJson) {
      _Base.collectDependency(this, name);
    }
    if (this.getPropertyValueCoreHandler) return this.getPropertyValueCoreHandler(propertiesHash, name);
    else return propertiesHash[name];
  }
  geValueFromHash() {
    return this.propertyHash["value"];
  }
  setPropertyValueCore(propertiesHash, name, val) {
    if (this.setPropertyValueCoreHandler) {
      if (!this.isDisposedValue) {
        this.setPropertyValueCoreHandler(propertiesHash, name, val);
      } else {
        ConsoleWarnings.disposedObjectChangedProperty(name, this.getType());
      }
    } else propertiesHash[name] = val;
  }
  get isEditingSurveyElement() {
    var survey = this.getSurvey();
    return !!survey && survey.isEditingSurveyElement;
  }
  iteratePropertiesHash(func) {
    var keys = [];
    for (var key in this.propertyHash) {
      if (key === "value" && this.isEditingSurveyElement && Array.isArray(this.value)) continue;
      keys.push(key);
    }
    keys.forEach((key2) => func(this.propertyHash, key2));
  }
  /**
   * Assigns a new value to a specified property.
   * @param name A property name.
   * @param val A new value for the property.
   */
  setPropertyValue(name, val) {
    if (this.isDisposedValue) return;
    if (!this.isLoadingFromJson) {
      const prop = this.getPropertyByName(name);
      if (!!prop) {
        val = prop.settingValue(this, val);
      }
    }
    var oldValue = this.getPropertyValue(name);
    if (oldValue && Array.isArray(oldValue) && !!this.arraysInfo && (!val || Array.isArray(val))) {
      if (!this.isTwoValueEquals(oldValue, val)) {
        this.setArrayPropertyDirectly(name, val);
      }
    } else {
      if (val !== oldValue) {
        this.setPropertyValueDirectly(name, val);
        if (!this.isTwoValueEquals(oldValue, val)) {
          this.propertyValueChanged(name, oldValue, val);
        }
      }
    }
  }
  setArrayPropertyDirectly(name, val, sendNotification = true) {
    var arrayInfo = this.arraysInfo[name];
    this.setArray(name, this.getPropertyValue(name), val, arrayInfo ? arrayInfo.isItemValues : false, arrayInfo ? sendNotification && arrayInfo.onPush : null);
  }
  setPropertyValueDirectly(name, val) {
    this.setPropertyValueCore(this.propertyHash, name, val);
  }
  clearPropertyValue(name) {
    this.setPropertyValueCore(this.propertyHash, name, null);
    delete this.propertyHash[name];
  }
  onPropertyValueChangedCallback(name, oldValue, newValue, sender, arrayChanges) {
  }
  itemValuePropertyChanged(item, name, oldValue, newValue) {
    this.onItemValuePropertyChanged.fire(this, {
      obj: item,
      name,
      oldValue,
      newValue,
      propertyName: item.ownerPropertyName
    });
  }
  onPropertyValueChanged(name, oldValue, newValue) {
  }
  propertyValueChanged(name, oldValue, newValue, arrayChanges, target) {
    if (this.isLoadingFromJson) return;
    this.updateBindings(name, newValue);
    this.onPropertyValueChanged(name, oldValue, newValue);
    this.onPropertyChanged.fire(this, {
      name,
      oldValue,
      newValue,
      arrayChanges,
      target
    });
    this.doPropertyValueChangedCallback(name, oldValue, newValue, arrayChanges, this);
    this.checkConditionPropertyChanged(name);
    if (!this.onPropChangeFunctions) return;
    for (var i = 0; i < this.onPropChangeFunctions.length; i++) {
      if (this.onPropChangeFunctions[i].name == name) this.onPropChangeFunctions[i].func(newValue, arrayChanges);
    }
  }
  onBindingChanged(oldValue, newValue) {
    if (this.isLoadingFromJson) return;
    this.doPropertyValueChangedCallback("bindings", oldValue, newValue);
  }
  get isInternal() {
    return false;
  }
  doPropertyValueChangedCallback(name, oldValue, newValue, arrayChanges, target) {
    const fireCallback = (obj) => {
      if (!!obj && !!obj.onPropertyValueChangedCallback) {
        obj.onPropertyValueChangedCallback(name, oldValue, newValue, target, arrayChanges);
      }
    };
    if (this.isInternal) {
      fireCallback(this);
      return;
    }
    if (!target) target = this;
    var notifier = this.getSurvey();
    if (!notifier) notifier = this;
    fireCallback(notifier);
    if (notifier !== this) {
      fireCallback(this);
    }
  }
  addExpressionProperty(name, onExecute, canRun) {
    if (!this.expressionInfo) {
      this.expressionInfo = {};
    }
    this.expressionInfo[name] = {
      onExecute,
      canRun
    };
  }
  getDataFilteredValues() {
    return {};
  }
  getDataFilteredProperties() {
    return {};
  }
  runConditionCore(values, properties) {
    if (!this.expressionInfo) return;
    for (var key in this.expressionInfo) {
      this.runConditionItemCore(key, values, properties);
    }
  }
  canRunConditions() {
    return !this.isDesignMode;
  }
  checkConditionPropertyChanged(propName) {
    if (!this.expressionInfo || !this.expressionInfo[propName]) return;
    if (!this.canRunConditions()) return;
    this.runConditionItemCore(propName, this.getDataFilteredValues(), this.getDataFilteredProperties());
  }
  runConditionItemCore(propName, values, properties) {
    const info = this.expressionInfo[propName];
    const expression = this.getPropertyValue(propName);
    if (!expression) return;
    if (!!info.canRun && !info.canRun(this)) return;
    if (!info.runner) {
      info.runner = this.createExpressionRunner(expression);
      info.runner.onRunComplete = (res) => {
        info.onExecute(this, res);
      };
    }
    info.runner.expression = expression;
    info.runner.run(values, properties);
  }
  doBeforeAsynRun(id) {
    if (!this.asynExpressionHash) this.asynExpressionHash = {};
    const isChanged = !this.isAsyncExpressionRunning;
    this.asynExpressionHash[id] = true;
    if (isChanged) {
      this.onAsyncRunningChanged();
    }
  }
  doAfterAsynRun(id) {
    if (!!this.asynExpressionHash) {
      delete this.asynExpressionHash[id];
      if (!this.isAsyncExpressionRunning) {
        this.onAsyncRunningChanged();
      }
    }
  }
  onAsyncRunningChanged() {
  }
  get isAsyncExpressionRunning() {
    return !!this.asynExpressionHash && Object.keys(this.asynExpressionHash).length > 0;
  }
  createExpressionRunner(expression) {
    const res = new ExpressionRunner(expression);
    res.onBeforeAsyncRun = (id) => {
      this.doBeforeAsynRun(id);
    };
    res.onAfterAsyncRun = (id) => {
      this.doAfterAsynRun(id);
    };
    return res;
  }
  /**
   * Registers a single value change handler for one or multiple properties.
   *
   * The `registerPropertyChangedHandlers` and [`unregisterPropertyChangedHandlers`](#unregisterPropertyChangedHandlers) methods allow you to manage property change event handlers dynamically. If you only need to attach an event handler without removing it afterwards, you can use the [`onPropertyChanged`](#onPropertyChanged) event instead.
   * @param propertyNames An array of one or multiple property names.
   * @param handler A function to call when one of the listed properties change. Accepts a new property value as an argument.
   * @param key *(Optional)* A key that identifies the current registration. If a function for one of the properties is already registered with the same key, the function will be overwritten. You can also use the key to subsequently unregister handlers.
   * @see unregisterPropertyChangedHandlers
   */
  registerPropertyChangedHandlers(propertyNames, handler, key = null) {
    for (var i = 0; i < propertyNames.length; i++) {
      this.registerFunctionOnPropertyValueChanged(propertyNames[i], handler, key);
    }
  }
  /**
   * Unregisters value change event handlers for the specified properties.
   * @param propertyNames An array of one or multiple property names.
   * @param key *(Optional)* A key of the registration that you want to cancel.
   * @see registerPropertyChangedHandlers
   */
  unregisterPropertyChangedHandlers(propertyNames, key = null) {
    for (var i = 0; i < propertyNames.length; i++) {
      this.unRegisterFunctionOnPropertyValueChanged(propertyNames[i], key);
    }
  }
  registerFunctionOnPropertyValueChanged(name, func, key = null) {
    if (!this.onPropChangeFunctions) {
      this.onPropChangeFunctions = [];
    }
    if (key) {
      for (var i = 0; i < this.onPropChangeFunctions.length; i++) {
        var item = this.onPropChangeFunctions[i];
        if (item.name == name && item.key == key) {
          item.func = func;
          return;
        }
      }
    }
    this.onPropChangeFunctions.push({
      name,
      func,
      key
    });
  }
  registerFunctionOnPropertiesValueChanged(names, func, key = null) {
    this.registerPropertyChangedHandlers(names, func, key);
  }
  unRegisterFunctionOnPropertyValueChanged(name, key = null) {
    if (!this.onPropChangeFunctions) return;
    for (var i = 0; i < this.onPropChangeFunctions.length; i++) {
      var item = this.onPropChangeFunctions[i];
      if (item.name == name && item.key == key) {
        this.onPropChangeFunctions.splice(i, 1);
        return;
      }
    }
  }
  unRegisterFunctionOnPropertiesValueChanged(names, key = null) {
    this.unregisterPropertyChangedHandlers(names, key);
  }
  createCustomLocalizableObj(name) {
    const locStr = this.getLocalizableString(name);
    if (locStr) return locStr;
    return this.createLocalizableString(name, this, false, true);
  }
  getLocale() {
    const locOwner = this.getSurvey();
    return !!locOwner ? locOwner.getLocale() : "";
  }
  getLocalizationString(strName) {
    return getLocaleString(strName, this.getLocale());
  }
  getLocalizationFormatString(strName, ...args) {
    const str = this.getLocalizationString(strName);
    if (!str || !str.format) return "";
    return str.format(...args);
  }
  createLocalizableString(name, owner, useMarkDown = false, defaultStr = false) {
    let locName = void 0;
    if (defaultStr) {
      locName = defaultStr === true ? name : defaultStr;
    }
    const locStr = new LocalizableString(owner, useMarkDown, name, locName);
    locStr.onStrChanged = (oldValue, newValue) => {
      this.propertyValueChanged(name, oldValue, newValue);
    };
    if (!this.localizableStrings) {
      this.localizableStrings = {};
    }
    this.localizableStrings[name] = locStr;
    const prop = this.getPropertyByName(name);
    locStr.disableLocalization = prop && prop.isLocalizable === false;
    return locStr;
  }
  removeLocalizableString(name) {
    if (this.localizableStrings) {
      delete this.localizableStrings[name];
    }
  }
  getLocalizableString(name) {
    return !!this.localizableStrings ? this.localizableStrings[name] : null;
  }
  getLocalizableStringText(name, defaultStr = "") {
    _Base.collectDependency(this, name);
    var locStr = this.getLocalizableString(name);
    if (!locStr) return "";
    var res = locStr.text;
    return res ? res : defaultStr;
  }
  setLocalizableStringText(name, value) {
    let locStr = this.getLocalizableString(name);
    if (!locStr) return;
    let oldValue = locStr.text;
    if (oldValue != value) {
      locStr.text = value;
    }
  }
  addUsedLocales(locales) {
    if (!!this.localizableStrings) {
      for (let key in this.localizableStrings) {
        let item = this.getLocalizableString(key);
        if (item) this.AddLocStringToUsedLocales(item, locales);
      }
    }
    if (!!this.arraysInfo) {
      for (let key in this.arraysInfo) {
        const prop = this.getPropertyByName(key);
        if (!prop || !prop.isPropertySerializable(this)) continue;
        let items = this.getPropertyValue(key);
        if (!items || !items.length) continue;
        for (let i = 0; i < items.length; i++) {
          let item = items[i];
          if (item && item.addUsedLocales) {
            item.addUsedLocales(locales);
          }
        }
      }
    }
  }
  searchText(text, founded) {
    var strs = [];
    this.getSearchableLocalizedStrings(strs);
    for (var i = 0; i < strs.length; i++) {
      if (strs[i].setFindText(text)) {
        founded.push({
          element: this,
          str: strs[i]
        });
      }
    }
  }
  getSearchableLocalizedStrings(arr) {
    if (!!this.localizableStrings) {
      let keys2 = [];
      this.getSearchableLocKeys(keys2);
      for (var i = 0; i < keys2.length; i++) {
        let item = this.getLocalizableString(keys2[i]);
        if (item) arr.push(item);
      }
    }
    if (!this.arraysInfo) return;
    let keys = [];
    this.getSearchableItemValueKeys(keys);
    for (var i = 0; i < keys.length; i++) {
      var items = this.getPropertyValue(keys[i]);
      if (!items) continue;
      for (var j = 0; j < items.length; j++) {
        arr.push(items[j].locText);
      }
    }
  }
  getSearchableLocKeys(keys) {
  }
  getSearchableItemValueKeys(keys) {
  }
  AddLocStringToUsedLocales(locStr, locales) {
    var locs = locStr.getLocales();
    for (var i = 0; i < locs.length; i++) {
      if (locales.indexOf(locs[i]) < 0) {
        locales.push(locs[i]);
      }
    }
  }
  createItemValues(name) {
    var self2 = this;
    var result = this.createNewArray(name, function(item) {
      item.locOwner = self2;
      item.ownerPropertyName = name;
      if (typeof item.getSurvey == "function") {
        const survey = item.getSurvey();
        if (!!survey && typeof survey.makeReactive == "function") {
          survey.makeReactive(item);
        }
      }
    });
    this.arraysInfo[name].isItemValues = true;
    return result;
  }
  notifyArrayChanged(ar, arrayChanges) {
    !!ar.onArrayChanged && ar.onArrayChanged(arrayChanges);
  }
  createNewArrayCore(name) {
    var res = null;
    if (!!this.createArrayCoreHandler) {
      res = this.createArrayCoreHandler(this.propertyHash, name);
    }
    if (!res) {
      res = new Array();
      this.setPropertyValueCore(this.propertyHash, name, res);
    }
    return res;
  }
  ensureArray(name, onPush = null, onRemove = null) {
    if (this.arraysInfo && this.arraysInfo[name]) {
      return;
    }
    return this.createNewArray(name, onPush, onRemove);
  }
  createNewArray(name, onPush = null, onRemove = null) {
    var newArray = this.createNewArrayCore(name);
    if (!this.arraysInfo) {
      this.arraysInfo = {};
    }
    this.arraysInfo[name] = {
      onPush,
      isItemValues: false
    };
    var self2 = this;
    newArray.push = function(value) {
      var result = Object.getPrototypeOf(newArray).push.call(newArray, value);
      if (!self2.isDisposedValue) {
        if (onPush) onPush(value, newArray.length - 1);
        const arrayChanges = new ArrayChanges(newArray.length - 1, 0, [value], []);
        self2.propertyValueChanged(name, newArray, newArray, arrayChanges);
        self2.notifyArrayChanged(newArray, arrayChanges);
      }
      return result;
    };
    newArray.shift = function() {
      var result = Object.getPrototypeOf(newArray).shift.call(newArray);
      if (!self2.isDisposedValue && result) {
        if (onRemove) onRemove(result);
        const arrayChanges = new ArrayChanges(newArray.length - 1, 1, [], []);
        self2.propertyValueChanged(name, newArray, newArray, arrayChanges);
        self2.notifyArrayChanged(newArray, arrayChanges);
      }
      return result;
    };
    newArray.unshift = function(value) {
      var result = Object.getPrototypeOf(newArray).unshift.call(newArray, value);
      if (!self2.isDisposedValue) {
        if (onPush) onPush(value, newArray.length - 1);
        const arrayChanges = new ArrayChanges(0, 0, [value], []);
        self2.propertyValueChanged(name, newArray, newArray, arrayChanges);
        self2.notifyArrayChanged(newArray, arrayChanges);
      }
      return result;
    };
    newArray.pop = function() {
      var result = Object.getPrototypeOf(newArray).pop.call(newArray);
      if (!self2.isDisposedValue) {
        if (onRemove) onRemove(result);
        const arrayChanges = new ArrayChanges(newArray.length - 1, 1, [], []);
        self2.propertyValueChanged(name, newArray, newArray, arrayChanges);
        self2.notifyArrayChanged(newArray, arrayChanges);
      }
      return result;
    };
    newArray.splice = function(start, deleteCount, ...items) {
      if (!start) start = 0;
      if (!deleteCount) deleteCount = 0;
      var result = Object.getPrototypeOf(newArray).splice.call(newArray, start, deleteCount, ...items);
      if (!items) items = [];
      if (!self2.isDisposedValue) {
        if (onRemove && result) {
          for (var i = 0; i < result.length; i++) {
            onRemove(result[i]);
          }
        }
        if (onPush) {
          for (var i = 0; i < items.length; i++) {
            onPush(items[i], start + i);
          }
        }
        const arrayChanges = new ArrayChanges(start, deleteCount, items, result);
        self2.propertyValueChanged(name, newArray, newArray, arrayChanges);
        self2.notifyArrayChanged(newArray, arrayChanges);
      }
      return result;
    };
    return newArray;
  }
  getItemValueType() {
    return void 0;
  }
  setArray(name, src, dest, isItemValues, onPush) {
    var deletedItems = [].concat(src);
    Object.getPrototypeOf(src).splice.call(src, 0, src.length);
    if (!!dest) {
      for (var i = 0; i < dest.length; i++) {
        var item = dest[i];
        if (isItemValues) {
          if (!!_Base.createItemValue) {
            item = _Base.createItemValue(item, this.getItemValueType());
          }
        }
        Object.getPrototypeOf(src).push.call(src, item);
        if (onPush) onPush(src[i]);
      }
    }
    const arrayChanges = new ArrayChanges(0, deletedItems.length, src, deletedItems);
    this.propertyValueChanged(name, deletedItems, src, arrayChanges);
    this.notifyArrayChanged(src, arrayChanges);
  }
  isTwoValueEquals(x, y, caseInSensitive = false, trimString = false) {
    return Helpers.isTwoValueEquals(x, y, false, !caseInSensitive, trimString);
  }
  static copyObject(dst, src) {
    for (var key in src) {
      var source = src[key];
      if (typeof source === "object") {
        source = {};
        this.copyObject(source, src[key]);
      }
      dst[key] = source;
    }
  }
  copyCssClasses(dest, source) {
    if (!source) return;
    if (typeof source === "string" || source instanceof String) {
      dest["root"] = source;
    } else {
      _Base.copyObject(dest, source);
    }
  }
  getValueInLowCase(val) {
    if (!!val && typeof val == "string") return val.toLowerCase();
    return val;
  }
  getElementsInDesign(includeHidden = false) {
    return [];
  }
  get animationAllowed() {
    return this.getIsAnimationAllowed();
  }
  getIsAnimationAllowed() {
    return settings.animationEnabled && this.animationAllowedLock >= 0 && !this.isLoadingFromJson && !this.isDisposed && (!!this.onElementRerendered || !this.supportOnElementRerenderedEvent);
  }
  blockAnimations() {
    this.animationAllowedLock--;
  }
  releaseAnimations() {
    this.animationAllowedLock++;
  }
  enableOnElementRerenderedEvent() {
    this.onElementRerenderedEventEnabled = true;
  }
  disableOnElementRerenderedEvent() {
    var _a;
    (_a = this.onElementRerendered) === null || _a === void 0 ? void 0 : _a.fire(this, {
      isCancel: true
    });
    this.onElementRerenderedEventEnabled = false;
  }
  get onElementRerendered() {
    return this.supportOnElementRerenderedEvent && this.onElementRerenderedEventEnabled ? this._onElementRerendered : void 0;
  }
  afterRerender() {
    var _a;
    (_a = this.onElementRerendered) === null || _a === void 0 ? void 0 : _a.fire(this, {
      isCancel: false
    });
  }
};
Base.currentDependencis = void 0;
var ArrayChanges = class {
  constructor(index, deleteCount, itemsToAdd, deletedItems) {
    this.index = index;
    this.deleteCount = deleteCount;
    this.itemsToAdd = itemsToAdd;
    this.deletedItems = deletedItems;
  }
};
var Event2 = class {
  get isEmpty() {
    return this.length === 0;
  }
  get length() {
    return !!this.callbacks ? this.callbacks.length : 0;
  }
  fireByCreatingOptions(sender, createOptions) {
    if (!this.callbacks) return;
    for (var i = 0; i < this.callbacks.length; i++) {
      this.callbacks[i](sender, createOptions());
      if (!this.callbacks) return;
    }
  }
  fire(sender, options) {
    if (!this.callbacks) return;
    const callbacks = [].concat(this.callbacks);
    for (var i = 0; i < callbacks.length; i++) {
      callbacks[i](sender, options);
      if (!this.callbacks) return;
    }
  }
  clear() {
    this.callbacks = void 0;
  }
  add(func) {
    if (this.hasFunc(func)) return;
    if (!this.callbacks) {
      this.callbacks = new Array();
    }
    this.callbacks.push(func);
    this.fireCallbackChanged();
  }
  remove(func) {
    if (this.hasFunc(func)) {
      var index = this.callbacks.indexOf(func, 0);
      this.callbacks.splice(index, 1);
      this.fireCallbackChanged();
    }
  }
  hasFunc(func) {
    if (this.callbacks == null) return false;
    return this.callbacks.indexOf(func, 0) > -1;
  }
  fireCallbackChanged() {
    if (!!this.onCallbacksChanged) {
      this.onCallbacksChanged();
    }
  }
};
var EventBase = class extends Event2 {
};
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function debounce(func) {
  let isSheduled = false;
  let isCanceled = false;
  let funcArgs;
  return {
    run: (...args) => {
      isCanceled = false;
      funcArgs = args;
      if (!isSheduled) {
        isSheduled = true;
        queueMicrotask(() => {
          if (!isCanceled) {
            func.apply(this, funcArgs);
          }
          isCanceled = false;
          isSheduled = false;
        });
      }
    },
    cancel: () => {
      isCanceled = true;
    }
  };
}
var ResponsivityManager = class {
  constructor(container, model) {
    this.container = container;
    this.model = model;
    this.resizeObserver = void 0;
    this.isInitialized = false;
    this.getComputedStyle = (elt) => {
      return DomDocumentHelper.getComputedStyle(elt);
    };
    this.debouncedProcess = debounce(() => {
      this.process();
    });
    this.isDisposed = false;
    this.model.updateCallback = (isResetInitialized) => {
      if (isResetInitialized) {
        this.isInitialized = false;
      }
      this.debouncedProcess.run();
    };
    if (typeof ResizeObserver !== "undefined") {
      let skipCallbackInResizeObserver = true;
      this.resizeObserver = new ResizeObserver((entries) => {
        if (skipCallbackInResizeObserver) {
          skipCallbackInResizeObserver = false;
          return;
        }
        DomWindowHelper.requestAnimationFrame(() => {
          this.process();
        });
      });
      this.resizeObserver.observe(this.container.parentElement);
      if (this.shouldProcessResponsiveness()) {
        this.process();
      } else {
        skipCallbackInResizeObserver = false;
      }
    }
  }
  getDimensions(element) {
    return {
      scroll: element.scrollWidth,
      offset: element.offsetWidth
    };
  }
  getAvailableSpace() {
    const style = this.getComputedStyle(this.container);
    let space = this.container.offsetWidth;
    if (style.boxSizing === "border-box") {
      space -= parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
    }
    return space;
  }
  getGap() {
    const computedStyle = this.getComputedStyle(this.container);
    if (computedStyle.display == "flex") {
      const gap = parseFloat(computedStyle.rowGap);
      return !isNaN(gap) ? gap : 0;
    }
    return 0;
  }
  calcItemSize(item) {
    return item.offsetWidth || item.getBoundingClientRect().width;
  }
  updateItemsDimensions(callback) {
    if (!this.container) return;
    const actionsToUpdateDimension = this.isInitialized ? this.model.renderedActions.filter((action) => action.needUpdateMaxDimension || action.needUpdateMinDimension) : this.model.renderedActions;
    let actionsCounter = actionsToUpdateDimension.length;
    if (actionsCounter == 0) {
      callback();
    }
    const onItemDimensionsUpdated = () => {
      if (--actionsCounter <= 0) {
        callback();
      }
    };
    actionsToUpdateDimension.forEach((action) => {
      const needUpdateMaxDimension = !this.isInitialized || action.needUpdateMaxDimension;
      const needUpdateMinDimension = !this.isInitialized || action.needUpdateMinDimension;
      const modeToCalculate = needUpdateMinDimension ? needUpdateMaxDimension ? void 0 : "small" : "large";
      action.updateDimensions((el) => this.calcItemSize(el), () => {
        action.needUpdateMaxDimension = false;
        action.needUpdateMinDimension = false;
        onItemDimensionsUpdated();
      }, modeToCalculate);
    });
  }
  get isContainerVisible() {
    return !!this.container && isContainerVisible(this.container);
  }
  shouldProcessResponsiveness() {
    return this.isContainerVisible && !this.model.isResponsivenessDisabled && !this.isDisposed;
  }
  process() {
    if (this.shouldProcessResponsiveness()) {
      this.updateItemsDimensions(() => {
        if (this.shouldProcessResponsiveness()) {
          this.model.fit({
            availableSpace: this.getAvailableSpace(),
            gap: this.getGap()
          });
        }
        this.isInitialized = true;
      });
    }
  }
  dispose() {
    this.isDisposed = true;
    this.model.updateCallback = void 0;
    if (!!this.resizeObserver) {
      this.resizeObserver.disconnect();
    }
    this.resizeObserver = void 0;
    this.container = void 0;
  }
};
var VerticalResponsivityManager = class extends ResponsivityManager {
  constructor(container, model) {
    super(container, model);
  }
  getDimensions() {
    return {
      scroll: this.container.scrollHeight,
      offset: this.container.offsetHeight
    };
  }
  getAvailableSpace() {
    const style = this.getComputedStyle(this.container);
    let space = this.container.offsetHeight;
    if (style.boxSizing === "border-box") {
      space -= parseFloat(style.paddingTop) + parseFloat(style.paddingBottom);
    }
    return space;
  }
  calcItemSize(item) {
    return item.offsetHeight;
  }
};
var CssClassBuilder = class {
  constructor() {
    this.classes = [];
  }
  isEmpty() {
    return this.toString() === "";
  }
  append(value, condition = true) {
    if (!!value && condition) {
      if (typeof value === "string") {
        value = value.trim();
      }
      this.classes.push(value);
    }
    return this;
  }
  toString() {
    return this.classes.join(" ");
  }
};
var defaultActionBarCss = {
  root: "sv-action-bar",
  defaultSizeMode: "sv-action-bar--default-size-mode",
  smallSizeMode: "sv-action-bar--small-size-mode",
  item: "sv-action-bar-item",
  itemWithTitle: "",
  itemAsIcon: "sv-action-bar-item--icon",
  itemActive: "sv-action-bar-item--active",
  itemPressed: "sv-action-bar-item--pressed",
  itemIcon: "sv-action-bar-item__icon",
  itemTitle: "sv-action-bar-item__title",
  itemTitleWithIcon: "sv-action-bar-item__title--with-icon"
};
var ActionContainer = class extends Base {
  constructor() {
    super(...arguments);
    this.sizeMode = "default";
  }
  getMarkdownHtml(text, name) {
    return !!this.locOwner ? this.locOwner.getMarkdownHtml(text, name) : void 0;
  }
  getRenderer(name) {
    return !!this.locOwner ? this.locOwner.getRenderer(name) : null;
  }
  getRendererContext(locStr) {
    return !!this.locOwner ? this.locOwner.getRendererContext(locStr) : locStr;
  }
  getProcessedText(text) {
    return this.locOwner ? this.locOwner.getProcessedText(text) : text;
  }
  getLocale() {
    return !!this.locOwner ? this.locOwner.getLocale() : "";
  }
  getRenderedActions() {
    return this.actions;
  }
  locStrsChanged() {
    super.locStrsChanged();
    this.actions.forEach((item) => {
      if (item.locTitle) item.locTitle.strChanged();
      item.locStrsChanged();
    });
  }
  raiseUpdate(isResetInitialized) {
    this.isEmpty = !this.actions.some((action) => action.visible);
    this.updateCallback && this.updateCallback(isResetInitialized);
  }
  onSet() {
    this.actions.forEach((item) => {
      this.setActionCssClasses(item);
    });
    this.raiseUpdate(true);
  }
  onPush(item) {
    this.setActionCssClasses(item);
    item.owner = this;
    this.raiseUpdate(true);
  }
  onRemove(item) {
    item.owner = null;
    this.raiseUpdate(true);
  }
  setActionCssClasses(item) {
    item.cssClasses = this.cssClasses;
  }
  get hasActions() {
    return (this.actions || []).length > 0;
  }
  get renderedActions() {
    return this.getRenderedActions();
  }
  get visibleActions() {
    return this.actions.filter((action) => action.visible !== false);
  }
  getRootCss() {
    const sizeModeClass = this.sizeMode === "small" ? this.cssClasses.smallSizeMode : this.cssClasses.defaultSizeMode;
    return new CssClassBuilder().append(this.cssClasses.root + (!!sizeModeClass ? " " + sizeModeClass : "") + (!!this.containerCss ? " " + this.containerCss : "")).append(this.cssClasses.root + "--empty", this.isEmpty).toString();
  }
  getDefaultCssClasses() {
    return defaultActionBarCss;
  }
  set cssClasses(val) {
    this.cssClassesValue = {};
    this.copyCssClasses(this.cssClassesValue, this.getDefaultCssClasses());
    mergeValues(val, this.cssClasses);
    this.actions.forEach((action) => {
      this.setActionCssClasses(action);
    });
  }
  get cssClasses() {
    if (!this.cssClassesValue) {
      this.cssClassesValue = this.getDefaultCssClasses();
    }
    return this.cssClassesValue;
  }
  createAction(item) {
    return item instanceof BaseAction ? item : new Action(item);
  }
  addAction(val, sortByVisibleIndex = true) {
    const res = this.createAction(val);
    if (sortByVisibleIndex && !this.isActionVisible(res)) return res;
    const items = [].concat(this.actions, res);
    this.sortItems(items);
    this.actions = items;
    return res;
  }
  setItems(items, sortByVisibleIndex = true) {
    const newActions = [];
    items.forEach((item) => {
      if (!sortByVisibleIndex || this.isActionVisible(item)) {
        newActions.push(this.createAction(item));
      }
    });
    if (sortByVisibleIndex) {
      this.sortItems(newActions);
    }
    this.actions = newActions;
  }
  sortItems(items) {
    if (this.hasSetVisibleIndex(items)) {
      items.sort(this.compareByVisibleIndex);
    }
  }
  hasSetVisibleIndex(items) {
    for (let i = 0; i < items.length; i++) {
      const index = items[i].visibleIndex;
      if (index !== void 0 && index >= 0) return true;
    }
    return false;
  }
  compareByVisibleIndex(first, second) {
    return first.visibleIndex - second.visibleIndex;
  }
  isActionVisible(item) {
    return item.visibleIndex >= 0 || item.visibleIndex === void 0;
  }
  popupAfterShowCallback(itemValue) {
  }
  mouseOverHandler(itemValue) {
    itemValue.isHovered = true;
    this.actions.forEach((action) => {
      if (action === itemValue && !!itemValue.popupModel) {
        itemValue.showPopupDelayed(this.subItemsShowDelay);
        this.popupAfterShowCallback(itemValue);
      }
    });
  }
  initResponsivityManager(container, delayedUpdateFunction) {
    return;
  }
  resetResponsivityManager() {
  }
  getActionById(id) {
    for (var i = 0; i < this.actions.length; i++) {
      if (this.actions[i].id === id) return this.actions[i];
    }
    return null;
  }
  dispose() {
    super.dispose();
    this.resetResponsivityManager();
    this.actions.forEach((action) => action.dispose());
    this.actions.length = 0;
  }
};
__decorate([propertyArray({
  onSet: (_, target) => {
    target.onSet();
  },
  onPush: (item, i, target) => {
    target.onPush(item);
  },
  onRemove: (item, i, target) => {
    target.onRemove(item);
  }
})], ActionContainer.prototype, "actions", void 0);
__decorate([property({})], ActionContainer.prototype, "containerCss", void 0);
__decorate([property({
  defaultValue: false
})], ActionContainer.prototype, "isEmpty", void 0);
__decorate([property({
  defaultValue: 300
})], ActionContainer.prototype, "subItemsShowDelay", void 0);
__decorate([property({
  defaultValue: 300
})], ActionContainer.prototype, "subItemsHideDelay", void 0);
var ElementHelper = class {
  static focusElement(element) {
    element && element.focus();
  }
  static visibility(node) {
    var style = DomDocumentHelper.getComputedStyle(node);
    if (style.display === "none" || style.visibility === "hidden") return false;
    return node.parentElement ? this.visibility(node.parentElement) : true;
  }
  static getNextElementPreorder(element) {
    const result = !!element.nextElementSibling ? element.nextElementSibling : element.parentElement.firstElementChild;
    if (this.visibility(result)) {
      return result;
    } else {
      return this.getNextElementPreorder(result);
    }
  }
  static getNextElementPostorder(element) {
    const result = !!element.previousElementSibling ? element.previousElementSibling : element.parentElement.lastElementChild;
    if (this.visibility(result)) {
      return result;
    } else {
      return this.getNextElementPostorder(result);
    }
  }
  static hasHorizontalScroller(element) {
    if (!!element) {
      return element.scrollWidth > element.offsetWidth;
    }
    return false;
  }
  static hasVerticalScroller(element) {
    if (!!element) {
      return element.scrollHeight > element.offsetHeight;
    }
    return false;
  }
};
var defaultListCss = {
  root: "sv-list__container",
  item: "sv-list__item",
  searchClearButtonIcon: "sv-list__filter-clear-button",
  loadingIndicator: "sv-list__loading-indicator",
  itemSelected: "sv-list__item--selected",
  itemGroup: "sv-list__item--group",
  itemGroupSelected: "sv-list__item--group-selected",
  itemWithIcon: "sv-list__item--with-icon",
  itemDisabled: "sv-list__item--disabled",
  itemFocused: "sv-list__item--focused",
  itemHovered: "sv-list__item--hovered",
  itemTextWrap: "sv-list__item-text--wrap",
  itemIcon: "sv-list__item-icon",
  itemMarkerIcon: "sv-list-item__marker-icon",
  itemSeparator: "sv-list__item-separator",
  itemBody: "sv-list__item-body",
  itemsContainer: "sv-list",
  itemsContainerFiltering: "sv-list--filtering",
  filter: "sv-list__filter",
  filterIcon: "sv-list__filter-icon",
  filterInput: "sv-list__input",
  emptyContainer: "sv-list__empty-container",
  emptyText: "sv-list__empty-text"
};
var ListModel = class _ListModel extends ActionContainer {
  hasText(item, filterStringInLow) {
    if (!filterStringInLow) return true;
    const text = item.title || "";
    if (this.onTextSearchCallback) return this.onTextSearchCallback(item, filterStringInLow);
    let textInLow = text.toLocaleLowerCase();
    textInLow = settings.comparator.normalizeTextCallback(textInLow, "filter");
    return textInLow.indexOf(filterStringInLow.toLocaleLowerCase()) > -1;
  }
  isItemVisible(item) {
    return item.visible && (!this.shouldProcessFilter || this.hasText(item, this.filterString));
  }
  getRenderedActions() {
    let actions = super.getRenderedActions();
    if (this.filterString) {
      let newActions = [];
      actions.forEach((action) => {
        newActions.push(action);
        if (action.items) {
          action.items.forEach((item) => {
            const a = new Action(item);
            if (!a.iconName) {
              a.iconName = action.iconName;
            }
            newActions.push(a);
          });
        }
      });
      return newActions;
    }
    return actions;
  }
  get visibleItems() {
    return this.visibleActions.filter((item) => this.isItemVisible(item));
  }
  get shouldProcessFilter() {
    return !this.onFilterStringChangedCallback;
  }
  onFilterStringChanged(text) {
    if (!!this.onFilterStringChangedCallback) {
      this.onFilterStringChangedCallback(text);
    }
    this.updateIsEmpty();
  }
  updateIsEmpty() {
    this.isEmpty = this.renderedActions.filter((action) => this.isItemVisible(action)).length === 0;
  }
  scrollToItem(classes, ms = 0) {
    setTimeout(() => {
      if (!this.listContainerHtmlElement) return;
      const item = this.listContainerHtmlElement.querySelector(classesToSelector(classes));
      if (item) {
        setTimeout(() => {
          item.scrollIntoView({
            behavior: "smooth",
            block: "nearest",
            inline: "start"
          });
        }, ms);
      }
    }, ms);
  }
  constructor(items, onSelectionChanged, allowSelection, selectedItem, elementId) {
    super();
    this.onSelectionChanged = onSelectionChanged;
    this.allowSelection = allowSelection;
    this.elementId = elementId;
    this.onItemClick = (itemValue) => {
      if (this.isItemDisabled(itemValue)) {
        return;
      }
      this.isExpanded = false;
      if (this.allowSelection) {
        this.selectedItem = itemValue;
      }
      if (!!this.onSelectionChanged) {
        this.onSelectionChanged(itemValue);
      }
      const action = itemValue.action;
      if (!!action) {
        action(itemValue);
      }
    };
    this.onItemHover = (itemValue) => {
      this.mouseOverHandler(itemValue);
    };
    this.isItemDisabled = (itemValue) => {
      return itemValue.enabled !== void 0 && !itemValue.enabled;
    };
    this.isItemSelected = (itemValue) => {
      return this.areSameItems(this.selectedItem, itemValue);
    };
    this.isItemFocused = (itemValue) => {
      return this.areSameItems(this.focusedItem, itemValue);
    };
    this.getListClass = () => {
      return new CssClassBuilder().append(this.cssClasses.itemsContainer).append(this.cssClasses.itemsContainerFiltering, !!this.filterString && this.visibleActions.length !== this.visibleItems.length).toString();
    };
    this.getItemClass = (itemValue) => {
      const isSelected = this.isItemSelected(itemValue);
      return new CssClassBuilder().append(this.cssClasses.item).append(this.cssClasses.itemWithIcon, !!itemValue.iconName).append(this.cssClasses.itemDisabled, this.isItemDisabled(itemValue)).append(this.cssClasses.itemFocused, this.isItemFocused(itemValue)).append(this.cssClasses.itemSelected, !itemValue.hasSubItems && isSelected).append(this.cssClasses.itemGroup, itemValue.hasSubItems).append(this.cssClasses.itemGroupSelected, itemValue.hasSubItems && isSelected).append(this.cssClasses.itemHovered, itemValue.isHovered).append(this.cssClasses.itemTextWrap, this.textWrapEnabled).append(itemValue.css).toString();
    };
    this.getItemStyle = (itemValue) => {
      const level = itemValue.level || 0;
      return {
        "--sjs-list-item-level": level + 1
      };
    };
    if (Object.keys(items).indexOf("items") !== -1) {
      const options = items;
      Object.keys(options).forEach((key) => {
        switch (key) {
          case "items":
            this.setItems(options.items);
            break;
          case "onFilterStringChangedCallback":
            this.setOnFilterStringChangedCallback(options.onFilterStringChangedCallback);
            break;
          case "onTextSearchCallback":
            this.setOnTextSearchCallback(options.onTextSearchCallback);
            break;
          default:
            this[key] = options[key];
        }
      });
      this.updateActionsIds();
    } else {
      this.setItems(items);
      this.selectedItem = selectedItem;
    }
  }
  setOnFilterStringChangedCallback(callback) {
    this.onFilterStringChangedCallback = callback;
  }
  setOnTextSearchCallback(callback) {
    this.onTextSearchCallback = callback;
  }
  setItems(items, sortByVisibleIndex = true) {
    super.setItems(items, sortByVisibleIndex);
    this.updateActionsIds();
    if (!this.isAllDataLoaded && !!this.actions.length) {
      this.actions.push(this.loadingIndicator);
    }
  }
  updateActionsIds() {
    if (this.elementId) {
      this.renderedActions.forEach((action) => {
        action.elementId = this.elementId + action.id;
      });
    }
  }
  setSearchEnabled(newValue) {
    this.searchEnabled = newValue;
    this.showSearchClearButton = newValue;
  }
  onSet() {
    this.showFilter = this.searchEnabled && (this.forceShowFilter || (this.actions || []).length > _ListModel.MINELEMENTCOUNT);
    super.onSet();
  }
  getDefaultCssClasses() {
    return defaultListCss;
  }
  popupAfterShowCallback(itemValue) {
    this.addScrollEventListener(() => {
      itemValue.hidePopup();
    });
  }
  onItemLeave(itemValue) {
    itemValue.hidePopupDelayed(this.subItemsHideDelay);
  }
  areSameItems(item1, item2) {
    if (!!this.areSameItemsCallback) return this.areSameItemsCallback(item1, item2);
    return !!item1 && !!item2 && item1.id == item2.id;
  }
  get filterStringPlaceholder() {
    return this.getLocalizationString("filterStringPlaceholder");
  }
  get emptyMessage() {
    return this.isAllDataLoaded ? this.getLocalizationString("emptyMessage") : this.loadingText;
  }
  get scrollableContainer() {
    return this.listContainerHtmlElement.querySelector(classesToSelector(this.cssClasses.itemsContainer));
  }
  get loadingText() {
    return this.getLocalizationString("loadingFile");
  }
  get loadingIndicator() {
    if (!this.loadingIndicatorValue) {
      this.loadingIndicatorValue = new Action({
        id: "loadingIndicator",
        title: this.loadingText,
        action: () => {
        },
        css: this.cssClasses.loadingIndicator
      });
    }
    return this.loadingIndicatorValue;
  }
  goToItems(event) {
    if (event.key === "ArrowDown" || event.keyCode === 40) {
      const currentElement = event.target.parentElement;
      const listElement = currentElement.parentElement.querySelector("ul");
      const firstChild = getFirstVisibleChild(listElement);
      if (!!listElement && !!firstChild) {
        ElementHelper.focusElement(firstChild);
        event.preventDefault();
      }
    }
  }
  onMouseMove(event) {
    this.resetFocusedItem();
  }
  onKeyDown(event) {
    const currentElement = event.target;
    if (event.key === "ArrowDown" || event.keyCode === 40) {
      ElementHelper.focusElement(ElementHelper.getNextElementPreorder(currentElement));
      event.preventDefault();
    } else if (event.key === "ArrowUp" || event.keyCode === 38) {
      ElementHelper.focusElement(ElementHelper.getNextElementPostorder(currentElement));
      event.preventDefault();
    }
  }
  onPointerDown(event, item) {
  }
  refresh() {
    if (this.filterString !== "") {
      this.filterString = "";
    } else {
      this.updateIsEmpty();
    }
    this.resetFocusedItem();
  }
  onClickSearchClearButton(event) {
    event.currentTarget.parentElement.querySelector("input").focus();
    this.refresh();
  }
  resetFocusedItem() {
    this.focusedItem = void 0;
  }
  focusFirstVisibleItem() {
    this.focusedItem = this.visibleItems[0];
  }
  focusLastVisibleItem() {
    this.focusedItem = this.visibleItems[this.visibleItems.length - 1];
  }
  initFocusedItem() {
    this.focusedItem = this.visibleItems.filter((item) => item.visible && this.isItemSelected(item))[0];
    if (!this.focusedItem) {
      this.focusFirstVisibleItem();
    }
  }
  focusNextVisibleItem() {
    if (!this.focusedItem) {
      this.initFocusedItem();
    } else {
      const items = this.visibleItems;
      const currentFocusedItemIndex = items.indexOf(this.focusedItem);
      const nextItem = items[currentFocusedItemIndex + 1];
      if (nextItem) {
        this.focusedItem = nextItem;
      } else {
        this.focusFirstVisibleItem();
      }
    }
  }
  focusPrevVisibleItem() {
    if (!this.focusedItem) {
      this.initFocusedItem();
    } else {
      const items = this.visibleItems;
      const currentFocusedItemIndex = items.indexOf(this.focusedItem);
      const prevItem = items[currentFocusedItemIndex - 1];
      if (prevItem) {
        this.focusedItem = prevItem;
      } else {
        this.focusLastVisibleItem();
      }
    }
  }
  selectFocusedItem() {
    !!this.focusedItem && this.onItemClick(this.focusedItem);
  }
  initListContainerHtmlElement(htmlElement) {
    this.listContainerHtmlElement = htmlElement;
  }
  onLastItemRended(item) {
    if (this.isAllDataLoaded) return;
    if (item === this.actions[this.actions.length - 1] && !!this.listContainerHtmlElement) {
      this.hasVerticalScroller = ElementHelper.hasVerticalScroller(this.scrollableContainer);
    }
  }
  scrollToFocusedItem() {
    this.scrollToItem(this.cssClasses.itemFocused);
  }
  scrollToSelectedItem() {
    if (!!this.selectedItem && this.selectedItem.items && this.selectedItem.items.length > 0) {
      this.scrollToItem(this.cssClasses.itemGroupSelected, 110);
    } else {
      this.scrollToItem(this.cssClasses.itemSelected, 110);
    }
  }
  addScrollEventListener(handler) {
    if (!!handler) {
      this.removeScrollEventListener();
      this.scrollHandler = handler;
    }
    if (!!this.scrollHandler) {
      this.scrollableContainer.addEventListener("scroll", this.scrollHandler);
    }
  }
  removeScrollEventListener() {
    if (!!this.scrollHandler) {
      this.scrollableContainer.removeEventListener("scroll", this.scrollHandler);
    }
  }
  dispose() {
    super.dispose();
    if (!!this.loadingIndicatorValue) {
      this.loadingIndicatorValue.dispose();
    }
    this.listContainerHtmlElement = void 0;
  }
};
ListModel.INDENT = 16;
ListModel.MINELEMENTCOUNT = 10;
__decorate([property({
  defaultValue: true,
  onSet: (newValue, target) => {
    target.onSet();
  }
})], ListModel.prototype, "searchEnabled", void 0);
__decorate([property({
  defaultValue: false
})], ListModel.prototype, "showFilter", void 0);
__decorate([property({
  defaultValue: false
})], ListModel.prototype, "forceShowFilter", void 0);
__decorate([property({
  defaultValue: false
})], ListModel.prototype, "isExpanded", void 0);
__decorate([property({})], ListModel.prototype, "selectedItem", void 0);
__decorate([property()], ListModel.prototype, "focusedItem", void 0);
__decorate([property({
  onSet: (_, target) => {
    target.onFilterStringChanged(target.filterString);
  }
})], ListModel.prototype, "filterString", void 0);
__decorate([property({
  defaultValue: false
})], ListModel.prototype, "hasVerticalScroller", void 0);
__decorate([property({
  defaultValue: true
})], ListModel.prototype, "isAllDataLoaded", void 0);
__decorate([property({
  defaultValue: false
})], ListModel.prototype, "showSearchClearButton", void 0);
__decorate([property({
  defaultValue: true
})], ListModel.prototype, "renderElements", void 0);
__decorate([property({
  defaultValue: false
})], ListModel.prototype, "textWrapEnabled", void 0);
__decorate([property({
  defaultValue: "sv-list-item-content"
})], ListModel.prototype, "itemComponent", void 0);
var PopupModel = class extends Base {
  refreshInnerModel() {
    const innerModel = this.contentComponentData["model"];
    innerModel && innerModel.refresh && innerModel.refresh();
  }
  constructor(contentComponentName, contentComponentData, options) {
    super();
    this.focusFirstInputSelector = "";
    this.onCancel = () => {
    };
    this.onApply = () => {
      return true;
    };
    this.onHide = () => {
    };
    this.onShow = () => {
    };
    this.onDispose = () => {
    };
    this.onVisibilityChanged = this.addEvent();
    this.onFooterActionsCreated = this.addEvent();
    this.onRecalculatePosition = this.addEvent();
    this.contentComponentName = contentComponentName;
    this.contentComponentData = contentComponentData;
    if (!!options) {
      for (var key in options) {
        this[key] = options[key];
      }
    }
  }
  get isVisible() {
    return this.getPropertyValue("isVisible", false);
  }
  set isVisible(value) {
    if (this.isVisible === value) {
      return;
    }
    this.setPropertyValue("isVisible", value);
    this.onVisibilityChanged.fire(this, {
      model: this,
      isVisible: value
    });
  }
  toggleVisibility() {
    this.isVisible = !this.isVisible;
  }
  show() {
    if (!this.isVisible) this.isVisible = true;
  }
  hide() {
    if (this.isVisible) this.isVisible = false;
  }
  recalculatePosition(isResetHeight) {
    this.onRecalculatePosition.fire(this, {
      isResetHeight
    });
  }
  updateFooterActions(footerActions) {
    const options = {
      actions: footerActions
    };
    this.onFooterActionsCreated.fire(this, options);
    return options.actions;
  }
  updateDisplayMode(menuType) {
    if (this.displayMode !== menuType) {
      const isDropdown = menuType === "dropdown";
      this.setWidthByTarget = isDropdown;
      this.isFocusedContent = !isDropdown;
    }
    switch (menuType) {
      case "dropdown": {
        this.displayMode = "popup";
        break;
      }
      case "popup": {
        this.displayMode = "overlay";
        this.overlayDisplayMode = "tablet-dropdown-overlay";
        break;
      }
      case "overlay": {
        this.displayMode = "overlay";
        this.overlayDisplayMode = "dropdown-overlay";
        break;
      }
    }
  }
  onHiding() {
    this.refreshInnerModel();
    this.onHide();
  }
  dispose() {
    super.dispose();
    this.onDispose();
  }
};
__decorate([property()], PopupModel.prototype, "contentComponentName", void 0);
__decorate([property()], PopupModel.prototype, "contentComponentData", void 0);
__decorate([property({
  defaultValue: "bottom"
})], PopupModel.prototype, "verticalPosition", void 0);
__decorate([property({
  defaultValue: "left"
})], PopupModel.prototype, "horizontalPosition", void 0);
__decorate([property({
  defaultValue: true
})], PopupModel.prototype, "showPointer", void 0);
__decorate([property({
  defaultValue: false
})], PopupModel.prototype, "isModal", void 0);
__decorate([property({
  defaultValue: true
})], PopupModel.prototype, "canShrink", void 0);
__decorate([property({
  defaultValue: true
})], PopupModel.prototype, "isFocusedContent", void 0);
__decorate([property({
  defaultValue: true
})], PopupModel.prototype, "isFocusedContainer", void 0);
__decorate([property({
  defaultValue: ""
})], PopupModel.prototype, "cssClass", void 0);
__decorate([property({
  defaultValue: ""
})], PopupModel.prototype, "title", void 0);
__decorate([property({
  defaultValue: "auto"
})], PopupModel.prototype, "overlayDisplayMode", void 0);
__decorate([property({
  defaultValue: "popup"
})], PopupModel.prototype, "displayMode", void 0);
__decorate([property({
  defaultValue: "flex"
})], PopupModel.prototype, "positionMode", void 0);
function createDropdownActionModel(actionOptions, dropdownOptions, locOwner) {
  dropdownOptions.locOwner = locOwner;
  return createDropdownActionModelAdvanced(actionOptions, dropdownOptions, dropdownOptions);
}
function createDropdownActionModelAdvanced(actionOptions, listOptions, popupOptions) {
  var _a;
  const originalSelectionChanged = listOptions.onSelectionChanged;
  listOptions.onSelectionChanged = (item, ...params) => {
    if (newAction.hasTitle) {
      newAction.title = item.title;
    }
    if (originalSelectionChanged) {
      originalSelectionChanged(item, params);
    }
  };
  const popupModel = createPopupModelWithListModel(listOptions, popupOptions);
  popupModel.getTargetCallback = getActionDropdownButtonTarget;
  const newActionOptions = Object.assign({}, actionOptions, {
    component: "sv-action-bar-item-dropdown",
    popupModel,
    action: (action, isUserAction) => {
      !!actionOptions.action && actionOptions.action();
      popupModel.isFocusedContent = popupModel.isFocusedContent || !isUserAction;
      popupModel.show();
    }
  });
  const newAction = new Action(newActionOptions);
  newAction.data = (_a = popupModel.contentComponentData) === null || _a === void 0 ? void 0 : _a.model;
  return newAction;
}
function createPopupModelWithListModel(listOptions, popupOptions) {
  const listModel = new ListModel(listOptions);
  listModel.onSelectionChanged = (item) => {
    if (listOptions.onSelectionChanged) {
      listOptions.onSelectionChanged(item);
    }
    popupModel.hide();
  };
  const _popupOptions = popupOptions || {};
  _popupOptions.onDispose = () => {
    listModel.dispose();
  };
  const popupModel = new PopupModel("sv-list", {
    model: listModel
  }, _popupOptions);
  popupModel.isFocusedContent = listModel.showFilter;
  popupModel.onShow = () => {
    if (!!_popupOptions.onShow) _popupOptions.onShow();
    listModel.scrollToSelectedItem();
  };
  return popupModel;
}
function getActionDropdownButtonTarget(container) {
  return container === null || container === void 0 ? void 0 : container.previousElementSibling;
}
var BaseAction = class _BaseAction extends Base {
  constructor() {
    super(...arguments);
    this.rendredIdValue = _BaseAction.getNextRendredId();
  }
  static getNextRendredId() {
    return _BaseAction.renderedId++;
  }
  get renderedId() {
    return this.rendredIdValue;
  }
  get owner() {
    return this.ownerValue;
  }
  set owner(val) {
    if (val !== this.owner) {
      this.ownerValue = val;
      this.locStrsChanged();
    }
  }
  get visible() {
    return this.getVisible();
  }
  set visible(val) {
    this.setVisible(val);
  }
  get enabled() {
    return this.getEnabled();
  }
  set enabled(val) {
    this.setEnabled(val);
  }
  get component() {
    return this.getComponent();
  }
  set component(val) {
    this.setComponent(val);
  }
  get locTitle() {
    return this.getLocTitle();
  }
  set locTitle(val) {
    this.setLocTitle(val);
  }
  get title() {
    return this.getTitle();
  }
  set title(val) {
    this.setTitle(val);
  }
  set cssClasses(val) {
    this.cssClassesValue = val;
  }
  get cssClasses() {
    return this.cssClassesValue || defaultActionBarCss;
  }
  get isVisible() {
    return this.visible && this.mode !== "popup" && this.mode !== "removed";
  }
  get disabled() {
    return this.enabled !== void 0 && !this.enabled;
  }
  get canShrink() {
    return !this.disableShrink && !!this.iconName;
  }
  get hasTitle() {
    return (this.mode != "small" && (this.showTitle || this.showTitle === void 0) || !this.iconName) && !!this.title;
  }
  get hasSubItems() {
    return !!this.items && this.items.length > 0;
  }
  getActionBarItemTitleCss() {
    return new CssClassBuilder().append(this.cssClasses.itemTitle).append(this.cssClasses.itemTitleWithIcon, !!this.iconName).toString();
  }
  getActionBarItemCss() {
    const hasTitle = this.hasTitle;
    return new CssClassBuilder().append(this.cssClasses.item).append(this.cssClasses.itemWithTitle, hasTitle).append(this.cssClasses.itemAsIcon, !hasTitle).append(this.cssClasses.itemActive, !!this.active).append(this.cssClasses.itemPressed, !!this.pressed).append(this.innerCss).toString();
  }
  getActionRootCss() {
    return new CssClassBuilder().append("sv-action").append(this.css).append("sv-action--space", this.needSpace).append("sv-action--hidden", !this.isVisible).toString();
  }
  getTooltip() {
    return this.tooltip || this.title;
  }
  getIsTrusted(args) {
    if (!!args.originalEvent) {
      return args.originalEvent.isTrusted;
    }
    return args.isTrusted;
  }
  showPopup() {
    if (!!this.popupModel) {
      this.popupModel.show();
    }
  }
  hidePopup() {
    if (!!this.popupModel) {
      this.popupModel.hide();
    }
  }
  clearPopupTimeouts() {
    if (this.showPopupTimeout) clearTimeout(this.showPopupTimeout);
    if (this.hidePopupTimeout) clearTimeout(this.hidePopupTimeout);
  }
  showPopupDelayed(delay) {
    this.clearPopupTimeouts();
    this.showPopupTimeout = setTimeout(() => {
      this.clearPopupTimeouts();
      this.showPopup();
    }, delay);
  }
  hidePopupDelayed(delay) {
    var _a;
    if ((_a = this.popupModel) === null || _a === void 0 ? void 0 : _a.isVisible) {
      this.clearPopupTimeouts();
      this.hidePopupTimeout = setTimeout(() => {
        this.clearPopupTimeouts();
        this.hidePopup();
        this.isHovered = false;
      }, delay);
    } else {
      this.clearPopupTimeouts();
      this.isHovered = false;
    }
  }
};
BaseAction.renderedId = 1;
__decorate([property()], BaseAction.prototype, "tooltip", void 0);
__decorate([property()], BaseAction.prototype, "showTitle", void 0);
__decorate([property()], BaseAction.prototype, "innerCss", void 0);
__decorate([property()], BaseAction.prototype, "active", void 0);
__decorate([property()], BaseAction.prototype, "pressed", void 0);
__decorate([property()], BaseAction.prototype, "popupModel", void 0);
__decorate([property()], BaseAction.prototype, "needSeparator", void 0);
__decorate([property()], BaseAction.prototype, "template", void 0);
__decorate([property({
  defaultValue: "large"
})], BaseAction.prototype, "mode", void 0);
__decorate([property()], BaseAction.prototype, "visibleIndex", void 0);
__decorate([property()], BaseAction.prototype, "disableTabStop", void 0);
__decorate([property()], BaseAction.prototype, "disableShrink", void 0);
__decorate([property()], BaseAction.prototype, "disableHide", void 0);
__decorate([property({
  defaultValue: false
})], BaseAction.prototype, "needSpace", void 0);
__decorate([property()], BaseAction.prototype, "ariaChecked", void 0);
__decorate([property()], BaseAction.prototype, "ariaExpanded", void 0);
__decorate([property({
  defaultValue: "button"
})], BaseAction.prototype, "ariaRole", void 0);
__decorate([property()], BaseAction.prototype, "iconName", void 0);
__decorate([property({
  defaultValue: 24
})], BaseAction.prototype, "iconSize", void 0);
__decorate([property()], BaseAction.prototype, "markerIconName", void 0);
__decorate([property()], BaseAction.prototype, "css", void 0);
__decorate([property({
  defaultValue: false
})], BaseAction.prototype, "isPressed", void 0);
__decorate([property({
  defaultValue: false
})], BaseAction.prototype, "isHovered", void 0);
var Action = class _Action extends BaseAction {
  raiseUpdate(isResetInitialized = false) {
    this.updateCallback && this.updateCallback(isResetInitialized);
  }
  constructor(innerItemData) {
    super();
    this.locTitleChanged = () => {
      const val = this.locTitle.renderedHtml;
      this.setPropertyValue("_title", !!val ? val : void 0);
    };
    this.needUpdateMaxDimension = false;
    this.needUpdateMinDimension = false;
    const innerItem = innerItemData instanceof _Action ? innerItemData.innerItem : innerItemData;
    this.innerItem = innerItem;
    this.locTitle = !!innerItem ? innerItem["locTitle"] : null;
    if (!!innerItem) {
      for (var key in innerItem) {
        if (key === "locTitle" || key === "title" && !!this.locTitle && !!this.title) continue;
        this[key] = innerItem[key];
      }
    }
    if (!!this.locTitleName) {
      this.locTitleChanged();
    }
    this.registerFunctionOnPropertyValueChanged("_title", () => {
      this.needUpdateMaxDimension = true;
      this.raiseUpdate();
    });
    this.locStrChangedInPopupModel();
  }
  createLocTitle() {
    return this.createLocalizableString("title", this, true);
  }
  setSubItems(options) {
    this.markerIconName = "icon-next_16x16";
    this.component = "sv-list-item-group";
    this.items = [...options.items];
    const listOptions = Object.assign({}, options);
    listOptions.searchEnabled = false;
    const popupModel = createPopupModelWithListModel(listOptions, {
      horizontalPosition: "right",
      showPointer: false,
      canShrink: false
    });
    popupModel.cssClass = "sv-popup-inner";
    this.popupModel = popupModel;
  }
  getLocTitle() {
    return this.locTitleValue;
  }
  setLocTitle(val) {
    if (!val && !this.locTitleValue) {
      val = this.createLocTitle();
    }
    if (!!this.locTitleValue) {
      this.locTitleValue.onStringChanged.remove(this.locTitleChanged);
    }
    this.locTitleValue = val;
    this.locTitleValue.onStringChanged.add(this.locTitleChanged);
    this.locTitleChanged();
  }
  getTitle() {
    return this._title;
  }
  setTitle(val) {
    this._title = val;
  }
  get locTitleName() {
    return this.locTitle.localizationName;
  }
  set locTitleName(val) {
    this.locTitle.localizationName = val;
  }
  locStrsChanged() {
    super.locStrsChanged();
    this.locTooltipChanged();
    this.locStrChangedInPopupModel();
  }
  doAction(args) {
    const evt = !!args.originalEvent ? args.originalEvent : args;
    this.action(this, evt.isTrusted);
    evt.preventDefault();
    evt.stopPropagation();
    return true;
  }
  doMouseDown(args) {
    this.isMouseDown = true;
  }
  doFocus(args) {
    if (!!this.onFocus) {
      const evt = !!args.originalEvent ? args.originalEvent : args;
      this.onFocus(this.isMouseDown, evt);
    }
    this.isMouseDown = false;
  }
  locStrChangedInPopupModel() {
    if (!this.popupModel || !this.popupModel.contentComponentData || !this.popupModel.contentComponentData.model) return;
    const model = this.popupModel.contentComponentData.model;
    if (Array.isArray(model.actions)) {
      const actions = model.actions;
      actions.forEach((item) => {
        if (!!item.locStrsChanged) {
          item.locStrsChanged();
        }
      });
    }
  }
  locTooltipChanged() {
    if (!this.locTooltipName) return;
    this.tooltip = getLocaleString(this.locTooltipName, this.locTitle.locale);
  }
  //ILocalizableOwner
  getLocale() {
    return this.owner ? this.owner.getLocale() : "";
  }
  getMarkdownHtml(text, name) {
    return this.owner ? this.owner.getMarkdownHtml(text, name) : void 0;
  }
  getProcessedText(text) {
    return this.owner ? this.owner.getProcessedText(text) : text;
  }
  getRenderer(name) {
    return this.owner ? this.owner.getRenderer(name) : null;
  }
  getRendererContext(locStr) {
    return this.owner ? this.owner.getRendererContext(locStr) : locStr;
  }
  setVisible(val) {
    if (this.visible !== val) {
      this._visible = val;
    }
  }
  getVisible() {
    return this._visible;
  }
  setEnabled(val) {
    this._enabled = val;
  }
  getEnabled() {
    if (this.enabledIf) return this.enabledIf();
    return this._enabled;
  }
  setComponent(val) {
    this._component = val;
  }
  getComponent() {
    return this._component;
  }
  dispose() {
    this.updateCallback = void 0;
    if (!!this.locTitleValue) {
      this.locTitleValue.onStringChanged.remove(this.locTitleChanged);
    }
    this.locTitleChanged = void 0;
    this.action = void 0;
    super.dispose();
    if (this.popupModel) {
      this.popupModel.dispose();
    }
  }
  updateDimension(mode, htmlElement, calcDimension) {
    const property2 = mode == "small" ? "minDimension" : "maxDimension";
    if (htmlElement) {
      const actionContainer = htmlElement;
      if (actionContainer.classList.contains("sv-action--hidden")) {
        actionContainer.classList.remove("sv-action--hidden");
        this[property2] = calcDimension(htmlElement);
        actionContainer.classList.add("sv-action--hidden");
      } else {
        this[property2] = calcDimension(htmlElement);
      }
    }
  }
  afterRender() {
    this.afterRenderCallback && this.afterRenderCallback();
  }
  updateMode(mode, callback) {
    if (this.updateModeCallback) {
      this.updateModeCallback(mode, callback);
    } else {
      this.afterRenderCallback = () => {
        this.updateModeCallback(mode, callback);
        this.afterRenderCallback = void 0;
      };
    }
  }
  updateDimensions(calcDimension, callback, modeToCalculate) {
    const mode = !modeToCalculate || modeToCalculate == "large" && this.mode !== "small" ? this.mode : modeToCalculate;
    this.updateMode(mode, (mode2, htmlElement) => {
      this.updateDimension(mode2, htmlElement, calcDimension);
      if (!modeToCalculate) {
        this.updateMode(mode2 !== "small" ? "small" : "large", (mode3, htmlElement2) => {
          this.updateDimension(mode3, htmlElement2, calcDimension);
          callback();
        });
      } else {
        callback();
      }
    });
  }
};
__decorate([property()], Action.prototype, "id", void 0);
__decorate([property({
  defaultValue: true,
  onSet: (_, target) => {
    target.raiseUpdate();
  }
})], Action.prototype, "_visible", void 0);
__decorate([property({
  onSet: (_, target) => {
    target.locTooltipChanged();
  }
})], Action.prototype, "locTooltipName", void 0);
__decorate([property()], Action.prototype, "_enabled", void 0);
__decorate([property()], Action.prototype, "action", void 0);
__decorate([property()], Action.prototype, "onFocus", void 0);
__decorate([property()], Action.prototype, "_component", void 0);
__decorate([property()], Action.prototype, "items", void 0);
__decorate([property({
  onSet: (val, target) => {
    if (target.locTitleValue.text === val) return;
    target.locTitleValue.text = val;
  }
})], Action.prototype, "_title", void 0);
var ActionDropdownViewModel = class {
  constructor(item) {
    this.item = item;
    this.funcKey = "sv-dropdown-action";
    this.setupPopupCallbacks();
  }
  setupPopupCallbacks() {
    const popupModel = this.popupModel = this.item.popupModel;
    if (!popupModel) return;
    popupModel.registerPropertyChangedHandlers(["isVisible"], () => {
      if (!popupModel.isVisible) {
        this.item.pressed = false;
      } else {
        this.item.pressed = true;
      }
    }, this.funcKey);
  }
  removePopupCallbacks() {
    if (!!this.popupModel) {
      this.popupModel.unregisterPropertyChangedHandlers(["isVisible"], this.funcKey);
    }
  }
  dispose() {
    this.removePopupCallbacks();
  }
};
var AdaptiveActionContainer = class _AdaptiveActionContainer extends ActionContainer {
  hideItemsGreaterN(visibleItemsCount) {
    const actionsToHide = this.getActionsToHide();
    visibleItemsCount = Math.max(visibleItemsCount, this.minVisibleItemsCount - (this.visibleActions.length - actionsToHide.length));
    const hiddenItems = [];
    actionsToHide.forEach((item) => {
      if (visibleItemsCount <= 0) {
        item.mode = "popup";
        hiddenItems.push(item.innerItem);
      }
      visibleItemsCount--;
    });
    this.hiddenItemsListModel.setItems(hiddenItems);
  }
  getActionsToHide() {
    return this.visibleActions.filter((action) => !action.disableHide);
  }
  updateItemMode(availableSpace, maxItemsSize) {
    const items = this.visibleActions;
    for (let index = items.length - 1; index >= 0; index--) {
      if (maxItemsSize > availableSpace && !items[index].disableShrink) {
        maxItemsSize -= items[index].maxDimension - items[index].minDimension;
        items[index].mode = "small";
      } else {
        items[index].mode = "large";
      }
    }
  }
  constructor() {
    super();
    this.minVisibleItemsCount = 0;
    this.isResponsivenessDisabled = false;
    this.dotsItem = createDropdownActionModelAdvanced({
      id: "dotsItem-id" + _AdaptiveActionContainer.ContainerID++,
      css: "sv-dots",
      innerCss: "sv-dots__item",
      iconName: "icon-more",
      visible: false,
      tooltip: getLocaleString("more")
    }, {
      items: [],
      allowSelection: false
    });
  }
  get hiddenItemsListModel() {
    return this.dotsItem.data;
  }
  onSet() {
    this.actions.forEach((action) => action.updateCallback = (isResetInitialized) => this.raiseUpdate(isResetInitialized));
    super.onSet();
  }
  onPush(item) {
    item.updateCallback = (isResetInitialized) => this.raiseUpdate(isResetInitialized);
    super.onPush(item);
  }
  getRenderedActions() {
    if (this.actions.length === 1 && !!this.actions[0].iconName) return this.actions;
    return this.actions.concat([this.dotsItem]);
  }
  raiseUpdate(isResetInitialized) {
    if (!this.isResponsivenessDisabled) {
      super.raiseUpdate(isResetInitialized);
    }
  }
  getActionMinDimension(action) {
    return action.disableShrink ? action.maxDimension : action.minDimension;
  }
  getVisibleItemsCount(options) {
    let {
      availableSpace,
      gap
    } = options;
    availableSpace -= this.dotsItem.minDimension + gap;
    let currentItemsSize = 0;
    if (this.visibleActions[0].disableHide) {
      availableSpace += gap;
    } else {
      currentItemsSize -= gap;
    }
    this.visibleActions.filter((action) => action.disableHide).forEach((action) => {
      return availableSpace -= this.getActionMinDimension(action) + gap;
    });
    const actionsToHide = this.getActionsToHide();
    if (actionsToHide.length === 1 && !!actionsToHide[0].iconName) {
      return 1;
    }
    for (let i = 0; i < actionsToHide.length; i++) {
      currentItemsSize += this.getActionMinDimension(actionsToHide[i]) + gap;
      if (currentItemsSize > availableSpace) {
        return i;
      }
    }
  }
  fit(options) {
    var _a;
    if (options.availableSpace <= 0) return;
    options.gap = (_a = options.gap) !== null && _a !== void 0 ? _a : 0;
    const {
      availableSpace,
      gap
    } = options;
    this.dotsItem.visible = false;
    const actions = this.visibleActions;
    let minSize = -1 * options.gap;
    let maxSize = -1 * options.gap;
    actions.forEach((action) => {
      minSize += this.getActionMinDimension(action) + gap;
      maxSize += action.maxDimension + gap;
    });
    if (availableSpace >= maxSize) {
      this.setActionsMode("large");
    } else if (availableSpace < minSize) {
      this.setActionsMode("small");
      this.hideItemsGreaterN(this.getVisibleItemsCount(options));
      this.dotsItem.visible = !!this.hiddenItemsListModel.actions.length;
    } else {
      this.updateItemMode(options.availableSpace, maxSize);
    }
  }
  initResponsivityManager(container) {
    if (!!this.responsivityManager) {
      if (this.responsivityManager.container == container) {
        return;
      }
      this.responsivityManager.dispose();
    }
    this.responsivityManager = new ResponsivityManager(container, this);
  }
  resetResponsivityManager() {
    if (!!this.responsivityManager) {
      this.responsivityManager.dispose();
      this.responsivityManager = void 0;
    }
  }
  setActionsMode(mode) {
    this.actions.forEach((action) => {
      if (mode == "small" && action.disableShrink) {
        action.mode = "large";
      } else {
        action.mode = mode;
      }
    });
  }
  dispose() {
    super.dispose();
    this.dotsItem.data.dispose();
    this.dotsItem.dispose();
    this.resetResponsivityManager();
  }
};
AdaptiveActionContainer.ContainerID = 1;
var AnimationUtils = class {
  constructor() {
    this.cancelQueue = [];
  }
  getMsFromRule(value) {
    if (value === "auto") return 0;
    return Number(value.slice(0, -1).replace(",", ".")) * 1e3;
  }
  reflow(element) {
    return element.offsetHeight;
  }
  getAnimationsCount(element) {
    let animationName = "";
    if (getComputedStyle) {
      animationName = getComputedStyle(element).animationName;
    }
    return animationName && animationName != "none" ? animationName.split(", ").length : 0;
  }
  getAnimationDuration(element) {
    const style = getComputedStyle(element);
    const delays = style["animationDelay"].split(", ");
    const durations = style["animationDuration"].split(", ");
    let duration = 0;
    for (let i = 0; i < Math.max(durations.length, delays.length); i++) {
      duration = Math.max(duration, this.getMsFromRule(durations[i % durations.length]) + this.getMsFromRule(delays[i % delays.length]));
    }
    return duration;
  }
  addCancelCallback(callback) {
    this.cancelQueue.push(callback);
  }
  removeCancelCallback(callback) {
    if (this.cancelQueue.indexOf(callback) >= 0) {
      this.cancelQueue.splice(this.cancelQueue.indexOf(callback), 1);
    }
  }
  onAnimationEnd(element, callback, options) {
    let cancelTimeout;
    let animationsCount = this.getAnimationsCount(element);
    const onEndCallback = (isCancel = true) => {
      callback(isCancel);
      clearTimeout(cancelTimeout);
      this.removeCancelCallback(onEndCallback);
      element.removeEventListener("animationend", onAnimationEndCallback);
    };
    const onAnimationEndCallback = (event) => {
      if (event.target == event.currentTarget && --animationsCount <= 0) {
        onEndCallback(false);
      }
    };
    if (animationsCount > 0) {
      element.addEventListener("animationend", onAnimationEndCallback);
      this.addCancelCallback(onEndCallback);
      cancelTimeout = setTimeout(() => {
        onEndCallback(false);
      }, this.getAnimationDuration(element) + 10);
    } else {
      callback(true);
    }
  }
  afterAnimationRun(element, options) {
    if (element && options) {
      options.onAfterRunAnimation && options.onAfterRunAnimation(element);
    }
  }
  beforeAnimationRun(element, options) {
    if (element && options) {
      options.onBeforeRunAnimation && options.onBeforeRunAnimation(element);
    }
  }
  getCssClasses(options) {
    return options.cssClass.replace(/\s+$/, "").split(/\s+/);
  }
  runAnimation(element, options, callback) {
    if (element && (options === null || options === void 0 ? void 0 : options.cssClass)) {
      this.reflow(element);
      this.getCssClasses(options).forEach((cssClass) => {
        element.classList.add(cssClass);
      });
      this.onAnimationEnd(element, callback, options);
    } else {
      callback(true);
    }
  }
  clearHtmlElement(element, options) {
    if (element && options.cssClass) {
      this.getCssClasses(options).forEach((cssClass) => {
        element.classList.remove(cssClass);
      });
    }
    this.afterAnimationRun(element, options);
  }
  onNextRender(callback, isCancel = false) {
    if (!isCancel && DomWindowHelper.isAvailable()) {
      let latestRAF;
      const cancelCallback = () => {
        callback(true);
        cancelAnimationFrame(latestRAF);
      };
      latestRAF = DomWindowHelper.requestAnimationFrame(() => {
        latestRAF = DomWindowHelper.requestAnimationFrame(() => {
          callback(false);
          this.removeCancelCallback(cancelCallback);
        });
      });
      this.addCancelCallback(cancelCallback);
    } else {
      callback(true);
    }
  }
  cancel() {
    const cancelQueue = [].concat(this.cancelQueue);
    cancelQueue.forEach((callback) => callback());
    this.cancelQueue = [];
  }
};
var AnimationPropertyUtils = class extends AnimationUtils {
  onEnter(options) {
    const htmlElement = options.getAnimatedElement();
    const enterOptions = options.getEnterOptions ? options.getEnterOptions() : {};
    this.beforeAnimationRun(htmlElement, enterOptions);
    this.runAnimation(htmlElement, enterOptions, () => {
      this.clearHtmlElement(htmlElement, enterOptions);
    });
  }
  onLeave(options, callback) {
    const htmlElement = options.getAnimatedElement();
    const leaveOptions = options.getLeaveOptions ? options.getLeaveOptions() : {};
    this.beforeAnimationRun(htmlElement, leaveOptions);
    this.runAnimation(htmlElement, leaveOptions, (isCancel) => {
      callback();
      this.onNextRender(() => {
        this.clearHtmlElement(htmlElement, leaveOptions);
      }, isCancel);
    });
  }
};
var AnimationGroupUtils = class extends AnimationUtils {
  runGroupAnimation(options, addedItems, removedItems, reorderedItems, callback) {
    const info = {
      isAddingRunning: addedItems.length > 0,
      isDeletingRunning: removedItems.length > 0,
      isReorderingRunning: reorderedItems.length > 0
    };
    const addedHtmlElements = addedItems.map((el) => options.getAnimatedElement(el));
    const enterOptions = addedItems.map((el) => options.getEnterOptions ? options.getEnterOptions(el, info) : {});
    const removedHtmlElements = removedItems.map((el) => options.getAnimatedElement(el));
    const leaveOptions = removedItems.map((el) => options.getLeaveOptions ? options.getLeaveOptions(el, info) : {});
    const reorderedHtmlElements = reorderedItems.map((el) => options.getAnimatedElement(el.item));
    const reorderedOptions = reorderedItems.map((el) => options.getReorderOptions ? options.getReorderOptions(el.item, el.movedForward, info) : {});
    addedItems.forEach((_, i) => {
      this.beforeAnimationRun(addedHtmlElements[i], enterOptions[i]);
    });
    removedItems.forEach((_, i) => {
      this.beforeAnimationRun(removedHtmlElements[i], leaveOptions[i]);
    });
    reorderedItems.forEach((_, i) => {
      this.beforeAnimationRun(reorderedHtmlElements[i], reorderedOptions[i]);
    });
    let counter = addedItems.length + removedItems.length + reorderedHtmlElements.length;
    const onAnimationEndCallback = (isCancel) => {
      if (--counter <= 0) {
        callback && callback();
        this.onNextRender(() => {
          addedItems.forEach((_, i) => {
            this.clearHtmlElement(addedHtmlElements[i], enterOptions[i]);
          });
          removedItems.forEach((_, i) => {
            this.clearHtmlElement(removedHtmlElements[i], leaveOptions[i]);
          });
          reorderedItems.forEach((_, i) => {
            this.clearHtmlElement(reorderedHtmlElements[i], reorderedOptions[i]);
          });
        }, isCancel);
      }
    };
    addedItems.forEach((_, i) => {
      this.runAnimation(addedHtmlElements[i], enterOptions[i], onAnimationEndCallback);
    });
    removedItems.forEach((_, i) => {
      this.runAnimation(removedHtmlElements[i], leaveOptions[i], onAnimationEndCallback);
    });
    reorderedItems.forEach((_, i) => {
      this.runAnimation(reorderedHtmlElements[i], reorderedOptions[i], onAnimationEndCallback);
    });
  }
};
var AnimationProperty = class {
  constructor(animationOptions, update, getCurrentValue) {
    this.animationOptions = animationOptions;
    this.update = update;
    this.getCurrentValue = getCurrentValue;
    this._debouncedSync = debounce((newValue) => {
      this.cancelAnimations();
      try {
        this._sync(newValue);
      } catch (_a) {
        this.update(newValue);
      }
    });
  }
  onNextRender(callback, onCancel) {
    const rerenderEvent = this.animationOptions.getRerenderEvent();
    if (!rerenderEvent) {
      if (DomWindowHelper.isAvailable()) {
        const raf = DomWindowHelper.requestAnimationFrame(() => {
          callback();
          this.cancelCallback = void 0;
        });
        this.cancelCallback = () => {
          onCancel && onCancel();
          cancelAnimationFrame(raf);
          this.cancelCallback = void 0;
        };
      } else {
        throw new Error("Can't get next render");
      }
    } else {
      const clear = () => {
        rerenderEvent.remove(nextRenderCallback);
        this.cancelCallback = void 0;
      };
      const nextRenderCallback = (_, options) => {
        if (options.isCancel) {
          onCancel && onCancel();
        } else {
          callback();
        }
        clear();
      };
      this.cancelCallback = () => {
        onCancel && onCancel();
        clear();
      };
      rerenderEvent.add(nextRenderCallback);
    }
  }
  sync(newValue) {
    if (this.animationOptions.isAnimationEnabled()) {
      this._debouncedSync.run(newValue);
    } else {
      this.cancel();
      this.update(newValue);
    }
  }
  cancel() {
    this._debouncedSync.cancel();
    this.cancelAnimations();
  }
  cancelAnimations() {
    this.cancelCallback && this.cancelCallback();
    this.animation.cancel();
  }
};
var AnimationBoolean = class extends AnimationProperty {
  constructor() {
    super(...arguments);
    this.animation = new AnimationPropertyUtils();
  }
  _sync(newValue) {
    if (newValue !== this.getCurrentValue()) {
      if (newValue) {
        this.onNextRender(() => {
          this.animation.onEnter(this.animationOptions);
        });
        this.update(newValue);
      } else {
        this.animation.onLeave(this.animationOptions, () => {
          this.update(newValue);
        });
      }
    } else {
      this.update(newValue);
    }
  }
};
var AnimationGroup = class extends AnimationProperty {
  constructor() {
    super(...arguments);
    this.animation = new AnimationGroupUtils();
  }
  _sync(newValue) {
    var _a, _b;
    newValue = [].concat(newValue);
    const oldValue = [].concat(this.getCurrentValue());
    const allowSyncRemovalAddition = (_a = this.animationOptions.allowSyncRemovalAddition) !== null && _a !== void 0 ? _a : true;
    let compareResult = compareArrays(oldValue, newValue, (_b = this.animationOptions.getKey) !== null && _b !== void 0 ? _b : (item) => item);
    if (!allowSyncRemovalAddition && (compareResult.reorderedItems.length > 0 || compareResult.addedItems.length > 0)) {
      compareResult.deletedItems = [];
      compareResult.mergedItems = newValue;
    }
    if (!!this.animationOptions.onCompareArrays) {
      this.animationOptions.onCompareArrays(compareResult);
    }
    let {
      addedItems,
      reorderedItems,
      deletedItems,
      mergedItems
    } = compareResult;
    const runAnimationCallback = () => {
      this.animation.runGroupAnimation(this.animationOptions, addedItems, deletedItems, reorderedItems, () => {
        if (deletedItems.length > 0) {
          this.update(newValue);
        }
      });
    };
    if ([addedItems, deletedItems, reorderedItems].some((arr) => arr.length > 0)) {
      if (deletedItems.length <= 0 || reorderedItems.length > 0 || addedItems.length > 0) {
        this.onNextRender(runAnimationCallback, () => {
          this.update(newValue);
        });
        this.update(mergedItems);
      } else {
        runAnimationCallback();
      }
    } else {
      this.update(newValue);
    }
  }
};
var AnimationTab = class extends AnimationProperty {
  constructor(animationOptions, update, getCurrentValue, mergeValues2) {
    super(animationOptions, update, getCurrentValue);
    this.mergeValues = mergeValues2;
    this.animation = new AnimationGroupUtils();
  }
  _sync(newValue) {
    const oldValue = [].concat(this.getCurrentValue());
    if (oldValue[0] !== newValue[0]) {
      const tempValue = !!this.mergeValues ? this.mergeValues(newValue, oldValue) : [].concat(oldValue, newValue);
      this.onNextRender(() => {
        this.animation.runGroupAnimation(this.animationOptions, newValue, oldValue, [], () => {
          this.update(newValue);
        });
      }, () => this.update(newValue));
      this.update(tempValue, true);
    } else {
      this.update(newValue);
    }
  }
};
var SurveyElementCore = class extends Base {
  constructor() {
    super();
    this.createLocTitleProperty();
  }
  createLocTitleProperty() {
    return this.createLocalizableString("title", this, true);
  }
  /**
   * Returns `true` if the survey element is a page.
   *
   * This property returns `false` for [`PageModel`](https://surveyjs.io/form-library/documentation/api-reference/page-model) objects in the following cases:
   *
   * - `SurveyModel`'s [`questionsOnPageMode`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#questionsOnPageMode) is set to `"singlePage"`.
   * - The page is included in a [preview of given answers](https://surveyjs.io/form-library/documentation/design-survey/create-a-multi-page-survey#preview-page).
   *
   * In those cases, the survey creates an internal `PageModel` object to show all questions on one page, and all regular pages become panels.
   */
  get isPage() {
    return false;
  }
  /**
   * Returns `true` if the survey element is a panel or acts as one.
   *
   * This property returns `true` for `PageModel` objects in the following cases:
   *
   * - `SurveyModel`'s [`questionsOnPageMode`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#questionsOnPageMode) is set to `"singlePage"`.
   * - The page is included in a [preview of given answers](https://surveyjs.io/form-library/documentation/design-survey/create-a-multi-page-survey#preview-page).
   *
   * In those cases, the survey creates an internal `PageModel` object to show all questions on one page, and all regular pages become panels.
   */
  get isPanel() {
    return false;
  }
  /**
   * Returns `true` if the survey element is a question.
   */
  get isQuestion() {
    return false;
  }
  /**
   * Returns `true` if the element is a survey.
   */
  get isSurvey() {
    return false;
  }
  /**
   * A title for the survey element. If `title` is undefined, the `name` property value is displayed instead.
   *
   * Empty pages and panels do not display their titles or names.
   *
   * @see [Configure Question Titles](https://surveyjs.io/form-library/documentation/design-survey-question-titles)
  */
  get title() {
    return this.getLocalizableStringText("title", this.getDefaultTitleValue());
  }
  set title(val) {
    this.setTitleValue(val);
  }
  get locTitle() {
    return this.getLocalizableString("title");
  }
  getDefaultTitleValue() {
    return void 0;
  }
  setTitleValue(val) {
    this.setLocalizableStringText("title", val);
  }
  /**
   * Returns `true` if the survey element has a description.
   * @see description
  */
  get hasDescription() {
    return this.getPropertyValue("hasDescription", void 0, () => this.calcDescriptionVisibility());
  }
  set hasDescription(val) {
    this.setPropertyValue("hasDescription", val);
  }
  calcDescriptionVisibility() {
    const newDescription = this.description;
    let showPlaceholder = false;
    if (this.isDesignMode) {
      const property2 = Serializer.findProperty(this.getType(), "description");
      showPlaceholder = !!(property2 === null || property2 === void 0 ? void 0 : property2.placeholder);
    }
    return !!newDescription || showPlaceholder && this.isDesignMode;
  }
  resetDescriptionVisibility() {
    this.resetPropertyValue("hasDescription");
  }
  get locDescription() {
    return this.getLocalizableString("description");
  }
  get titleTagName() {
    let titleTagName = this.getDefaultTitleTagName();
    const survey = this.getSurvey();
    return !!survey ? survey.getElementTitleTagName(this, titleTagName) : titleTagName;
  }
  getDefaultTitleTagName() {
    return settings.titleTags[this.getType()];
  }
  get hasTitle() {
    return this.title.length > 0;
  }
  get hasTitleActions() {
    return false;
  }
  get hasTitleEvents() {
    return this.hasTitleActions;
  }
  getTitleToolbar() {
    return null;
  }
  getTitleOwner() {
    return void 0;
  }
  get isTitleOwner() {
    return !!this.getTitleOwner();
  }
  get isTitleRenderedAsString() {
    return this.getIsTitleRenderedAsString();
  }
  toggleState() {
    return void 0;
  }
  get cssClasses() {
    return {};
  }
  get cssTitle() {
    return "";
  }
  get ariaTitleId() {
    return void 0;
  }
  get ariaDescriptionId() {
    return void 0;
  }
  get titleTabIndex() {
    return void 0;
  }
  get titleAriaExpanded() {
    return void 0;
  }
  get titleAriaRole() {
    return void 0;
  }
  get ariaLabel() {
    return this.locTitle.renderedHtml;
  }
  get titleAriaLabel() {
    return this.ariaLabel;
  }
  getIsTitleRenderedAsString() {
    return !this.isTitleOwner;
  }
};
__decorate([property({
  localizable: true,
  onSet: (newDescription, self2) => {
    self2.resetDescriptionVisibility();
  }
})], SurveyElementCore.prototype, "description", void 0);
var DragTypeOverMeEnum;
(function(DragTypeOverMeEnum2) {
  DragTypeOverMeEnum2[DragTypeOverMeEnum2["InsideEmptyPanel"] = 1] = "InsideEmptyPanel";
  DragTypeOverMeEnum2[DragTypeOverMeEnum2["MultilineRight"] = 2] = "MultilineRight";
  DragTypeOverMeEnum2[DragTypeOverMeEnum2["MultilineLeft"] = 3] = "MultilineLeft";
  DragTypeOverMeEnum2[DragTypeOverMeEnum2["Top"] = 4] = "Top";
  DragTypeOverMeEnum2[DragTypeOverMeEnum2["Right"] = 5] = "Right";
  DragTypeOverMeEnum2[DragTypeOverMeEnum2["Bottom"] = 6] = "Bottom";
  DragTypeOverMeEnum2[DragTypeOverMeEnum2["Left"] = 7] = "Left";
})(DragTypeOverMeEnum || (DragTypeOverMeEnum = {}));
var SurveyElement = class _SurveyElement extends SurveyElementCore {
  static getProgressInfoByElements(children, isRequired) {
    const info = Base.createProgressInfo();
    for (let i = 0; i < children.length; i++) {
      if (!children[i].isVisible) continue;
      const childInfo = children[i].getProgressInfo();
      info.questionCount += childInfo.questionCount;
      info.answeredQuestionCount += childInfo.answeredQuestionCount;
      info.requiredQuestionCount += childInfo.requiredQuestionCount;
      info.requiredAnsweredQuestionCount += childInfo.requiredAnsweredQuestionCount;
    }
    if (isRequired && info.questionCount > 0) {
      if (info.requiredQuestionCount == 0) info.requiredQuestionCount = 1;
      if (info.answeredQuestionCount > 0) info.requiredAnsweredQuestionCount = 1;
    }
    return info;
  }
  static IsNeedScrollIntoView(el, checkLeft, scrollIfVisible) {
    const elTop = scrollIfVisible ? -1 : el.getBoundingClientRect().top;
    let needScroll = elTop < 0;
    let elLeft = -1;
    if (!needScroll && checkLeft) {
      elLeft = el.getBoundingClientRect().left;
      needScroll = elLeft < 0;
    }
    if (!needScroll && DomWindowHelper.isAvailable()) {
      const height = DomWindowHelper.getInnerHeight();
      needScroll = height > 0 && height < elTop;
      if (!needScroll && checkLeft) {
        const width = DomWindowHelper.getInnerWidth();
        needScroll = width > 0 && width < elLeft;
      }
    }
    return needScroll;
  }
  static ScrollIntoView(el, scrollIntoViewOptions, doneCallback) {
    el.scrollIntoView(scrollIntoViewOptions);
    if (typeof doneCallback === "function") {
      let lastPos = null;
      let same = 0;
      const checkPos = () => {
        const newPos = el.getBoundingClientRect().top;
        if (newPos === lastPos) {
          if (same++ > 2) {
            doneCallback();
            return;
          }
        } else {
          lastPos = newPos;
          same = 0;
        }
        requestAnimationFrame(checkPos);
      };
      DomWindowHelper.requestAnimationFrame(checkPos);
    }
  }
  static ScrollElementToTop(elementId, scrollIfVisible, scrollIntoViewOptions, doneCallback) {
    const {
      root
    } = settings.environment;
    if (!elementId || typeof root === "undefined") return false;
    const el = root.getElementById(elementId);
    return _SurveyElement.ScrollElementToViewCore(el, false, scrollIfVisible, scrollIntoViewOptions, doneCallback);
  }
  static ScrollElementToViewCore(el, checkLeft, scrollIfVisible, scrollIntoViewOptions, doneCallback) {
    if (!el || !el.scrollIntoView) {
      doneCallback && doneCallback();
      return false;
    }
    const needScroll = _SurveyElement.IsNeedScrollIntoView(el, checkLeft, scrollIfVisible);
    if (needScroll) {
      _SurveyElement.ScrollIntoView(el, scrollIntoViewOptions, doneCallback);
    } else {
      doneCallback && doneCallback();
    }
    return needScroll;
  }
  static GetFirstNonTextElement(elements, removeSpaces = false) {
    if (!elements || !elements.length || elements.length == 0) return null;
    if (removeSpaces) {
      let tEl = elements[0];
      if (tEl.nodeName === "#text") tEl.data = "";
      tEl = elements[elements.length - 1];
      if (tEl.nodeName === "#text") tEl.data = "";
    }
    for (let i = 0; i < elements.length; i++) {
      if (elements[i].nodeName != "#text" && elements[i].nodeName != "#comment") return elements[i];
    }
    return null;
  }
  static FocusElement(elementId, isTimeOut, containerEl) {
    if (!elementId || !DomDocumentHelper.isAvailable()) return false;
    const res = !isTimeOut ? _SurveyElement.focusElementCore(elementId, containerEl) : false;
    if (!res) {
      setTimeout(() => {
        _SurveyElement.focusElementCore(elementId, containerEl);
      }, isTimeOut ? 100 : 10);
    }
    return res;
  }
  static focusElementCore(elementId, containerEl) {
    const {
      root
    } = settings.environment;
    if (!root && !containerEl) return false;
    const el = containerEl ? containerEl.querySelector(`#${CSS.escape(elementId)}`) : root.getElementById(elementId);
    if (el && !el["disabled"] && el.style.display !== "none" && el.offsetParent !== null) {
      _SurveyElement.ScrollElementToViewCore(el, true, false);
      el.focus();
      return true;
    }
    return false;
  }
  get effectiveColSpan() {
    const res = this.getPropertyValueWithoutDefault("effectiveColSpan");
    if (res !== void 0) return res;
    this.setRootStyle();
    return this.getPropertyValue("effectiveColSpan");
  }
  /**
   * Specifies how many columns this survey element spans in the grid layout. Applies only if you set the `SurveyModel`'s [`gridLayoutEnabled`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#gridLayoutEnabled) property to `true` and define the [`gridLayoutColumns`](https://surveyjs.io/form-library/documentation/api-reference/page-model#gridLayoutColumns) array for the parent page or panel.
   *
   * Default value: 1
   */
  get colSpan() {
    return this.getPropertyValue("colSpan", 1);
  }
  set colSpan(val) {
    this.setPropertyValue("colSpan", val);
  }
  constructor(name) {
    super();
    this.selectedElementInDesignValue = this;
    this.disableDesignActions = _SurveyElement.CreateDisabledDesignElements;
    this.parentQuestionValue = null;
    this.isContentElement = false;
    this.isEditableTemplateElement = false;
    this.isInteractiveDesignElement = true;
    this.isSingleInRow = true;
    this._renderedIsExpanded = true;
    this._isAnimatingCollapseExpand = false;
    this.animationCollapsed = new AnimationBoolean(this.getExpandCollapseAnimationOptions(), (val) => {
      this._renderedIsExpanded = val;
      if (this.animationAllowed) {
        if (val) {
          this.isAnimatingCollapseExpand = true;
        } else {
          this.updateElementCss(false);
        }
      }
    }, () => this.renderedIsExpanded);
    this.onAfterRenderElement = this.addEvent();
    this.setPropertyValueDirectly("name", this.getValidName(name));
    this.createNewArray("errors");
    this.createNewArray("titleActions");
    this.registerPropertyChangedHandlers(["isReadOnly"], () => {
      this.onReadOnlyChanged();
    });
    this.registerPropertyChangedHandlers(["errors"], () => {
      this.updateVisibleErrors();
    });
    this.registerPropertyChangedHandlers(["isSingleInRow"], () => {
      this.updateElementCss(false);
    });
    this.registerPropertyChangedHandlers(["minWidth", "maxWidth", "renderWidth", "allowRootStyle", "parent"], () => {
      this.updateRootStyle();
    });
    this.registerPropertyChangedHandlers(["effectiveColSpan"], (val) => {
      this.colSpan = val;
    });
  }
  onPropertyValueChanged(name, oldValue, newValue) {
    super.onPropertyValueChanged(name, oldValue, newValue);
    if (name === "state") {
      this.updateElementCss(false);
      this.notifyStateChanged(oldValue);
      if (this.stateChangedCallback) this.stateChangedCallback();
    }
  }
  getSkeletonComponentNameCore() {
    if (this.survey) {
      return this.survey.getSkeletonComponentName(this);
    }
    return "sv-skeleton";
  }
  /**
   * A Dynamic Panel, Dynamic Matrix, or Dropdown Matrix that includes the current question.
   *
   * This property is `null` for standalone questions.
   */
  get parentQuestion() {
    return this.parentQuestionValue;
  }
  setParentQuestion(val) {
    this.parentQuestionValue = val;
    this.onParentQuestionChanged();
  }
  onParentQuestionChanged() {
  }
  updateElementVisibility() {
    this.setPropertyValue("isVisible", this.isVisible);
  }
  get skeletonComponentName() {
    return this.getSkeletonComponentNameCore();
  }
  /**
   * Gets and sets the survey element's expand state.
   *
   * Possible values:
   *
   * - `"default"` (default) - The survey element is displayed in full and cannot be collapsed in the UI.
   * - `"expanded"` - The survey element is displayed in full and can be collapsed in the UI.
   * - `"collapsed"` - The survey element displays only `title` and `description` and can be expanded in the UI.
   *
   * @see toggleState
   * @see collapse
   * @see expand
   * @see isCollapsed
   * @see isExpanded
   */
  get state() {
    return this.getPropertyValue("state");
  }
  set state(val) {
    this.setPropertyValue("state", val);
    this.renderedIsExpanded = !this.isCollapsed;
  }
  notifyStateChanged(prevState) {
    if (this.survey) {
      this.survey.elementContentVisibilityChanged(this);
    }
  }
  /**
   * Returns `true` if the survey element is collapsed.
   * @see state
   * @see toggleState
   * @see collapse
   * @see expand
   * @see isExpanded
   */
  get isCollapsed() {
    return this.state === "collapsed" && !this.isDesignMode;
  }
  /**
   * Returns `true` if the survey element is expanded.
   * @see state
   * @see toggleState
   * @see collapse
   * @see expand
   * @see isCollapsed
   */
  get isExpanded() {
    return this.state === "expanded";
  }
  /**
   * Collapses the survey element.
   *
   * In collapsed state, the element displays only `title` and `description`.
   * @see title
   * @see description
   * @see state
   * @see toggleState
   * @see expand
   * @see isCollapsed
   * @see isExpanded
   */
  collapse() {
    if (this.isDesignMode) return;
    this.state = "collapsed";
  }
  /**
   * Expands the survey element.
   * @see state
   * @see toggleState
   * @see collapse
   * @see isCollapsed
   * @see isExpanded
   */
  expand() {
    this.state = "expanded";
  }
  /**
   * Toggles the survey element's `state` between collapsed and expanded.
   * @see state
   * @see collapse
   * @see expand
   * @see isCollapsed
   * @see isExpanded
   */
  toggleState() {
    if (this.isCollapsed) {
      this.expand();
      return true;
    }
    if (this.isExpanded) {
      this.collapse();
      return false;
    }
    return true;
  }
  get hasStateButton() {
    return this.isExpanded || this.isCollapsed;
  }
  get shortcutText() {
    return this.title || this.name;
  }
  getTitleToolbar() {
    if (!this.titleToolbarValue) {
      this.titleToolbarValue = this.createActionContainer(true);
      this.titleToolbarValue.locOwner = this;
      this.titleToolbarValue.containerCss = (this.isPanel ? this.cssClasses.panel.titleBar : this.cssClasses.titleBar) || "sv-action-title-bar";
      this.titleToolbarValue.setItems(this.getTitleActions());
    }
    return this.titleToolbarValue;
  }
  createActionContainer(allowAdaptiveActions) {
    const actionContainer = allowAdaptiveActions ? new AdaptiveActionContainer() : new ActionContainer();
    if (this.survey && !!this.survey.getCss().actionBar) {
      actionContainer.cssClasses = this.survey.getCss().actionBar;
    }
    return actionContainer;
  }
  get titleActions() {
    return this.getPropertyValue("titleActions");
  }
  getTitleActions() {
    if (!this.isTitleActionRequested) {
      this.updateTitleActions();
      this.isTitleActionRequested = true;
    }
    return this.titleActions;
  }
  getDefaultTitleActions() {
    return [];
  }
  updateTitleActions() {
    let actions = this.getDefaultTitleActions();
    if (!!this.survey) {
      actions = this.survey.getUpdatedElementTitleActions(this, actions);
    }
    this.setPropertyValue("titleActions", actions);
  }
  locStrsChanged() {
    super.locStrsChanged();
    if (!!this.titleToolbarValue) {
      this.titleToolbarValue.locStrsChanged();
    }
  }
  get hasTitleActions() {
    return this.getTitleActions().length > 0;
  }
  get hasTitleEvents() {
    return this.state !== void 0 && this.state !== "default";
  }
  get titleTabIndex() {
    return !this.isPage && this.state !== "default" ? 0 : void 0;
  }
  get titleAriaExpanded() {
    if (this.isPage || this.state === "default") return void 0;
    return this.state === "expanded" ? "true" : "false";
  }
  get titleAriaRole() {
    if (this.isPage || this.state === "default") return void 0;
    return "button";
  }
  setSurveyImpl(value, isLight) {
    this.surveyImplValue = value;
    if (!this.surveyImplValue) {
      this.setSurveyCore(null);
      this.surveyDataValue = null;
    } else {
      this.surveyDataValue = this.surveyImplValue.getSurveyData();
      this.setSurveyCore(this.surveyImplValue.getSurvey());
      this.textProcessorValue = this.surveyImplValue.getTextProcessor();
      this.onSetData();
    }
    if (!!this.survey) {
      this.resetDescriptionVisibility();
      this.clearCssClasses();
    }
    this.blockAnimations();
    this.renderedIsExpanded = !this.isCollapsed;
    this.releaseAnimations();
  }
  canRunConditions() {
    return super.canRunConditions() && !!this.data;
  }
  getDataFilteredValues() {
    return !!this.data ? this.data.getFilteredValues() : {};
  }
  getDataFilteredProperties() {
    var props = !!this.data ? this.data.getFilteredProperties() : {};
    props.question = this;
    return props;
  }
  get surveyImpl() {
    return this.surveyImplValue;
  }
  /* You shouldn't use this method ever */
  __setData(data) {
    this.surveyDataValue = data;
  }
  get data() {
    return this.surveyDataValue;
  }
  /**
   * Returns the survey object.
   */
  get survey() {
    return this.getSurvey();
  }
  getSurvey(live = false) {
    if (!!this.surveyValue) return this.surveyValue;
    if (!!this.surveyImplValue) {
      this.setSurveyCore(this.surveyImplValue.getSurvey());
    }
    return this.surveyValue;
  }
  setSurveyCore(value) {
    this.surveyValue = value;
    if (!!this.surveyChangedCallback) {
      this.surveyChangedCallback();
    }
  }
  get skeletonHeight() {
    let skeletonHeight = void 0;
    if (!!this.survey && this.survey.skeletonHeight) {
      skeletonHeight = this.survey.skeletonHeight + "px";
    }
    return skeletonHeight;
  }
  get isInternal() {
    return this.isContentElement;
  }
  get areInvisibleElementsShowing() {
    return !!this.survey && this.survey.areInvisibleElementsShowing && !this.isContentElement;
  }
  get isVisible() {
    return true;
  }
  /**
   * Returns `true` if the survey element or its parent element is read-only.
   *
   * If you want to switch a survey element to the read-only state based on a condition, specify the [`enableIf`](https://surveyjs.io/form-library/documentation/question#enableIf) property. Refer to the following help topic for information: [Conditional Visibility](https://surveyjs.io/form-library/documentation/design-survey-conditional-logic#conditional-visibility).
   * @see readOnly
   */
  get isReadOnly() {
    return this.readOnly;
  }
  /**
   * Makes the survey element read-only.
   *
   * If you want to switch a survey element to the read-only state based on a condition, specify the [`enableIf`](https://surveyjs.io/form-library/documentation/question#enableIf) property. Refer to the following help topic for information: [Conditional Visibility](https://surveyjs.io/form-library/documentation/design-survey-conditional-logic#conditional-visibility).
   * @see isReadOnly
   */
  get readOnly() {
    return this.getPropertyValue("readOnly");
  }
  set readOnly(val) {
    if (this.readOnly == val) return;
    this.setPropertyValue("readOnly", val);
    if (!this.isLoadingFromJson) {
      this.setPropertyValue("isReadOnly", this.isReadOnly);
    }
  }
  onReadOnlyChanged() {
    if (!!this.readOnlyChangedCallback) {
      this.readOnlyChangedCallback();
    }
  }
  get css() {
    return !!this.survey ? this.survey.getCss() : {};
  }
  get cssClassesValue() {
    let res = this.getPropertyValueWithoutDefault("cssClassesValue");
    if (!res && !this.isCssValueCalculating) {
      this.isCssValueCalculating = true;
      res = this.createCssClassesValue();
      this.isCssValueCalculating = false;
    }
    return res;
  }
  createCssClassesValue() {
    const res = this.calcCssClasses(this.css);
    this.setPropertyValue("cssClassesValue", res);
    this.onCalcCssClasses(res);
    this.updateElementCssCore(this.cssClassesValue);
    return res;
  }
  onCalcCssClasses(classes) {
  }
  /**
   * Returns an object in which keys are UI elements and values are CSS classes applied to them.
   *
   * Use the following events of the [`SurveyModel`](https://surveyjs.io/form-library/documentation/surveymodel) object to override CSS classes:
   *
   * - [`onUpdateQuestionCssClasses`](https://surveyjs.io/form-library/documentation/surveymodel#onUpdateQuestionCssClasses)
   * - [`onUpdatePanelCssClasses`](https://surveyjs.io/form-library/documentation/surveymodel#onUpdatePanelCssClasses)
   * - [`onUpdatePageCssClasses`](https://surveyjs.io/form-library/documentation/surveymodel#onUpdatePageCssClasses)
   * - [`onUpdateChoiceItemCss`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#onUpdateChoiceItemCss)
   */
  get cssClasses() {
    this.cssClassesValue;
    if (!this.survey) return this.calcCssClasses(this.css);
    if (!this.cssClassesValue) {
      this.createCssClassesValue();
    }
    return this.cssClassesValue;
  }
  get cssTitleNumber() {
    const css = this.cssClasses;
    if (css.number) return css.number;
    return css.panel ? css.panel.number : void 0;
  }
  get cssRequiredMark() {
    const css = this.cssClasses;
    return css.requiredMark || css.panel && css.panel.requiredMark;
  }
  getCssTitleExpandableSvg() {
    if (this.state === "default") return null;
    return this.cssClasses.titleExpandableSvg;
  }
  calcCssClasses(css) {
    return void 0;
  }
  updateElementCssCore(cssClasses) {
  }
  get cssError() {
    return "";
  }
  updateElementCss(reNew) {
    this.clearCssClasses();
  }
  clearCssClasses() {
    this.resetPropertyValue("cssClassesValue");
  }
  getIsLoadingFromJson() {
    if (super.getIsLoadingFromJson()) return true;
    return this.surveyValue ? this.surveyValue.isLoadingFromJson : false;
  }
  /**
   * A survey element identifier.
   *
   * > Question names must be unique.
   */
  get name() {
    return this.getPropertyValue("name", "");
  }
  set name(val) {
    var oldValue = this.name;
    this.setPropertyValue("name", this.getValidName(val));
    if (!this.isLoadingFromJson && !!oldValue) {
      this.onNameChanged(oldValue);
    }
  }
  getValidName(name) {
    return name;
  }
  onNameChanged(oldValue) {
  }
  updateBindingValue(valueName, value) {
    if (!!this.data && !this.isTwoValueEquals(value, this.data.getValue(valueName))) {
      this.data.setValue(valueName, value, false);
    }
  }
  /**
   * Validation errors. Call the `validate()` method to validate survey element data.
   * @see validate
   */
  get errors() {
    return this.getPropertyValue("errors");
  }
  set errors(val) {
    this.setPropertyValue("errors", val);
  }
  updateVisibleErrors() {
    var counter = 0;
    for (var i = 0; i < this.errors.length; i++) {
      if (this.errors[i].visible) counter++;
    }
    this.hasVisibleErrors = counter > 0;
  }
  /**
   * Returns `true` if the survey element or its child elements have validation errors.
   *
   * This property contains the result of the most recent validation. This result may be outdated. Call the `validate` method to get an up-to-date value.
   * @see errors
   */
  get containsErrors() {
    return this.getPropertyValue("containsErrors", false);
  }
  updateContainsErrors() {
    this.setPropertyValue("containsErrors", this.getContainsErrors());
  }
  getContainsErrors() {
    return this.errors.length > 0;
  }
  get selectedElementInDesign() {
    return this.selectedElementInDesignValue;
  }
  set selectedElementInDesign(val) {
    this.selectedElementInDesignValue = val;
  }
  updateCustomWidgets() {
  }
  onSurveyLoad() {
  }
  get wasRendered() {
    return !!this.wasRenderedValue;
  }
  onFirstRendering() {
    if (!this.wasRendered) {
      this.wasRenderedValue = true;
      this.onFirstRenderingCore();
    }
  }
  onFirstRenderingCore() {
  }
  endLoadingFromJson() {
    super.endLoadingFromJson();
    if (!this.survey) {
      this.onSurveyLoad();
    }
  }
  setVisibleIndex(index) {
    return 0;
  }
  delete(doDispose) {
  }
  /**
   * Returns the survey's [locale](https://surveyjs.io/form-library/documentation/surveymodel#locale).
   *
   * If a default locale is used, this method returns an empty string. To get the applied locale in this case, use the following code:
   *
   * ```js
   * import { surveyLocalization } from 'survey-core';
   * const defaultLocale = surveyLocalization.defaultLocale;
   * ```
   *
   * @see [Localization & Globalization](https://surveyjs.io/form-library/documentation/localization)
   */
  getLocale() {
    return this.survey ? this.survey.getLocale() : this.locOwner ? this.locOwner.getLocale() : "";
  }
  getMarkdownHtml(text, name) {
    return this.survey ? this.survey.getSurveyMarkdownHtml(this, text, name) : this.locOwner ? this.locOwner.getMarkdownHtml(text, name) : void 0;
  }
  getRenderer(name) {
    return this.survey && typeof this.survey.getRendererForString === "function" ? this.survey.getRendererForString(this, name) : this.locOwner && typeof this.locOwner.getRenderer === "function" ? this.locOwner.getRenderer(name) : null;
  }
  getRendererContext(locStr) {
    return this.survey && typeof this.survey.getRendererContextForString === "function" ? this.survey.getRendererContextForString(this, locStr) : this.locOwner && typeof this.locOwner.getRendererContext === "function" ? this.locOwner.getRendererContext(locStr) : locStr;
  }
  getProcessedText(text) {
    if (this.isLoadingFromJson) return text;
    if (this.textProcessor) return this.textProcessor.processText(text, this.getUseDisplayValuesInDynamicTexts());
    if (this.locOwner) return this.locOwner.getProcessedText(text);
    return text;
  }
  getUseDisplayValuesInDynamicTexts() {
    return true;
  }
  removeSelfFromList(list) {
    if (!list || !Array.isArray(list)) return;
    const index = list.indexOf(this);
    if (index > -1) {
      list.splice(index, 1);
    }
  }
  get textProcessor() {
    return this.textProcessorValue;
  }
  getProcessedHtml(html) {
    if (!html || !this.textProcessor) return html;
    return this.textProcessor.processText(html, true);
  }
  onSetData() {
  }
  get parent() {
    return this.getPropertyValue("parent", null);
  }
  set parent(val) {
    this.setPropertyValue("parent", val);
  }
  getPage(parent) {
    while (parent && parent.parent) parent = parent.parent;
    if (parent && parent.isPage) return parent;
    return null;
  }
  moveToBase(parent, container, insertBefore = null) {
    if (!container) return false;
    parent.removeElement(this);
    let index = -1;
    if (Helpers.isNumber(insertBefore)) {
      index = parseInt(insertBefore);
    }
    if (index == -1 && !!insertBefore && !!insertBefore.getType) {
      index = container.indexOf(insertBefore);
    }
    container.addElement(this, index);
    return true;
  }
  setPage(parent, newPage) {
    const oldPage = this.getPage(parent);
    this.prevSurvey = this.survey;
    if (typeof newPage === "string") {
      const survey = this.getSurvey();
      survey.pages.forEach((page) => {
        if (newPage === page.name) newPage = page;
      });
    }
    if (oldPage === newPage) return;
    if (parent) parent.removeElement(this);
    if (newPage) {
      newPage.addElement(this, -1);
    }
    this.prevSurvey = void 0;
  }
  getSearchableLocKeys(keys) {
    keys.push("title");
    keys.push("description");
  }
  get isDefaultV2Theme() {
    return this.survey && this.survey.getCss().root.indexOf("sd-root-modern") !== -1;
  }
  get hasParent() {
    return this.parent && !this.parent.isPage || this.parent === void 0;
  }
  shouldAddRunnerStyles() {
    return !this.isDesignMode && this.isDefaultV2Theme;
  }
  get isCompact() {
    return this.survey && this.survey["isCompact"];
  }
  canHaveFrameStyles() {
    var _a;
    if (!!((_a = this.survey) === null || _a === void 0 ? void 0 : _a.currentSingleQuestion)) return true;
    return this.parent !== void 0 && (!this.hasParent || this.parent && this.parent.showPanelAsPage);
  }
  getHasFrameV2() {
    return this.shouldAddRunnerStyles() && this.canHaveFrameStyles();
  }
  getIsNested() {
    return this.shouldAddRunnerStyles() && !this.canHaveFrameStyles();
  }
  getCssRoot(cssClasses) {
    const isExpanadable = !!this.isCollapsed || !!this.isExpanded;
    return new CssClassBuilder().append(cssClasses.withFrame, this.getHasFrameV2() && !this.isCompact).append(cssClasses.compact, this.isCompact && this.getHasFrameV2()).append(cssClasses.collapsed, !!this.isCollapsed).append(cssClasses.expandableAnimating, isExpanadable && this.isAnimatingCollapseExpand).append(cssClasses.expanded, !!this.isExpanded && this.renderedIsExpanded).append(cssClasses.expandable, isExpanadable).append(cssClasses.nested, this.getIsNested()).toString();
  }
  /**
   * Sets survey element width in CSS values.
   *
   * Default value: ""
   * @see minWidth
   * @see maxWidth
  */
  get width() {
    return this.getPropertyValue("width", "");
  }
  set width(val) {
    this.setPropertyValue("width", val);
  }
  /**
   * Gets or sets minimum survey element width in CSS values.
   *
   * Default value: "300px" (taken from [`settings.minWidth`](https://surveyjs.io/form-library/documentation/settings#minWidth))
   * @see maxWidth
   * @see renderWidth
   * @see width
   */
  get minWidth() {
    return this.getPropertyValue("minWidth");
  }
  set minWidth(val) {
    this.setPropertyValue("minWidth", val);
  }
  /**
   * Gets or sets maximum survey element width in CSS values.
   *
   * Default value: "100%" (taken from [`settings.maxWidth`](https://surveyjs.io/form-library/documentation/settings#maxWidth))
   * @see minWidth
   * @see renderWidth
   * @see width
   */
  get maxWidth() {
    return this.getPropertyValue("maxWidth");
  }
  set maxWidth(val) {
    this.setPropertyValue("maxWidth", val);
  }
  /**
   * Returns a calculated width of the rendered survey element in CSS values.
   * @see width
   * @see minWidth
   * @see maxWidth
   */
  get renderWidth() {
    return this.getPropertyValue("renderWidth", "");
  }
  set renderWidth(val) {
    this.setPropertyValue("renderWidth", val);
  }
  /**
   * Increases or decreases an indent of survey element content from the left edge. Accepts positive integer values and 0.
   */
  get indent() {
    return this.getPropertyValue("indent");
  }
  set indent(val) {
    this.setPropertyValue("indent", val);
  }
  get rightIndent() {
    return this.getPropertyValue("rightIndent", 0);
  }
  set rightIndent(val) {
    this.setPropertyValue("rightIndent", val);
  }
  getRootStyle() {
    const style = {};
    if (!!this.paddingLeft) {
      style["--sv-element-add-padding-left"] = this.paddingLeft;
    }
    if (!!this.paddingRight) {
      style["--sv-element-add-padding-right"] = this.paddingRight;
    }
    return style;
  }
  get paddingLeft() {
    return this.getPropertyValue("paddingLeft", void 0, () => this.calcPaddingLeft());
  }
  calcPaddingLeft() {
    return "";
  }
  get paddingRight() {
    return this.getPropertyValue("paddingRight", void 0, () => this.calcPaddingRight());
  }
  set paddingRight(val) {
    this.setPropertyValue("paddingRight", val);
  }
  calcPaddingRight() {
    return "";
  }
  resetIndents() {
    this.resetPropertyValue("paddingLeft");
    this.resetPropertyValue("paddingRight");
  }
  get rootStyle() {
    return this.getPropertyValue("rootStyle", void 0, () => this.calcRootStyle());
  }
  set rootStyle(val) {
    this.setPropertyValue("rootStyle", val);
  }
  updateRootStyle() {
    if (!this.getPropertyValueWithoutDefault("rootStyle")) {
      this.resetPropertyValue("effectiveColSpan");
    } else {
      this.setRootStyle();
    }
  }
  setRootStyle() {
    this.rootStyle = this.calcRootStyle();
  }
  calcRootStyle() {
    const style = {};
    let _width;
    if (!!this.parent) {
      const columns = this.parent.getColumsForElement(this);
      _width = columns.reduce((sum2, col) => col.effectiveWidth + sum2, 0);
      if (!!_width && _width !== 100) {
        style["flexGrow"] = 1;
        style["flexShrink"] = 0;
        style["flexBasis"] = _width + "%";
        style["minWidth"] = void 0;
        style["maxWidth"] = this.maxWidth;
      }
    }
    if (Object.keys(style).length == 0) {
      let minWidth = "" + this.minWidth;
      if (!!minWidth && minWidth != "auto") {
        if (minWidth.indexOf("px") != -1 && this.survey) {
          minWidth = minWidth.replace("px", "");
          let minWidthNum = parseFloat(minWidth);
          if (!isNaN(minWidthNum)) {
            minWidth = minWidthNum * this.survey.widthScale / 100;
            minWidth = "" + minWidth + "px";
          }
        }
        minWidth = "min(100%, " + minWidth + ")";
      }
      if (this.allowRootStyle && this.renderWidth) {
        style["flexGrow"] = 1;
        style["flexShrink"] = 1;
        style["flexBasis"] = this.renderWidth;
        style["minWidth"] = minWidth;
        style["maxWidth"] = this.maxWidth;
      }
    }
    return style;
  }
  isContainsSelection(el) {
    let elementWithSelection = void 0;
    const _document = DomDocumentHelper.getDocument();
    if (DomDocumentHelper.isAvailable() && !!_document && _document["selection"]) {
      elementWithSelection = _document["selection"].createRange().parentElement();
    } else {
      var selection = DomWindowHelper.getSelection();
      if (!!selection && selection.rangeCount > 0) {
        const range = selection.getRangeAt(0);
        if (range.startOffset !== range.endOffset) {
          elementWithSelection = range.startContainer.parentNode;
        }
      }
    }
    return elementWithSelection == el;
  }
  get clickTitleFunction() {
    if (this.needClickTitleFunction()) {
      return (event) => {
        if (!!event && this.isContainsSelection(event.target)) {
          return;
        }
        return this.processTitleClick();
      };
    }
    return void 0;
  }
  needClickTitleFunction() {
    return this.state !== "default";
  }
  processTitleClick() {
    if (this.state !== "default") {
      this.toggleState();
    }
  }
  get hasAdditionalTitleToolbar() {
    return false;
  }
  get additionalTitleToolbar() {
    return this.getAdditionalTitleToolbar();
  }
  getAdditionalTitleToolbar() {
    return null;
  }
  getCssTitle(cssClasses) {
    if (!cssClasses) return "";
    const isExpandable = this.state !== "default";
    const numInlineLimit = 4;
    return new CssClassBuilder().append(cssClasses.title).append(cssClasses.titleNumInline, (this.no || "").length > numInlineLimit || isExpandable).append(cssClasses.titleExpandable, isExpandable).append(cssClasses.titleExpanded, this.isExpanded).append(cssClasses.titleCollapsed, this.isCollapsed).append(cssClasses.titleDisabled, this.isDisabledStyle).append(cssClasses.titleReadOnly, this.isReadOnly).append(cssClasses.titleOnError, this.containsErrors).toString();
  }
  get isDisabledStyle() {
    return this.getIsDisableAndReadOnlyStyles(false)[1];
  }
  get isReadOnlyStyle() {
    return this.getIsDisableAndReadOnlyStyles(false)[0];
  }
  getIsDisableAndReadOnlyStyles(itemReadOnly) {
    const isPreview = this.isPreviewStyle;
    const isReadOnly = itemReadOnly || this.isReadOnly;
    const isReadOnlyStyle = isReadOnly && !isPreview;
    const isDisableStyle = !this.isDefaultV2Theme && (isReadOnly || isPreview);
    return [isReadOnlyStyle, isDisableStyle];
  }
  get isPreviewStyle() {
    return !!this.survey && this.survey.state === "preview";
  }
  localeChanged() {
    super.localeChanged();
    this.resetDescriptionVisibility();
    if (this.errors.length > 0) {
      this.errors.forEach((err) => {
        err.updateText();
      });
    }
  }
  setWrapperElement(element) {
    this.wrapperElement = element;
  }
  getWrapperElement() {
    return this.wrapperElement;
  }
  set isAnimatingCollapseExpand(val) {
    if (val !== this._isAnimatingCollapseExpand) {
      this._isAnimatingCollapseExpand = val;
      this.updateElementCss(false);
    }
  }
  get isAnimatingCollapseExpand() {
    return this._isAnimatingCollapseExpand || this._renderedIsExpanded != this.isExpanded;
  }
  onElementExpanded(elementIsRendered) {
  }
  getExpandCollapseAnimationOptions() {
    const beforeRunAnimation = (el) => {
      this.isAnimatingCollapseExpand = true;
      prepareElementForVerticalAnimation(el);
    };
    const afterRunAnimation = (el) => {
      this.isAnimatingCollapseExpand = false;
      cleanHtmlElementAfterAnimation(el);
    };
    return {
      getRerenderEvent: () => this.onElementRerendered,
      getEnterOptions: () => {
        const cssClasses = this.isPanel ? this.cssClasses.panel : this.cssClasses;
        return {
          cssClass: cssClasses.contentEnter,
          onBeforeRunAnimation: beforeRunAnimation,
          onAfterRunAnimation: (el) => {
            afterRunAnimation(el);
            this.onElementExpanded(true);
          }
        };
      },
      getLeaveOptions: () => {
        const cssClasses = this.isPanel ? this.cssClasses.panel : this.cssClasses;
        return {
          cssClass: cssClasses.contentLeave,
          onBeforeRunAnimation: beforeRunAnimation,
          onAfterRunAnimation: afterRunAnimation
        };
      },
      getAnimatedElement: () => {
        var _a;
        const cssClasses = this.isPanel ? this.cssClasses.panel : this.cssClasses;
        if (cssClasses.content) {
          const selector = classesToSelector(cssClasses.content);
          if (selector) {
            return (_a = this.getWrapperElement()) === null || _a === void 0 ? void 0 : _a.querySelector(`:scope ${selector}`);
          }
        }
        return void 0;
      },
      isAnimationEnabled: () => this.isExpandCollapseAnimationEnabled
    };
  }
  get isExpandCollapseAnimationEnabled() {
    return this.animationAllowed && !this.isDesignMode;
  }
  set renderedIsExpanded(val) {
    const oldValue = this._renderedIsExpanded;
    this.animationCollapsed.sync(val);
    if (!this.isExpandCollapseAnimationEnabled && !oldValue && this.renderedIsExpanded) {
      this.onElementExpanded(false);
    }
  }
  get renderedIsExpanded() {
    return !!this._renderedIsExpanded;
  }
  getIsAnimationAllowed() {
    return super.getIsAnimationAllowed() && !!this.survey && !this.survey["isEndLoadingFromJson"];
  }
  afterRenderCore(element) {
    this.onAfterRenderElement.fire(this, {
      htmlElement: element
    });
  }
  dispose() {
    super.dispose();
    if (this.titleToolbarValue) {
      this.titleToolbarValue.dispose();
    }
  }
};
SurveyElement.CreateDisabledDesignElements = false;
__decorate([property({
  defaultValue: null
})], SurveyElement.prototype, "dragTypeOverMe", void 0);
__decorate([property({
  defaultValue: false
})], SurveyElement.prototype, "isDragMe", void 0);
__decorate([property({
  defaultValue: false
})], SurveyElement.prototype, "hasVisibleErrors", void 0);
__decorate([property({
  defaultValue: true
})], SurveyElement.prototype, "isSingleInRow", void 0);
__decorate([property({
  defaultValue: true
})], SurveyElement.prototype, "allowRootStyle", void 0);
__decorate([property()], SurveyElement.prototype, "_renderedIsExpanded", void 0);
var RenderingCompletedAwaiter = class {
  constructor(_elements, _renderedHandler, waitingTimeout = 100) {
    this._elements = _elements;
    this._renderedHandler = _renderedHandler;
    this._elementsToRenderCount = 0;
    this._elementsToRenderTimer = void 0;
    this._elementRenderedHandler = (s, o) => {
      var _a;
      (_a = s.onAfterRenderElement) === null || _a === void 0 ? void 0 : _a.remove(this._elementRenderedHandler);
      this._elementsToRenderCount--;
      if (this._elementsToRenderCount <= 0) {
        this.visibleElementsRendered();
      }
    };
    this._elements.forEach((element) => {
      if (element.onAfterRenderElement) {
        element.onAfterRenderElement.add(this._elementRenderedHandler);
        this._elementsToRenderCount++;
      }
    });
    if (this._elementsToRenderCount > 0) {
      this._elementsToRenderTimer = setTimeout(() => {
        if (this._elementsToRenderCount > 0) {
          this.visibleElementsRendered();
        }
      }, waitingTimeout);
    } else {
      this.visibleElementsRendered();
    }
  }
  stopWaitingForElementsRendering() {
    if (this._elementsToRenderTimer) {
      clearTimeout(this._elementsToRenderTimer);
      this._elementsToRenderTimer = void 0;
    }
    this._elements.forEach((element) => {
      var _a;
      (_a = element.onAfterRenderElement) === null || _a === void 0 ? void 0 : _a.remove(this._elementRenderedHandler);
    });
    this._elementsToRenderCount = 0;
  }
  visibleElementsRendered() {
    const renderedHandler = this._renderedHandler;
    this.dispose();
    if (typeof renderedHandler == "function") {
      renderedHandler();
    }
  }
  dispose() {
    this.stopWaitingForElementsRendering();
    this._elements = void 0;
    this._renderedHandler = void 0;
  }
};
var LocalizableString = class _LocalizableString {
  static get defaultLocale() {
    return settings.localization.defaultLocaleName;
  }
  static set defaultLocale(val) {
    settings.localization.defaultLocaleName = val;
  }
  get localizationName() {
    return this._localizationName;
  }
  set localizationName(val) {
    if (this._localizationName != val) {
      this._localizationName = val;
      this.strChanged();
    }
  }
  get allowLineBreaks() {
    var _a;
    if (this._allowLineBreaks === void 0) {
      this._allowLineBreaks = false;
      if (!!this.name && this.owner instanceof SurveyElementCore) {
        this._allowLineBreaks = ((_a = Serializer.findProperty(this.owner.getType(), this.name)) === null || _a === void 0 ? void 0 : _a.type) == "text";
      }
    }
    return this._allowLineBreaks;
  }
  constructor(owner, useMarkdown = false, name, locName) {
    this.owner = owner;
    this.useMarkdown = useMarkdown;
    this.name = name;
    this.values = {};
    this.htmlValues = {};
    this.onStringChanged = new EventBase();
    this._localizationName = locName;
    this.onCreating();
  }
  getIsMultiple() {
    return false;
  }
  get locale() {
    if (this.owner && this.owner.getLocale) {
      const res = this.owner.getLocale();
      if (!!res || !this.sharedData) return res;
    }
    if (!!this.sharedData) return this.sharedData.locale;
    return "";
  }
  strChanged() {
    if (!this.isTextRequested) return;
    this.searchableText = void 0;
    if (this.renderedText === void 0 && this.isEmpty && !this.onGetTextCallback && !this.localizationName) return;
    this.calculatedTextValue = this.calcText();
    if (this.renderedText !== this.calculatedTextValue) {
      this.renderedText = void 0;
      this.calculatedTextValue = void 0;
    }
    this.htmlValues = {};
    this.onChanged();
    this.onStringChanged.fire(this, {});
  }
  get text() {
    return this.pureText;
  }
  set text(value) {
    this.setLocaleText(this.locale, value);
  }
  get calculatedText() {
    this.renderedText = this.calculatedTextValue !== void 0 ? this.calculatedTextValue : this.calcText();
    this.calculatedTextValue = void 0;
    return this.renderedText;
  }
  calcText() {
    const pureText = this.pureText;
    let res = pureText;
    if (res && this.owner && this.owner.getProcessedText && res.indexOf("{") > -1) {
      res = this.owner.getProcessedText(res);
    }
    if (this.onGetTextCallback) res = this.onGetTextCallback(res, pureText);
    return res;
  }
  get pureText() {
    this.isTextRequested = true;
    var loc = this.locale;
    if (!loc) loc = this.defaultLoc;
    var res = this.getValue(loc);
    if (this.isValueEmpty(res) && loc === this.defaultLoc) {
      res = this.getValue(surveyLocalization.defaultLocale);
    }
    if (this.isValueEmpty(res)) {
      const dialect = this.getRootDialect(loc);
      if (!!dialect) {
        res = this.getValue(dialect);
      }
    }
    if (this.isValueEmpty(res) && loc !== this.defaultLoc) {
      res = this.getValue(this.defaultLoc);
    }
    if (this.isValueEmpty(res) && !!this.getLocalizationName()) {
      res = this.getLocalizationStr();
      if (!!this.onGetLocalizationTextCallback) {
        res = this.onGetLocalizationTextCallback(res);
      }
    }
    if (!res) res = this.defaultValue || "";
    return res;
  }
  getRootDialect(loc) {
    if (!loc) return loc;
    const index = loc.indexOf("-");
    return index > -1 ? loc.substring(0, index) : "";
  }
  getLocalizationName() {
    return !!this.sharedData ? this.sharedData.localizationName : this.localizationName;
  }
  getLocalizationStr() {
    const name = this.getLocalizationName();
    return !!name ? getLocaleString(name, this.locale) : "";
  }
  get hasHtml() {
    return this.hasHtmlValue();
  }
  get html() {
    if (!this.hasHtml) return "";
    return this.getHtmlValue();
  }
  get isEmpty() {
    return this.getValuesKeys().length == 0;
  }
  get textOrHtml() {
    return this.hasHtml ? this.getHtmlValue() : this.calculatedText;
  }
  get renderedHtml() {
    return this.textOrHtml;
  }
  getLocaleText(loc) {
    const res = this.getLocaleTextCore(loc);
    return res ? res : "";
  }
  getLocaleTextCore(loc) {
    if (!loc) loc = this.defaultLoc;
    return this.getValue(loc);
  }
  isLocaleTextEqualsWithDefault(loc, val) {
    let res = this.getLocaleTextCore(loc);
    if (res === val) return true;
    return this.isValueEmpty(res) && this.isValueEmpty(val);
  }
  clear() {
    this.setJson(void 0);
  }
  clearLocale(loc) {
    this.setLocaleText(loc, void 0);
  }
  setLocaleText(loc, value) {
    loc = this.getValueLoc(loc);
    if (!!loc && value === void 0) {
      const oldValue2 = this.getValue(loc);
      if (oldValue2 !== void 0) {
        this.deleteValue(loc);
        this.fireStrChanged(loc, oldValue2);
      }
      return;
    }
    if (!this.storeDefaultText && this.isLocaleTextEqualsWithDefault(loc, value)) {
      if (!this.isValueEmpty(value) || !!loc && loc !== this.defaultLoc) return;
      let dl = surveyLocalization.defaultLocale;
      let oldValue2 = this.getValue(dl);
      if (!!dl && !this.isValueEmpty(oldValue2)) {
        this.setValue(dl, value);
        this.fireStrChanged(dl, oldValue2);
      }
      return;
    }
    if (!settings.localization.storeDuplicatedTranslations && !this.isValueEmpty(value) && loc && loc != this.defaultLoc && !this.getValue(loc) && value == this.getLocaleText(this.defaultLoc)) return;
    var curLoc = this.curLocale;
    if (!loc) loc = this.defaultLoc;
    var oldValue = this.onStrChanged && loc === curLoc ? this.pureText : void 0;
    delete this.htmlValues[loc];
    if (this.isValueEmpty(value)) {
      this.deleteValue(loc);
    } else {
      if (typeof value === "string") {
        if (this.canRemoveLocValue(loc, value)) {
          this.setLocaleText(loc, null);
        } else {
          this.setValue(loc, value);
          if (loc == this.defaultLoc) {
            this.deleteValuesEqualsToDefault(value);
          }
        }
      }
    }
    this.fireStrChanged(loc, oldValue);
  }
  isValueEmpty(val) {
    if (val === void 0 || val === null) return true;
    if (this.localizationName) return false;
    return val === "";
  }
  get curLocale() {
    return !!this.locale ? this.locale : this.defaultLoc;
  }
  canRemoveLocValue(loc, val) {
    if (settings.localization.storeDuplicatedTranslations) return false;
    if (loc === this.defaultLoc) return false;
    const dialect = this.getRootDialect(loc);
    if (!!dialect) {
      const dialectVal = this.getLocaleText(dialect);
      if (!!dialectVal) return dialectVal == val;
      return this.canRemoveLocValue(dialect, val);
    } else {
      return val == this.getLocaleText(this.defaultLoc);
    }
  }
  fireStrChanged(loc, oldValue) {
    this.strChanged();
    if (!this.onStrChanged) return;
    const value = this.pureText;
    if (loc !== this.curLocale || oldValue !== value) {
      this.onStrChanged(oldValue, value);
    }
  }
  hasNonDefaultText() {
    var keys = this.getValuesKeys();
    if (keys.length == 0) return false;
    return keys.length > 1 || keys[0] != this.defaultLoc;
  }
  getLocales() {
    var keys = this.getValuesKeys();
    if (keys.length == 0) return [];
    return keys;
  }
  getJson() {
    if (!!this.sharedData) return this.sharedData.getJson();
    const keys = this.getValuesKeys();
    if (keys.length == 0) {
      if (this.serializeCallBackText) {
        const text = this.calcText();
        if (!!text) return text;
      }
      return null;
    }
    if (keys.length == 1 && keys[0] == settings.localization.defaultLocaleName && !settings.serialization.localizableStringSerializeAsObject) return this.values[keys[0]];
    const res = {};
    for (let key in this.values) {
      res[key] = this.values[key];
    }
    return res;
  }
  setJson(value, isLoading) {
    if (!!this.sharedData) {
      this.sharedData.setJson(value, isLoading);
      return;
    }
    this.values = {};
    this.htmlValues = {};
    if (value === null || value === void 0) return;
    if (isLoading) {
      if (typeof value === "string") {
        this.values[settings.defaultLocaleName] = value;
      } else {
        this.values = value;
        delete this.values["pos"];
      }
    } else {
      if (typeof value === "string") {
        this.setLocaleText(null, value);
      } else {
        for (var key in value) {
          this.setLocaleText(key, value[key]);
        }
      }
      this.strChanged();
    }
  }
  get renderAs() {
    if (!this.owner || typeof this.owner.getRenderer !== "function") {
      return _LocalizableString.defaultRenderer;
    }
    return this.owner.getRenderer(this.name) || _LocalizableString.defaultRenderer;
  }
  get renderAsData() {
    if (!this.owner || typeof this.owner.getRendererContext !== "function") {
      return this;
    }
    return this.owner.getRendererContext(this) || this;
  }
  equals(obj) {
    if (!!this.sharedData) return this.sharedData.equals(obj);
    if (!obj || !obj.values) return false;
    return Helpers.isTwoValueEquals(this.values, obj.values, false, true, false);
  }
  setFindText(text) {
    if (this.searchText == text) return;
    this.searchText = text;
    if (!this.searchableText) {
      let textOrHtml = this.textOrHtml;
      this.searchableText = !!textOrHtml ? textOrHtml.toLowerCase() : "";
    }
    var str = this.searchableText;
    var index = !!str && !!text ? str.indexOf(text) : void 0;
    if (index < 0) index = void 0;
    if (index != void 0 || this.searchIndex != index) {
      this.searchIndex = index;
      if (!!this.onSearchChanged) {
        this.onSearchChanged();
      }
    }
    return this.searchIndex != void 0;
  }
  onChanged() {
  }
  onCreating() {
  }
  hasHtmlValue() {
    if (!this.owner || !this.useMarkdown) return false;
    let loc = this.locale;
    if (!loc) loc = this.defaultLoc;
    if (this.htmlValues[loc] !== void 0) return !!this.htmlValues[loc];
    let renderedText = this.calculatedText;
    if (!renderedText) {
      this.setHtmlValue(loc, "");
      return false;
    }
    if (!!this.getLocalizationName() && renderedText === this.getLocalizationStr()) {
      this.setHtmlValue(loc, "");
      return false;
    }
    const res = this.owner.getMarkdownHtml(renderedText, this.name);
    this.setHtmlValue(loc, res);
    return !!res;
  }
  setHtmlValue(loc, val) {
    this.htmlValues[loc] = val;
  }
  getHtmlValue() {
    var loc = this.locale;
    if (!loc) loc = this.defaultLoc;
    return this.htmlValues[loc];
  }
  deleteValuesEqualsToDefault(defaultValue) {
    if (settings.localization.storeDuplicatedTranslations) return;
    var keys = this.getValuesKeys();
    for (var i = 0; i < keys.length; i++) {
      if (keys[i] == this.defaultLoc) continue;
      if (this.getValue(keys[i]) == defaultValue) {
        this.deleteValue(keys[i]);
      }
    }
  }
  getValue(loc) {
    if (!!this.sharedData) return this.sharedData.getValue(loc);
    return this.values[this.getValueLoc(loc)];
  }
  setValue(loc, value) {
    if (!!this.sharedData) this.sharedData.setValue(loc, value);
    else this.values[this.getValueLoc(loc)] = value;
  }
  deleteValue(loc) {
    if (!!this.sharedData) this.sharedData.deleteValue(loc);
    else delete this.values[this.getValueLoc(loc)];
  }
  getValueLoc(loc) {
    if (this.disableLocalization) return settings.localization.defaultLocaleName;
    return loc;
  }
  getValuesKeys() {
    if (!!this.sharedData) return this.sharedData.getValuesKeys();
    return Object.keys(this.values);
  }
  get defaultLoc() {
    return settings.localization.defaultLocaleName;
  }
};
LocalizableString.SerializeAsObject = false;
LocalizableString.defaultRenderer = "sv-string-viewer";
LocalizableString.editableRenderer = "sv-string-editor";
var LocalizableStrings = class {
  constructor(owner) {
    this.owner = owner;
    this.values = {};
  }
  getIsMultiple() {
    return true;
  }
  get locale() {
    return this.owner && this.owner.getLocale ? this.owner.getLocale() : "";
  }
  get value() {
    return this.getValue("");
  }
  set value(val) {
    this.setValue("", val);
  }
  get text() {
    return Array.isArray(this.value) ? this.value.join("\n") : "";
  }
  set text(val) {
    this.value = !!val ? val.split("\n") : [];
  }
  getLocaleText(loc) {
    var res = this.getValueCore(loc, !loc || loc === this.locale);
    if (!res || !Array.isArray(res) || res.length == 0) return "";
    return res.join("\n");
  }
  setLocaleText(loc, newValue) {
    var val = !!newValue ? newValue.split("\n") : null;
    this.setValue(loc, val);
  }
  getValue(loc) {
    return this.getValueCore(loc);
  }
  getValueCore(loc, useDefault = true) {
    loc = this.getLocale(loc);
    if (this.values[loc]) return this.values[loc];
    if (useDefault) {
      var defLoc = settings.localization.defaultLocaleName;
      if (loc !== defLoc && this.values[defLoc]) return this.values[defLoc];
    }
    return [];
  }
  setValue(loc, val) {
    loc = this.getLocale(loc);
    const oldValue = Helpers.createCopy(this.values);
    if (!val || val.length == 0) {
      delete this.values[loc];
    } else {
      this.values[loc] = val;
    }
    if (!!this.onValueChanged) {
      this.onValueChanged(oldValue, this.values);
    }
  }
  hasValue(loc = "") {
    return !this.isEmpty && this.getValue(loc).length > 0;
  }
  get isEmpty() {
    return this.getValuesKeys().length == 0;
  }
  getLocale(loc) {
    if (!!loc) return loc;
    loc = this.locale;
    return !!loc ? loc : settings.localization.defaultLocaleName;
  }
  getLocales() {
    var keys = this.getValuesKeys();
    if (keys.length == 0) return [];
    return keys;
  }
  getJson() {
    var keys = this.getValuesKeys();
    if (keys.length == 0) return null;
    if (keys.length == 1 && keys[0] == settings.localization.defaultLocaleName && !settings.serialization.localizableStringSerializeAsObject) return this.values[keys[0]];
    return Helpers.createCopy(this.values);
  }
  setJson(value) {
    this.values = {};
    if (!value) return;
    if (Array.isArray(value)) {
      this.setValue(null, value);
    } else {
      for (var key in value) {
        this.setValue(key, value[key]);
      }
    }
  }
  getValuesKeys() {
    return Object.keys(this.values);
  }
};
function confirmAction(message) {
  if (!!settings && !!settings.confirmActionFunc) return settings.confirmActionFunc(message);
  return confirm(message);
}
function confirmActionAsync(options) {
  const callbackFunc = (res) => {
    if (res) options.funcOnYes();
    else if (!!options.funcOnNo) options.funcOnNo();
  };
  if (!!settings && !!settings.confirmActionAsync) {
    if (settings.confirmActionAsync(options.message, callbackFunc, options)) return;
  }
  callbackFunc(confirmAction(options.message));
}
function detectIEOrEdge() {
  if (typeof detectIEOrEdge.isIEOrEdge === "undefined") {
    const ua = navigator.userAgent;
    const msie = ua.indexOf("MSIE ");
    const trident = ua.indexOf("Trident/");
    const edge = ua.indexOf("Edge/");
    detectIEOrEdge.isIEOrEdge = edge > 0 || trident > 0 || msie > 0;
  }
  return detectIEOrEdge.isIEOrEdge;
}
function loadFileFromBase64(b64Data, fileName) {
  try {
    const byteString = atob(b64Data.split(",")[1]);
    const mimeString = b64Data.split(",")[0].split(":")[1].split(";")[0];
    const ab = new ArrayBuffer(byteString.length);
    const ia = new Uint8Array(ab);
    for (let i = 0; i < byteString.length; i++) {
      ia[i] = byteString.charCodeAt(i);
    }
    const bb = new Blob([ab], {
      type: mimeString
    });
    if (!!navigator && navigator["msSaveBlob"]) {
      navigator["msSaveOrOpenBlob"](bb, fileName);
    }
  } catch (err) {
  }
}
var isShadowDOM = (rootElement) => {
  return !!rootElement && !!("host" in rootElement && rootElement.host);
};
var getElement = (element) => {
  const {
    root
  } = settings.environment;
  return typeof element === "string" ? root.getElementById(element) : element;
};
function isElementVisible(element, threshold = 0) {
  if (typeof settings.environment === "undefined") {
    return false;
  }
  const {
    root
  } = settings.environment;
  const clientHeight = isShadowDOM(root) ? root.host.clientHeight : root.documentElement.clientHeight;
  const elementRect = element.getBoundingClientRect();
  const viewHeight = Math.max(clientHeight, DomWindowHelper.getInnerHeight());
  const topWin = -threshold;
  const bottomWin = viewHeight + threshold;
  const topEl = elementRect.top;
  const bottomEl = elementRect.bottom;
  const maxTop = Math.max(topWin, topEl);
  const minBottom = Math.min(bottomWin, bottomEl);
  return maxTop <= minBottom;
}
function findScrollableParent(element) {
  const {
    root
  } = settings.environment;
  if (!element) {
    return isShadowDOM(root) ? root.host : root.documentElement;
  }
  if (element.scrollHeight > element.clientHeight && (getComputedStyle(element).overflowY === "scroll" || getComputedStyle(element).overflowY === "auto")) {
    return element;
  }
  if (element.scrollWidth > element.clientWidth && (getComputedStyle(element).overflowX === "scroll" || getComputedStyle(element).overflowX === "auto")) {
    return element;
  }
  return findScrollableParent(element.parentElement);
}
function activateLazyRenderingChecks(id) {
  const environment = settings.environment;
  if (!environment) return;
  const {
    root
  } = environment;
  const el = root.getElementById(id);
  if (!el) return;
  const scrollableEl = findScrollableParent(el);
  if (!!scrollableEl) {
    setTimeout(() => scrollableEl.dispatchEvent(new CustomEvent("scroll")), 10);
  }
}
function navigateToUrl(url) {
  const location = DomWindowHelper.getLocation();
  if (!url || !location) return;
  location.href = getSafeUrl(url);
}
function wrapUrlForBackgroundImage(url) {
  return !!url ? ["url(", url, ")"].join("") : "";
}
function isBase64URL(url) {
  if (typeof url == "string") {
    return /^data:((?:\w+\/(?:(?!;).)+)?)((?:;[^;]+?)*),(.+)$/.test(url);
  }
  return null;
}
var renamedIcons = {
  "changecamera": "flip-24x24",
  "clear": "clear-24x24",
  "cancel": "cancel-24x24",
  "closecamera": "close-24x24",
  "defaultfile": "file-72x72",
  "choosefile": "folder-24x24",
  "file": "toolbox-file-24x24",
  "left": "chevronleft-16x16",
  "modernbooleancheckchecked": "plus-32x32",
  "modernbooleancheckunchecked": "minus-32x32",
  "more": "more-24x24",
  "navmenu_24x24": "navmenu-24x24",
  "removefile": "error-24x24",
  "takepicture": "camera-32x32",
  "takepicture_24x24": "camera-24x24",
  "v2check": "check-16x16",
  "checked": "check-16x16",
  "v2check_24x24": "check-24x24",
  "back-to-panel_16x16": "restoredown-16x16",
  "clear_16x16": "clear-16x16",
  "close_16x16": "close-16x16",
  "collapsedetail": "collapsedetails-16x16",
  "expanddetail": "expanddetails-16x16",
  "full-screen_16x16": "maximize-16x16",
  "loading": "loading-48x48",
  "minimize_16x16": "minimize-16x16",
  "next_16x16": "chevronright-16x16",
  "previous_16x16": "chevronleft-16x16",
  "no-image": "noimage-48x48",
  "ranking-dash": "rankingundefined-16x16",
  "drag-n-drop": "drag-24x24",
  "ranking-arrows": "reorder-24x24",
  "restore_16x16": "fullsize-16x16",
  "reset": "restore-24x24",
  "search": "search-24x24",
  "average": "smiley-rate5-24x24",
  "excellent": "smiley-rate9-24x24",
  "good": "smiley-rate7-24x24",
  "normal": "smiley-rate6-24x24",
  "not-good": "smiley-rate4-24x24",
  "perfect": "smiley-rate10-24x24",
  "poor": "smiley-rate3-24x24",
  "terrible": "smiley-rate1-24x24",
  "very-good": "smiley-rate8-24x24",
  "very-poor": "smiley-rate2-24x24",
  "add_16x16": "add-16x16",
  "add_24x24": "add-24x24",
  "alert_24x24": "warning-24x24",
  "apply": "apply-24x24",
  "arrow-down": "arrowdown-24x24",
  "arrow-left": "arrowleft-24x24",
  "arrow-left_16x16": "arrowleft-16x16",
  "arrowleft": "arrowleft-16x16",
  "arrow-right": "arrowright-24x24",
  "arrow-right_16x16": "arrowright-16x16",
  "arrowright": "arrowright-16x16",
  "arrow-up": "arrowup-24x24",
  "boolean": "toolbox-boolean-24x24",
  "change-question-type_16x16": "speechbubble-16x16",
  "checkbox": "toolbox-checkbox-24x24",
  "collapse-detail_16x16": "minusbox-16x16",
  "collapse-panel": "collapse-pg-24x24",
  "collapse_16x16": "collapse-16x16",
  "color-picker": "dropper-16x16",
  "comment": "toolbox-longtext-24x24",
  "config": "wrench-24x24",
  "copy": "copy-24x24",
  "default": "toolbox-customquestion-24x24",
  "delete_16x16": "delete-16x16",
  "delete_24x24": "delete-24x24",
  "delete": "delete-24x24",
  "description-hide": "hidehint-16x16",
  "description": "hint-16x16",
  "device-desktop": "desktop-24x24",
  "device-phone": "phone-24x24",
  "device-rotate": "rotate-24x24",
  "device-tablet": "tablet-24x24",
  "download": "download-24x24",
  "drag-area-indicator": "drag-24x24",
  "drag-area-indicator_24x16": "draghorizontal-24x16",
  "v2dragelement_16x16": "draghorizontal-24x16",
  "drop-down-arrow": "chevrondown-24x24",
  "drop-down-arrow_16x16": "chevrondown-16x16",
  "chevron_16x16": "chevrondown-16x16",
  "dropdown": "toolbox-dropdown-24x24",
  "duplicate_16x16": "copy-16x16",
  "edit": "edit-24x24",
  "edit_16x16": "edit-16x16",
  "editing-finish": "finishedit-24x24",
  "error": "error-16x16",
  "expand-detail_16x16": "plusbox-16x16",
  "expand-panel": "expand-pg-24x24",
  "expand_16x16": "expand-16x16",
  "expression": "toolbox-expression-24x24",
  "fast-entry": "textedit-24x24",
  "fix": "fix-24x24",
  "html": "toolbox-html-24x24",
  "image": "toolbox-image-24x24",
  "imagepicker": "toolbox-imagepicker-24x24",
  "import": "import-24x24",
  "invisible-items": "invisible-24x24",
  "language": "language-24x24",
  "load": "import-24x24",
  "logic-collapse": "collapse-24x24",
  "logic-expand": "expand-24x24",
  "logo": "image-48x48",
  "matrix": "toolbox-matrix-24x24",
  "matrixdropdown": "toolbox-multimatrix-24x24",
  "matrixdynamic": "toolbox-dynamicmatrix-24x24",
  "multipletext": "toolbox-multipletext-24x24",
  "panel": "toolbox-panel-24x24",
  "paneldynamic": "toolbox-dynamicpanel-24x24",
  "preview": "preview-24x24",
  "radiogroup": "toolbox-radiogroup-24x24",
  "ranking": "toolbox-ranking-24x24",
  "rating": "toolbox-rating-24x24",
  "redo": "redo-24x24",
  "remove_16x16": "remove-16x16",
  "required": "required-16x16",
  "save": "save-24x24",
  "select-page": "selectpage-24x24",
  "settings": "settings-24x24",
  "settings_16x16": "settings-16x16",
  "signaturepad": "toolbox-signature-24x24",
  "switch-active_16x16": "switchon-16x16",
  "switch-inactive_16x16": "switchoff-16x16",
  "tagbox": "toolbox-tagbox-24x24",
  "text": "toolbox-singleline-24x24",
  "theme": "theme-24x24",
  "toolbox": "toolbox-24x24",
  "undo": "undo-24x24",
  "visible": "visible-24x24",
  "wizard": "wand-24x24",
  "searchclear": "clear-16x16",
  "chevron-16x16": "chevrondown-16x16",
  "chevron": "chevrondown-24x24",
  "progressbuttonv2": "arrowleft-16x16",
  "right": "chevronright-16x16",
  "add-lg": "add-24x24",
  "add": "add-24x24"
};
function getIconNameFromProxy(iconName) {
  const customIconName = getCustomNewIconNameIfExists(iconName);
  return customIconName || getNewIconName(iconName);
}
function getNewIconName(iconName) {
  const prefix = "icon-";
  const nameWithoutPrefix = iconName.replace(prefix, "");
  const result = renamedIcons[nameWithoutPrefix] || nameWithoutPrefix;
  return prefix + result;
}
function getCustomNewIconNameIfExists(iconName) {
  let result = settings.customIcons[iconName];
  if (result) return getNewIconName(result);
  iconName = getNewIconName(iconName);
  result = settings.customIcons[iconName];
  if (result) return result;
  return null;
}
function createSvg(size, width, height, iconName, svgElem, title) {
  if (!svgElem) return;
  if (size !== "auto") {
    svgElem.style.width = (size || width || 16) + "px";
    svgElem.style.height = (size || height || 16) + "px";
  }
  const node = svgElem.childNodes[0];
  const realIconName = getIconNameFromProxy(iconName);
  node.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", "#" + realIconName);
  let titleElement = svgElem.getElementsByTagName("title")[0];
  if (!title) {
    if (!!titleElement) {
      svgElem.removeChild(titleElement);
    }
    return;
  } else {
    if (!titleElement) {
      titleElement = DomDocumentHelper.getDocument().createElementNS("http://www.w3.org/2000/svg", "title");
      svgElem.appendChild(titleElement);
    }
  }
  titleElement.textContent = title;
}
function getSafeUrl(url) {
  if (!url) return url;
  if (url.toLocaleLowerCase().indexOf("javascript:") > -1) return encodeURIComponent(url);
  return url;
}
function getRenderedSize(val) {
  if (typeof val == "string") {
    if (!isNaN(Number(val))) {
      return Number(val);
    } else if (val.includes("px")) {
      return parseFloat(val);
    }
  }
  if (typeof val == "number") {
    return val;
  }
  return void 0;
}
function getRenderedStyleSize(val) {
  if (getRenderedSize(val) !== void 0) {
    return void 0;
  }
  return val;
}
var keyFocusedClassName = "sv-focused--by-key";
function doKey2ClickBlur(evt) {
  const element = evt.target;
  if (!element || !element.classList) return;
  element.classList.remove(keyFocusedClassName);
}
function doKey2ClickUp(evt, options) {
  if (!!evt.target && evt.target["contentEditable"] === "true") {
    return;
  }
  const element = evt.target;
  if (!element) return;
  const char = evt.which || evt.keyCode;
  if (char === 9) {
    if (!!element.classList && !element.classList.contains(keyFocusedClassName)) {
      element.classList.add(keyFocusedClassName);
    }
    return;
  }
  if (options) {
    if (!options.__keyDownReceived) return;
    options.__keyDownReceived = false;
  }
  if (char === 13 || char === 32) {
    if (element.click) element.click();
  } else if ((!options || options.processEsc) && char === 27) {
    if (element.blur) element.blur();
  }
}
function doKey2ClickDown(evt, options = {
  processEsc: true
}) {
  if (options) options.__keyDownReceived = true;
  if (!!evt.target && evt.target["contentEditable"] === "true") {
    return;
  }
  var char = evt.which || evt.keyCode;
  const supportedCodes = [13, 32];
  if (options.processEsc) {
    supportedCodes.push(27);
  }
  if (supportedCodes.indexOf(char) !== -1) {
    evt.preventDefault();
  }
}
function increaseHeightByContent(element, getComputedStyle2) {
  if (!element) return;
  if (!getComputedStyle2) getComputedStyle2 = (elt) => {
    return DomDocumentHelper.getComputedStyle(elt);
  };
  const style = getComputedStyle2(element);
  element.style.height = "auto";
  if (!!element.scrollHeight) {
    element.style.height = element.scrollHeight + parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth) + "px";
  }
}
function preventDefaults(event) {
  event.preventDefault();
  event.stopPropagation();
}
function classesToSelector(str) {
  if (!str) return str;
  const re = /\s*?([\w-]+)\s*?/g;
  return str.replace(re, ".$1");
}
function getElementWidth(el) {
  return !!getComputedStyle ? Number.parseFloat(getComputedStyle(el).width) : el.offsetWidth;
}
function isContainerVisible(el) {
  return !!(el.offsetWidth || el.offsetHeight || el.getClientRects().length);
}
function getFirstVisibleChild(el) {
  let result;
  for (let index = 0; index < el.children.length; index++) {
    if (!result && getComputedStyle(el.children[index]).display !== "none") {
      result = el.children[index];
    }
  }
  return result;
}
function mergeValues(src, dest) {
  if (!dest || !src) return;
  if (typeof dest !== "object") return;
  for (var key in src) {
    var value = src[key];
    if (!Array.isArray(value) && value && typeof value === "object") {
      if (!dest[key] || typeof dest[key] !== "object") dest[key] = {};
      mergeValues(value, dest[key]);
    } else {
      dest[key] = value;
    }
  }
}
function updateListCssValues(res, css) {
  const listCssClasses = {};
  mergeValues(css.list, listCssClasses);
  mergeValues(res.list, listCssClasses);
  res["list"] = listCssClasses;
}
function showConfirmDialog(message, callback, options = {}) {
  const locStr = new LocalizableString(void 0);
  const popupViewModel = settings.showDialog({
    componentName: "sv-string-viewer",
    data: {
      locStr,
      locString: locStr,
      model: locStr
    },
    //TODO fix in library
    onApply: () => {
      callback(true);
      return true;
    },
    onCancel: () => {
      callback(false);
      return false;
    },
    title: message || options.message,
    displayMode: "popup",
    isFocusedContent: false,
    cssClass: options.cssClass || "sv-popup--confirm"
  }, options.rootElement);
  const toolbar = popupViewModel.footerToolbar;
  const applyBtn = toolbar.getActionById("apply");
  const cancelBtn = toolbar.getActionById("cancel");
  cancelBtn.title = getLocaleString("cancel", options.locale);
  cancelBtn.innerCss = "sv-popup__body-footer-item sv-popup__button sd-btn sd-btn--small";
  applyBtn.title = options.applyTitle || getLocaleString("ok", options.locale);
  applyBtn.innerCss = "sv-popup__body-footer-item sv-popup__button sv-popup__button--danger sd-btn sd-btn--small sd-btn--danger";
  configConfirmDialog(popupViewModel);
  return true;
}
function configConfirmDialog(popupViewModel) {
  popupViewModel.width = "min-content";
}
function chooseFiles(input, callback) {
  if (!DomWindowHelper.isFileReaderAvailable()) return;
  input.value = "";
  input.onchange = (event) => {
    if (!DomWindowHelper.isFileReaderAvailable()) return;
    if (!input || !input.files || input.files.length < 1) return;
    let files = [];
    for (let i = 0; i < input.files.length; i++) {
      files.push(input.files[i]);
    }
    callback(files);
  };
  input.click();
}
function compareArrays(oldValue, newValue, getKey) {
  const oldItemsMap = /* @__PURE__ */ new Map();
  const newItemsMap = /* @__PURE__ */ new Map();
  const commonItemsInNewMap = /* @__PURE__ */ new Map();
  const commonItemsInOldMap = /* @__PURE__ */ new Map();
  oldValue.forEach((item) => {
    const itemKey = getKey(item);
    if (!oldItemsMap.has(itemKey)) {
      oldItemsMap.set(getKey(item), item);
    } else {
      throw new Error("keys must be unique");
    }
  });
  newValue.forEach((item) => {
    const itemKey = getKey(item);
    if (!newItemsMap.has(itemKey)) {
      newItemsMap.set(itemKey, item);
    } else {
      throw new Error("keys must be unique");
    }
  });
  const addedItems = [];
  const deletedItems = [];
  newItemsMap.forEach((item, key) => {
    if (!oldItemsMap.has(key)) {
      addedItems.push(item);
    } else {
      commonItemsInNewMap.set(key, commonItemsInNewMap.size);
    }
  });
  oldItemsMap.forEach((item, key) => {
    if (!newItemsMap.has(key)) {
      deletedItems.push(item);
    } else {
      commonItemsInOldMap.set(key, commonItemsInOldMap.size);
    }
  });
  const reorderedItems = [];
  commonItemsInNewMap.forEach((index, key) => {
    const oldIndex = commonItemsInOldMap.get(key);
    const item = newItemsMap.get(key);
    if (oldIndex !== index) reorderedItems.push({
      item,
      movedForward: oldIndex < index
    });
  });
  const oldItemsWithCorrectOrder = new Array(oldValue.length);
  let commonItemsIndex = 0;
  const commonItemsKeysOrder = Array.from(commonItemsInNewMap.keys());
  oldValue.forEach((item, index) => {
    if (commonItemsInNewMap.has(getKey(item))) {
      oldItemsWithCorrectOrder[index] = newItemsMap.get(commonItemsKeysOrder[commonItemsIndex]);
      commonItemsIndex++;
    } else {
      oldItemsWithCorrectOrder[index] = item;
    }
  });
  const valuesToInsertBeforeKey = /* @__PURE__ */ new Map();
  let tempValuesArray = [];
  oldItemsWithCorrectOrder.forEach((item) => {
    const itemKey = getKey(item);
    if (newItemsMap.has(itemKey)) {
      if (tempValuesArray.length > 0) {
        valuesToInsertBeforeKey.set(itemKey, tempValuesArray);
        tempValuesArray = [];
      }
    } else {
      tempValuesArray.push(item);
    }
  });
  const mergedItems = new Array();
  newItemsMap.forEach((item, key) => {
    if (valuesToInsertBeforeKey.has(key)) {
      valuesToInsertBeforeKey.get(key).forEach((item2) => {
        mergedItems.push(item2);
      });
    }
    mergedItems.push(item);
  });
  tempValuesArray.forEach((item) => {
    mergedItems.push(item);
  });
  return {
    reorderedItems,
    deletedItems,
    addedItems,
    mergedItems
  };
}
function getVerticalDimensions(el) {
  if (DomDocumentHelper.isAvailable()) {
    const {
      paddingTop,
      paddingBottom,
      borderTopWidth,
      borderBottomWidth,
      marginTop,
      marginBottom,
      boxSizing
    } = DomDocumentHelper.getComputedStyle(el);
    let heightTo = el.offsetHeight + "px";
    if (boxSizing == "content-box") {
      let heightPx = el.offsetHeight;
      [borderBottomWidth, borderTopWidth, paddingBottom, paddingTop].forEach((style) => {
        heightPx -= parseFloat(style);
      });
      heightTo = heightPx + "px";
    }
    return {
      paddingTop,
      paddingBottom,
      borderTopWidth,
      borderBottomWidth,
      marginTop,
      marginBottom,
      heightFrom: "0px",
      heightTo
    };
  } else {
    return void 0;
  }
}
function setPropertiesOnElementForAnimation(el, styles, prefix = "--animation-") {
  var _a;
  el["__sv_created_properties"] = (_a = el["__sv_created_properties"]) !== null && _a !== void 0 ? _a : [];
  Object.keys(styles).forEach((key) => {
    const propertyName = `${prefix}${key.split(/\.?(?=[A-Z])/).join("-").toLowerCase()}`;
    el.style.setProperty(propertyName, styles[key]);
    el["__sv_created_properties"].push(propertyName);
  });
}
function prepareElementForVerticalAnimation(el) {
  setPropertiesOnElementForAnimation(el, getVerticalDimensions(el));
}
function cleanHtmlElementAfterAnimation(el) {
  if (Array.isArray(el["__sv_created_properties"])) {
    el["__sv_created_properties"].forEach((propertyName) => {
      el.style.removeProperty(propertyName);
    });
    delete el["__sv_created_properties"];
  }
}
function floorTo2Decimals(number) {
  return Math.floor(number * 100) / 100;
}
var document$1 = typeof globalThis !== "undefined" ? globalThis.document : (void 0).document;
var defaultEnvironment = !!document$1 ? {
  root: document$1,
  _rootElement: DomDocumentHelper.getBody(),
  get rootElement() {
    var _a;
    return (_a = this._rootElement) !== null && _a !== void 0 ? _a : DomDocumentHelper.getBody();
  },
  set rootElement(rootElement) {
    this._rootElement = rootElement;
  },
  _popupMountContainer: DomDocumentHelper.getBody(),
  get popupMountContainer() {
    var _a;
    return (_a = this._popupMountContainer) !== null && _a !== void 0 ? _a : DomDocumentHelper.getBody();
  },
  set popupMountContainer(popupMountContainer) {
    this._popupMountContainer = popupMountContainer;
  },
  svgMountContainer: document$1.head,
  stylesSheetsMountContainer: document$1.head
} : void 0;
var columnWidthsByType = {
  "file": {
    minWidth: "240px"
  },
  "comment": {
    minWidth: "200px"
  }
};
var settings = {
  version: "",
  /**
   * An object that configures survey appearance when the survey is being designed in Survey Creator.
   *
   * Nested properties:
   *
   * - `showEmptyDescriptions`: `boolean`\
   * Specifies whether to display an empty description for pages and panels. Default value: `true`.
   *
   * - `showEmptyTitles`: `boolean`\
   * Specifies whether to display an empty title for pages and panels. Default value: `true`.
   */
  designMode: {
    showEmptyDescriptions: true,
    showEmptyTitles: true
  },
  //#region designMode section, Obsolete properties
  get allowShowEmptyDescriptionInDesignMode() {
    return this.designMode.showEmptyDescriptions;
  },
  set allowShowEmptyDescriptionInDesignMode(val) {
    this.designMode.showEmptyDescriptions = val;
  },
  get allowShowEmptyTitleInDesignMode() {
    return this.designMode.showEmptyTitles;
  },
  set allowShowEmptyTitleInDesignMode(val) {
    this.designMode.showEmptyTitles = val;
  },
  //#endregion
  /**
   * An object that contains properties related to localization.
   *
   * Nested properties:
   *
   * - `useLocalTimeZone`: `boolean`\
   * Disable this property if you want internal SurveyJS functions to use methods that work with UTC date and time (`setUTCDate()` `setUTCHours()`, etc.) instead of methods that work with local date and time (`setYear()`, `setHours()`, etc.). Default value: `true`.
   *
   * - `defaultLocaleName`: `string`\
   * A property key that stores a translation for the default locale. Default value: `"default"`.
   *
   * - `storeDuplicatedTranslations`: `boolean`\
   * Specifies whether surveys should store translation strings that equal the translation strings in the default locale. Default value: `false`.
   */
  localization: {
    useLocalTimeZone: true,
    storeDuplicatedTranslations: false,
    defaultLocaleName: "default"
  },
  //#region localization section, obsolete properties
  get useLocalTimeZone() {
    return this.localization.useLocalTimeZone;
  },
  set useLocalTimeZone(val) {
    this.localization.useLocalTimeZone = val;
  },
  get storeDuplicatedTranslations() {
    return this.localization.storeDuplicatedTranslations;
  },
  set storeDuplicatedTranslations(val) {
    this.localization.storeDuplicatedTranslations = val;
  },
  get defaultLocaleName() {
    return this.localization.defaultLocaleName;
  },
  set defaultLocaleName(val) {
    this.localization.defaultLocaleName = val;
  },
  //#endregion
  /**
   * An object with properties that configure surveys when they work with a web service.
   *
   * Nested properties:
   *
   * - `encodeUrlParams`: `boolean`\
   * Specifies whether to encode URL parameters when you access a web service. Default value: `true`.
   *
   * - `cacheLoadedChoices`: `boolean`\
   * Specifies whether to cache [choices loaded from a web service](https://surveyjs.io/form-library/documentation/api-reference/questionselectbase#choicesByUrl). Default value: `true`.
   *
   * - `disableQuestionWhileLoadingChoices`: `boolean`\
   * Disables a question while its choices are being loaded from a web service. Default value: `false`.
   *
   * - `surveyServiceUrl`: `string`\
   * Obsolete. Self-hosted Form Library [no longer supports integration with SurveyJS Demo Service](https://surveyjs.io/stay-updated/release-notes/v2.0.0#form-library-removes-apis-for-integration-with-surveyjs-demo-service).
   *
   * - `onBeforeRequestChoices`: `(sender: ChoicesRestful, options: { request: XMLHttpRequest })`\
   * An event that is raised before a request for choices is send. Applies to questions with a specified [`choiceByUrl`](https://surveyjs.io/form-library/documentation/api-reference/questionselectbase#choicesByUrl) property. Use the `options.request` parameter to access and modify the `XMLHttpRequest` object. For instance, you can add authentication headers to it:
   *
   *     ```js
   *     import { settings } from "survey-core";
   *
   *     settings.web.onBeforeRequestChoices = (sender, options) => {
   *       options.request.setRequestHeader('RequestVerificationToken', requestVerificationToken);
   *     };
   *     ```
   */
  web: {
    onBeforeRequestChoices: (sender, options) => {
    },
    encodeUrlParams: true,
    cacheLoadedChoices: true,
    disableQuestionWhileLoadingChoices: false
  },
  //#region web section, obsolete properties
  get webserviceEncodeParameters() {
    return this.web.encodeUrlParams;
  },
  set webserviceEncodeParameters(val) {
    this.web.encodeUrlParams = val;
  },
  get useCachingForChoicesRestful() {
    return this.web.cacheLoadedChoices;
  },
  set useCachingForChoicesRestful(val) {
    this.web.cacheLoadedChoices = val;
  },
  get useCachingForChoicesRestfull() {
    return this.web.cacheLoadedChoices;
  },
  set useCachingForChoicesRestfull(val) {
    this.web.cacheLoadedChoices = val;
  },
  get disableOnGettingChoicesFromWeb() {
    return this.web.disableQuestionWhileLoadingChoices;
  },
  set disableOnGettingChoicesFromWeb(val) {
    this.web.disableQuestionWhileLoadingChoices = val;
  },
  //#endregion
  /**
   * An object that contains properties related to [triggers](https://surveyjs.io/form-library/documentation/design-survey/conditional-logic#conditional-survey-logic-triggers).
   *
   * Nested properties:
   *
   * - `changeNavigationButtonsOnComplete`: `boolean`\
   * Specifies whether to re-evaluate an expression associated with the [Complete trigger](https://surveyjs.io/form-library/documentation/design-survey/conditional-logic#complete) immediately when a question value changes. If the expression evaluates to `true`, the trigger is executed. Default value: `false`.\
   * Keep this property set to `false` if you want to re-evaluate the Complete trigger's expression only when the respondents navigate to another page.
   *
   * - `executeCompleteOnValueChanged`: `boolean`\
   * Specifies whether to replace the Next button with the Complete button when the [Complete trigger](https://surveyjs.io/form-library/documentation/design-survey/conditional-logic#complete) is going to be executed. Default value: `true`.
   *
   * - `executeSkipOnValueChanged`: `boolean`\
   * Specifies whether to re-evaluate an expression associated with the [Skip trigger](https://surveyjs.io/form-library/documentation/design-survey/conditional-logic#skip) immediately when a question value changes. If the expression evaluates to `true`, the trigger is executed. Default value: `true`.\
   * Disable this property if you want to re-evaluate the Skip trigger's expression only when respondents navigate to another page.
   */
  triggers: {
    changeNavigationButtonsOnComplete: true,
    executeCompleteOnValueChanged: false,
    executeSkipOnValueChanged: true
  },
  //#region triggers section, Obsolete properties
  get executeCompleteTriggerOnValueChanged() {
    return this.triggers.executeCompleteOnValueChanged;
  },
  set executeCompleteTriggerOnValueChanged(val) {
    this.triggers.executeCompleteOnValueChanged = val;
  },
  get changeNavigationButtonsOnCompleteTrigger() {
    return this.triggers.changeNavigationButtonsOnComplete;
  },
  set changeNavigationButtonsOnCompleteTrigger(val) {
    this.triggers.changeNavigationButtonsOnComplete = val;
  },
  get executeSkipTriggerOnValueChanged() {
    return this.triggers.executeSkipOnValueChanged;
  },
  set executeSkipTriggerOnValueChanged(val) {
    this.triggers.executeSkipOnValueChanged = val;
  },
  //#endregion
  /**
   * An object that contains properties related to JSON serialization.
   *
   * Nested properties:
   *
   * - `itemValueSerializeAsObject`: `boolean`\
   * Enable this property if you want to serialize [`ItemValue`](https://surveyjs.io/form-library/documentation/api-reference/itemvalue) instances (choice options, matrix rows, columns in a [Single-Select Matrix](https://surveyjs.io/form-library/documentation/api-reference/matrix-table-question-model)) as objects even when they include only the `value` property. Default value: `false`.
   *
   * - `itemValueSerializeDisplayText`: `boolean`\
   * Enable this property if you want to serialize the `text` property of [`ItemValue`](https://surveyjs.io/form-library/documentation/api-reference/itemvalue) objects even when it is empty or equal to the `value` property. Default value: `false`.
   *
   * - `localizableStringSerializeAsObject`: `boolean`\
   * Enable this property if you want to serialize [`LocalizableString`](https://surveyjs.io/form-library/documentation/api-reference/localizablestring) instances as objects even when they include only a translation string for the default locale. For example, `"Custom String"` will be serialized as `{ default: "Custom String" }`. Default value: `false`.
   *
   * - `matrixDropdownColumnSerializeTitle`: `boolean`\
   * Enable this property if you want to serialize the `title` property of [`MatrixDropdownColumn`](https://surveyjs.io/form-library/documentation/api-reference/multi-select-matrix-column-values) objects even when it is empty or equal to the `name` property. Default value: `false`.
   * @see [settings.parseNumber](https://surveyjs.io/form-library/documentation/api-reference/settings#parseNumber)
   */
  serialization: {
    itemValueSerializeAsObject: false,
    itemValueSerializeDisplayText: false,
    localizableStringSerializeAsObject: false,
    matrixDropdownColumnSerializeTitle: false
  },
  //#region serialization section, Obsolete properties
  get itemValueAlwaysSerializeAsObject() {
    return this.serialization.itemValueSerializeAsObject;
  },
  set itemValueAlwaysSerializeAsObject(val) {
    this.serialization.itemValueSerializeAsObject = val;
  },
  get itemValueAlwaysSerializeText() {
    return this.serialization.itemValueSerializeDisplayText;
  },
  set itemValueAlwaysSerializeText(val) {
    this.serialization.itemValueSerializeDisplayText = val;
  },
  get serializeLocalizableStringAsObject() {
    return this.serialization.localizableStringSerializeAsObject;
  },
  set serializeLocalizableStringAsObject(val) {
    this.serialization.localizableStringSerializeAsObject = val;
  },
  //#endregion
  /**
   * An object that configures lazy rendering.
   *
   * Nested properties:
   *
   * - `enabled`: `boolean`\
   * Specifies whether to add questions to the DOM only when they get into the viewport. Default value: `false`.
   *
   * [View Demo](https://surveyjs.io/form-library/examples/survey-lazy/ (linkStyle))
   * @see [SurveyModel.lazyRenderEnabled](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#lazyRenderEnabled)
   */
  lazyRender: {
    enabled: false,
    firstBatchSize: 3
  },
  //#region lazyRender section, Obsolete properties
  get lazyRowsRendering() {
    return this.lazyRender.enabled;
  },
  set lazyRowsRendering(val) {
    this.lazyRender.enabled = val;
  },
  get lazyRowsRenderingStartRow() {
    return this.lazyRender.firstBatchSize;
  },
  set lazyRowsRenderingStartRow(val) {
    this.lazyRender.firstBatchSize = val;
  },
  //#endregion
  /**
   * An object with properties that apply to [Single-Choice](https://surveyjs.io/form-library/documentation/api-reference/matrix-table-question-model), [Multiple-Choice](https://surveyjs.io/form-library/documentation/api-reference/matrix-table-with-dropdown-list), and [Dynamic Matrix](https://surveyjs.io/form-library/documentation/api-reference/dynamic-matrix-table-question-model) questions.
   *
   * Nested properties:
   *
   * - `defaultRowName`: `string`\
   * A property key that stores an object with default cell values. Default value: "default".
   *
   * - `defaultCellType`: `string`\
   * The default type of matrix cells. Default value: `"dropdown"`.\
   * You can specify this setting for individual questions or matrix columns: [`cellType`](https://surveyjs.io/form-library/documentation/api-reference/dynamic-matrix-table-question-model#cellType). Refer to the `cellType` property description for information on possible values.
   *
   * - `totalsSuffix`: `string`\
   * A suffix added to the name of the property that stores total values. The resulting property name consists of the matrix name and the suffix. Default value: `"-total"`.
   *
   * - `maxRowCount`: `number`\
   * A maximum number of rows in a Dynamic Matrix. Default value: 1000.\
   * You can specify this setting for an individual Dynamic Matrix: [`maxRowCount`](https://surveyjs.io/form-library/documentation/api-reference/dynamic-matrix-table-question-model#maxRowCount).
   *
   * - `maxRowCountInCondition`: `number`\
   * A maximum number of matrix rows included in the Condition drop-down menu in Survey Creator. This menu is used to configure conditional survey logic. Default value: 1.\
   * If you set this property to 0, the Condition menu does not include any matrix rows. Users still can specify conditions that use matrix rows but only with Manual Entry.
   *
   * - `renderRemoveAsIcon`: `boolean`\
   * Disable this property if you want to render the Remove action in Dynamic Matrix as a button. Otherwise, the action is rendered as an icon. Default value: `true`.
   *
   * - `columnWidthsByType`: `object`\
   * An object that specifies fixed and minimum column width based on the column type.\
   * Example: `settings.matrix.columnWidthsByType = { "tagbox": { minWidth: "240px", width: "300px" } }`
   *
   * - `rateSize`: `"small"` (default) | `"normal"`\
   * Specifies the size of rate values. Applies to [Rating Scale](https://surveyjs.io/form-library/examples/rating-scale/) questions within matrixes.
   */
  matrix: {
    defaultCellType: "dropdown",
    defaultRowName: "default",
    totalsSuffix: "-total",
    maxRowCount: 1e3,
    maxRowCountInCondition: 1,
    renderRemoveAsIcon: true,
    columnWidthsByType,
    rateSize: "small"
  },
  //#region matrix section, Obsolete properties
  get matrixDefaultRowName() {
    return this.matrix.defaultRowName;
  },
  set matrixDefaultRowName(val) {
    this.matrix.defaultRowName = val;
  },
  get matrixDefaultCellType() {
    return this.matrix.defaultCellType;
  },
  set matrixDefaultCellType(val) {
    this.matrix.defaultCellType = val;
  },
  get matrixTotalValuePostFix() {
    return this.matrix.totalsSuffix;
  },
  set matrixTotalValuePostFix(val) {
    this.matrix.totalsSuffix = val;
  },
  get matrixMaximumRowCount() {
    return this.matrix.maxRowCount;
  },
  set matrixMaximumRowCount(val) {
    this.matrix.maxRowCount = val;
  },
  get matrixMaxRowCountInCondition() {
    return this.matrix.maxRowCountInCondition;
  },
  set matrixMaxRowCountInCondition(val) {
    this.matrix.maxRowCountInCondition = val;
  },
  get matrixRenderRemoveAsIcon() {
    return this.matrix.renderRemoveAsIcon;
  },
  set matrixRenderRemoveAsIcon(val) {
    this.matrix.renderRemoveAsIcon = val;
  },
  //#endregion
  /**
   * An object with properties that apply to [Dynamic Panel](https://surveyjs.io/form-library/documentation/api-reference/dynamic-panel-model) questions.
   *
   * Nested properties:
   *
   * - `maxPanelCount`: `number`\
   * A maximum number of panels in Dynamic Panel. Default value: 100.\
   * You can specify this setting for an individual Dynamic Panel: [`maxPanelCount`](https://surveyjs.io/form-library/documentation/api-reference/dynamic-panel-model#maxPanelCount).
   *
   * - `maxPanelCountInCondition`: `number`\
   * A maximum number of Dynamic Panel panels included in the Condition drop-down menu in Survey Creator. This menu is used to configure conditional survey logic. Default value: 1.\
   * If you set this property to 0, the Condition menu does not include any panel questions. Users still can specify conditions that use panel questions but only with Manual Entry.
   */
  panel: {
    maxPanelCount: 100,
    maxPanelCountInCondition: 1
  },
  //#region panel section, Obsolete properties
  get panelDynamicMaxPanelCountInCondition() {
    return this.panel.maxPanelCountInCondition;
  },
  set panelDynamicMaxPanelCountInCondition(val) {
    this.panel.maxPanelCountInCondition = val;
  },
  get panelMaximumPanelCount() {
    return this.panel.maxPanelCount;
  },
  set panelMaximumPanelCount(val) {
    this.panel.maxPanelCount = val;
  },
  //#endregion
  /**
   * An object with properties that configure questions in read-only mode.
   *
   * Nested properties:
   *
   * - `commentRenderMode`: `"textarea"` (default) | `"div"`\
   * Specifies how to render the input field of [Comment](https://surveyjs.io/form-library/documentation/api-reference/comment-field-model) questions in [read-only](https://surveyjs.io/form-library/documentation/api-reference/comment-field-model#readOnly) mode: as a disabled `<textarea>` element or as a `<div>` element with a non-editable question value within it.
   *
   * - `textRenderMode`: `"input"` (default) | `"div"`\
   * Specifies how to render the input field of [Text](https://surveyjs.io/form-library/documentation/api-reference/text-entry-question-model) questions in [read-only](https://surveyjs.io/form-library/documentation/api-reference/text-entry-question-model#readOnly) mode: as a disabled `<input>` element or as a `<div>` element with a non-editable question value within it.
   */
  readOnly: {
    enableValidation: false,
    commentRenderMode: "textarea",
    textRenderMode: "input"
  },
  //#region readOnly section, Obsolete properties
  get readOnlyCommentRenderMode() {
    return this.readOnly.commentRenderMode;
  },
  set readOnlyCommentRenderMode(val) {
    this.readOnly.commentRenderMode = val;
  },
  get readOnlyTextRenderMode() {
    return this.readOnly.textRenderMode;
  },
  set readOnlyTextRenderMode(val) {
    this.readOnly.textRenderMode = val;
  },
  //#endregion
  /**
   * An object with properties that configure question numbering.
   *
   * Nested properties:
   *
   * - `includeQuestionsWithHiddenNumber`: `boolean`\
   * Specifies whether to number questions whose [`showNumber`](https://surveyjs.io/form-library/documentation/api-reference/question#showNumber) property is disabled. Default value: `false`.
   *
   * - `includeQuestionsWithHiddenTitle`: `boolean`\
   * Specifies whether to number questions whose [`titleLocation`](https://surveyjs.io/form-library/documentation/api-reference/question#titleLocation) property is set to `"hidden"`. Default value: `false`.
   */
  numbering: {
    includeQuestionsWithHiddenNumber: false,
    includeQuestionsWithHiddenTitle: false
  },
  //#region numbering section, Obsolete properties
  get setQuestionVisibleIndexForHiddenTitle() {
    return this.numbering.includeQuestionsWithHiddenTitle;
  },
  set setQuestionVisibleIndexForHiddenTitle(val) {
    this.numbering.includeQuestionsWithHiddenTitle = val;
  },
  get setQuestionVisibleIndexForHiddenNumber() {
    return this.numbering.includeQuestionsWithHiddenNumber;
  },
  set setQuestionVisibleIndexForHiddenNumber(val) {
    this.numbering.includeQuestionsWithHiddenNumber = val;
  },
  //#endregion
  /**
   * Specifies an action to perform when users press the Enter key within a survey.
   *
   * Possible values:
   *
   * - `"moveToNextEditor"` - Moves focus to the next editor.
   * - `"loseFocus"` - Removes focus from the current editor.
   * - `"default"` - Behaves as a standard `<input>` element.
   */
  enterKeyAction: "default",
  /**
   * An object that configures string comparison.
   *
   * Nested properties:
   *
   * - `trimStrings`: `boolean`\
   * Specifies whether to remove whitespace from both ends of a string before the comparison. Default value: `true`.
   *
   * - `caseSensitive`: `boolean`\
   * Specifies whether to differentiate between capital and lower-case letters. Default value: `false`.
   */
  comparator: {
    trimStrings: true,
    caseSensitive: false,
    normalizeTextCallback: (str, reason) => {
      return str;
    }
  },
  expressionDisableConversionChar: "#",
  get commentPrefix() {
    return settings.commentSuffix;
  },
  set commentPrefix(val) {
    settings.commentSuffix = val;
  },
  /**
   * A suffix added to the name of the property that stores comments.
   *
   * Default value: "-Comment"
   *
   * You can specify this setting for an individual survey: [`commentSuffix`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#commentSuffix).
   */
  commentSuffix: "-Comment",
  /**
   * A separator used in a shorthand notation that specifies a value and display text for an [`ItemValue`](https://surveyjs.io/form-library/documentation/api-reference/itemvalue) object: `"value|text"`.
   *
   * Default value: `"|"`
   * @see [settings.choicesSeparator](https://surveyjs.io/form-library/documentation/api-reference/settings#choicesSeparator)
   */
  itemValueSeparator: "|",
  /**
   * A maximum number of rate values in a [Rating](https://surveyjs.io/form-library/documentation/api-reference/rating-scale-question-model) question.
   *
   * Default value: 20
   */
  ratingMaximumRateValueCount: 20,
  /**
   * Specifies whether to close the drop-down menu of a [Multi-Select Dropdown (Tag Box)](https://surveyjs.io/form-library/examples/how-to-create-multiselect-tag-box/) question after a user selects a value.
   *
   * This setting applies to all Multi-Select Dropdown questions on a web page. You can use the [`closeOnSelect`](https://surveyjs.io/form-library/documentation/api-reference/dropdown-tag-box-model#closeOnSelect) property to specify the same setting for an individual Multi-Select Dropdown question.
   */
  tagboxCloseOnSelect: false,
  /**
   * A time interval in milliseconds between the last entered character and the beginning of search in [Single-](https://surveyjs.io/form-library/examples/create-dropdown-menu-in-javascript/) and [Multi-Select Dropdown](https://surveyjs.io/form-library/examples/how-to-create-multiselect-tag-box/) questions. Applies only to questions with the [`choicesLazyLoadEnabled`](https://surveyjs.io/form-library/documentation/api-reference/dropdown-menu-model#choicesLazyLoadEnabled) property set to `true`.
   *
   * Default value: 500
   *
   * [View Demo](https://surveyjs.io/form-library/examples/lazy-loading-dropdown/ (linkStyle))
   */
  dropdownSearchDelay: 500,
  /**
   * A function that activates a browser confirm dialog.
   *
   * Use the following code to execute this function:
   *
   * ```js
   * import { settings } from "survey-core";
   *
   * // `result` contains `true` if the action was confirmed or `false` otherwise
   * const result = settings.confirmActionFunc("Are you sure?");
   * ```
   *
   * You can redefine the `confirmActionFunc` function if you want to display a custom dialog window. Your function should return `true` if a user confirms an action or `false` otherwise.
   * @param message A message to be displayed in the confirm dialog window.
   */
  confirmActionFunc: function(message) {
    return confirm(message);
  },
  /**
   * A function that activates a proprietary SurveyJS confirm dialog.
   *
   * Use the following code to execute this function:
   *
   * ```js
   * import { settings } from "survey-core";
   *
   * settings.confirmActionAsync("Are you sure?", (confirmed) => {
   *   if (confirmed) {
   *     // ...
   *     // Proceed with the action
   *     // ...
   *   } else {
   *     // ...
   *     // Cancel the action
   *     // ...
   *   }
   * });
   * ```
   *
   * You can redefine the `confirmActionAsync` function if you want to display a custom dialog window. Your function should return `true` to be enabled; otherwise, a survey executes the [`confirmActionFunc`](#confirmActionFunc) function. Pass the dialog result as the `callback` parameter: `true` if a user confirms an action, `false` otherwise.
   * @param message A message to be displayed in the confirm dialog window.
   * @param callback A callback function that should be called with `true` if a user confirms an action or `false` otherwise.
   */
  confirmActionAsync: function(message, callback, options) {
    return showConfirmDialog(message, callback, options);
  },
  /**
   * A minimum width value for all survey elements.
   *
   * Default value: `"300px"`
   *
   * You can override this setting for individual elements: [`minWidth`](https://surveyjs.io/form-library/documentation/api-reference/surveyelement#minWidth).
   */
  minWidth: "300px",
  /**
   * A maximum width value for all survey elements.
   *
   * Default value: `"100%"`
   *
   * You can override this setting for individual elements: [`maxWidth`](https://surveyjs.io/form-library/documentation/api-reference/surveyelement#maxWidth).
   */
  maxWidth: "100%",
  /**
   * Specifies how many times surveys can re-evaluate expressions when a question value changes. This limit helps avoid recursions in expressions.
   *
   * Default value: 10
   */
  maxConditionRunCountOnValueChanged: 10,
  /**
   * An object that configures notifications.
   *
   * Nested properties:
   *
   * - `lifetime`: `number`\
   * Specifies a time period during which a notification is displayed; measured in milliseconds. Default value: 2000.
   */
  notifications: {
    lifetime: 2e3
  },
  /**
   * Specifies how many milliseconds a survey should wait before it automatically switches to the next page. Applies only when [auto-advance](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#autoAdvanceEnabled) is enabled.
   *
   * Default value: 300
   */
  autoAdvanceDelay: 300,
  /**
   * Specifies the direction in which to lay out Checkbox and Radio Button Group items. This setting affects the resulting UI when items are arranged in [more than one column](https://surveyjs.io/form-library/documentation/api-reference/checkbox-question-model#colCount).
   *
   * Possible values:
   *
   * - `"column"` (default) - Items fill the current column, then move on to the next column.
   * - `"row"` - Items fill the current row, then move on to the next row.
   */
  itemFlowDirection: "column",
  /**
   * @deprecated Use the [`itemFlowDirection`](https://surveyjs.io/form-library/documentation/api-reference/settings#itemFlowDirection) property instead.
   */
  get showItemsInOrder() {
    return settings.itemFlowDirection;
  },
  set showItemsInOrder(val) {
    settings.itemFlowDirection = val;
  },
  /**
   * A value to save in survey results when respondents select the "None" choice item.
   *
   * Default value: `"none"`
   */
  noneItemValue: "none",
  /**
   * A value to save in survey results when respondents select the "Refuse to answer" choice item.
   *
   * Default value: `"refused"`
   */
  refuseItemValue: "refused",
  /**
   * A value to save in survey results when respondents select the "Don't know" choice item.
   *
   * Default value: `"dontknow"`
   */
  dontKnowItemValue: "dontknow",
  /**
   * An object whose properties specify the order of the special choice items ("None", "Other", "Select All", "Refuse to answer", "Don't know") in select-based questions.
   *
   * Default value: `{ selectAllItem: [-1], noneItem: [1], otherItem: [2], dontKnowItem: [3], otherItem: [4] }`
   *
   * Use this object to reorder special choices. Each property accepts an array of integer numbers. Negative numbers place a special choice item above regular choice items, positive numbers place it below them. For instance, the code below specifies the following order of choices: None, Select All, regular choices, Other.
   *
   * ```js
   * import { settings } from "survey-core";
   *
   * settings.specialChoicesOrder.noneItem = [-2];
   * settings.specialChoicesOrder.selectAllItem = [-1];
   * settings.specialChoicesOrder.otherItem = [1];
   * ```
   *
   * If you want to duplicate a special choice item above and below other choices, add two numbers to the corresponding array:
   *
   * ```js
   * settings.specialChoicesOrder.selectAllItem = [-1, 3] // Displays Select All above and below other choices
   * ```
   */
  specialChoicesOrder: {
    selectAllItem: [-1],
    noneItem: [1],
    refuseItem: [2],
    dontKnowItem: [3],
    otherItem: [4]
  },
  /**
   * One or several characters used to separate choice options in a list.
   *
   * Default value: `", "`
   * @see [settings.itemValueSeparator](https://surveyjs.io/form-library/documentation/api-reference/settings#itemValueSeparator)
   */
  choicesSeparator: ", ",
  /**
   * A list of supported validators by question type.
   */
  supportedValidators: {
    question: ["expression"],
    comment: ["text", "regex"],
    text: ["numeric", "text", "regex", "email"],
    checkbox: ["answercount"],
    imagepicker: ["answercount"]
  },
  /**
   * Specifies a minimum date that users can enter into a [Text](https://surveyjs.io/form-library/documentation/api-reference/text-entry-question-model) question with [`inputType`](https://surveyjs.io/form-library/documentation/api-reference/text-entry-question-model#inputType) set to `"date"` or `"datetime-local"`. Set this property to a string with the folllowing format: `"yyyy-mm-dd"`.
   */
  minDate: "",
  /**
   * Specifies a maximum date that users can enter into a [Text](https://surveyjs.io/form-library/documentation/api-reference/text-entry-question-model) question with [`inputType`](https://surveyjs.io/form-library/documentation/api-reference/text-entry-question-model#inputType) set to `"date"` or `"datetime-local"`. Set this property to a string with the folllowing format: `"yyyy-mm-dd"`.
   */
  maxDate: "",
  showDialog: void 0,
  showDefaultItemsInCreator: true,
  /**
   * An object that specifies icon replacements. Object keys are built-in icon names. To use a custom icon, assign its name to the key of the icon you want to replace:
   *
   * ```js
   * import { settings } from "survey-core";
   *
   * settings.customIcons["icon-redo"] = "custom-redo-icon";
   * ```
   *
   * For more information about icons in SurveyJS, refer to the following help topic: [UI Icons](https://surveyjs.io/form-library/documentation/icons).
   */
  customIcons: {},
  /**
   * Specifies which part of a choice item responds to a drag gesture in Ranking questions.
   *
   * Possible values:
   *
   * - `"entireItem"` (default) - Users can use the entire choice item as a drag handle.
   * - `"icon"` - Users can only use the choice item icon as a drag handle.
   */
  rankingDragHandleArea: "entireItem",
  environment: defaultEnvironment,
  /**
   * Allows you to hide the maximum length indicator in text input questions.
   *
   * If you specify a question's [`maxLength`](https://surveyjs.io/form-library/documentation/api-reference/text-entry-question-model#maxLength) property or a survey's [`maxTextLength`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#maxTextLength) property, text input questions indicate the number of entered characters and the character limit. Assign `false` to the `settings.showMaxLengthIndicator` property if you want to hide this indicator.
   *
   * Default value: `true`
   */
  showMaxLengthIndicator: true,
  /**
   * Specifies whether to animate survey elements.
   *
   * Default value: `true`
  */
  animationEnabled: true,
  /**
   * An object that specifies HTML tags to use when rendering survey, page, panel, and question titles.
   *
   * Default value: `{ survey: "h3", page: "h4", panel: "h4", question: "h5" }`
   *
   * If you want to modify HTML tags for individual titles, handle `SurveyModel`'s [`onGetTitleTagName`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#onGetTitleTagName) event.
   */
  titleTags: {
    survey: "h3",
    page: "h4",
    panel: "h4",
    question: "h5"
  },
  questions: {
    inputTypes: ["color", "date", "datetime-local", "email", "month", "number", "password", "range", "tel", "text", "time", "url", "week"],
    dataList: ["", "name", "honorific-prefix", "given-name", "additional-name", "family-name", "honorific-suffix", "nickname", "organization-title", "username", "new-password", "current-password", "organization", "street-address", "address-line1", "address-line2", "address-line3", "address-level4", "address-level3", "address-level2", "address-level1", "country", "country-name", "postal-code", "cc-name", "cc-given-name", "cc-additional-name", "cc-family-name", "cc-number", "cc-exp", "cc-exp-month", "cc-exp-year", "cc-csc", "cc-type", "transaction-currency", "transaction-amount", "language", "bday", "bday-day", "bday-month", "bday-year", "sex", "url", "photo", "tel", "tel-country-code", "tel-national", "tel-area-code", "tel-local", "tel-local-prefix", "tel-local-suffix", "tel-extension", "email", "impp"]
  },
  legacyProgressBarView: false,
  /**
   * An object with properties that configure input masks.
   *
   * Nested properties:
   *
   * - `patternPlaceholderChar`: `string`\
   * A symbol used as a placeholder for characters to be entered in [pattern masks](https://surveyjs.io/form-library/documentation/api-reference/inputmaskpattern). Default value: `"_"`.
   *
   * - `patternEscapeChar`: `string`\
   * A symbol used to insert literal representations of special characters in [pattern masks](https://surveyjs.io/form-library/documentation/api-reference/inputmaskpattern). Default value: `"\\"`.
   *
   * - `patternDefinitions`: `<{ [key: string]: RegExp }>`\
   * An object that maps placeholder symbols to regular expressions in [pattern masks](https://surveyjs.io/form-library/documentation/api-reference/inputmaskpattern). Default value: `{ "9": /[0-9]/, "a": /[a-zA-Z]/, "#": /[a-zA-Z0-9]/ }`.
   */
  maskSettings: {
    patternPlaceholderChar: "_",
    patternEscapeChar: "\\",
    patternDefinitions: {
      "9": /[0-9]/,
      "a": /[a-zA-Z]/,
      "#": /[a-zA-Z0-9]/
    }
  },
  /**
   * Specifies whether to store date-time values in the following format: `"YYYY-MM-DDThh:mm:ss.sssZ"`. Applies only to form fields with [`inputType`](https://surveyjs.io/form-library/documentation/api-reference/text-entry-question-model#inputType) set to `"datetime-local"`.
   *
   * Default value: `false`
   *
   * If you enable this setting, date-time values are converted from local time to UTC when they are saved to the survey's [`data`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#data) object, while the question values remain in local time. Therefore, when you specify default values using a question's [`defaultValue`](https://surveyjs.io/form-library/documentation/api-reference/text-entry-question-model#defaultValue) property, you need to use local time, but if you specify them using the `data` object, use a UTC date-time value in the following format: `"YYYY-MM-DDThh:mm:ss.sssZ"`.
   *
   * ```js
   * const surveyJson = {
   *   "elements": [{
   *     "name": "datetime",
   *     "type": "text",
   *     "title": "Select a date and time",
   *     "inputType": "datetime-local",
   *     "defaultValue": "2024-07-16T12:15:00" // Local date-time value
   *   }]
   * }
   * ```
   *
   * ```js
   * import { Model } from "survey-core";
   * const surveyJson = { ... }
   * const survey = new Model(surveyJson);
   *
   * survey.data = {
   *   datetime: "2024-07-16T12:15:00.000Z" // UTC date-time value
   * }
   * ```
   */
  storeUtcDates: false,
  // @param reason "function-[functionname]", "question-[questionname]", "expression-operand"
  onDateCreated: (newDate, reason, val) => {
    return newDate;
  },
  /**
   * A function that allows you to define custom parsing rules for numbers represented as string values.
   *
   * The following code shows a template that you can use to implement the `parseNumber` function:
   *
   * ```js
   * import { settings } from "survey-core";
   *
   * settings.parseNumber = (stringValue, numericValue) => {
   *   if (typeof stringValue !== "string" || !stringValue)
   *     return numericValue;
   *   let parsedNumber = numericValue;
   *   // ...
   *   // Parsing the number according to custom parsing rules
   *   // ...
   *   return parsedNumber;
   * };
   * ```
   * @param stringValue A number represented as a string value.
   * @param numericValue A number parsed using a default parsing function. `NaN` if the original string is not a number.
   * @returns A number that results from parsing the string value.
   * @see [settings.serialization](https://surveyjs.io/form-library/documentation/api-reference/settings#serialization)
   */
  parseNumber: (stringValue, numericValue) => {
    return numericValue;
  }
};
var SurveyError = class {
  constructor(text = null, errorOwner = null) {
    this.text = text;
    this.errorOwner = errorOwner;
    this.visible = true;
    this.onUpdateErrorTextCallback = void 0;
  }
  equals(error) {
    if (!error || !error.getErrorType) return false;
    if (this.getErrorType() !== error.getErrorType()) return false;
    return this.text === error.text && this.visible === error.visible;
  }
  get locText() {
    if (!this.locTextValue) {
      this.locTextValue = new LocalizableString(this.errorOwner, true);
      this.locTextValue.storeDefaultText = true;
      this.locTextValue.text = this.getText();
    }
    return this.locTextValue;
  }
  getText() {
    var res = this.text;
    if (!res) res = this.getDefaultText();
    if (!!this.errorOwner) {
      res = this.errorOwner.getErrorCustomText(res, this);
    }
    return res;
  }
  getErrorType() {
    return "base";
  }
  getDefaultText() {
    return "";
  }
  getLocale() {
    return !!this.errorOwner ? this.errorOwner.getLocale() : "";
  }
  getLocalizationString(locStrName) {
    return getLocaleString(locStrName, this.getLocale());
  }
  updateText() {
    if (this.onUpdateErrorTextCallback) {
      this.onUpdateErrorTextCallback(this);
    }
    this.locText.text = this.getText();
  }
};
var AnswerRequiredError = class extends SurveyError {
  constructor(text = null, errorOwner = null) {
    super(text, errorOwner);
    this.text = text;
  }
  getErrorType() {
    return "required";
  }
  getDefaultText() {
    return this.getLocalizationString("requiredError");
  }
};
var OneAnswerRequiredError = class extends SurveyError {
  constructor(text = null, errorOwner = null) {
    super(text, errorOwner);
    this.text = text;
  }
  getErrorType() {
    return "requireoneanswer";
  }
  getDefaultText() {
    return this.getLocalizationString("requiredErrorInPanel");
  }
};
var RequreNumericError = class extends SurveyError {
  constructor(text = null, errorOwner = null) {
    super(text, errorOwner);
    this.text = text;
  }
  getErrorType() {
    return "requirenumeric";
  }
  getDefaultText() {
    return this.getLocalizationString("numericError");
  }
};
var ExceedSizeError = class extends SurveyError {
  constructor(maxSize, errorOwner = null) {
    super(null, errorOwner);
    this.maxSize = maxSize;
    this.locText.text = this.getText();
  }
  getErrorType() {
    return "exceedsize";
  }
  getDefaultText() {
    return this.getLocalizationString("exceedMaxSize")["format"](this.getTextSize());
  }
  getTextSize() {
    var sizes = ["Bytes", "KB", "MB", "GB", "TB"];
    var fixed = [0, 0, 2, 3, 3];
    if (this.maxSize === 0) {
      return "0 Byte";
    }
    var i = Math.floor(Math.log(this.maxSize) / Math.log(1024));
    var value = this.maxSize / Math.pow(1024, i);
    return value.toFixed(fixed[i]) + " " + sizes[i];
  }
};
var WebRequestError = class extends SurveyError {
  constructor(status, response, errorOwner = null) {
    super(null, errorOwner);
    this.status = status;
    this.response = response;
  }
  getErrorType() {
    return "webrequest";
  }
  getDefaultText() {
    const str = this.getLocalizationString("urlRequestError");
    return !!str ? str["format"](this.status, this.response) : "";
  }
};
var WebRequestEmptyError = class extends SurveyError {
  constructor(text, errorOwner = null) {
    super(text, errorOwner);
    this.text = text;
  }
  getErrorType() {
    return "webrequestempty";
  }
  getDefaultText() {
    return this.getLocalizationString("urlGetChoicesError");
  }
};
var OtherEmptyError = class extends SurveyError {
  constructor(text, errorOwner = null) {
    super(text, errorOwner);
    this.text = text;
  }
  getErrorType() {
    return "otherempty";
  }
  getDefaultText() {
    return this.getLocalizationString("otherRequiredError");
  }
};
var UploadingFileError = class extends SurveyError {
  constructor(text, errorOwner = null) {
    super(text, errorOwner);
    this.text = text;
  }
  getErrorType() {
    return "uploadingfile";
  }
  getDefaultText() {
    return this.getLocalizationString("uploadingFile");
  }
};
var RequiredInAllRowsError = class extends SurveyError {
  constructor(text, errorOwner = null) {
    super(text, errorOwner);
    this.text = text;
  }
  getErrorType() {
    return "requiredinallrowserror";
  }
  getDefaultText() {
    return this.getLocalizationString("requiredInAllRowsError");
  }
};
var EachRowUniqueError = class extends SurveyError {
  constructor(text, errorOwner = null) {
    super(text, errorOwner);
    this.text = text;
  }
  getErrorType() {
    return "eachrowuniqueeerror";
  }
  getDefaultText() {
    return this.getLocalizationString("eachRowUniqueError");
  }
};
var MinRowCountError = class extends SurveyError {
  constructor(minRowCount, errorOwner = null) {
    super(null, errorOwner);
    this.minRowCount = minRowCount;
  }
  getErrorType() {
    return "minrowcounterror";
  }
  getDefaultText() {
    return this.getLocalizationString("minRowCountError")["format"](this.minRowCount);
  }
};
var KeyDuplicationError = class extends SurveyError {
  constructor(text, errorOwner = null) {
    super(text, errorOwner);
    this.text = text;
  }
  getErrorType() {
    return "keyduplicationerror";
  }
  getDefaultText() {
    return this.getLocalizationString("keyDuplicationError");
  }
};
var CustomError = class extends SurveyError {
  constructor(text, errorOwner = null) {
    super(text, errorOwner);
    this.text = text;
  }
  getErrorType() {
    return "custom";
  }
};
var ValidatorResult = class {
  constructor(value, error = null) {
    this.value = value;
    this.error = error;
  }
};
var SurveyValidator = class extends Base {
  constructor() {
    super();
    this.createLocalizableString("text", this, true);
  }
  get isValidator() {
    return true;
  }
  getSurvey(live = false) {
    return !!this.errorOwner && !!this.errorOwner["getSurvey"] ? this.errorOwner.getSurvey() : null;
  }
  /**
   * An error message to display when a value fails validation.
   */
  get text() {
    return this.getLocalizableStringText("text");
  }
  set text(value) {
    this.setLocalizableStringText("text", value);
  }
  get isValidateAllValues() {
    return false;
  }
  get locText() {
    return this.getLocalizableString("text");
  }
  getErrorText(name) {
    if (this.text) return this.text;
    return this.getDefaultErrorText(name);
  }
  getDefaultErrorText(name) {
    return "";
  }
  validate(value, name = null, values = null, properties = null) {
    return null;
  }
  get isRunning() {
    return false;
  }
  get isAsync() {
    return false;
  }
  getLocale() {
    return !!this.errorOwner ? this.errorOwner.getLocale() : "";
  }
  getMarkdownHtml(text, name) {
    return !!this.errorOwner ? this.errorOwner.getMarkdownHtml(text, name) : void 0;
  }
  getRenderer(name) {
    return !!this.errorOwner ? this.errorOwner.getRenderer(name) : null;
  }
  getRendererContext(locStr) {
    return !!this.errorOwner ? this.errorOwner.getRendererContext(locStr) : locStr;
  }
  getProcessedText(text) {
    return !!this.errorOwner ? this.errorOwner.getProcessedText(text) : text;
  }
  createCustomError(name) {
    const err = new CustomError(this.getErrorText(name), this.errorOwner);
    err.onUpdateErrorTextCallback = (err2) => err2.text = this.getErrorText(name);
    return err;
  }
  toString() {
    var res = this.getType().replace("validator", "");
    if (!!this.text) {
      res += ", " + this.text;
    }
    return res;
  }
};
var ValidatorRunner = class {
  run(owner) {
    var res = [];
    var values = null;
    var properties = null;
    this.prepareAsyncValidators();
    var asyncResults = [];
    var validators = owner.getValidators();
    for (var i = 0; i < validators.length; i++) {
      var validator = validators[i];
      if (!values && validator.isValidateAllValues) {
        values = owner.getDataFilteredValues();
        properties = owner.getDataFilteredProperties();
      }
      if (validator.isAsync) {
        this.asyncValidators.push(validator);
        validator.onAsyncCompleted = (result) => {
          if (!!result && !!result.error) asyncResults.push(result.error);
          if (!this.onAsyncCompleted) return;
          for (var i2 = 0; i2 < this.asyncValidators.length; i2++) {
            if (this.asyncValidators[i2].isRunning) return;
          }
          this.onAsyncCompleted(asyncResults);
        };
      }
    }
    validators = owner.getValidators();
    for (var i = 0; i < validators.length; i++) {
      var validator = validators[i];
      var validatorResult = validator.validate(owner.validatedValue, owner.getValidatorTitle(), values, properties);
      if (!!validatorResult && !!validatorResult.error) {
        res.push(validatorResult.error);
      }
    }
    if (this.asyncValidators.length == 0 && !!this.onAsyncCompleted) this.onAsyncCompleted([]);
    return res;
  }
  prepareAsyncValidators() {
    if (!!this.asyncValidators) {
      for (var i = 0; i < this.asyncValidators.length; i++) {
        this.asyncValidators[i].onAsyncCompleted = null;
      }
    }
    this.asyncValidators = [];
  }
};
var NumericValidator = class extends SurveyValidator {
  constructor(minValue = null, maxValue = null) {
    super();
    this.minValue = minValue;
    this.maxValue = maxValue;
  }
  getType() {
    return "numericvalidator";
  }
  validate(value, name = null, values = null, properties = null) {
    if (this.isValueEmpty(value)) return null;
    if (!Helpers.isNumber(value)) {
      return new ValidatorResult(null, new RequreNumericError(this.text, this.errorOwner));
    }
    var result = new ValidatorResult(Helpers.getNumber(value));
    if (this.minValue !== null && this.minValue > result.value) {
      result.error = this.createCustomError(name);
      return result;
    }
    if (this.maxValue !== null && this.maxValue < result.value) {
      result.error = this.createCustomError(name);
      return result;
    }
    return typeof value === "number" ? null : result;
  }
  getDefaultErrorText(name) {
    var vName = name ? name : this.getLocalizationString("value");
    if (this.minValue !== null && this.maxValue !== null) {
      return this.getLocalizationFormatString("numericMinMax", vName, this.minValue, this.maxValue);
    } else {
      if (this.minValue !== null) {
        return this.getLocalizationFormatString("numericMin", vName, this.minValue);
      }
      return this.getLocalizationFormatString("numericMax", vName, this.maxValue);
    }
  }
  /**
   * A minimum allowed numeric value.
   *
   * [View Demo](https://surveyjs.io/form-library/examples/javascript-form-validation/ (linkStyle))
   */
  get minValue() {
    return this.getPropertyValue("minValue");
  }
  set minValue(val) {
    this.setPropertyValue("minValue", val);
  }
  /**
   * A maximum allowed numeric value.
   *
   * [View Demo](https://surveyjs.io/form-library/examples/javascript-form-validation/ (linkStyle))
   */
  get maxValue() {
    return this.getPropertyValue("maxValue");
  }
  set maxValue(val) {
    this.setPropertyValue("maxValue", val);
  }
};
var TextValidator = class extends SurveyValidator {
  constructor() {
    super();
  }
  getType() {
    return "textvalidator";
  }
  validate(value, name = null, values = null, properties = null) {
    if (this.isValueEmpty(value)) return null;
    if (!this.allowDigits) {
      var reg = /\d+$/;
      if (reg.test(value)) {
        return new ValidatorResult(null, this.createCustomError("textNoDigitsAllow"));
      }
    }
    if (this.minLength > 0 && value.length < this.minLength) {
      return new ValidatorResult(null, this.createCustomError(name));
    }
    if (this.maxLength > 0 && value.length > this.maxLength) {
      return new ValidatorResult(null, this.createCustomError(name));
    }
    return null;
  }
  getDefaultErrorText(name) {
    if (name === "textNoDigitsAllow") return this.getLocalizationString(name);
    if (this.minLength > 0 && this.maxLength > 0) return this.getLocalizationFormatString("textMinMaxLength", this.minLength, this.maxLength);
    if (this.minLength > 0) return this.getLocalizationFormatString("textMinLength", this.minLength);
    return this.getLocalizationFormatString("textMaxLength", this.maxLength);
  }
  /**
   * The minimum length of a text value measured in characters.
   *
   * Default value: 0
   *
   * [View Demo](https://surveyjs.io/form-library/examples/javascript-form-validation/ (linkStyle))
   */
  get minLength() {
    return this.getPropertyValue("minLength");
  }
  set minLength(val) {
    this.setPropertyValue("minLength", val);
  }
  /**
   * The maximum length of a text value measured in characters.
   *
   * Default value: 0 (unlimited)
   *
   * [View Demo](https://surveyjs.io/form-library/examples/javascript-form-validation/ (linkStyle))
   */
  get maxLength() {
    return this.getPropertyValue("maxLength");
  }
  set maxLength(val) {
    this.setPropertyValue("maxLength", val);
  }
  /**
   * Specifies whether a text value can include numerical digits.
   *
   * Default value: `true`
   */
  get allowDigits() {
    return this.getPropertyValue("allowDigits");
  }
  set allowDigits(val) {
    this.setPropertyValue("allowDigits", val);
  }
};
var AnswerCountValidator = class extends SurveyValidator {
  constructor(minCount = null, maxCount = null) {
    super();
    this.minCount = minCount;
    this.maxCount = maxCount;
  }
  getType() {
    return "answercountvalidator";
  }
  validate(value, name = null, values = null, properties = null) {
    if (value == null || value.constructor != Array) return null;
    var count2 = value.length;
    if (count2 == 0) return null;
    if (this.minCount && count2 < this.minCount) {
      return new ValidatorResult(null, this.createCustomError(this.getLocalizationFormatString("minSelectError", this.minCount)));
    }
    if (this.maxCount && count2 > this.maxCount) {
      return new ValidatorResult(null, this.createCustomError(this.getLocalizationFormatString("maxSelectError", this.maxCount)));
    }
    return null;
  }
  getDefaultErrorText(name) {
    return name;
  }
  /**
   * A minimum number of selected answers.
   *
   * [View Demo](https://surveyjs.io/form-library/examples/javascript-form-validation/ (linkStyle))
   */
  get minCount() {
    return this.getPropertyValue("minCount");
  }
  set minCount(val) {
    this.setPropertyValue("minCount", val);
  }
  /**
   * A maximum number of selected answers.
   *
   * [View Demo](https://surveyjs.io/form-library/examples/javascript-form-validation/ (linkStyle))
   */
  get maxCount() {
    return this.getPropertyValue("maxCount");
  }
  set maxCount(val) {
    this.setPropertyValue("maxCount", val);
  }
};
var RegexValidator = class extends SurveyValidator {
  constructor(regex = null) {
    super();
    this.regex = regex;
  }
  getType() {
    return "regexvalidator";
  }
  validate(value, name = null, values = null, properties = null) {
    if (!this.regex || this.isValueEmpty(value)) return null;
    var re = this.createRegExp();
    if (Array.isArray(value)) {
      for (var i = 0; i < value.length; i++) {
        var res = this.hasError(re, value[i], name);
        if (res) return res;
      }
    }
    return this.hasError(re, value, name);
  }
  hasError(re, value, name) {
    if (re.test(value)) return null;
    return new ValidatorResult(value, this.createCustomError(name));
  }
  /**
   * A regular expression used to validate values.
   *
   * [View Demo](https://surveyjs.io/form-library/examples/javascript-form-validation/ (linkStyle))
   */
  get regex() {
    return this.getPropertyValue("regex");
  }
  set regex(val) {
    this.setPropertyValue("regex", val);
  }
  /**
   * Specifies whether uppercase and lowercase letters must be treated as distinct or equivalent when validating values.
   *
   * Default value: `false` (uppercase and lowercase letters are treated as distinct)
   */
  get caseInsensitive() {
    return this.getPropertyValue("caseInsensitive");
  }
  set caseInsensitive(val) {
    this.setPropertyValue("caseInsensitive", val);
  }
  get insensitive() {
    return this.caseInsensitive;
  }
  set insensitive(val) {
    this.caseInsensitive = val;
  }
  createRegExp() {
    return new RegExp(this.regex, this.caseInsensitive ? "i" : "");
  }
};
var EmailValidator = class extends SurveyValidator {
  constructor() {
    super();
    this.re = /^(([^<>()\[\]\.,;:\s@\"]+(\.[^<>()\[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()=[\]\.,;:\s@\"]+\.)+[^<>()=[\]\.,;:\s@\"]{2,})$/i;
  }
  getType() {
    return "emailvalidator";
  }
  validate(value, name = null, values = null, properties = null) {
    if (!value) return null;
    if (this.re.test(value)) return null;
    return new ValidatorResult(value, this.createCustomError(name));
  }
  getDefaultErrorText(name) {
    return this.getLocalizationString("invalidEmail");
  }
};
var ExpressionValidator = class extends SurveyValidator {
  constructor(expression = null) {
    super();
    this.conditionRunner = null;
    this.isRunningValue = false;
    this.expression = expression;
  }
  getType() {
    return "expressionvalidator";
  }
  get isValidateAllValues() {
    return true;
  }
  get isAsync() {
    if (!this.ensureConditionRunner(false)) return false;
    return this.conditionRunner.isAsync;
  }
  get isRunning() {
    return this.isRunningValue;
  }
  validate(value, name = null, values = null, properties = null) {
    if (!this.expression) return null;
    if (!!this.conditionRunner) {
      this.conditionRunner.onRunComplete = null;
    }
    this.ensureConditionRunner(true);
    this.conditionRunner.onRunComplete = (res2) => {
      this.isRunningValue = false;
      if (!!this.onAsyncCompleted) {
        this.onAsyncCompleted(this.generateError(res2, value, name));
      }
    };
    this.isRunningValue = true;
    var res = this.conditionRunner.run(values, properties);
    if (this.conditionRunner.isAsync) return null;
    this.isRunningValue = false;
    return this.generateError(res, value, name);
  }
  generateError(res, value, name) {
    if (!res) {
      return new ValidatorResult(value, this.createCustomError(name));
    }
    return null;
  }
  getDefaultErrorText(name) {
    return this.getLocalizationFormatString("invalidExpression", this.expression);
  }
  ensureConditionRunner(reNew) {
    if (!this.expression) return false;
    if (reNew || !this.conditionRunner) {
      this.conditionRunner = new ConditionRunner(this.expression);
    } else {
      this.conditionRunner.expression = this.expression;
    }
    return true;
  }
  /**
   * A Boolean [expression](https://surveyjs.io/form-library/documentation/design-survey/conditional-logic#expressions). If it evaluates to `false`, validation fails.
   *
   * [View Demo](https://surveyjs.io/form-library/examples/javascript-form-validation/ (linkStyle))
   */
  get expression() {
    return this.getPropertyValue("expression");
  }
  set expression(val) {
    this.setPropertyValue("expression", val);
  }
};
Serializer.addClass("surveyvalidator", [{
  name: "text",
  serializationProperty: "locText"
}]);
Serializer.addClass("numericvalidator", ["minValue:number", "maxValue:number"], function() {
  return new NumericValidator();
}, "surveyvalidator");
Serializer.addClass("textvalidator", [{
  name: "minLength:number",
  default: 0
}, {
  name: "maxLength:number",
  default: 0
}, {
  name: "allowDigits:boolean",
  default: true
}], function() {
  return new TextValidator();
}, "surveyvalidator");
Serializer.addClass("answercountvalidator", ["minCount:number", "maxCount:number"], function() {
  return new AnswerCountValidator();
}, "surveyvalidator");
Serializer.addClass("regexvalidator", ["regex", {
  name: "caseInsensitive:boolean",
  alternativeName: "insensitive"
}], function() {
  return new RegexValidator();
}, "surveyvalidator");
Serializer.addClass("emailvalidator", [], function() {
  return new EmailValidator();
}, "surveyvalidator");
Serializer.addClass("expressionvalidator", ["expression:condition"], function() {
  return new ExpressionValidator();
}, "surveyvalidator");
var QuestionCustomWidget = class {
  constructor(name, widgetJson) {
    this.name = name;
    this.widgetJson = widgetJson;
    this.htmlTemplate = widgetJson.htmlTemplate ? widgetJson.htmlTemplate : "";
  }
  afterRender(question, el) {
    if (!this.widgetJson.afterRender) return;
    question.localeChangedCallback = () => {
      if (this.widgetJson.willUnmount) {
        this.widgetJson.willUnmount(question, el);
      }
      this.widgetJson.afterRender(question, el);
    };
    this.widgetJson.afterRender(question, el);
  }
  willUnmount(question, el) {
    if (this.widgetJson.willUnmount) this.widgetJson.willUnmount(question, el);
  }
  getDisplayValue(question, value = void 0) {
    if (this.widgetJson.getDisplayValue) return this.widgetJson.getDisplayValue(question, value);
    return null;
  }
  validate(question) {
    if (this.widgetJson.validate) return this.widgetJson.validate(question);
    return void 0;
  }
  isFit(question) {
    if (this.isLibraryLoaded() && this.widgetJson.isFit) return this.widgetJson.isFit(question);
    return false;
  }
  get canShowInToolbox() {
    if (this.widgetJson.showInToolbox === false) return false;
    if (CustomWidgetCollection.Instance.getActivatedBy(this.name) != "customtype") return false;
    return !this.widgetJson.widgetIsLoaded || this.widgetJson.widgetIsLoaded();
  }
  get showInToolbox() {
    return this.widgetJson.showInToolbox !== false;
  }
  set showInToolbox(val) {
    this.widgetJson.showInToolbox = val;
  }
  init() {
    if (this.widgetJson.init) {
      this.widgetJson.init();
    }
  }
  activatedByChanged(activatedBy) {
    if (this.isLibraryLoaded() && this.widgetJson.activatedByChanged) {
      this.widgetJson.activatedByChanged(activatedBy);
    }
  }
  isLibraryLoaded() {
    if (this.widgetJson.widgetIsLoaded) return this.widgetJson.widgetIsLoaded() == true;
    return true;
  }
  get isDefaultRender() {
    return this.widgetJson.isDefaultRender;
  }
  get pdfQuestionType() {
    return this.widgetJson.pdfQuestionType;
  }
  get pdfRender() {
    return this.widgetJson.pdfRender;
  }
};
var CustomWidgetCollection = class {
  constructor() {
    this.widgetsValues = [];
    this.widgetsActivatedBy = {};
    this.onCustomWidgetAdded = new Event2();
  }
  get widgets() {
    return this.widgetsValues;
  }
  add(widgetJson, activatedBy = "property") {
    this.addCustomWidget(widgetJson, activatedBy);
  }
  addCustomWidget(widgetJson, activatedBy = "property") {
    var name = widgetJson.name;
    if (!name) {
      name = "widget_" + this.widgets.length + 1;
    }
    var customWidget = new QuestionCustomWidget(name, widgetJson);
    this.widgetsValues.push(customWidget);
    customWidget.init();
    this.widgetsActivatedBy[name] = activatedBy;
    customWidget.activatedByChanged(activatedBy);
    this.onCustomWidgetAdded.fire(customWidget, null);
    return customWidget;
  }
  /**
   * Returns the way the custom wiget is activated. It can be activated by a property ("property"), question type ("type") or by new/custom question type ("customtype").
   * @param widgetName the custom widget name
   * @see setActivatedBy
   */
  getActivatedBy(widgetName) {
    var res = this.widgetsActivatedBy[widgetName];
    return res ? res : "property";
  }
  /**
   * Sets the way the custom wiget is activated. The activation types are: property ("property"), question type ("type") or new/custom question type ("customtype"). A custom wiget may support all or only some of this activation types.
   * @param widgetName
   * @param activatedBy there are three possible variants: "property", "type" and "customtype"
   */
  setActivatedBy(widgetName, activatedBy) {
    if (!widgetName || !activatedBy) return;
    var widget = this.getCustomWidgetByName(widgetName);
    if (!widget) return;
    this.widgetsActivatedBy[widgetName] = activatedBy;
    widget.activatedByChanged(activatedBy);
  }
  clear() {
    this.widgetsValues = [];
  }
  getCustomWidgetByName(name) {
    for (var i = 0; i < this.widgets.length; i++) {
      if (this.widgets[i].name == name) return this.widgets[i];
    }
    return null;
  }
  getCustomWidget(question) {
    for (var i = 0; i < this.widgetsValues.length; i++) {
      if (this.widgetsValues[i].isFit(question)) return this.widgetsValues[i];
    }
    return null;
  }
};
CustomWidgetCollection.Instance = new CustomWidgetCollection();
var RendererFactory = class {
  constructor() {
    this.renderersHash = {};
    this.defaultHash = {};
  }
  unregisterRenderer(questionType2, rendererAs) {
    delete this.renderersHash[questionType2][rendererAs];
    if (this.defaultHash[questionType2] === rendererAs) {
      delete this.defaultHash[questionType2];
    }
  }
  registerRenderer(questionType2, renderAs, renderer, useAsDefault = false) {
    if (!this.renderersHash[questionType2]) {
      this.renderersHash[questionType2] = {};
    }
    this.renderersHash[questionType2][renderAs] = renderer;
    if (useAsDefault) {
      this.defaultHash[questionType2] = renderAs;
    }
  }
  getRenderer(questionType2, renderAs) {
    const qHash = this.renderersHash[questionType2];
    if (!!qHash) {
      if (!!renderAs && qHash[renderAs]) return qHash[renderAs];
      const dVal = this.defaultHash[questionType2];
      if (!!dVal && qHash[dVal]) return qHash[dVal];
    }
    return "default";
  }
  getRendererByQuestion(question) {
    return this.getRenderer(question.getType(), question.renderAs);
  }
  clear() {
    this.renderersHash = {};
  }
};
RendererFactory.Instance = new RendererFactory();
var TextAreaModel = class {
  updateElement() {
    if (this.element && this.autoGrow) {
      setTimeout(() => increaseHeightByContent(this.element), 1);
    }
  }
  constructor(options) {
    this.options = options;
    this.onPropertyChangedCallback = () => {
      if (this.element) {
        this.element.value = this.getTextValue();
        this.updateElement();
      }
    };
    this.question.registerFunctionOnPropertyValueChanged(this.options.propertyName, this.onPropertyChangedCallback, "__textarea");
  }
  setElement(element) {
    if (!!element) {
      this.element = element;
      this.updateElement();
    }
  }
  resetElement() {
    this.element = void 0;
  }
  getTextValue() {
    if (!!this.options.getTextValue) return this.options.getTextValue() || "";
    return "";
  }
  onTextAreaChange(event) {
    if (!!this.options.onTextAreaChange) this.options.onTextAreaChange(event);
  }
  onTextAreaInput(event) {
    if (!!this.options.onTextAreaInput) this.options.onTextAreaInput(event);
    if (this.element && this.autoGrow) {
      increaseHeightByContent(this.element);
    }
  }
  onTextAreaKeyDown(event) {
    if (!!this.options.onTextAreaKeyDown) this.options.onTextAreaKeyDown(event);
  }
  onTextAreaBlur(event) {
    this.onTextAreaChange(event);
    if (!!this.options.onTextAreaBlur) this.options.onTextAreaBlur(event);
  }
  onTextAreaFocus(event) {
    if (!!this.options.onTextAreaFocus) this.options.onTextAreaFocus(event);
  }
  get question() {
    return this.options.question;
  }
  get id() {
    return this.options.id();
  }
  get placeholder() {
    return this.options.placeholder();
  }
  get className() {
    return this.options.className();
  }
  get maxLength() {
    if (this.options.maxLength) return this.options.maxLength();
  }
  get autoGrow() {
    if (this.options.autoGrow) return this.options.autoGrow();
  }
  get rows() {
    if (this.options.rows) return this.options.rows();
  }
  get cols() {
    if (this.options.cols) return this.options.cols();
  }
  get isDisabledAttr() {
    return this.options.isDisabledAttr();
  }
  get isReadOnlyAttr() {
    if (this.options.isReadOnlyAttr) return this.options.isReadOnlyAttr();
  }
  get ariaRequired() {
    if (this.options.ariaRequired) return this.options.ariaRequired();
  }
  get ariaLabel() {
    if (this.options.ariaLabel) return this.options.ariaLabel();
  }
  get ariaInvalid() {
    if (this.options.ariaInvalid) return this.options.ariaInvalid();
  }
  get ariaLabelledBy() {
    if (this.options.ariaLabelledBy) return this.options.ariaLabelledBy();
  }
  get ariaDescribedBy() {
    if (this.options.ariaDescribedBy) return this.options.ariaDescribedBy();
  }
  get ariaErrormessage() {
    if (this.options.ariaErrormessage) return this.options.ariaErrormessage();
  }
  dispose() {
    if (this.question) {
      this.question.unRegisterFunctionOnPropertyValueChanged(this.options.propertyName, "__textarea");
    }
    this.resetElement();
  }
};
var TriggerExpressionInfo = class {
  constructor(name, canRun, doComplete) {
    this.name = name;
    this.canRun = canRun;
    this.doComplete = doComplete;
    this.getSecondRunner = () => void 0;
  }
};
var Question = class _Question extends SurveyElement {
  static getQuestionId() {
    return "sq_" + _Question.questionCounter++;
  }
  isReadOnlyRenderDiv() {
    return this.isReadOnly && settings.readOnly.commentRenderMode === "div";
  }
  allowMobileInDesignMode() {
    return false;
  }
  updateIsMobileFromSurvey() {
    this.setIsMobile(this.survey._isMobile);
  }
  setIsMobile(val) {
    const newVal = val && (this.allowMobileInDesignMode() || !this.isDesignMode);
    this.isMobile = newVal;
  }
  getIsMobile() {
    return this._isMobile;
  }
  get isMobile() {
    return this.getIsMobile();
  }
  set isMobile(val) {
    this._isMobile = val;
  }
  themeChanged(theme) {
  }
  get _isMobile() {
    return this.getPropertyValue("_isMobile", false);
  }
  set _isMobile(val) {
    this.setPropertyValue("_isMobile", val);
  }
  get forceIsInputReadOnly() {
    return this.getPropertyValue("forceIsInputReadOnly");
  }
  set forceIsInputReadOnly(val) {
    this.setPropertyValue("forceIsInputReadOnly", val);
  }
  get ariaExpanded() {
    return this.getPropertyValue("ariaExpanded");
  }
  set ariaExpanded(val) {
    this.setPropertyValue("ariaExpanded", val);
  }
  constructor(name) {
    super(name);
    this.customWidgetData = {
      isNeedRender: true
    };
    this.hasCssErrorCallback = () => false;
    this.isReadyValue = true;
    this.dependedQuestions = [];
    this.onReadyChanged = this.addEvent();
    this.triggersInfo = [];
    this.isRunningValidatorsValue = false;
    this.isValueChangedInSurvey = false;
    this.allowNotifyValueChanged = true;
    this.setPropertyValueDirectly("id", _Question.getQuestionId());
    this.onCreating();
    this.createNewArray("validators", (validator) => {
      validator.errorOwner = this;
    });
    this.addExpressionProperty("visibleIf", (obj, res) => {
      this.visible = res === true;
    });
    this.addExpressionProperty("enableIf", (obj, res) => {
      this.readOnly = res === false;
    });
    this.addExpressionProperty("requiredIf", (obj, res) => {
      this.isRequired = res === true;
    });
    this.createLocalizableString("commentText", this, true, "otherItemText");
    this.createLocalizableString("requiredErrorText", this);
    this.createLocalizableString("commentPlaceholder", this);
    this.createLocalizableString("defaultDisplayValue", this);
    this.addTriggerInfo("resetValueIf", () => !this.isEmpty(), () => {
      this.startSetValueOnExpression();
      this.clearValue();
      this.updateValueWithDefaults();
      this.finishSetValueOnExpression();
    });
    const setValueIfInfo = this.addTriggerInfo("setValueIf", () => true, () => this.runSetValueExpression());
    setValueIfInfo.getSecondRunner = () => this.getSetValueExpressionRunner();
    this.registerPropertyChangedHandlers(["width"], () => {
      this.updateQuestionCss();
      if (!!this.parent) {
        this.parent.elementWidthChanged(this);
      }
    });
    this.registerPropertyChangedHandlers(["isRequired"], () => {
      if (!this.isRequired && this.errors.length > 0) {
        this.validate();
      }
      this.locTitle.strChanged();
      this.clearCssClasses();
    });
    this.registerPropertyChangedHandlers(["indent", "rightIndent"], () => {
      this.resetIndents();
    });
    this.registerPropertyChangedHandlers(["showCommentArea", "showOtherItem"], () => {
      this.initCommentFromSurvey();
    });
    this.registerPropertyChangedHandlers(["commentPlaceholder"], () => {
      this.resetRenderedCommentPlaceholder();
    });
    this.registerFunctionOnPropertiesValueChanged(["no", "readOnly", "hasVisibleErrors", "containsErrors"], () => {
      this.updateQuestionCss();
    });
    this.registerPropertyChangedHandlers(["_isMobile"], () => {
      this.onMobileChanged();
    });
    this.registerPropertyChangedHandlers(["colSpan"], () => {
      var _a;
      (_a = this.parent) === null || _a === void 0 ? void 0 : _a.updateColumns();
    });
  }
  getDefaultTitle() {
    return this.name;
  }
  createLocTitleProperty() {
    const locTitleValue = super.createLocTitleProperty();
    locTitleValue.storeDefaultText = true;
    locTitleValue.onGetTextCallback = (text, nonProcessedText) => {
      if (!text && !nonProcessedText) {
        text = this.getDefaultTitle();
      }
      if (!this.survey) return text;
      return this.survey.getUpdatedQuestionTitle(this, text);
    };
    this.locProcessedTitle = new LocalizableString(this, true);
    this.locProcessedTitle.sharedData = locTitleValue;
    return locTitleValue;
  }
  get commentTextAreaModel() {
    if (!this.commentTextAreaModelValue) {
      this.commentTextAreaModelValue = new TextAreaModel(this.getCommentTextAreaOptions());
    }
    return this.commentTextAreaModelValue;
  }
  getCommentTextAreaOptions() {
    const options = {
      question: this,
      id: () => this.commentId,
      propertyName: "comment",
      className: () => this.cssClasses.comment,
      placeholder: () => this.renderedCommentPlaceholder,
      isDisabledAttr: () => this.isInputReadOnly || false,
      rows: () => this.commentAreaRows,
      autoGrow: () => this.autoGrowComment,
      maxLength: () => this.getOthersMaxLength(),
      ariaRequired: () => this.a11y_input_ariaRequired,
      ariaLabel: () => this.a11y_input_ariaLabel,
      getTextValue: () => {
        return this.comment;
      },
      onTextAreaChange: (e) => {
        this.onCommentChange(e);
      },
      onTextAreaInput: (e) => {
        this.onCommentInput(e);
      }
    };
    return options;
  }
  getSurvey(live = false) {
    if (live) {
      return !!this.parent ? this.parent.getSurvey(live) : null;
    }
    if (!!this.onGetSurvey) return this.onGetSurvey();
    return super.getSurvey();
  }
  getValueName() {
    if (!!this.valueName) return this.valueName.toString();
    return this.name;
  }
  /**
   * Specifies an object property that should store the question value.
   *
   * Refer to the [Merge Question Values](https://surveyjs.io/form-library/documentation/design-survey-merge-question-values) help topic for more information.
   */
  get valueName() {
    return this.getPropertyValue("valueName", "");
  }
  set valueName(val) {
    var oldValueName = this.getValueName();
    this.setPropertyValue("valueName", val);
    this.onValueNameChanged(oldValueName);
  }
  onValueNameChanged(oldValue) {
    if (!this.survey) return;
    this.survey.questionRenamed(this, this.name, !!oldValue ? oldValue : this.name);
    this.initDataFromSurvey();
  }
  onNameChanged(oldValue) {
    this.locTitle.strChanged();
    if (!this.survey) return;
    this.survey.questionRenamed(this, oldValue, this.valueName ? this.valueName : oldValue);
  }
  get isReady() {
    return this.isReadyValue;
  }
  onAsyncRunningChanged() {
    this.updateIsReady();
  }
  updateIsReady() {
    let res = this.getIsQuestionReady();
    if (res) {
      const questions = this.getIsReadyDependsOn();
      for (let i = 0; i < questions.length; i++) {
        if (!questions[i].getIsQuestionReady()) {
          res = false;
          break;
        }
      }
    }
    this.setIsReady(res);
  }
  getIsQuestionReady() {
    return !this.isAsyncExpressionRunning && this.getAreNestedQuestionsReady();
  }
  getAreNestedQuestionsReady() {
    const questions = this.getIsReadyNestedQuestions();
    if (!Array.isArray(questions)) return true;
    for (let i = 0; i < questions.length; i++) {
      if (!questions[i].isReady) return false;
    }
    return true;
  }
  getIsReadyNestedQuestions() {
    return this.getNestedQuestions();
  }
  setIsReady(val) {
    const oldIsReady = this.isReadyValue;
    this.isReadyValue = val;
    if (oldIsReady != val) {
      this.getIsReadyDependends().forEach((q) => q.updateIsReady());
      this.onReadyChanged.fire(this, {
        question: this,
        isReady: val,
        oldIsReady
      });
    }
  }
  getIsReadyDependsOn() {
    return this.getIsReadyDependendCore(true);
  }
  getIsReadyDependends() {
    return this.getIsReadyDependendCore(false);
  }
  getIsReadyDependendCore(isDependOn) {
    if (!this.survey) return [];
    const questions = this.survey.questionsByValueName(this.getValueName());
    const res = new Array();
    questions.forEach((q) => {
      if (q !== this) res.push(q);
    });
    if (!isDependOn) {
      if (this.parentQuestion) {
        res.push(this.parentQuestion);
      }
      if (this.dependedQuestions.length > 0) {
        this.dependedQuestions.forEach((q) => res.push(q));
      }
    }
    return res;
  }
  choicesLoaded() {
  }
  /**
   * Returns a page to which the question belongs and allows you to move this question to a different page.
   */
  get page() {
    if (!!this.parentQuestion) return this.parentQuestion.page;
    return this.getPage(this.parent);
  }
  set page(val) {
    this.setPage(this.parent, val);
  }
  getPanel() {
    return null;
  }
  delete(doDispose = true) {
    this.removeFromParent();
    if (doDispose) {
      this.dispose();
    } else {
      this.resetDependedQuestions();
    }
  }
  removeFromParent() {
    if (!!this.parent) {
      this.removeSelfFromList(this.parent.elements);
    }
  }
  addDependedQuestion(question) {
    if (!question || this.dependedQuestions.indexOf(question) > -1) return;
    this.dependedQuestions.push(question);
  }
  removeDependedQuestion(question) {
    if (!question) return;
    var index = this.dependedQuestions.indexOf(question);
    if (index > -1) {
      this.dependedQuestions.splice(index, 1);
    }
  }
  updateDependedQuestions() {
    for (var i = 0; i < this.dependedQuestions.length; i++) {
      this.dependedQuestions[i].updateDependedQuestion();
    }
  }
  updateDependedQuestion() {
  }
  resetDependedQuestion() {
  }
  get isFlowLayout() {
    return this.getLayoutType() === "flow";
  }
  getLayoutType() {
    if (!!this.parent) return this.parent.getChildrenLayoutType();
    return "row";
  }
  isLayoutTypeSupported(layoutType) {
    return layoutType !== "flow";
  }
  /**
   * Gets or sets question visibility.
   *
   * If you want to display or hide a question based on a condition, specify the [`visibleIf`](https://surveyjs.io/form-library/documentation/question#visibleIf) property. Refer to the following help topic for information: [Conditional Visibility](https://surveyjs.io/form-library/documentation/design-survey-conditional-logic#conditional-visibility).
   * @see isVisible
   * @see visibleIf
   */
  get visible() {
    return this.getPropertyValue("visible", true);
  }
  set visible(val) {
    if (val == this.visible) return;
    this.setPropertyValue("visible", val);
    this.onVisibleChanged();
    this.notifySurveyVisibilityChanged();
  }
  onVisibleChanged() {
    this.updateIsVisibleProp();
    if (!this.isVisible && this.errors && this.errors.length > 0) {
      this.errors = [];
    }
  }
  notifyStateChanged(prevState) {
    super.notifyStateChanged(prevState);
    if (this.isCollapsed) {
      this.onHidingContent();
    }
  }
  updateElementVisibility() {
    this.updateIsVisibleProp();
  }
  updateIsVisibleProp() {
    const prev = this.getPropertyValue("isVisible");
    const val = this.isVisible;
    if (prev !== val) {
      this.setPropertyValue("isVisible", val);
      if (!val) {
        this.onHidingContent();
      }
    }
    if (val !== this.visible && this.areInvisibleElementsShowing) {
      this.updateQuestionCss(true);
    }
  }
  /**
   * Specifies whether to use display names for question values in placeholders.
   *
   * Default value: `true`
   *
   * This property applies to questions whose values are defined as objects with the `value` and `text` properties (for example, [choice items](https://surveyjs.io/form-library/documentation/questionradiogroupmodel#choices) in Radiogroup, Checkbox, and Dropdown questions).
   *
   * You can use question values as placeholders in the following places:
   *
   * - Survey element titles and descriptions
   * - The [`html`](https://surveyjs.io/form-library/documentation/questionhtmlmodel#html) property of the [HTML](https://surveyjs.io/form-library/documentation/questionhtmlmodel) question
   *
   * To use a question value as a placeholder, specify the question `name` in curly brackets: `{questionName}`. Refer to the following help topic for more information: [Dynamic Texts - Question Values](https://surveyjs.io/form-library/documentation/design-survey-conditional-logic#question-values).
   */
  get useDisplayValuesInDynamicTexts() {
    return this.getPropertyValue("useDisplayValuesInDynamicTexts");
  }
  set useDisplayValuesInDynamicTexts(val) {
    this.setPropertyValue("useDisplayValuesInDynamicTexts", val);
  }
  getUseDisplayValuesInDynamicTexts() {
    return this.useDisplayValuesInDynamicTexts;
  }
  /**
   * A Boolean expression. If it evaluates to `false`, this question becomes hidden.
   *
   * A survey parses and runs all expressions on startup. If any values used in the expression change, the survey re-evaluates it.
   *
   * Refer to the following help topic for more information: [Conditional Visibility](https://surveyjs.io/form-library/documentation/design-survey-conditional-logic#conditional-visibility).
   * @see visible
   * @see isVisible
   */
  get visibleIf() {
    return this.getPropertyValue("visibleIf", "");
  }
  set visibleIf(val) {
    this.setPropertyValue("visibleIf", val);
  }
  /**
   * Returns `true` if the question is visible or the survey is currently in design mode.
   *
   * If you want to display or hide a question based on a condition, specify the [`visibleIf`](https://surveyjs.io/form-library/documentation/question#visibleIf) property. Refer to the following help topic for information: [Conditional Visibility](https://surveyjs.io/form-library/documentation/design-survey-conditional-logic#conditional-visibility).
   * @see visibleIf
   * @see visible
   * @see isParentVisible
   */
  get isVisible() {
    if (this.survey && this.survey.areEmptyElementsHidden && this.isEmpty()) return false;
    if (this.areInvisibleElementsShowing) return true;
    return this.isVisibleCore();
  }
  get isVisibleInSurvey() {
    return this.isVisible && this.isParentVisible;
  }
  isVisibleCore() {
    return this.visible;
  }
  /**
   * Returns the visible index of the question in the survey. It can be from 0 to all visible questions count - 1
   * The visibleIndex is -1 if the title is 'hidden' or showNumber is false
   * @see titleLocation
   * @see showNumber
   */
  get visibleIndex() {
    return this.getPropertyValue("visibleIndex", -1);
  }
  onHidingContent() {
  }
  /**
   * Specifies whether to show a number for this question. Setting this property to `false` hides the question number from the title and excludes the question from numbering.
   *
   * Default value: `false` (inherited from the `SurveyModel`'s [`showQuestionNumbers`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#showQuestionNumbers) property)
   * @see no
   */
  get showNumber() {
    return this.getPropertyValue("showNumber");
  }
  set showNumber(val) {
    this.setPropertyValue("showNumber", val);
    this.notifySurveyVisibilityChanged();
  }
  /**
   * @deprecated Use the [`showNumber`](https://surveyjs.io/form-library/documentation/api-reference/question#showNumber) property instead.
   */
  get hideNumber() {
    return !this.showNumber;
  }
  set hideNumber(val) {
    this.showNumber = !val;
  }
  /**
   * Returns `true` if the question can display its title to the left of the input field.
   * @see titleLocation
   * @see getTitleLocation
   * @see hasTitle
   */
  get isAllowTitleLeft() {
    return true;
  }
  /**
   * Returns the question type.
   * Possible values:
   * - [*"boolean"*](https://surveyjs.io/Documentation/Library?id=questionbooleanmodel)
   * - [*"checkbox"*](https://surveyjs.io/Documentation/Library?id=questioncheckboxmodel)
   * - [*"comment"*](https://surveyjs.io/Documentation/Library?id=questioncommentmodel)
   * - [*"dropdown"*](https://surveyjs.io/Documentation/Library?id=questiondropdownmodel)
   * - [*"tagbox"*](https://surveyjs.io/form-library/documentation/questiontagboxmodel)
   * - [*"expression"*](https://surveyjs.io/Documentation/Library?id=questionexpressionmodel)
   * - [*"file"*](https://surveyjs.io/Documentation/Library?id=questionfilemodel)
   * - [*"html"*](https://surveyjs.io/Documentation/Library?id=questionhtmlmodel)
   * - [*"image"*](https://surveyjs.io/Documentation/Library?id=questionimagemodel)
   * - [*"imagepicker"*](https://surveyjs.io/Documentation/Library?id=questionimagepickermodel)
   * - [*"matrix"*](https://surveyjs.io/Documentation/Library?id=questionmatrixmodel)
   * - [*"matrixdropdown"*](https://surveyjs.io/Documentation/Library?id=questionmatrixdropdownmodel)
   * - [*"matrixdynamic"*](https://surveyjs.io/Documentation/Library?id=questionmatrixdynamicmodel)
   * - [*"multipletext"*](https://surveyjs.io/Documentation/Library?id=questionmultipletextmodel)
   * - [*"panel"*](https://surveyjs.io/Documentation/Library?id=panelmodel)
   * - [*"paneldynamic"*](https://surveyjs.io/Documentation/Library?id=questionpaneldynamicmodel)
   * - [*"radiogroup"*](https://surveyjs.io/Documentation/Library?id=questionradiogroupmodel)
   * - [*"rating"*](https://surveyjs.io/Documentation/Library?id=questionratingmodel)
   * - [*"ranking"*](https://surveyjs.io/Documentation/Library?id=questionrankingmodel)
   * - [*"signaturepad"*](https://surveyjs.io/Documentation/Library?id=questionsignaturepadmodel)
   * - [*"text"*](https://surveyjs.io/Documentation/Library?id=questiontextmodel)
   */
  getType() {
    return "question";
  }
  get isQuestion() {
    return true;
  }
  moveTo(container, insertBefore = null) {
    return this.moveToBase(this.parent, container, insertBefore);
  }
  getProgressInfo() {
    if (!this.hasInput) return super.getProgressInfo();
    return {
      questionCount: 1,
      answeredQuestionCount: !this.isEmpty() ? 1 : 0,
      requiredQuestionCount: this.isRequired ? 1 : 0,
      requiredAnsweredQuestionCount: !this.isEmpty() && this.isRequired ? 1 : 0
    };
  }
  ensureSetValueExpressionRunner() {
    if (!this.setValueExpressionRunner) {
      this.setValueExpressionRunner = new ExpressionRunner(this.setValueExpression);
      this.setValueExpressionRunner.onRunComplete = (res) => {
        this.runExpressionSetValue(res);
      };
    } else {
      this.setValueExpressionRunner.expression = this.setValueExpression;
    }
  }
  runSetValueExpression() {
    if (!this.setValueExpression) {
      this.clearValue();
    } else {
      this.ensureSetValueExpressionRunner();
      this.setValueExpressionRunner.run(this.getDataFilteredValues(), this.getDataFilteredProperties());
    }
  }
  getSetValueExpressionRunner() {
    this.ensureSetValueExpressionRunner();
    return this.setValueExpressionRunner;
  }
  addTriggerInfo(name, canRun, doComplete) {
    const info = new TriggerExpressionInfo(name, canRun, doComplete);
    this.triggersInfo.push(info);
    return info;
  }
  runTriggerInfo(info, keys) {
    const expression = this[info.name];
    if (!expression && !info.getSecondRunner() || info.isRunning || !info.canRun()) {
      return;
    }
    if (!info.runner) {
      info.runner = new ExpressionRunner(expression);
      info.runner.onRunComplete = (res) => {
        if (res === true) {
          info.doComplete();
        }
        info.isRunning = false;
      };
    } else {
      info.runner.expression = expression;
    }
    if (!this.canExecuteTriggerByKeys(keys, info.runner, info.getSecondRunner())) return;
    info.isRunning = true;
    if (!expression && info.getSecondRunner()) {
      info.doComplete();
      info.isRunning = false;
    } else {
      info.runner.run(this.getDataFilteredValues(), this.getDataFilteredProperties());
    }
  }
  canExecuteTriggerByKeys(keys, runner, secondRunner) {
    if (!runner && !!secondRunner) {
      runner = secondRunner;
      secondRunner = void 0;
    }
    const run1 = this.canExecuteTriggerByKeysCore(keys, runner);
    if (run1 === "var") return true;
    if (!secondRunner) return run1 === "func";
    const run2 = this.canExecuteTriggerByKeysCore(keys, secondRunner);
    return run2 !== "";
  }
  canExecuteTriggerByKeysCore(keys, runner) {
    const vars = runner.getVariables();
    if ((!vars || vars.length === 0) && runner.hasFunction()) return "func";
    return new ProcessValue().isAnyKeyChanged(keys, vars) ? "var" : "";
  }
  runTriggers(name, value, keys) {
    if (this.isSettingQuestionValue || this.parentQuestion && this.parentQuestion.getValueName() === name) return;
    if (!keys) {
      keys = {};
      keys[name] = value;
    }
    this.triggersInfo.forEach((info) => {
      this.runTriggerInfo(info, keys);
    });
  }
  runConditions() {
    if (this.data && !this.isLoadingFromJson) {
      if (!this.isDesignMode) {
        this.runCondition(this.getDataFilteredValues(), this.getDataFilteredProperties());
      }
      this.locStrsChanged();
    }
  }
  setSurveyImpl(value, isLight) {
    super.setSurveyImpl(value);
    if (!this.survey) return;
    this.survey.questionCreated(this);
    if (isLight !== true) {
      this.runConditions();
    }
    if (!this.visible) {
      this.updateIsVisibleProp();
    }
    this.updateIsMobileFromSurvey();
  }
  /**
   * Returns a survey element (panel or page) that contains the question and allows you to move this question to a different survey element.
   */
  get parent() {
    return this.getPropertyValue("parent", null);
  }
  set parent(val) {
    if (this.parent === val) return;
    this.removeFromParent();
    this.setPropertyValue("parent", val);
    if (!!val) {
      this.updateQuestionCss();
    }
    this.onParentChanged();
  }
  onParentChanged() {
  }
  /**
   * Returns `false` if the `titleLocation` property is set to `"hidden"` or if the question cannot have a title (for example, an [HTML](https://surveyjs.io/form-library/documentation/questionhtmlmodel) question).
   *
   * If the `title` property is `undefined` or set to an empty string, the `hasTitle` property returns `true`, because the question uses its `name` as a title in this case.
   * @see title
   * @see titleLocation
   */
  get hasTitle() {
    return this.getTitleLocation() !== "hidden";
  }
  /**
   * Sets question title location relative to the input field. Overrides the `questionTitleLocation` property specified for the question's container (survey, page, or panel).
   *
   * Possible values:
   *
   * - `"default"` (default) - Inherits the setting from the `questionTitleLocation` property specified for the question's container.
   * - `"top"` - Displays the title above the input field.
   * - `"bottom"` - Displays the title below the input field.
   * - `"left"` - Displays the title to the left of the input field.
   * - `"hidden"` - Hides the question title.
   *
   * > Certain question types (Matrix, Multiple Text) do not support the `"left"` value. For them, the `"top"` value is used.
   * @see SurveyModel.questionTitleLocation
   * @see getTitleLocation
   * @see isAllowTitleLeft
   */
  get titleLocation() {
    return this.getPropertyValue("titleLocation");
  }
  set titleLocation(value) {
    var isVisibilityChanged = this.titleLocation == "hidden" || value == "hidden";
    this.setPropertyValue("titleLocation", value.toLowerCase());
    this.updateQuestionCss();
    if (isVisibilityChanged) {
      this.notifySurveyVisibilityChanged();
    }
  }
  getTitleOwner() {
    return this;
  }
  getIsTitleRenderedAsString() {
    return this.titleLocation === "hidden";
  }
  notifySurveyOnChildrenVisibilityChanged() {
    return false;
  }
  notifySurveyVisibilityChanged() {
    if (!this.survey || this.isLoadingFromJson) return;
    this.survey.questionVisibilityChanged(this, this.isVisible, !this.parentQuestion || this.parentQuestion.notifySurveyOnChildrenVisibilityChanged());
    const isClearOnHidden = this.isClearValueOnHidden;
    if (!this.visible) {
      this.clearValueOnHidding(isClearOnHidden);
    }
    if (isClearOnHidden && this.isVisibleInSurvey) {
      this.updateValueWithDefaults();
    }
  }
  clearValueOnHidding(isClearOnHidden) {
    if (isClearOnHidden) {
      this.clearValueIfInvisible();
    }
  }
  get titleWidth() {
    if (this.parent && this.getTitleLocation() === "left") {
      const columns = this.parent.getColumsForElement(this);
      const columnCount = columns.length;
      if (columnCount !== 0 && !!columns[0].questionTitleWidth) return columns[0].questionTitleWidth;
      const percentWidth = this.getPercentQuestionTitleWidth();
      if (!percentWidth && !!this.parent) {
        let width = this.parent.getQuestionTitleWidth();
        if (width && !isNaN(width)) width = width + "px";
        return width;
      }
      return percentWidth / (columnCount || 1) + "%";
    }
    return void 0;
  }
  getPercentQuestionTitleWidth() {
    const width = !!this.parent && this.parent.getQuestionTitleWidth();
    if (!!width && width[width.length - 1] === "%") {
      return parseInt(width);
    }
    return void 0;
  }
  /**
   * Returns title location calculated based on the question's `titleLocation` property and the `questionTitleLocation` property of the question's containers (survey, page, or panel).
   * @see titleLocation
   * @see SurveyModel.questionTitleLocation
   */
  getTitleLocation() {
    if (this.isFlowLayout) return "hidden";
    var location = this.getTitleLocationCore();
    if (location === "left" && !this.isAllowTitleLeft) location = "top";
    return location;
  }
  getTitleLocationCore() {
    if (this.titleLocation !== "default") return this.titleLocation;
    if (!!this.parent) return this.parent.getQuestionTitleLocation();
    if (!!this.survey) return this.survey.questionTitleLocation;
    return "top";
  }
  get hasTitleOnLeft() {
    return this.hasTitle && this.getTitleLocation() === "left";
  }
  get hasTitleOnTop() {
    return this.hasTitle && this.getTitleLocation() === "top";
  }
  get hasTitleOnBottom() {
    return this.hasTitle && this.getTitleLocation() === "bottom";
  }
  get hasTitleOnLeftTop() {
    if (!this.hasTitle) return false;
    const location = this.getTitleLocation();
    return location === "left" || location === "top";
  }
  /**
   * Specifies the error message position. Overrides the `questionErrorLocation` property specified for the question's container ([survey](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#questionErrorLocation), [page](https://surveyjs.io/form-library/documentation/api-reference/page-model#questionErrorLocation), or [panel](https://surveyjs.io/form-library/documentation/api-reference/panel-model#questionErrorLocation)).
   *
   * Possible values:
   *
   * - `"default"` (default) - Inherits the setting from the `questionErrorLocation` property specified for the question's container.
   * - `"top"` - Displays error messages above questions.
   * - `"bottom"` - Displays error messages below questions.
   */
  get errorLocation() {
    return this.getPropertyValue("errorLocation");
  }
  set errorLocation(val) {
    this.setPropertyValue("errorLocation", val);
  }
  getErrorLocation() {
    if (this.errorLocation !== "default") return this.errorLocation;
    if (this.parentQuestion) return this.parentQuestion.getChildErrorLocation(this);
    if (this.parent) return this.parent.getQuestionErrorLocation();
    return this.survey ? this.survey.questionErrorLocation : "top";
  }
  getChildErrorLocation(child) {
    return this.getErrorLocation();
  }
  /**
   * Returns `false` if the question has no input fields ([HTML](https://surveyjs.io/form-library/documentation/questionhtmlmodel), [Image](https://surveyjs.io/form-library/documentation/questionimagemodel), and similar question types).
   * @see hasSingleInput
   */
  get hasInput() {
    return true;
  }
  /**
   * Returns `false` if the question has no input fields ([HTML](https://surveyjs.io/form-library/documentation/questionhtmlmodel), [Image](https://surveyjs.io/form-library/documentation/questionimagemodel)) or has multiple input fields ([Matrix](https://surveyjs.io/form-library/documentation/questionmatrixmodel), [Multiple Text](https://surveyjs.io/form-library/documentation/questionmultipletextmodel)).
   * @see hasInput
   */
  get hasSingleInput() {
    return this.hasInput;
  }
  get inputId() {
    return this.id + "i";
  }
  getDefaultTitleValue() {
    return this.name;
  }
  getDefaultTitleTagName() {
    return settings.titleTags.question;
  }
  /**
   * Specifies where to display a question description.
   *
   * Possible values:
   *
   * - `"default"` (default) - Inherits the setting from the Survey's [`questionDescriptionLocation`](https://surveyjs.io/form-library/documentation/surveymodel#questionDescriptionLocation) property.
   * - `"underTitle"` - Displays the description under the question title.
   * - `"underInput"` - Displays the description under the interactive area.
   * @see description
   * @see hasDescription
   */
  get descriptionLocation() {
    return this.getPropertyValue("descriptionLocation");
  }
  set descriptionLocation(val) {
    this.setPropertyValue("descriptionLocation", val);
    this.updateQuestionCss();
  }
  get hasDescriptionUnderTitle() {
    return this.getDescriptionLocation() == "underTitle" && this.hasDescription;
  }
  get hasDescriptionUnderInput() {
    return this.getDescriptionLocation() == "underInput" && this.hasDescription;
  }
  getDescriptionLocation() {
    if (this.descriptionLocation !== "default") return this.descriptionLocation;
    return !!this.survey ? this.survey.questionDescriptionLocation : "underTitle";
  }
  needClickTitleFunction() {
    return super.needClickTitleFunction() || this.hasInput;
  }
  processTitleClick() {
    super.processTitleClick();
    if (this.isCollapsed) return;
    setTimeout(() => {
      this.focus();
    }, 1);
    return true;
  }
  /**
   * Specifies a custom error message for a required form field.
   * @see isRequired
   */
  get requiredErrorText() {
    return this.getLocalizableStringText("requiredErrorText");
  }
  set requiredErrorText(val) {
    this.setLocalizableStringText("requiredErrorText", val);
  }
  get locRequiredErrorText() {
    return this.getLocalizableString("requiredErrorText");
  }
  /**
   * Specifies a caption displayed above the comment area. Applies when the `showCommentArea` property is `true`.
   * @see showCommentArea
   * @see comment
   */
  get commentText() {
    return this.getLocalizableStringText("commentText");
  }
  set commentText(val) {
    this.setLocalizableStringText("commentText", val);
  }
  get locCommentText() {
    return this.getLocalizableString("commentText");
  }
  /**
   * A placeholder for the comment area. Applies when the `showCommentArea` property is `true`.
   * @see showCommentArea
   * @see comment
   * @see commentText
   */
  get commentPlaceholder() {
    return this.getLocalizableStringText("commentPlaceholder");
  }
  set commentPlaceholder(val) {
    this.setLocalizableStringText("commentPlaceholder", val);
  }
  get locCommentPlaceholder() {
    return this.getLocalizableString("commentPlaceholder");
  }
  get commentPlaceHolder() {
    return this.commentPlaceholder;
  }
  set commentPlaceHolder(newValue) {
    this.commentPlaceholder = newValue;
  }
  get renderedCommentPlaceholder() {
    var _a;
    return (_a = this.getPropertyValue("renderedCommentPlaceholder")) !== null && _a !== void 0 ? _a : !this.isReadOnly ? this.commentPlaceHolder : void 0;
  }
  resetRenderedCommentPlaceholder() {
    this.resetPropertyValue("renderedCommentPlaceholder");
  }
  /**
   * A value to show in HTML questions and in the dynamic titles and descriptions of survey elements when the question value is [empty](#isValueEmpty).
   *
   * Default value: `""`
   *
   * [Dynamic Texts](https://surveyjs.io/form-library/documentation/design-survey/conditional-logic#dynamic-texts (linkStyle))
   */
  get defaultDisplayValue() {
    return this.getLocalizableStringText("defaultDisplayValue");
  }
  set defaultDisplayValue(val) {
    this.setLocalizableStringText("defaultDisplayValue", val);
  }
  get locDefaultDisplayValue() {
    return this.getLocalizableString("defaultDisplayValue");
  }
  getAllErrors() {
    return this.errors.slice();
  }
  getErrorByType(errorType) {
    for (let i = 0; i < this.errors.length; i++) {
      if (this.errors[i].getErrorType() === errorType) return this.errors[i];
    }
    return null;
  }
  get customWidget() {
    if (!this.isCustomWidgetRequested && !this.customWidgetValue) {
      this.isCustomWidgetRequested = true;
      this.updateCustomWidget();
    }
    return this.customWidgetValue;
  }
  updateCustomWidget() {
    this.customWidgetValue = CustomWidgetCollection.Instance.getCustomWidget(this);
  }
  localeChanged() {
    super.localeChanged();
    this.resetRenderedCommentPlaceholder();
    if (!!this.localeChangedCallback) {
      this.localeChangedCallback();
    }
  }
  get isCompositeQuestion() {
    return false;
  }
  get isContainer() {
    return false;
  }
  updateCommentElements() {
  }
  onCommentInput(event) {
    if (this.isInputTextUpdate) {
      if (event.target) {
        this.comment = event.target.value;
      }
    } else {
      this.updateCommentElements();
    }
  }
  onCommentChange(event) {
    this.comment = event.target.value;
    if (this.comment !== event.target.value) {
      event.target.value = this.comment;
    }
  }
  afterRenderQuestionElement(el) {
    if (!this.survey || !this.hasSingleInput) return;
    this.survey.afterRenderQuestionInput(this, el);
  }
  afterRender(el) {
    this.afterRenderCore(el);
    if (!this.survey) return;
    this.survey.afterRenderQuestion(this, el);
    if (!!this.afterRenderQuestionCallback) {
      this.afterRenderQuestionCallback(this, el);
    }
    if (this.supportComment() || this.supportOther()) {
      this.commentElements = [];
      this.getCommentElementsId().forEach((id) => {
        const {
          root
        } = settings.environment;
        let el2 = root.getElementById(id);
        if (el2) this.commentElements.push(el2);
      });
      this.updateCommentElements();
    }
    this.checkForResponsiveness(el);
  }
  afterRenderCore(element) {
    super.afterRenderCore(element);
  }
  getCommentElementsId() {
    return [this.commentId];
  }
  beforeDestroyQuestionElement(el) {
    this.commentElements = void 0;
  }
  get processedTitle() {
    var res = this.locProcessedTitle.textOrHtml;
    return res ? res : this.name;
  }
  get fullTitle() {
    return this.locTitle.renderedHtml;
  }
  get titlePattern() {
    return !!this.survey ? this.survey.questionTitlePattern : "numTitleRequire";
  }
  get isRequireTextOnStart() {
    return this.isRequired && this.titlePattern == "requireNumTitle";
  }
  get isRequireTextBeforeTitle() {
    return this.isRequired && this.titlePattern == "numRequireTitle" && this.requiredMark !== "";
  }
  get isRequireTextAfterTitle() {
    return this.isRequired && this.titlePattern == "numTitleRequire" && this.requiredMark !== "";
  }
  /**
   * Disable this property if you want to render the current question on the same line or row with the previous question or panel.
   */
  get startWithNewLine() {
    return this.getPropertyValue("startWithNewLine");
  }
  set startWithNewLine(val) {
    if (this.startWithNewLine == val) return;
    this.setPropertyValue("startWithNewLine", val);
  }
  calcCssClasses(css) {
    const classes = {
      error: {}
    };
    this.copyCssClasses(classes, css.question);
    this.copyCssClasses(classes.error, css.error);
    this.updateCssClasses(classes, css);
    return classes;
  }
  onCalcCssClasses(classes) {
    super.onCalcCssClasses(classes);
    if (this.survey) {
      this.survey.updateQuestionCssClasses(this, classes);
    }
    if (this.onUpdateCssClassesCallback) {
      this.onUpdateCssClassesCallback(classes);
    }
  }
  get cssRoot() {
    this.ensureElementCss();
    return this.getPropertyValue("cssRoot", "");
  }
  setCssRoot(val) {
    this.setPropertyValue("cssRoot", val);
  }
  getCssRoot(cssClasses) {
    const hasError = this.hasCssError();
    return new CssClassBuilder().append(super.getCssRoot(cssClasses)).append(this.isFlowLayout && !this.isDesignMode ? cssClasses.flowRoot : cssClasses.mainRoot).append(cssClasses.titleLeftRoot, !this.isFlowLayout && this.hasTitleOnLeft).append(cssClasses.titleTopRoot, !this.isFlowLayout && this.hasTitleOnTop).append(cssClasses.titleBottomRoot, !this.isFlowLayout && this.hasTitleOnBottom).append(cssClasses.descriptionUnderInputRoot, !this.isFlowLayout && this.hasDescriptionUnderInput).append(cssClasses.hasError, hasError).append(cssClasses.hasErrorTop, hasError && this.getErrorLocation() == "top").append(cssClasses.hasErrorBottom, hasError && this.getErrorLocation() == "bottom").append(cssClasses.small, !this.width).append(cssClasses.answered, this.isAnswered).append(cssClasses.noPointerEventsMode, this.isReadOnlyAttr).toString();
  }
  get cssHeader() {
    this.ensureElementCss();
    return this.getPropertyValue("cssHeader", "");
  }
  setCssHeader(val) {
    this.setPropertyValue("cssHeader", val);
  }
  getCssHeader(cssClasses) {
    return new CssClassBuilder().append(cssClasses.header).append(cssClasses.headerTop, this.hasTitleOnTop).append(cssClasses.headerLeft, this.hasTitleOnLeft).append(cssClasses.headerBottom, this.hasTitleOnBottom).toString();
  }
  supportContainerQueries() {
    return false;
  }
  get cssContent() {
    this.ensureElementCss();
    return this.getPropertyValue("cssContent", "");
  }
  setCssContent(val) {
    this.setPropertyValue("cssContent", val);
  }
  getCssContent(cssClasses) {
    return new CssClassBuilder().append(cssClasses.content).append(cssClasses.contentSupportContainerQueries, this.supportContainerQueries()).append(cssClasses.contentLeft, this.hasTitleOnLeft).toString();
  }
  get cssTitle() {
    this.ensureElementCss();
    return this.getPropertyValue("cssTitle", "");
  }
  setCssTitle(val) {
    this.setPropertyValue("cssTitle", val);
  }
  getCssTitle(cssClasses) {
    return new CssClassBuilder().append(super.getCssTitle(cssClasses)).append(cssClasses.titleOnAnswer, !this.containsErrors && this.isAnswered).append(cssClasses.titleEmpty, !this.title.trim()).toString();
  }
  get cssDescription() {
    this.ensureElementCss();
    return this.getPropertyValue("cssDescription", "");
  }
  setCssDescription(val) {
    this.setPropertyValue("cssDescription", val);
  }
  getCssDescription(cssClasses) {
    return new CssClassBuilder().append(cssClasses.description).append(cssClasses.descriptionUnderInput, this.getDescriptionLocation() == "underInput").toString();
  }
  showErrorOnCore(location) {
    return !this.showErrorsAboveQuestion && !this.showErrorsBelowQuestion && this.getErrorLocation() === location;
  }
  get showErrorOnTop() {
    return this.showErrorOnCore("top");
  }
  get showErrorOnBottom() {
    return this.showErrorOnCore("bottom");
  }
  get showErrorsOutsideQuestion() {
    return this.isDefaultV2Theme;
  }
  get showErrorsAboveQuestion() {
    return this.showErrorsOutsideQuestion && this.getErrorLocation() === "top";
  }
  get showErrorsBelowQuestion() {
    return this.showErrorsOutsideQuestion && this.getErrorLocation() === "bottom";
  }
  get cssError() {
    this.ensureElementCss();
    return this.getPropertyValue("cssError", "");
  }
  setCssError(val) {
    this.setPropertyValue("cssError", val);
  }
  getCssError(cssClasses) {
    return new CssClassBuilder().append(cssClasses.error.root).append(cssClasses.errorsContainer, this.showErrorsBelowQuestion || this.showErrorsAboveQuestion).append(cssClasses.errorsContainerTop, this.showErrorsAboveQuestion).append(cssClasses.errorsContainerBottom, this.showErrorsBelowQuestion).append(cssClasses.error.locationTop, this.showErrorOnTop).append(cssClasses.error.locationBottom, this.showErrorOnBottom).toString();
  }
  hasCssError() {
    return this.errors.length > 0 || this.hasCssErrorCallback();
  }
  getRootCss() {
    return new CssClassBuilder().append(this.cssRoot).append(this.cssClasses.mobile, this.isMobile).append(this.cssClasses.readOnly, this.isReadOnlyStyle).append(this.cssClasses.disabled, this.isDisabledStyle).append(this.cssClasses.preview, this.isPreviewStyle).append(this.cssClasses.invisible, !this.isDesignMode && this.areInvisibleElementsShowing && !this.visible).toString();
  }
  getQuestionRootCss() {
    return new CssClassBuilder().append(this.cssClasses.root).append(this.cssClasses.rootMobile, this.isMobile).toString();
  }
  updateElementCss(reNew) {
    if (this.wasRendered) {
      super.updateElementCss(reNew);
      if (reNew) {
        this.updateQuestionCss(true);
      }
    } else {
      this.clearCssClasses();
    }
    this.resetIndents();
  }
  updateQuestionCss(reNew) {
    if (this.isLoadingFromJson || !this.survey) return;
    if (this.wasRendered) {
      this.updateElementCssCore(this.cssClasses);
    } else {
      this.isRequireUpdateElements = true;
    }
  }
  ensureElementCss() {
    if (!this.cssClassesValue) {
      this.updateQuestionCss(true);
    }
  }
  updateElementCssCore(cssClasses) {
    this.setCssRoot(this.getCssRoot(cssClasses));
    this.setCssHeader(this.getCssHeader(cssClasses));
    this.setCssContent(this.getCssContent(cssClasses));
    this.setCssTitle(this.getCssTitle(cssClasses));
    this.setCssDescription(this.getCssDescription(cssClasses));
    this.setCssError(this.getCssError(cssClasses));
  }
  updateCssClasses(res, css) {
    if (!css.question) return;
    const objCss = css[this.getCssType()];
    const titleBuilder = new CssClassBuilder().append(res.title).append(css.question.titleRequired, this.isRequired);
    res.title = titleBuilder.toString();
    const rootBuilder = new CssClassBuilder().append(res.root).append(objCss, this.isRequired && !!css.question.required);
    if (objCss === void 0 || objCss === null) {
      res.root = rootBuilder.toString();
    } else if (typeof objCss === "string" || objCss instanceof String) {
      res.root = rootBuilder.append(objCss.toString()).toString();
    } else {
      res.root = rootBuilder.toString();
      for (const key in objCss) {
        res[key] = objCss[key];
      }
    }
  }
  getCssType() {
    return this.getType();
  }
  get renderCssRoot() {
    return this.cssClasses.root || void 0;
  }
  calcPaddingLeft() {
    return this.getIndentSize(this.indent);
  }
  calcPaddingRight() {
    return this.getIndentSize(this.rightIndent);
  }
  getIndentSize(indent) {
    if (indent < 1 || !this.getSurvey() || !this.cssClasses || !this.cssClasses.indent) return "";
    return indent * this.cssClasses.indent + "px";
  }
  /**
   * Moves focus to the input field of this question.
   * @param onError Pass `true` if you want to focus an input field with the first validation error. Default value: `false` (focuses the first input field). Applies to question types with multiple input fields.
   */
  focus(onError = false, scrollIfVisible) {
    if (this.isDesignMode || !this.isVisible || !this.survey) return;
    let page = this.page;
    const shouldChangePage = !!page && this.survey.activePage !== page;
    if (shouldChangePage) {
      this.survey.focusQuestionByInstance(this, onError);
    } else {
      if (!!this.survey) {
        this.expandAllParents();
        const scrollOptions = this.survey["isSmoothScrollEnabled"] ? {
          behavior: "smooth"
        } : void 0;
        this.survey.scrollElementToTop(this, this, null, this.id, scrollIfVisible, scrollOptions, void 0, () => {
          this.focusInputElement(onError);
        });
      } else {
        this.focusInputElement(onError);
      }
    }
  }
  focusInputElement(onError) {
    var _a;
    const id = !onError ? this.getFirstInputElementId() : this.getFirstErrorInputElementId();
    const surveyRoot = (_a = this.survey) === null || _a === void 0 ? void 0 : _a.rootElement;
    if (SurveyElement.FocusElement(id, false, surveyRoot)) {
      this.fireCallback(this.focusCallback);
    }
  }
  get isValidateVisitedEmptyFields() {
    return this.supportEmptyValidation() && !!this.survey && this.survey.getValidateVisitedEmptyFields() && this.isEmpty();
  }
  supportEmptyValidation() {
    return false;
  }
  onBlur(event) {
    this.onBlurCore(event);
  }
  onFocus(event) {
    this.onFocusCore(event);
  }
  onBlurCore(event) {
    if (this.isFocusEmpty && this.isEmpty()) {
      this.validate(true);
    }
  }
  onFocusCore(event) {
    this.isFocusEmpty = this.isValidateVisitedEmptyFields;
  }
  expandAllParents() {
    this.expandAllParentsCore(this);
  }
  expandAllParentsCore(element) {
    if (!element) return;
    if (element.isCollapsed) {
      element.expand();
    }
    this.expandAllParentsCore(element.parent);
    this.expandAllParentsCore(element.parentQuestion);
  }
  focusIn() {
    if (!this.survey || this.isDisposed || this.isContainer) return;
    this.survey.whenQuestionFocusIn(this);
  }
  fireCallback(callback) {
    if (callback) callback();
  }
  getOthersMaxLength() {
    if (!this.survey) return null;
    return this.survey.maxCommentLength > 0 ? this.survey.maxCommentLength : null;
  }
  onCreating() {
  }
  getFirstQuestionToFocus(withError) {
    return this.hasInput && (!withError || this.currentErrorCount > 0) ? this : null;
  }
  getFirstInputElementId() {
    return this.inputId;
  }
  getFirstErrorInputElementId() {
    return this.getFirstInputElementId();
  }
  getProcessedTextValue(textValue) {
    var name = textValue.name.toLocaleLowerCase();
    textValue.isExists = Object.keys(_Question.TextPreprocessorValuesMap).indexOf(name) !== -1 || this[textValue.name] !== void 0;
    textValue.value = this[_Question.TextPreprocessorValuesMap[name] || textValue.name];
  }
  supportComment() {
    const prop = this.getPropertyByName("showCommentArea");
    return !prop || prop.visible;
  }
  supportOther() {
    return false;
  }
  /**
   * Makes the question required. If a respondent skips a required question, the survey displays a validation error.
   * @see requiredIf
   * @see [Data Validation](https://surveyjs.io/form-library/documentation/data-validation)
   */
  get isRequired() {
    return this.getPropertyValue("isRequired");
  }
  set isRequired(val) {
    this.setPropertyValue("isRequired", val);
  }
  /**
   * A Boolean expression. If it evaluates to `true`, this question becomes required.
   *
   * A survey parses and runs all expressions on startup. If any values used in the expression change, the survey re-evaluates it.
   *
   * Refer to the following help topic for more information: [Conditional Visibility](https://surveyjs.io/form-library/documentation/design-survey-conditional-logic#conditional-visibility).
   * @see isRequired
   */
  get requiredIf() {
    return this.getPropertyValue("requiredIf", "");
  }
  set requiredIf(val) {
    this.setPropertyValue("requiredIf", val);
  }
  /**
   * Specifies whether to display a comment area. Incompatible with the `showOtherItem` property.
   * @see comment
   * @see commentText
   * @see showOtherItem
   */
  get showCommentArea() {
    return this.getPropertyValue("showCommentArea", false);
  }
  set showCommentArea(val) {
    if (!this.supportComment()) return;
    this.setPropertyValue("showCommentArea", val);
  }
  get hasComment() {
    return this.showCommentArea;
  }
  set hasComment(val) {
    this.showCommentArea = val;
  }
  /**
   * A value to assign to the `id` attribute of the rendered HTML element. A default `id` is generated automatically.
   */
  get id() {
    return this.getPropertyValue("id");
  }
  set id(val) {
    this.setPropertyValue("id", val);
  }
  get ariaTitleId() {
    return this.id + "_ariaTitle";
  }
  get ariaDescriptionId() {
    return this.id + "_ariaDescription";
  }
  get commentId() {
    return this.id + "_comment";
  }
  /**
   * Specifies whether to display the "Other" choice item. Incompatible with the `showCommentArea` property.
   *
   * @see otherText
   * @see otherItem
   * @see otherErrorText
   * @see showCommentArea
   * @see [settings.specialChoicesOrder](https://surveyjs.io/form-library/documentation/api-reference/settings#specialChoicesOrder)
   */
  get showOtherItem() {
    return this.getPropertyValue("showOtherItem", false);
  }
  set showOtherItem(val) {
    if (!this.supportOther() || this.showOtherItem == val) return;
    this.setPropertyValue("showOtherItem", val);
    this.hasOtherChanged();
  }
  get hasOther() {
    return this.showOtherItem;
  }
  set hasOther(val) {
    this.showOtherItem = val;
  }
  hasOtherChanged() {
  }
  get requireUpdateCommentValue() {
    return this.hasComment || this.hasOther;
  }
  get isReadOnly() {
    const isParentReadOnly = !!this.parent && this.parent.isReadOnly;
    const isPareQuestionReadOnly = !!this.parentQuestion && this.parentQuestion.isReadOnly;
    const isSurveyReadOnly = !!this.survey && this.survey.isDisplayMode;
    const callbackVal = !!this.readOnlyCallback && this.readOnlyCallback();
    return this.readOnly || isParentReadOnly || isSurveyReadOnly || isPareQuestionReadOnly || callbackVal;
  }
  get isInputReadOnly() {
    if (this.forceIsInputReadOnly !== void 0) {
      return this.forceIsInputReadOnly;
    }
    return this.isReadOnly || this.isDesignMode;
  }
  get renderedInputReadOnly() {
    return this.isInputReadOnly ? "" : void 0;
  }
  get renderedInputDisabled() {
    return this.isInputReadOnly ? "" : void 0;
  }
  get isReadOnlyAttr() {
    return this.isReadOnly;
  }
  get isDisabledAttr() {
    return this.isDesignMode || !!this.readOnlyCallback && this.readOnlyCallback();
  }
  onReadOnlyChanged() {
    this.setPropertyValue("isInputReadOnly", this.isInputReadOnly);
    super.onReadOnlyChanged();
    if (this.isReadOnly) {
      this.clearErrors();
    }
    this.updateQuestionCss();
    this.resetRenderedCommentPlaceholder();
  }
  /**
   * A Boolean expression. If it evaluates to `false`, this question becomes read-only.
   *
   * A survey parses and runs all expressions on startup. If any values used in the expression change, the survey re-evaluates it.
   *
   * Refer to the following help topic for more information: [Conditional Visibility](https://surveyjs.io/form-library/documentation/design-survey-conditional-logic#conditional-visibility).
   *
   * [View Demo](https://surveyjs.io/form-library/examples/how-to-conditionally-make-input-field-read-only/ (linkStyle))
   * @see readOnly
   * @see isReadOnly
   */
  get enableIf() {
    return this.getPropertyValue("enableIf", "");
  }
  set enableIf(val) {
    this.setPropertyValue("enableIf", val);
  }
  surveyChoiceItemVisibilityChange() {
  }
  runCondition(values, properties) {
    if (this.isDesignMode) return;
    if (!properties) properties = {};
    properties["question"] = this;
    this.runConditionCore(values, properties);
    if (!this.isValueChangedDirectly && (!this.isClearValueOnHidden || this.isVisibleInSurvey)) {
      this.defaultValueRunner = this.getDefaultRunner(this.defaultValueRunner, this.defaultValueExpression);
      this.runDefaultValueExpression(this.defaultValueRunner, values, properties);
    }
  }
  get isInDesignMode() {
    return !this.isContentElement && this.isDesignMode;
  }
  /**
   * A question number or letter (depends on the `questionStartIndex` property of the question container (panel, page, or survey)).
   *
   * When the question number, title, or the entire question is invisible, this property returns an empty string.
   * @see SurveyModel.questionStartIndex
   * @see showNumber
   * @see titleLocation
   * @see visibleIf
   */
  get no() {
    return this.getPropertyValue("no");
  }
  calcNo() {
    var _a;
    if (!this.hasTitle || !this.showNumber) return "";
    const parentIndex = (_a = this.parent) === null || _a === void 0 ? void 0 : _a.visibleIndex;
    var no = Helpers.getNumberByIndex(this.visibleIndex, this.getStartIndex(), parentIndex);
    if (!!this.survey) {
      no = this.survey.getUpdatedQuestionNo(this, no);
    }
    return no;
  }
  getStartIndex() {
    if (!!this.parent) return this.parent.getQuestionStartIndex();
    if (!!this.survey) return this.survey.questionStartIndex;
    return "";
  }
  onSurveyLoad() {
    this.isCustomWidgetRequested = false;
    this.fireCallback(this.surveyLoadCallback);
    this.updateValueWithDefaults();
    if (this.isEmpty()) {
      this.initDataFromSurvey();
    }
  }
  onSetData() {
    super.onSetData();
    if (!this.isDesignMode && !!this.survey && !this.isLoadingFromJson) {
      this.initDataFromSurvey();
      this.onSurveyValueChanged(this.value);
      this.updateValueWithDefaults();
      this.updateIsAnswered();
    }
  }
  initDataFromSurvey() {
    if (!!this.data) {
      const val = this.data.getValue(this.getValueName());
      if (!Helpers.isValueEmpty(val) || !this.isLoadingFromJson) {
        this.updateValueFromSurvey(val);
      }
      this.initCommentFromSurvey();
    }
  }
  initCommentFromSurvey() {
    if (!!this.data && this.requireUpdateCommentValue) {
      this.updateCommentFromSurvey(this.data.getComment(this.getValueName()));
    } else {
      this.updateCommentFromSurvey("");
    }
  }
  runExpression(expression) {
    if (!this.survey || !expression) return void 0;
    return this.survey.runExpression(expression);
  }
  get commentAreaRows() {
    return this.survey && this.survey.commentAreaRows;
  }
  get autoGrowComment() {
    return this.survey && this.survey.autoGrowComment;
  }
  get allowResizeComment() {
    return this.survey && this.survey.allowResizeComment;
  }
  get questionValue() {
    return this.getPropertyValueWithoutDefault("value");
  }
  set questionValue(val) {
    this.setPropertyValue("value", val);
  }
  get questionComment() {
    return this.getPropertyValueWithoutDefault("comment");
  }
  set questionComment(val) {
    this.setPropertyValue("comment", val);
    this.fireCallback(this.commentChangedCallback);
  }
  get isValueArray() {
    return false;
  }
  /**
   * Gets or sets the question value.
   *
   * The following table illustrates how the value type depends on the question type:
   *
   * | Question type | Value type(s) |
   * | ------------- | ------------- |
   * | Checkboxes | <code>Array&lt;string &#124; number&gt;</code> |
   * | Dropdown | `string` \| `number` |
   * | Dynamic Matrix | `Array<object>` |
   * | Dynamic Panel | `Array<object>` |
   * | Expression | `string` \| `number` \| `boolean` |
   * | File Upload | `File` \| `Array<File>` |
   * | HTML | (no value) |
   * | Image | (no value) |
   * | Image Picker | <code>Array&lt;string &#124; number&gt;</code> |
   * | Long Text | `string` |
   * | Multi-Select Dropdown | `object` |
   * | Multi-Select Matrix | `object` |
   * | Multiple Textboxes | `Array<string>` |
   * | Panel | (no value) |
   * | Radio Button Group | `string` \| `number` |
   * | Ranking | <code>Array&lt;string &#124; number&gt;</code> |
   * | Rating Scale | `number` \| `string` |
   * | Signature | `string` (base64-encoded image) |
   * | Single-Line Input | `string` \| `number` \| `Date` |
   * | Single-Select Matrix | `object` |
   * | Yes/No (Boolean) | `boolean` \| `string` |
   */
  get value() {
    return this.getValueCore();
  }
  set value(newValue) {
    this.setNewValue(newValue);
  }
  get hasFilteredValue() {
    return false;
  }
  getFilteredValue() {
    return this.value;
  }
  getFilteredName() {
    return this.getValueName();
  }
  get valueForSurvey() {
    return this.valueForSurveyCore(this.value);
  }
  valueForSurveyCore(val) {
    if (!!this.valueToDataCallback) {
      return this.valueToDataCallback(val);
    }
    return val;
  }
  valueFromDataCore(val) {
    if (!!this.valueFromDataCallback) {
      return this.valueFromDataCallback(val);
    }
    return val;
  }
  /**
   * Sets the question's `value` and `comment` properties to `undefined`.
   * @see value
   * @see comment
   */
  clearValue(keepComment) {
    if (this.value !== void 0) {
      this.value = void 0;
    }
    if (!!this.comment && keepComment !== true) {
      this.comment = void 0;
    }
    this.setValueChangedDirectly(false);
  }
  clearValueOnly() {
    this.clearValue(true);
  }
  unbindValue() {
    this.clearValue();
  }
  createValueCopy() {
    return this.getUnbindValue(this.value);
  }
  initDataUI() {
  }
  getUnbindValue(value) {
    if (this.isValueSurveyElement(value)) return value;
    return Helpers.getUnbindValue(value);
  }
  isValueSurveyElement(val) {
    if (!val) return false;
    if (Array.isArray(val)) return val.length > 0 ? this.isValueSurveyElement(val[0]) : false;
    return val.isSurveyObj === true;
  }
  canClearValueAsInvisible(reason) {
    if (reason === "onHiddenContainer" && !this.isParentVisible) return true;
    if (this.isVisibleInSurvey) return false;
    if (!!this.page && this.page.isStartPage) return false;
    if (!this.survey) return true;
    return !this.survey.hasVisibleQuestionByValueName(this.getValueName());
  }
  /**
   * Returns `true` if a parent element (page or panel) is visible.
   */
  get isParentVisible() {
    if (this.parentQuestion && !this.parentQuestion.isVisible) return false;
    var parent = this.parent;
    while (parent) {
      if (!parent.isVisible) return false;
      parent = parent.parent;
    }
    return true;
  }
  clearValueIfInvisible(reason = "onHidden") {
    const clearIf = this.getClearIfInvisible();
    if (clearIf === "none") return;
    if (reason === "onHidden" && clearIf === "onComplete") return;
    if (reason === "onHiddenContainer" && clearIf !== reason) return;
    this.clearValueIfInvisibleCore(reason);
  }
  clearValueIfInvisibleCore(reason) {
    if (this.canClearValueAsInvisible(reason)) {
      this.clearValue();
    }
  }
  /**
   * Specifies when to clear the question value if the question becomes invisible.
   *
   * Possible values:
   *
   * - `"default"` (default) - Inherits the setting from the Survey's [`clearInvisibleValues`](https://surveyjs.io/form-library/documentation/surveymodel#clearInvisibleValues) property.
   * - `"onHidden"` - Clears the value when the question becomes invisible. If a question is invisible on startup and has an initial value, this value will be cleared when the survey is complete.
   * - `"onHiddenContainer"` - Clears the value when the question or its container (page or panel) becomes invisible. If a question is invisible on startup and has an initial value, this value will be cleared when the survey is complete.
   * - `"onComplete"` - Clears the value when the survey is complete.
   * - `"none"` - Never clears the value of an invisible question.
   * @see SurveyModel.clearInvisibleValues
   * @see visible
   * @see SurveyModel.onComplete
   */
  get clearIfInvisible() {
    return this.getPropertyValue("clearIfInvisible");
  }
  set clearIfInvisible(val) {
    this.setPropertyValue("clearIfInvisible", val);
  }
  getClearIfInvisible() {
    const res = this.clearIfInvisible;
    if (!!this.survey) return this.survey.getQuestionClearIfInvisible(res);
    return res !== "default" ? res : "onComplete";
  }
  get displayValue() {
    if (this.isLoadingFromJson) return "";
    return this.getDisplayValue(true);
  }
  /**
   * Returns a display text that corresponds to the question value. For example, if you call this method for a Dropdown question, it returns an item text instead of an item value.
   * @param keysAsText Applies when the question value is an object (in Matrix, Multiple Text, and similar questions). Pass `true` if not only values in the object should be display texts, but also keys. Default value: `false`.
   * @param value Specify this parameter to get a display text for a specific value, not for the current question value. If the question value is an object, this parameter should be a similar object.
   */
  getDisplayValue(keysAsText, value = void 0) {
    var res = this.calcDisplayValue(keysAsText, value);
    if (this.survey) {
      res = this.survey.getQuestionDisplayValue(this, res);
    }
    return !!this.displayValueCallback ? this.displayValueCallback(res) : res;
  }
  calcDisplayValue(keysAsText, value = void 0) {
    if (this.customWidget) {
      var res = this.customWidget.getDisplayValue(this, value);
      if (res) return res;
    }
    value = value == void 0 ? this.createValueCopy() : value;
    if (this.isValueEmpty(value) && !this.locDefaultDisplayValue.isEmpty) {
      value = this.defaultDisplayValue;
    }
    if (this.isValueEmpty(value, !this.allowSpaceAsAnswer)) return this.getDisplayValueEmpty();
    return this.getDisplayValueCore(keysAsText, value);
  }
  getDisplayValueCore(keyAsText, value) {
    return value;
  }
  getDisplayValueEmpty() {
    return "";
  }
  /**
   * A default value for the question. Ignored for question types that cannot have a [value](https://surveyjs.io/form-library/documentation/question#value) (for example, HTML).
   *
   * The default value is used as a question value in the following cases:
   *
   * - While the survey is being loaded from JSON.
   * - The question is just added to the survey and does not yet have an answer.
   * - The respondent left the answer empty.
   * @see defaultValueExpression
   */
  get defaultValue() {
    return this.getPropertyValue("defaultValue");
  }
  set defaultValue(val) {
    if (this.isValueExpression(val)) {
      this.defaultValueExpression = val.substring(1);
      return;
    }
    this.setPropertyValue("defaultValue", this.convertDefaultValue(val));
    this.updateValueWithDefaults();
  }
  /**
   * An expression used to calculate the [defaultValue](https://surveyjs.io/form-library/documentation/question#defaultValue).
   *
   * This expression applies until the question [value](https://surveyjs.io/form-library/documentation/question#value) is specified by an end user or programmatically.
   *
   * An expression can reference other questions as follows:
   *
   * - `{other_question_name}`
   * - `{panel.other_question_name}` (to access questions inside the same dynamic panel)
   * - `{row.other_question_name}` (to access questions inside the same dynamic matrix or multi-column dropdown)
   *
   * An expression can also include built-in and custom functions for advanced calculations. For example, if the `defaultValue` should be today's date, set the `defaultValueExpression` to `"today()"`, and the corresponding built-in function will be executed each time the survey is loaded. Refer to the following help topic for more information: [Built-In Functions](https://surveyjs.io/form-library/documentation/design-survey-conditional-logic#built-in-functions).
   *
   * [View Demo](https://surveyjs.io/form-library/examples/specify-default-question-value-dynamically (linkStyle))
   * @see defaultValue
   * @see setValueExpression
   */
  get defaultValueExpression() {
    return this.getPropertyValue("defaultValueExpression");
  }
  set defaultValueExpression(val) {
    this.setPropertyValue("defaultValueExpression", val);
    this.defaultValueRunner = void 0;
    this.updateValueWithDefaults();
  }
  /**
   * A Boolean [expression](https://surveyjs.io/form-library/documentation/design-survey/conditional-logic#expressions). If it evaluates to `true`, the question value is reset to [default](#defaultValue).
   *
   * A survey parses and runs all expressions on startup. If any values used in the expression change, the survey re-evaluates it.
   *
   * [View Demo](https://surveyjs.io/form-library/examples/set-question-value-dynamically/ (linkStyle))
   * @see setValueIf
   */
  get resetValueIf() {
    return this.getPropertyValue("resetValueIf");
  }
  set resetValueIf(val) {
    this.setPropertyValue("resetValueIf", val);
  }
  /**
   * A Boolean [expression](https://surveyjs.io/form-library/documentation/design-survey/conditional-logic#expressions). If it evaluates to `true`, the question value is set to a value calculated using the [`setValueExpression`](#setValueExpression).
   *
   * A survey parses and runs all expressions on startup. If any values used in the expression change, the survey re-evaluates it.
   *
   * [View Demo](https://surveyjs.io/form-library/examples/set-question-value-dynamically/ (linkStyle))
   * @see resetValueIf
   */
  get setValueIf() {
    return this.getPropertyValue("setValueIf");
  }
  set setValueIf(val) {
    this.setPropertyValue("setValueIf", val);
  }
  /**
   * An [expression](https://surveyjs.io/form-library/documentation/design-survey/conditional-logic#expressions) used to calculate the question value.
   *
   * You can use `setValueExpression` as a standalone property or in conjunction with the [`setValueIf`](#setValueIf) expression, in which case the calculated question value applies only when `setValueIf` evaluates to `true`.
   *
   * [View Demo](https://surveyjs.io/form-library/examples/set-question-value-dynamically/ (linkStyle))
   * @see defaultValueExpression
   * @see resetValueIf
   */
  get setValueExpression() {
    return this.getPropertyValue("setValueExpression");
  }
  set setValueExpression(val) {
    this.setPropertyValue("setValueExpression", val);
  }
  get resizeStyle() {
    return this.allowResizeComment ? "both" : "none";
  }
  /**
   * Returns the question value as an object in which the question name, title, value, and other parameters are stored as individual properties.
   *
   * If the question can have more than one value (Matrix, Multiple Text), the object enables the `isNode` flag and stores information about these values in the `data` property. Refer to the following help topic for more information: [Access Full Survey Results](https://surveyjs.io/form-library/documentation/handle-survey-results-access#access-full-survey-results).
   *
   * Pass an object with the `includeEmpty` property set to `false` if you want to skip empty answers.
   */
  getPlainData(options) {
    if (!options) {
      options = {
        includeEmpty: true,
        includeQuestionTypes: false
      };
    }
    if (options.includeEmpty || !this.isEmpty()) {
      var questionPlainData = {
        name: this.name,
        title: this.locTitle.renderedHtml,
        value: this.value,
        displayValue: this.displayValue,
        isNode: false,
        getString: (val) => typeof val === "object" ? JSON.stringify(val) : val
      };
      if (options.includeQuestionTypes === true) {
        questionPlainData.questionType = this.getType();
      }
      (options.calculations || []).forEach((calculation) => {
        questionPlainData[calculation.propertyName] = this.getPlainDataCalculatedValue(calculation.propertyName);
      });
      if (this.hasComment) {
        questionPlainData.isNode = true;
        questionPlainData.data = [{
          name: 0,
          isComment: true,
          title: "Comment",
          value: settings.commentSuffix,
          displayValue: this.comment,
          getString: (val) => typeof val === "object" ? JSON.stringify(val) : val,
          isNode: false
        }];
      }
      return questionPlainData;
    }
    return void 0;
  }
  getPlainDataCalculatedValue(propName) {
    return this[propName];
  }
  /**
   * A correct answer to this question. Specify this property if you want to [create a quiz](https://surveyjs.io/form-library/documentation/design-survey-create-a-quiz).
   * @see SurveyModel.getCorrectAnswerCount
   * @see SurveyModel.getIncorrectAnswerCount
   */
  get correctAnswer() {
    return this.getPropertyValue("correctAnswer");
  }
  set correctAnswer(val) {
    this.setPropertyValue("correctAnswer", this.convertDefaultValue(val));
  }
  convertDefaultValue(val) {
    return val;
  }
  /**
   * The number of quiz questions. A question counts if it is visible, has an input field, and specifies `correctAnswer`.
   * @see [Create a Quiz](https://surveyjs.io/form-library/documentation/design-survey-create-a-quiz)
   * @see correctAnswer
   * @see SurveyModel.getQuizQuestions
   */
  get quizQuestionCount() {
    if (this.isVisible && this.hasInput && !this.isValueEmpty(this.correctAnswer)) return this.getQuizQuestionCount();
    return 0;
  }
  get correctAnswerCount() {
    if (!this.isEmpty() && !this.isValueEmpty(this.correctAnswer)) return this.getCorrectAnswerCount();
    return 0;
  }
  getQuizQuestionCount() {
    return 1;
  }
  getCorrectAnswerCount() {
    return this.checkIfAnswerCorrect() ? 1 : 0;
  }
  checkIfAnswerCorrect() {
    const isEqual = Helpers.isTwoValueEquals(this.value, this.correctAnswer, this.getAnswerCorrectIgnoreOrder(), settings.comparator.caseSensitive, true);
    const correct = isEqual ? 1 : 0;
    const incorrect = this.quizQuestionCount - correct;
    const options = {
      result: isEqual,
      correctAnswers: correct,
      correctAnswerCount: correct,
      incorrectAnswers: incorrect,
      incorrectAnswerCount: incorrect
    };
    if (!!this.survey) {
      this.survey.onCorrectQuestionAnswer(this, options);
    }
    return options.result;
  }
  getAnswerCorrectIgnoreOrder() {
    return false;
  }
  /**
  * Returns `true` if a question answer matches the `correctAnswer` property value.
  *
  * [View Demo](https://surveyjs.io/form-library/examples/create-a-scored-quiz (linkStyle))
  * @see correctAnswer
  * @see SurveyModel.getQuizQuestions
  */
  isAnswerCorrect() {
    return this.correctAnswerCount == this.quizQuestionCount;
  }
  updateValueWithDefaults() {
    if (this.isLoadingFromJson || !this.isDesignMode && this.isDefaultValueEmpty()) return;
    if (!this.isDesignMode && !this.isEmpty()) return;
    if (this.isEmpty() && this.isDefaultValueEmpty()) return;
    if (this.isClearValueOnHidden && !this.isVisible) return;
    if (this.isDesignMode && this.isContentElement && this.isDefaultValueEmpty()) return;
    this.setDefaultValue();
  }
  get isValueDefault() {
    return !this.isEmpty() && (this.isTwoValueEquals(this.defaultValue, this.value) || !this.isValueChangedDirectly && !!this.defaultValueExpression);
  }
  get isClearValueOnHidden() {
    const clearIf = this.getClearIfInvisible();
    if (clearIf === "none" || clearIf === "onComplete") return false;
    return clearIf === "onHidden" || clearIf === "onHiddenContainer";
  }
  getQuestionFromArray(name, index) {
    return null;
  }
  getDefaultValue() {
    return this.defaultValue;
  }
  isDefaultValueEmpty() {
    return !this.defaultValueExpression && this.isValueEmpty(this.defaultValue, !this.allowSpaceAsAnswer);
  }
  getDefaultRunner(runner, expression) {
    if (!runner && !!expression) {
      runner = this.createExpressionRunner(expression);
    }
    if (!!runner) {
      runner.expression = expression;
    }
    return runner;
  }
  setDefaultValue() {
    this.setDefaultValueCore((val) => {
      if (!this.isTwoValueEquals(this.value, val)) {
        this.value = val;
      }
    });
  }
  setDefaultValueCore(func) {
    this.defaultValueRunner = this.getDefaultRunner(this.defaultValueRunner, this.defaultValueExpression);
    this.setValueAndRunExpression(this.defaultValueRunner, this.getUnbindValue(this.defaultValue), (val) => func(val));
  }
  isValueExpression(val) {
    return !!val && typeof val == "string" && val.length > 0 && val[0] == "=";
  }
  setValueAndRunExpression(runner, defaultValue, setFunc, values = null, properties = null) {
    const func = (val) => {
      this.runExpressionSetValueCore(val, setFunc);
    };
    if (!this.runDefaultValueExpression(runner, values, properties, func)) {
      func(defaultValue);
    }
  }
  convertFuncValuetoQuestionValue(val) {
    return Helpers.convertValToQuestionVal(val);
  }
  runExpressionSetValueCore(val, setFunc) {
    setFunc(this.convertFuncValuetoQuestionValue(val));
  }
  runExpressionSetValue(val) {
    this.runExpressionSetValueCore(val, (val2) => {
      if (!this.isTwoValueEquals(this.value, val2)) {
        this.startSetValueOnExpression();
        this.value = val2;
        this.finishSetValueOnExpression();
      }
    });
  }
  startSetValueOnExpression() {
    var _a;
    (_a = this.survey) === null || _a === void 0 ? void 0 : _a.startSetValueOnExpression();
  }
  finishSetValueOnExpression() {
    var _a;
    (_a = this.survey) === null || _a === void 0 ? void 0 : _a.finishSetValueOnExpression();
  }
  runDefaultValueExpression(runner, values = null, properties = null, setFunc) {
    if (!runner || !this.data) return false;
    if (!setFunc) {
      setFunc = (val) => {
        this.runExpressionSetValue(val);
      };
    }
    if (!values) values = this.defaultValueExpression ? this.data.getFilteredValues() : {};
    if (!properties) {
      properties = this.defaultValueExpression ? this.data.getFilteredProperties() : {};
      properties["question"] = this;
    }
    if (!!runner && runner.canRun) {
      runner.onRunComplete = (res) => {
        if (res == void 0) res = this.defaultValue;
        this.isChangingViaDefaultValue = true;
        setFunc(res);
        this.isChangingViaDefaultValue = false;
      };
      runner.run(values, properties);
    }
    return true;
  }
  /**
   * A comment to the selected question value. Enable the `showCommentArea` property to allow users to leave comments.
   * @see showCommentArea
   * @see commentText
   */
  get comment() {
    return this.getQuestionComment();
  }
  set comment(newValue) {
    if (!!newValue) {
      const trimmedValue = newValue.toString().trim();
      if (trimmedValue !== newValue) {
        newValue = trimmedValue;
        if (newValue === this.comment) {
          this.setPropertyValueDirectly("comment", newValue);
        }
      }
    }
    if (this.comment == newValue) return;
    this.setQuestionComment(newValue);
    this.updateCommentElements();
  }
  getCommentAreaCss(isOther = false) {
    return new CssClassBuilder().append("form-group", isOther).append(this.cssClasses.formGroup, !isOther).append(this.cssClasses.commentArea).toString();
  }
  getQuestionComment() {
    return this.questionComment;
  }
  setQuestionComment(newValue) {
    this.setNewComment(newValue);
  }
  /**
   * Returns `true` if the question value is an empty string, array, or object or if it equals `undefined` or `null`.
   */
  isEmpty() {
    return this.isValueEmpty(this.value, !this.allowSpaceAsAnswer);
  }
  get isAnswered() {
    return this.getPropertyValue("isAnswered") || false;
  }
  set isAnswered(val) {
    this.setPropertyValue("isAnswered", val);
  }
  updateIsAnswered() {
    const oldVal = this.isAnswered;
    this.setPropertyValue("isAnswered", this.getIsAnswered());
    if (oldVal !== this.isAnswered) {
      this.updateQuestionCss();
    }
  }
  getIsAnswered() {
    return !this.isEmpty();
  }
  /**
   * Question validators.
   *
   * [Data Validation](https://surveyjs.io/form-library/documentation/data-validation (linkStyle))
   */
  get validators() {
    return this.getPropertyValue("validators");
  }
  set validators(val) {
    this.setPropertyValue("validators", val);
  }
  getValidators() {
    return this.validators;
  }
  getSupportedValidators() {
    var res = [];
    var className = this.getType();
    while (!!className) {
      var classValidators = settings.supportedValidators[className];
      if (!!classValidators) {
        for (var i = classValidators.length - 1; i >= 0; i--) {
          res.splice(0, 0, classValidators[i]);
        }
      }
      var classInfo = Serializer.findClass(className);
      className = classInfo.parentName;
    }
    return res;
  }
  addConditionObjectsByContext(objects, context) {
    objects.push({
      name: this.getFilteredName(),
      text: this.processedTitle,
      question: this
    });
  }
  /**
   * Returns an array of questions nested within the current question. Use this method to obtain questions within [Multiple Text](https://surveyjs.io/form-library/documentation/api-reference/multiple-text-entry-question-model), [Dynamic Panel](https://surveyjs.io/form-library/documentation/api-reference/dynamic-panel-model), and [Matrix](https://surveyjs.io/form-library/documentation/api-reference/matrix-table-question-model)-like questions.
   * @param visibleOnly A Boolean value that specifies whether to include only visible nested questions.
   * @returns An array of nested questions.
   */
  getNestedQuestions(visibleOnly = false) {
    const res = [];
    this.collectNestedQuestions(res, visibleOnly);
    if (res.length === 1 && res[0] === this) return [];
    return res;
  }
  collectNestedQuestions(questions, visibleOnly = false) {
    if (visibleOnly && !this.isVisible) return;
    this.collectNestedQuestionsCore(questions, visibleOnly);
  }
  collectNestedQuestionsCore(questions, visibleOnly) {
    questions.push(this);
  }
  getConditionJson(operator = null, path = null) {
    const json2 = new JsonObject().toJsonObject(this);
    json2["type"] = this.getType();
    return json2;
  }
  hasErrors(fireCallback = true, rec = null) {
    const errors = this.checkForErrors(!!rec && rec.isOnValueChanged === true, fireCallback);
    if (fireCallback) {
      this.errors = errors;
      if (this.errors !== errors) {
        this.errors.forEach((er) => er.locText.strChanged());
      }
    }
    this.updateContainsErrors();
    if (this.isCollapsed && rec && fireCallback && errors.length > 0) {
      this.expand();
    }
    return errors.length > 0;
  }
  /**
   * Validates this question and returns `false` if the validation fails.
   * @param fireCallback *(Optional)* Pass `false` if you do not want to show validation errors in the UI.
   * @see [Data Validation](https://surveyjs.io/form-library/documentation/data-validation)
   */
  validate(fireCallback = true, rec = null) {
    if (!!rec && rec.isOnValueChanged) {
      if (!!this.parent) {
        this.parent.validateContainerOnly();
      }
    }
    return !this.hasErrors(fireCallback, rec);
  }
  get currentErrorCount() {
    return this.errors.length;
  }
  /**
   * Returns a character or text string that indicates a required question.
   * @see SurveyModel.requiredMark
   * @see isRequired
   */
  get requiredMark() {
    return this.survey != null && this.isRequired ? this.survey.requiredMark : "";
  }
  /**
   * @deprecated Use the [`requiredMark`](https://surveyjs.io/form-library/documentation/api-reference/question#requiredMark) property instead.
   */
  get requiredText() {
    return this.requiredMark;
  }
  addError(error) {
    if (!error) return;
    let newError = null;
    if (typeof error === "string" || error instanceof String) {
      newError = this.addCustomError(error);
    } else {
      newError = error;
    }
    this.errors.push(newError);
  }
  addCustomError(error) {
    return new CustomError(error, this.survey);
  }
  removeError(error) {
    if (!error) return false;
    const errors = this.errors;
    const index = errors.indexOf(error);
    if (index !== -1) errors.splice(index, 1);
    return index !== -1;
  }
  checkForErrors(isOnValueChanged, fireCallback) {
    var qErrors = new Array();
    if (this.isVisible && this.canCollectErrors()) {
      this.collectErrors(qErrors, isOnValueChanged, fireCallback);
    }
    if (!!this.survey) {
      if (this.validateValueCallback && qErrors.length === 0) {
        const error = this.validateValueCallback();
        if (error) {
          qErrors.push(error);
        }
      }
      this.survey.validateQuestion(this, qErrors, fireCallback);
    }
    return qErrors;
  }
  canCollectErrors() {
    return !this.isReadOnly || settings.readOnly.enableValidation;
  }
  collectErrors(qErrors, isOnValueChanged, fireCallback) {
    this.onCheckForErrors(qErrors, isOnValueChanged, fireCallback);
    if (qErrors.length > 0 || !this.canRunValidators(isOnValueChanged)) return;
    var errors = this.runValidators();
    if (errors.length > 0) {
      qErrors.length = 0;
      for (var i = 0; i < errors.length; i++) {
        qErrors.push(errors[i]);
      }
    }
  }
  canRunValidators(isOnValueChanged) {
    return true;
  }
  onCheckForErrors(errors, isOnValueChanged, fireCallback) {
    if ((!isOnValueChanged || this.isOldAnswered) && this.hasRequiredError()) {
      const err = new AnswerRequiredError(this.requiredErrorText, this);
      err.onUpdateErrorTextCallback = (err2) => {
        err2.text = this.requiredErrorText;
      };
      errors.push(err);
    }
    if (!this.isEmpty() && this.customWidget) {
      const text = this.customWidget.validate(this);
      if (!!text) {
        errors.push(this.addCustomError(text));
      }
    }
  }
  hasRequiredError() {
    return this.isRequired && this.isEmpty();
  }
  get isRunningValidators() {
    return this.getIsRunningValidators();
  }
  getIsRunningValidators() {
    return this.isRunningValidatorsValue;
  }
  runValidators() {
    if (!!this.validatorRunner) {
      this.validatorRunner.onAsyncCompleted = null;
    }
    this.validatorRunner = new ValidatorRunner();
    this.isRunningValidatorsValue = true;
    this.validatorRunner.onAsyncCompleted = (errors) => {
      this.doOnAsyncCompleted(errors);
    };
    return this.validatorRunner.run(this);
  }
  doOnAsyncCompleted(errors) {
    for (var i = 0; i < errors.length; i++) {
      this.errors.push(errors[i]);
    }
    this.isRunningValidatorsValue = false;
    this.raiseOnCompletedAsyncValidators();
  }
  raiseOnCompletedAsyncValidators() {
    if (!!this.onCompletedAsyncValidators && !this.isRunningValidators) {
      this.onCompletedAsyncValidators(this.getAllErrors().length > 0);
      this.onCompletedAsyncValidators = null;
    }
  }
  setNewValue(newValue) {
    if (this.isNewValueEqualsToValue(newValue)) return;
    if (!this.checkIsValueCorrect(newValue)) return;
    this.isOldAnswered = this.isAnswered;
    this.isSettingQuestionValue = true;
    this.setNewValueInData(newValue);
    this.allowNotifyValueChanged && this.onValueChanged();
    this.isSettingQuestionValue = false;
    if (this.isAnswered !== this.isOldAnswered) {
      this.updateQuestionCss();
    }
    this.isOldAnswered = void 0;
    if (this.parent) {
      this.parent.onQuestionValueChanged(this);
    }
  }
  checkIsValueCorrect(val) {
    const res = this.isValueEmpty(val, !this.allowSpaceAsAnswer) || this.isNewValueCorrect(val);
    if (!res) {
      ConsoleWarnings.inCorrectQuestionValue(this.name, val);
    }
    return res;
  }
  isNewValueCorrect(val) {
    return true;
  }
  isNewValueEqualsToValue(newValue) {
    const val = this.value;
    if (!this.isTwoValueEquals(newValue, val, false, false)) return false;
    const isObj = newValue === val && !!val && (Array.isArray(val) || typeof val === "object");
    return !isObj;
  }
  isTextValue() {
    return false;
  }
  getIsInputTextUpdate() {
    return !!this.survey ? this.survey.isUpdateValueTextOnTyping : false;
  }
  get requireStrictCompare() {
    return false;
  }
  getDataLocNotification() {
    return this.isInputTextUpdate ? "text" : false;
  }
  get isInputTextUpdate() {
    return this.getIsInputTextUpdate() && this.isTextValue();
  }
  setNewValueInData(newValue) {
    newValue = this.valueToData(newValue);
    if (!this.isValueChangedInSurvey) {
      this.setValueCore(newValue);
    }
  }
  getValueCore() {
    return this.questionValue;
  }
  setValueCore(newValue) {
    this.setQuestionValue(newValue);
    if (this.data != null && this.canSetValueToSurvey()) {
      newValue = this.valueForSurvey;
      this.data.setValue(this.getValueName(), newValue, this.getDataLocNotification(), this.allowNotifyValueChanged, this.name);
    }
    this.isMouseDown = false;
  }
  canSetValueToSurvey() {
    return true;
  }
  valueFromData(val) {
    return val;
  }
  valueToData(val) {
    return val;
  }
  convertToCorrectValue(val) {
    return val;
  }
  onValueChanged() {
  }
  onMouseDown() {
    this.isMouseDown = true;
  }
  setNewComment(newValue) {
    if (this.questionComment === newValue) return;
    this.questionComment = newValue;
    this.setCommentIntoData(newValue);
  }
  setCommentIntoData(newValue) {
    if (this.data != null) {
      this.data.setComment(this.getValueName(), newValue, this.getIsInputTextUpdate() ? "text" : false);
    }
  }
  getValidName(name) {
    return makeNameValid(name);
  }
  //IQuestion
  updateValueFromSurvey(newValue, clearData = false) {
    newValue = this.getUnbindValue(newValue);
    newValue = this.valueFromDataCore(newValue);
    if (!this.checkIsValueCorrect(newValue)) return;
    const isEmpty = this.isValueEmpty(newValue);
    if (!isEmpty && this.defaultValueExpression) {
      this.setDefaultValueCore((val) => {
        this.updateValueFromSurveyCore(newValue, this.isTwoValueEquals(newValue, val));
      });
    } else {
      this.updateValueFromSurveyCore(newValue, this.data !== this.getSurvey());
      if (clearData && isEmpty) {
        this.isValueChangedDirectly = false;
      }
    }
    this.updateDependedQuestions();
    this.updateIsAnswered();
  }
  updateValueFromSurveyCore(newValue, viaDefaultVal) {
    this.isChangingViaDefaultValue = viaDefaultVal;
    this.setQuestionValue(this.valueFromData(newValue));
    this.isChangingViaDefaultValue = false;
  }
  updateCommentFromSurvey(newValue) {
    this.questionComment = newValue;
  }
  onChangeQuestionValue(newValue) {
  }
  setValueChangedDirectly(val) {
    this.isValueChangedDirectly = val;
    if (!!this.setValueChangedDirectlyCallback) {
      this.setValueChangedDirectlyCallback(val);
    }
  }
  setQuestionValue(newValue, updateIsAnswered = true) {
    newValue = this.convertToCorrectValue(newValue);
    const isEqual = this.isTwoValueEquals(this.questionValue, newValue);
    if (!isEqual && !this.isChangingViaDefaultValue && !this.isParentChangingViaDefaultValue) {
      this.setValueChangedDirectly(true);
    }
    this.questionValue = newValue;
    if (!isEqual) {
      this.onChangeQuestionValue(newValue);
    }
    !isEqual && this.allowNotifyValueChanged && this.fireCallback(this.valueChangedCallback);
    if (updateIsAnswered) this.updateIsAnswered();
  }
  get isParentChangingViaDefaultValue() {
    var _a;
    return ((_a = this.data) === null || _a === void 0 ? void 0 : _a.isChangingViaDefaultValue) === true;
  }
  onSurveyValueChanged(newValue) {
  }
  setVisibleIndex(val) {
    if (val > -1 && (!this.isVisible || !this.hasTitle && !settings.numbering.includeQuestionsWithHiddenTitle || !this.showNumber && !settings.numbering.includeQuestionsWithHiddenNumber)) {
      val = -1;
    }
    this.setPropertyValue("visibleIndex", val);
    this.setPropertyValue("no", this.calcNo());
    return val < 0 ? 0 : 1;
  }
  removeElement(element) {
    return false;
  }
  // Obsolete
  supportGoNextPageAutomatic() {
    return this.supportAutoAdvance();
  }
  supportAutoAdvance() {
    return false;
  }
  supportGoNextPageError() {
    return true;
  }
  /**
   * Removes values that cannot be assigned to this question, for example, choices unlisted in the `choices` array.
   *
   * Call this method after you assign new question values in code to ensure that they are acceptable.
   *
   * > This method does not remove values that fail validation. Call the `validate()` method to validate newly assigned values.
   *
   * @see validate
   */
  clearIncorrectValues() {
  }
  clearOnDeletingContainer() {
  }
  /**
   * Empties the `errors` array.
   * @see errors
   */
  clearErrors() {
    this.errors = [];
  }
  clearUnusedValues() {
  }
  onAnyValueChanged(name, questionName) {
  }
  checkBindings(valueName, value) {
    if (this.bindings.isEmpty() || !this.data) return;
    var props = this.bindings.getPropertiesByValueName(valueName);
    for (var i = 0; i < props.length; i++) {
      const propName = props[i];
      if (this.isValueEmpty(value) && Helpers.isNumber(this[propName])) {
        value = 0;
      }
      this.updateBindingProp(propName, value);
    }
  }
  updateBindingProp(propName, value) {
    this[propName] = value;
  }
  getComponentName() {
    return RendererFactory.Instance.getRendererByQuestion(this);
  }
  isDefaultRendering() {
    return !!this.customWidget || this.getComponentName() === "default";
  }
  get renderAs() {
    return this.getPropertyValue("renderAs");
  }
  set renderAs(val) {
    this.setPropertyValue("renderAs", val);
  }
  get inMatrixMode() {
    return this.getPropertyValue("inMatrixMode", false);
  }
  set inMatrixMode(val) {
    this.setPropertyValue("inMatrixMode", val);
  }
  //ISurveyErrorOwner
  getErrorCustomText(text, error) {
    if (!!this.survey) return this.survey.getSurveyErrorCustomText(this, text, error);
    return text;
  }
  //IValidatorOwner
  getValidatorTitle() {
    return null;
  }
  get validatedValue() {
    return this.value;
  }
  set validatedValue(val) {
    this.value = val;
  }
  getAllValues() {
    return !!this.data ? this.data.getAllValues() : null;
  }
  processPopupVisiblilityChanged(popupModel, visible) {
    this.survey.processPopupVisiblityChanged(this, popupModel, visible);
  }
  processOpenDropdownMenu(options) {
    this.survey.processOpenDropdownMenu(this, options);
  }
  onTextKeyDownHandler(event) {
    if (event.keyCode === 13) {
      this.survey.questionEditFinishCallback(this, event);
    }
  }
  transformToMobileView() {
  }
  transformToDesktopView() {
  }
  needResponsiveWidth() {
    return false;
  }
  //responsiveness methods
  supportResponsiveness() {
    return false;
  }
  needResponsiveness() {
    return this.supportResponsiveness() && this.isDefaultV2Theme && !this.isDesignMode;
  }
  checkForResponsiveness(el) {
    if (this.needResponsiveness()) {
      if (this.isCollapsed) {
        const onStateChanged = () => {
          if (this.isExpanded) {
            this.initResponsiveness(el);
            this.unregisterPropertyChangedHandlers(["state"], "for-responsiveness");
          }
        };
        this.registerPropertyChangedHandlers(["state"], onStateChanged, "for-responsiveness");
      } else {
        this.initResponsiveness(el);
      }
    }
  }
  getObservedElementSelector() {
    return ".sd-scrollable-container";
  }
  onMobileChanged() {
    this.onMobileChangedCallback && this.onMobileChangedCallback();
  }
  triggerResponsiveness(hard = true) {
    if (this.triggerResponsivenessCallback) {
      this.triggerResponsivenessCallback(hard);
    }
  }
  initResponsiveness(el) {
    this.destroyResizeObserver();
    if (!!el && this.isDefaultRendering()) {
      const scrollableSelector = this.getObservedElementSelector();
      if (!scrollableSelector) return;
      const defaultRootEl = el.querySelector(scrollableSelector);
      if (!defaultRootEl) return;
      let isProcessed = false;
      let requiredWidth = void 0;
      this.triggerResponsivenessCallback = (hard) => {
        if (hard) {
          requiredWidth = void 0;
          this.renderAs = "default";
          isProcessed = false;
        }
        const callback = () => {
          const rootEl = el.querySelector(scrollableSelector);
          if (!requiredWidth && this.isDefaultRendering()) {
            requiredWidth = rootEl.scrollWidth;
          }
          if (isProcessed || !isContainerVisible(rootEl)) {
            isProcessed = false;
          } else {
            isProcessed = this.processResponsiveness(requiredWidth, getElementWidth(rootEl));
          }
        };
        if (hard) {
          setTimeout(callback, 1);
        } else {
          callback();
        }
      };
      this.resizeObserver = new ResizeObserver((entries) => {
        DomWindowHelper.requestAnimationFrame(() => {
          this.triggerResponsiveness(false);
        });
      });
      this.onMobileChangedCallback = () => {
        setTimeout(() => {
          const rootEl = el.querySelector(scrollableSelector);
          this.processResponsiveness(requiredWidth, getElementWidth(rootEl));
        }, 0);
      };
      this.resizeObserver.observe(el);
    }
  }
  getCompactRenderAs() {
    return "default";
  }
  getDesktopRenderAs() {
    return "default";
  }
  onBeforeSetCompactRenderer() {
  }
  onBeforeSetDesktopRenderer() {
  }
  processResponsiveness(requiredWidth, availableWidth) {
    availableWidth = Math.round(availableWidth);
    if (Math.abs(requiredWidth - availableWidth) > 2) {
      const oldRenderAs = this.renderAs;
      if (requiredWidth > availableWidth) {
        this.onBeforeSetCompactRenderer();
        this.renderAs = this.getCompactRenderAs();
      } else {
        this.onBeforeSetDesktopRenderer();
        this.renderAs = this.getDesktopRenderAs();
      }
      return oldRenderAs !== this.renderAs;
    }
    return false;
  }
  destroyResizeObserver() {
    if (!!this.resizeObserver) {
      this.resizeObserver.disconnect();
      this.resizeObserver = void 0;
      this.onMobileChangedCallback = void 0;
      this.triggerResponsivenessCallback = void 0;
      this.renderAs = this.getDesktopRenderAs();
    }
  }
  dispose() {
    super.dispose();
    this.resetDependedQuestions();
    this.destroyResizeObserver();
  }
  resetDependedQuestions() {
    for (var i = 0; i < this.dependedQuestions.length; i++) {
      this.dependedQuestions[i].resetDependedQuestion();
    }
  }
  //a11y
  get isNewA11yStructure() {
    return false;
  }
  get ariaLabel() {
    if (this.isNewA11yStructure) return null;
    return this.locTitle.renderedHtml;
  }
  get ariaRole() {
    if (this.isNewA11yStructure) return null;
    return "textbox";
  }
  get ariaRequired() {
    if (this.isNewA11yStructure) return null;
    return this.isRequired ? "true" : "false";
  }
  get ariaInvalid() {
    if (this.isNewA11yStructure) return null;
    return this.hasCssError() ? "true" : "false";
  }
  get ariaLabelledBy() {
    if (this.isNewA11yStructure) return null;
    if (this.hasTitle) {
      return this.ariaTitleId;
    } else {
      return null;
    }
  }
  get ariaDescribedBy() {
    if (this.isNewA11yStructure) return null;
    if (this.hasTitle && this.hasDescription) {
      return this.ariaDescriptionId;
    } else {
      return null;
    }
  }
  get ariaErrormessage() {
    if (this.isNewA11yStructure) return null;
    return this.hasCssError() ? this.id + "_errors" : null;
  }
  //EO a11y
  //new a11y
  get a11y_input_ariaRole() {
    return null;
  }
  get a11y_input_ariaRequired() {
    return this.isRequired ? "true" : "false";
  }
  get a11y_input_ariaInvalid() {
    return this.hasCssError() ? "true" : "false";
  }
  get a11y_input_ariaLabel() {
    if (this.hasTitle && !this.parentQuestion) {
      return null;
    } else {
      return this.locTitle.renderedHtml;
    }
  }
  get a11y_input_ariaLabelledBy() {
    if (this.hasTitle && !this.parentQuestion) {
      return this.ariaTitleId;
    } else {
      return null;
    }
  }
  get a11y_input_ariaDescribedBy() {
    if (this.hasTitle && !this.parentQuestion && this.hasDescription) {
      return this.ariaDescriptionId;
    } else {
      return null;
    }
  }
  get a11y_input_ariaErrormessage() {
    return this.hasCssError() ? this.id + "_errors" : null;
  }
};
Question.TextPreprocessorValuesMap = {
  title: "processedTitle",
  require: "requiredMark"
};
Question.questionCounter = 100;
function makeNameValid(str) {
  if (!str) return str;
  str = str.trim().replace(/[\{\}]+/g, "");
  while (!!str && str[0] === settings.expressionDisableConversionChar) {
    str = str.substring(1);
  }
  return str;
}
Serializer.addClass("question", [{
  name: "!name",
  onSettingValue: (obj, val) => {
    return makeNameValid(val);
  }
}, {
  name: "state",
  default: "default",
  choices: ["default", "collapsed", "expanded"]
}, {
  name: "visible:switch",
  default: true,
  overridingProperty: "visibleIf"
}, {
  name: "useDisplayValuesInDynamicTexts:boolean",
  alternativeName: "useDisplayValuesInTitle",
  default: true,
  layout: "row"
}, "visibleIf:condition", {
  name: "width"
}, {
  name: "minWidth",
  defaultFunc: () => settings.minWidth
}, {
  name: "maxWidth",
  defaultFunc: () => settings.maxWidth
}, {
  name: "colSpan:number",
  visible: false,
  onSerializeValue: (obj) => {
    return obj.getPropertyValue("colSpan");
  }
}, {
  name: "effectiveColSpan:number",
  minValue: 1,
  isSerializable: false,
  visibleIf: function(obj) {
    return !!obj && !!obj.survey && obj.survey.gridLayoutEnabled;
  }
}, {
  name: "startWithNewLine:boolean",
  default: true,
  layout: "row"
}, {
  name: "indent:number",
  default: 0,
  choices: [0, 1, 2, 3],
  layout: "row"
}, {
  name: "page",
  isSerializable: false,
  visibleIf: function(obj) {
    var survey = obj ? obj.survey : null;
    return !survey || !survey.pages || survey.pages.length > 1;
  },
  choices: function(obj) {
    var survey = obj ? obj.survey : null;
    return survey ? survey.pages.map((p) => {
      return {
        value: p.name,
        text: p.title
      };
    }) : [];
  }
}, {
  name: "title:text",
  serializationProperty: "locTitle",
  layout: "row",
  dependsOn: "name",
  onPropertyEditorUpdate: function(obj, editor) {
    if (!!obj && !!editor) {
      editor.placeholder = obj.getDefaultTitle();
    }
  }
}, {
  name: "titleLocation",
  default: "default",
  choices: ["default", "top", "bottom", "left", "hidden"],
  layout: "row"
}, {
  name: "description:text",
  serializationProperty: "locDescription",
  layout: "row"
}, {
  name: "descriptionLocation",
  default: "default",
  choices: ["default", "underInput", "underTitle"]
}, {
  name: "showNumber:boolean",
  dependsOn: "titleLocation",
  default: true,
  visibleIf: function(obj) {
    if (!obj) {
      return true;
    }
    if (obj.titleLocation === "hidden") {
      return false;
    }
    var parent = obj ? obj.parent : null;
    var numberingAllowedByParent = !parent || parent.showQuestionNumbers !== "off";
    if (!numberingAllowedByParent) {
      return false;
    }
    var survey = obj ? obj.survey : null;
    return !survey || survey.showQuestionNumbers !== "off" || !!parent && parent.showQuestionNumbers === "onpanel";
  }
}, {
  name: "hideNumber:boolean",
  visible: false,
  isSerializable: false
}, {
  name: "valueName",
  onSettingValue: (obj, val) => {
    return makeNameValid(val);
  }
}, "enableIf:condition", "resetValueIf:condition", "setValueIf:condition", "setValueExpression:expression", "defaultValue:value", {
  name: "defaultValueExpression:expression",
  category: "logic"
}, "correctAnswer:value", {
  name: "clearIfInvisible",
  default: "default",
  choices: ["default", "none", "onComplete", "onHidden", "onHiddenContainer"]
}, {
  name: "isRequired:switch",
  overridingProperty: "requiredIf"
}, "requiredIf:condition", {
  name: "requiredErrorText:text",
  serializationProperty: "locRequiredErrorText"
}, {
  name: "errorLocation",
  default: "default",
  choices: ["default", "top", "bottom"]
}, {
  name: "readOnly:switch",
  overridingProperty: "enableIf"
}, {
  name: "validators:validators",
  baseClassName: "surveyvalidator",
  classNamePart: "validator"
}, {
  name: "bindings:bindings",
  serializationProperty: "bindings",
  isSerializableFunc: (obj) => !obj.isBindingEmpty(),
  visibleIf: function(obj) {
    return obj.bindings.getNames().length > 0;
  }
}, {
  name: "renderAs",
  default: "default",
  visible: false
}, {
  name: "showCommentArea",
  visible: false,
  default: false,
  alternativeName: "hasComment",
  category: "general"
}, {
  name: "commentText",
  dependsOn: "showCommentArea",
  visibleIf: function(obj) {
    return obj.showCommentArea;
  },
  serializationProperty: "locCommentText"
}, {
  name: "commentPlaceholder",
  alternativeName: "commentPlaceHolder",
  serializationProperty: "locCommentPlaceholder",
  dependsOn: "showCommentArea",
  visibleIf: function(obj) {
    return obj.hasComment;
  }
}, {
  name: "defaultDisplayValue",
  serializationProperty: "locDefaultDisplayValue"
}]);
Serializer.addAlterNativeClassName("question", "questionbase");
var ItemValue = class _ItemValue extends BaseAction {
  getMarkdownHtml(text, name) {
    return !!this.locOwner ? this.locOwner.getMarkdownHtml(text, name) : void 0;
  }
  getRenderer(name) {
    return !!this.locOwner ? this.locOwner.getRenderer(name) : null;
  }
  getRendererContext(locStr) {
    return !!this.locOwner ? this.locOwner.getRendererContext(locStr) : locStr;
  }
  getProcessedText(text) {
    return this.locOwner ? this.locOwner.getProcessedText(text) : text;
  }
  static get Separator() {
    return settings.itemValueSeparator;
  }
  static set Separator(val) {
    settings.itemValueSeparator = val;
  }
  /**
   * Resets the input array and fills it with values from the values array
   */
  static setData(items, values, type) {
    items.length = 0;
    for (let i = 0; i < values.length; i++) {
      const value = values[i];
      const itemType = !!value && typeof value.getType === "function" ? value.getType() : type !== null && type !== void 0 ? type : "itemvalue";
      const item = Serializer.createClass(itemType);
      item.setData(value);
      if (!!value.originalItem) {
        item.originalItem = value.originalItem;
      }
      items.push(item);
    }
  }
  static getData(items) {
    var result = [];
    for (var i = 0; i < items.length; i++) {
      result.push(items[i].getData());
    }
    return result;
  }
  static getItemByValue(items, val) {
    if (!Array.isArray(items)) return null;
    const valIsEmpty = Helpers.isValueEmpty(val);
    for (var i = 0; i < items.length; i++) {
      if (valIsEmpty && Helpers.isValueEmpty(items[i].value)) return items[i];
      if (Helpers.isTwoValueEquals(items[i].value, val, false, true, false)) return items[i];
    }
    return null;
  }
  static getTextOrHtmlByValue(items, val) {
    var item = _ItemValue.getItemByValue(items, val);
    return item !== null ? item.textOrHtml : "";
  }
  static locStrsChanged(items) {
    for (var i = 0; i < items.length; i++) {
      items[i].locStrsChanged();
    }
  }
  static runConditionsForItems(items, filteredItems, runner, values, properties, useItemExpression = true, onItemCallBack) {
    return _ItemValue.runConditionsForItemsCore(items, filteredItems, runner, values, properties, true, useItemExpression, onItemCallBack);
  }
  static runEnabledConditionsForItems(items, runner, values, properties, onItemCallBack) {
    return _ItemValue.runConditionsForItemsCore(items, null, runner, values, properties, false, true, onItemCallBack);
  }
  static runConditionsForItemsCore(items, filteredItems, runner, values, properties, isVisible, useItemExpression = true, onItemCallBack) {
    if (!values) {
      values = {};
    }
    var itemValue = values["item"];
    var choiceValue = values["choice"];
    var hasChanded = false;
    for (var i = 0; i < items.length; i++) {
      var item = items[i];
      values["item"] = item.value;
      values["choice"] = item.value;
      var itemRunner = useItemExpression && !!item.getConditionRunner ? item.getConditionRunner(isVisible) : false;
      if (!itemRunner) {
        itemRunner = runner;
      }
      var newValue = true;
      if (itemRunner) {
        newValue = itemRunner.run(values, properties);
      }
      if (!!onItemCallBack) {
        newValue = onItemCallBack(item, newValue);
      }
      if (!!filteredItems && newValue) {
        filteredItems.push(item);
      }
      var oldValue = isVisible ? item.isVisible : item.isEnabled;
      if (newValue != oldValue) {
        hasChanded = true;
        if (isVisible) {
          if (!!item.setIsVisible) item.setIsVisible(newValue);
        } else {
          if (!!item.setIsEnabled) item.setIsEnabled(newValue);
        }
      }
    }
    if (itemValue) {
      values["item"] = itemValue;
    } else {
      delete values["item"];
    }
    if (choiceValue) {
      values["choice"] = choiceValue;
    } else {
      delete values["choice"];
    }
    return hasChanded;
  }
  constructor(value, text = null, typeName = "itemvalue") {
    super();
    this.typeName = typeName;
    this.ownerPropertyName = "";
    if (text) this.locText.text = text;
    if (!!value && typeof value === "object") {
      this.setData(value, true);
    } else {
      this.setValue(value, true);
    }
    if (this.getType() != "itemvalue") {
      CustomPropertiesCollection.createProperties(this);
    }
    this.data = this;
    this.onCreating();
  }
  onCreating() {
  }
  getType() {
    return !!this.typeName ? this.typeName : "itemvalue";
  }
  getSurvey(live = false) {
    return !!this.locOwner && !!this.locOwner["getSurvey"] ? this.locOwner.getSurvey() : null;
  }
  getLocale() {
    return !!this.locOwner && this.locOwner.getLocale ? this.locOwner.getLocale() : "";
  }
  get isInternal() {
    return this.isGhost === true;
  }
  createLocText() {
    const res = new LocalizableString(this, true, "text");
    res.onStrChanged = (oldValue, newValue) => {
      this.propertyValueChanged("text", oldValue, newValue);
    };
    res.onGetTextCallback = (txt) => {
      return txt || this.getValueText();
    };
    return res;
  }
  getValueText() {
    const val = this.value;
    return !Helpers.isValueEmpty(val) ? val.toString() : null;
  }
  get locText() {
    if (!this.locTextValue) {
      this.locTextValue = this.createLocText();
    }
    return this.locTextValue;
  }
  setLocText(locText) {
    this.locTextValue = locText;
  }
  get locOwner() {
    return this._locOwner;
  }
  set locOwner(value) {
    this._locOwner = value;
  }
  get value() {
    return this.getPropertyValue("value");
  }
  set value(newValue) {
    this.setValue(newValue, false);
  }
  setValue(newValue, newItem) {
    let text = void 0;
    if (!Helpers.isValueEmpty(newValue)) {
      var str = newValue.toString();
      var index = str.indexOf(settings.itemValueSeparator);
      if (index > -1) {
        newValue = str.slice(0, index);
        text = str.slice(index + 1);
      }
    }
    if (newItem) {
      this.setPropertyValueDirectly("value", newValue);
    } else {
      this.setPropertyValue("value", newValue);
    }
    if (!!text) {
      this.text = text;
    }
    this.id = this.value;
  }
  get hasText() {
    return this.pureText ? true : false;
  }
  get pureText() {
    var _a;
    return ((_a = this.locTextValue) === null || _a === void 0 ? void 0 : _a.pureText) || "";
  }
  set pureText(val) {
    this.text = val;
  }
  get text() {
    return this.calculatedText;
  }
  set text(newText) {
    this.locText.text = newText;
  }
  get textOrHtml() {
    if (this.locTextValue) return this.locText.textOrHtml;
    return this.getValueText();
  }
  get calculatedText() {
    if (this.locTextValue) return this.locText.calculatedText;
    return this.getValueText();
  }
  get shortcutText() {
    return this.text;
  }
  canSerializeValue() {
    const val = this.value;
    if (val === void 0 || val === null) return false;
    return !Array.isArray(val) && typeof val !== "object";
  }
  getData() {
    var json2 = this.toJSON();
    if (!!json2["value"] && !!json2["value"]["pos"]) {
      delete json2["value"]["pos"];
    }
    if (Helpers.isValueEmpty(json2.value)) return json2;
    const canSerializeVal = this.canSerializeValue();
    const canSerializeAsContant = !canSerializeVal || !settings.serialization.itemValueSerializeAsObject && !settings.serialization.itemValueSerializeDisplayText;
    if (canSerializeAsContant && Object.keys(json2).length == 1) return this.value;
    if (settings.serialization.itemValueSerializeDisplayText && json2.text === void 0 && canSerializeVal) {
      json2.text = this.value.toString();
    }
    return json2;
  }
  toJSON() {
    var res = {};
    var properties = Serializer.getProperties(this.getType());
    if (!properties || properties.length == 0) {
      properties = Serializer.getProperties("itemvalue");
    }
    var jsoObj = new JsonObject();
    for (var i = 0; i < properties.length; i++) {
      const prop = properties[i];
      if (prop.name === "text" && (!this.locTextValue || !this.locTextValue.hasNonDefaultText() && Helpers.isTwoValueEquals(this.value, this.locTextValue.getLocaleText(""), false, true, false))) continue;
      jsoObj.valueToJson(this, res, prop);
    }
    return res;
  }
  setData(value, isNewItem) {
    var _a;
    if (Helpers.isValueEmpty(value)) return;
    if (typeof value.value === "undefined" && typeof value.text !== "undefined" && Object.keys(value).length === 1) {
      value.value = value.text;
    }
    if (typeof value.value !== "undefined") {
      let json2;
      if (typeof value.toJSON === "function") {
        json2 = value.toJSON();
      } else {
        json2 = value;
      }
      new JsonObject().toObject(json2, this);
    } else {
      this.setValue(value, isNewItem);
    }
    if (!isNewItem) {
      (_a = this.locTextValue) === null || _a === void 0 ? void 0 : _a.strChanged();
    }
  }
  get visibleIf() {
    return this.getPropertyValueWithoutDefault("visibleIf") || "";
  }
  set visibleIf(val) {
    this.setPropertyValue("visibleIf", val);
  }
  get enableIf() {
    return this.getPropertyValueWithoutDefault("enableIf") || "";
  }
  set enableIf(val) {
    this.setPropertyValue("enableIf", val);
  }
  get isVisible() {
    const res = this.getPropertyValueWithoutDefault("isVisible");
    return res !== void 0 ? res : true;
  }
  setIsVisible(val) {
    this.setPropertyValue("isVisible", val);
  }
  get isEnabled() {
    const res = this.getPropertyValueWithoutDefault("isEnabled");
    return res !== void 0 ? res : true;
  }
  setIsEnabled(val) {
    this.setPropertyValue("isEnabled", val);
  }
  addUsedLocales(locales) {
    if (this.locTextValue) {
      this.AddLocStringToUsedLocales(this.locTextValue, locales);
    }
  }
  locStrsChanged() {
    var _a;
    super.locStrsChanged();
    (_a = this.locTextValue) === null || _a === void 0 ? void 0 : _a.strChanged();
  }
  onPropertyValueChanged(name, oldValue, newValue) {
    var _a;
    if (name === "value" && !this.hasText) {
      (_a = this.locTextValue) === null || _a === void 0 ? void 0 : _a.strChanged();
    }
    var funcName = "itemValuePropertyChanged";
    if (!this.locOwner || !this.locOwner[funcName]) return;
    this.locOwner[funcName](this, name, oldValue, newValue);
  }
  getConditionRunner(isVisible) {
    if (isVisible) return this.getVisibleConditionRunner();
    return this.getEnableConditionRunner();
  }
  getVisibleConditionRunner() {
    if (!this.visibleIf) return null;
    if (!this.visibleConditionRunner) this.visibleConditionRunner = new ConditionRunner(this.visibleIf);
    this.visibleConditionRunner.expression = this.visibleIf;
    return this.visibleConditionRunner;
  }
  getEnableConditionRunner() {
    if (!this.enableIf) return null;
    if (!this.enableConditionRunner) this.enableConditionRunner = new ConditionRunner(this.enableIf);
    this.enableConditionRunner.expression = this.enableIf;
    return this.enableConditionRunner;
  }
  get selected() {
    const locOwner = this._locOwner;
    if (locOwner instanceof Question && locOwner.isItemSelected && this.selectedValue === void 0) {
      this.selectedValue = new ComputedUpdater(() => locOwner.isItemSelected(this));
    }
    return this.selectedValue;
  }
  getComponent() {
    if (this._locOwner instanceof Question) {
      return this.componentValue || this._locOwner.itemComponent;
    }
    return this.componentValue;
  }
  setComponent(val) {
    this.componentValue = val;
  }
  setRootElement(val) {
    this._htmlElement = val;
  }
  getRootElement() {
    return this._htmlElement;
  }
  getEnabled() {
    return this.isEnabled;
  }
  setEnabled(val) {
    this.setIsEnabled(val);
  }
  getVisible() {
    const isVisible = this.isVisible === void 0 ? true : this.isVisible;
    const visible = this._visible === void 0 ? true : this._visible;
    return isVisible && visible;
  }
  setVisible(val) {
    if (this.visible !== val) {
      this._visible = val;
    }
  }
  get _visible() {
    return this.getPropertyValue("visible", true);
  }
  set _visible(val) {
    this.setPropertyValue("visible", val);
  }
  getLocTitle() {
    return this.locText;
  }
  getTitle() {
    return this.text;
  }
  setLocTitle(val) {
  }
  setTitle(val) {
  }
  get icon() {
    return this.getPropertyValue("icon", "");
  }
  set icon(val) {
    this.setPropertyValue("icon", val);
  }
};
__decorate([property()], ItemValue.prototype, "selectedValue", void 0);
Base.createItemValue = function(source, type) {
  var item = null;
  if (!!type) {
    item = JsonObject.metaData.createClass(type, {});
  } else if (typeof source.getType === "function") {
    item = new ItemValue(null, void 0, source.getType());
  } else {
    item = new ItemValue(null);
  }
  item.setData(source);
  return item;
};
Base.itemValueLocStrChanged = function(arr) {
  ItemValue.locStrsChanged(arr);
};
JsonObjectProperty.getItemValuesDefaultValue = (val, type) => {
  const res = new Array();
  ItemValue.setData(res, Array.isArray(val) ? val : [], type);
  return res;
};
Serializer.addClass("itemvalue", [{
  name: "!value",
  isUnique: true
}, {
  name: "text",
  serializationProperty: "locText"
}, {
  name: "visibleIf:condition",
  locationInTable: "detail"
}, {
  name: "enableIf:condition",
  locationInTable: "detail",
  visibleIf: (obj) => {
    return !obj || obj.ownerPropertyName !== "rateValues";
  }
}], (value) => new ItemValue(value));
var CalculatedValue = class extends Base {
  constructor(name = null, expression = null) {
    super();
    this.expressionIsRunning = false;
    this.isCalculated = false;
    if (!!name) {
      this.name = name;
    }
    if (!!expression) {
      this.expression = expression;
    }
  }
  setOwner(data) {
    this.data = data;
    this.rerunExpression();
  }
  getType() {
    return "calculatedvalue";
  }
  getSurvey(live = false) {
    return !!this.data && !!this.data["getSurvey"] ? this.data.getSurvey() : null;
  }
  get owner() {
    return this.data;
  }
  /**
   * The calculated value name. It should be non empty and unique.
   */
  get name() {
    return this.getPropertyValue("name") || "";
  }
  set name(val) {
    this.setPropertyValue("name", val);
  }
  /**
   * Set this property to true to include the non-empty calculated value into survey result, survey.data property.
   */
  get includeIntoResult() {
    return this.getPropertyValue("includeIntoResult");
  }
  set includeIntoResult(val) {
    this.setPropertyValue("includeIntoResult", val);
  }
  /**
   * The Expression that used to calculate the value. You may use standard operators like +, -, * and /, squares (). Here is the example of accessing the question value {questionname}.
   * Example: "({quantity} * {price}) * (100 - {discount}) / 100"
   */
  get expression() {
    return this.getPropertyValue("expression") || "";
  }
  set expression(val) {
    this.setPropertyValue("expression", val);
    this.rerunExpression();
  }
  locCalculation() {
    this.expressionIsRunning = true;
  }
  unlocCalculation() {
    this.expressionIsRunning = false;
  }
  resetCalculation() {
    this.isCalculated = false;
  }
  doCalculation(calculatedValues, values, properties) {
    if (this.isCalculated) return;
    this.runExpressionCore(calculatedValues, values, properties);
    this.isCalculated = true;
  }
  runExpression(values, properties) {
    this.runExpressionCore(null, values, properties);
  }
  get value() {
    if (!this.data) return void 0;
    return this.data.getVariable(this.name);
  }
  setValue(val) {
    if (!this.data) return;
    this.data.setVariable(this.name, val);
  }
  get canRunExpression() {
    return !!this.data && !this.isLoadingFromJson && !!this.expression && !this.expressionIsRunning && !!this.name;
  }
  rerunExpression() {
    if (!this.canRunExpression) return;
    this.runExpression(this.data.getFilteredValues(), this.data.getFilteredProperties());
  }
  runExpressionCore(calculatedValues, values, properties) {
    if (!this.canRunExpression) return;
    this.ensureExpression(values);
    this.locCalculation();
    if (!!calculatedValues) {
      this.runDependentExpressions(calculatedValues, values, properties);
    }
    this.expressionRunner.run(values, properties);
  }
  runDependentExpressions(calculatedValues, values, properties) {
    var variables = this.expressionRunner.getVariables();
    if (!variables) return;
    for (var i = 0; i < calculatedValues.length; i++) {
      var calcItem = calculatedValues[i];
      if (calcItem === this || variables.indexOf(calcItem.name) < 0) continue;
      calcItem.doCalculation(calculatedValues, values, properties);
      values[calcItem.name] = calcItem.value;
    }
  }
  ensureExpression(values) {
    if (!!this.expressionRunner) return;
    this.expressionRunner = new ExpressionRunner(this.expression);
    this.expressionRunner.onRunComplete = (newValue) => {
      if (!Helpers.isTwoValueEquals(newValue, this.value, false, true, false)) {
        this.setValue(newValue);
      }
      this.unlocCalculation();
    };
  }
};
Serializer.addClass("calculatedvalue", [{
  name: "!name",
  isUnique: true
}, "expression:expression", "includeIntoResult:boolean"], function() {
  return new CalculatedValue();
}, "base");
var ExpressionItem = class extends Base {
  constructor(expression = null) {
    super();
    this.expression = expression;
  }
  getType() {
    return "expressionitem";
  }
  runCondition(values, properties) {
    if (!this.expression) return false;
    return new ConditionRunner(this.expression).run(values, properties);
  }
  /**
   * The expression property. If this expression returns true, then survey will use html property to show on complete page.
   */
  get expression() {
    return this.getPropertyValue("expression", "");
  }
  set expression(val) {
    this.setPropertyValue("expression", val);
  }
  get locHtml() {
    return this.getLocalizableString("html");
  }
  getLocale() {
    return !!this.locOwner ? this.locOwner.getLocale() : "";
  }
  getMarkdownHtml(text, name) {
    return !!this.locOwner ? this.locOwner.getMarkdownHtml(text, name) : void 0;
  }
  getRenderer(name) {
    return !!this.locOwner ? this.locOwner.getRenderer(name) : null;
  }
  getRendererContext(locStr) {
    return !!this.locOwner ? this.locOwner.getRendererContext(locStr) : locStr;
  }
  getProcessedText(text) {
    return this.locOwner ? this.locOwner.getProcessedText(text) : text;
  }
  getSurvey(isLive = false) {
    return this.locOwner;
  }
};
var HtmlConditionItem = class extends ExpressionItem {
  constructor(expression = null, html = null) {
    super(expression);
    this.createLocalizableString("html", this);
    this.html = html;
  }
  getType() {
    return "htmlconditionitem";
  }
  /**
   * The html that shows on completed ('Thank you') page. The expression should return true
   * @see expression
   */
  get html() {
    return this.getLocalizableStringText("html");
  }
  set html(value) {
    this.setLocalizableStringText("html", value);
  }
  get locHtml() {
    return this.getLocalizableString("html");
  }
};
var UrlConditionItem = class extends ExpressionItem {
  constructor(expression = null, url = null) {
    super(expression);
    this.createLocalizableString("url", this);
    this.url = url;
  }
  getType() {
    return "urlconditionitem";
  }
  /**
   * The url that survey navigates to on completing the survey. The expression should return true
   * @see expression
   */
  get url() {
    return this.getLocalizableStringText("url");
  }
  set url(value) {
    this.setLocalizableStringText("url", value);
  }
  get locUrl() {
    return this.getLocalizableString("url");
  }
};
Serializer.addClass("expressionitem", ["expression:condition"], function() {
  return new ExpressionItem();
}, "base");
Serializer.addClass("htmlconditionitem", [{
  name: "html:html",
  serializationProperty: "locHtml"
}], function() {
  return new HtmlConditionItem();
}, "expressionitem");
Serializer.addClass("urlconditionitem", [{
  name: "url:string",
  serializationProperty: "locUrl"
}], function() {
  return new UrlConditionItem();
}, "expressionitem");
var XmlParser = class {
  constructor() {
    this.parser = new DOMParser();
  }
  assignValue(target, name, value) {
    if (Array.isArray(target[name])) {
      target[name].push(value);
    } else if (target[name] !== void 0) {
      target[name] = [target[name]].concat(value);
    } else if (typeof value === "object" && Object.keys(value).length === 1 && Object.keys(value)[0] === name) {
      target[name] = value[name];
    } else {
      target[name] = value;
    }
  }
  xml2Json(xmlNode, result) {
    if (xmlNode.children && xmlNode.children.length > 0) {
      for (let i = 0; i < xmlNode.children.length; i++) {
        let childNode = xmlNode.children[i];
        let childObject = {};
        this.xml2Json(childNode, childObject);
        this.assignValue(result, childNode.nodeName, childObject);
      }
    } else {
      this.assignValue(result, xmlNode.nodeName, xmlNode.textContent);
    }
  }
  parseXmlString(xmlString) {
    let xmlRoot = this.parser.parseFromString(xmlString, "text/xml");
    let json2 = {};
    this.xml2Json(xmlRoot, json2);
    return json2;
  }
};
var ChoicesRestful = class _ChoicesRestful extends Base {
  static get EncodeParameters() {
    return settings.web.encodeUrlParams;
  }
  static set EncodeParameters(val) {
    settings.web.encodeUrlParams = val;
  }
  static clearCache() {
    _ChoicesRestful.itemsResult = {};
    _ChoicesRestful.sendingSameRequests = {};
  }
  static addSameRequest(obj) {
    if (!obj.isUsingCache) return false;
    var hash = obj.objHash;
    var res = _ChoicesRestful.sendingSameRequests[hash];
    if (!res) {
      _ChoicesRestful.sendingSameRequests[obj.objHash] = [];
      return false;
    }
    res.push(obj);
    obj.isRunningValue = true;
    return true;
  }
  static unregisterSameRequests(obj, items) {
    if (!obj.isUsingCache) return;
    var res = _ChoicesRestful.sendingSameRequests[obj.objHash];
    delete _ChoicesRestful.sendingSameRequests[obj.objHash];
    if (!res) return;
    for (var i = 0; i < res.length; i++) {
      res[i].isRunningValue = false;
      if (!!res[i].getResultCallback) {
        res[i].getResultCallback(items);
      }
    }
  }
  static get onBeforeSendRequest() {
    return settings.web.onBeforeRequestChoices;
  }
  static set onBeforeSendRequest(val) {
    settings.web.onBeforeRequestChoices = val;
  }
  static getCachedItemsResult(obj) {
    var hash = obj.objHash;
    var res = _ChoicesRestful.itemsResult[hash];
    if (!res) return false;
    if (obj.getResultCallback) {
      obj.getResultCallback(res);
    }
    return true;
  }
  constructor() {
    super();
    this.lastObjHash = "";
    this.isRunningValue = false;
    this.processedUrl = "";
    this.processedPath = "";
    this.isUsingCacheFromUrl = void 0;
    this.error = null;
    this.createItemValue = (value) => {
      return new ItemValue(value);
    };
    this.registerPropertyChangedHandlers(["url"], () => {
      if (this.owner) this.owner.setPropertyValue("isUsingRestful", !!this.url);
    });
  }
  getSurvey(live = false) {
    return !!this.owner ? this.owner.survey : null;
  }
  run(textProcessor = null) {
    if (!this.url || !this.getResultCallback) return;
    this.processedText(textProcessor);
    if (!this.processedUrl) {
      this.doEmptyResultCallback({});
      this.lastObjHash = this.objHash;
      return;
    }
    if (this.lastObjHash === this.objHash) return;
    this.lastObjHash = this.objHash;
    this.error = null;
    if (this.useChangedItemsResults()) return;
    if (_ChoicesRestful.addSameRequest(this)) return;
    this.sendRequest();
  }
  get isUsingCache() {
    if (this.isUsingCacheFromUrl === true) return true;
    if (this.isUsingCacheFromUrl === false) return false;
    return settings.web.cacheLoadedChoices;
  }
  get isRunning() {
    return this.getIsRunning();
  }
  getIsRunning() {
    return this.isRunningValue;
  }
  get isWaitingForParameters() {
    return this.url && !this.processedUrl;
  }
  useChangedItemsResults() {
    return _ChoicesRestful.getCachedItemsResult(this);
  }
  doEmptyResultCallback(serverResult) {
    var items = [];
    if (this.updateResultCallback) {
      items = this.updateResultCallback(items, serverResult);
    }
    this.getResultCallback(items);
  }
  processedText(textProcessor) {
    var urlText = this.url;
    if (!!urlText) {
      urlText = urlText.replace(_ChoicesRestful.cacheText, "").replace(_ChoicesRestful.noCacheText, "");
    }
    if (textProcessor) {
      var pUrl = textProcessor.processTextEx({
        text: urlText,
        runAtDesign: true
      });
      var pPath = textProcessor.processTextEx({
        text: this.path,
        runAtDesign: true
      });
      if (!pUrl.hasAllValuesOnLastRun || !pPath.hasAllValuesOnLastRun) {
        this.processedUrl = "";
        this.processedPath = "";
      } else {
        this.processedUrl = pUrl.text;
        this.processedPath = pPath.text;
      }
    } else {
      this.processedUrl = urlText;
      this.processedPath = this.path;
    }
    if (this.onProcessedUrlCallback) {
      this.onProcessedUrlCallback(this.processedUrl, this.processedPath);
    }
  }
  parseResponse(response) {
    let parsedResponse;
    if (!!response && typeof response.indexOf === "function" && response.indexOf("<") === 0) {
      var parser = new XmlParser();
      parsedResponse = parser.parseXmlString(response);
    } else {
      try {
        parsedResponse = JSON.parse(response);
      } catch (_a) {
        parsedResponse = (response || "").split("\n").map((s) => s.trim(" ")).filter((s) => !!s);
      }
    }
    return parsedResponse;
  }
  sendRequest() {
    var xhr = new XMLHttpRequest();
    xhr.open("GET", this.processedUrl);
    xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
    var self2 = this;
    var loadingObjHash = this.objHash;
    xhr.onload = function() {
      self2.beforeLoadRequest();
      if (xhr.status === 200) {
        self2.onLoad(self2.parseResponse(xhr.response), loadingObjHash);
      } else {
        self2.onError(xhr.statusText, xhr.responseText);
      }
    };
    var options = {
      request: xhr
    };
    if (!!settings.web.onBeforeRequestChoices) {
      settings.web.onBeforeRequestChoices(this, options);
    }
    this.beforeSendRequest();
    options.request.send();
  }
  getType() {
    return "choicesByUrl";
  }
  get isEmpty() {
    return !this.url && !this.path;
  }
  getCustomPropertiesNames() {
    var properties = this.getCustomProperties();
    var res = new Array();
    for (var i = 0; i < properties.length; i++) {
      res.push(this.getCustomPropertyName(properties[i].name));
    }
    return res;
  }
  getCustomPropertyName(propertyName) {
    return propertyName + "Name";
  }
  getCustomProperties() {
    var properties = Serializer.getProperties(this.itemValueType);
    var res = [];
    for (var i = 0; i < properties.length; i++) {
      if (properties[i].name === "value" || properties[i].name === "text" || properties[i].name === "visibleIf" || properties[i].name === "enableIf") continue;
      res.push(properties[i]);
    }
    return res;
  }
  getAllPropertiesNames() {
    const res = new Array();
    Serializer.getPropertiesByObj(this).forEach((prop) => res.push(prop.name));
    this.getCustomPropertiesNames().forEach((prop) => res.push(prop));
    return res;
  }
  setData(json2) {
    if (!json2) json2 = {};
    this.getAllPropertiesNames().forEach((name) => {
      this[name] = json2[name];
    });
  }
  getData() {
    const res = {};
    let hasValue = false;
    this.getAllPropertiesNames().forEach((name) => {
      const val = this[name];
      if (!this.isValueEmpty(val) && val !== this.getDefaultPropertyValue(name)) {
        res[name] = val;
        hasValue = true;
      }
    });
    return hasValue ? res : null;
  }
  /**
   * A RESTful service's URL.
   *
   * This property supports [dynamic URLs](https://surveyjs.io/Documentation/Library?id=design-survey-conditional-logic#dynamic-texts). For example, the URL below depends on the `region` question's value. When the value changes, the survey automatically loads a new dataset that corresponds to the selected region.
   *
   * ```js
   * url: "https://surveyjs.io/api/CountriesExample?region={region}"
   * ```
   *
   * [View Demo](https://surveyjs.io/Examples/Library/?id=questiontype-dropdownrestfull (linkStyle))
   * @see path
   * @see valueName
   * @see titleName
   */
  get url() {
    return this.getPropertyValue("url") || "";
  }
  set url(val) {
    this.setPropertyValue("url", val);
    this.isUsingCacheFromUrl = void 0;
    if (!val) return;
    if (val.indexOf(_ChoicesRestful.cacheText) > -1) {
      this.isUsingCacheFromUrl = true;
    } else {
      if (val.indexOf(_ChoicesRestful.noCacheText) > -1) {
        this.isUsingCacheFromUrl = false;
      }
    }
  }
  /**
   * Path to the array of choices. The following path separators are allowed: semicolon `;`, comma `,`.
   *
   * Specify this property only if the array of choices is nested within the object returned by the service. For example, the service returns the following object:
   *
   * ```js
   * {
   *   countries: [ ... ],
   *   capitals: [ ... ]
   * }
   * ```
   *
   * To populate choices with values from the `countries` array, set the `path` property to `"countries"`. To use the `capitals` array, set this property to `"capitals"`.
   * @see url
   * @see valueName
   * @see titleName
   */
  get path() {
    return this.getPropertyValue("path") || "";
  }
  set path(val) {
    this.setPropertyValue("path", val);
  }
  /**
   * Specifies which property in the obtained data object contains choice values.
   *
   * [View Demo](https://surveyjs.io/Examples/Library/?id=questiontype-dropdownrestfull (linkStyle))
   *
   * @see url
   * @see path
   * @see titleName
   */
  get valueName() {
    return this.getPropertyValue("valueName", "");
  }
  set valueName(val) {
    this.setPropertyValue("valueName", val);
  }
  /**
   * Specifies which property in the obtained data object contains display texts for choices.
   *
   * @see url
   * @see path
   * @see valueName
   */
  get titleName() {
    return this.getPropertyValue("titleName", "");
  }
  set titleName(val) {
    this.setPropertyValue("titleName", val);
  }
  /**
   * Specifies which property in the obtained data object contains image URLs. Used only in [Image Picker](https://surveyjs.io/Examples/Library?id=questiontype-imagepicker) questions.
   *
   * @see url
   * @see path
   * @see valueName
   */
  get imageLinkName() {
    return this.getPropertyValue("imageLinkName", "");
  }
  set imageLinkName(val) {
    this.setPropertyValue("imageLinkName", val);
  }
  /**
   * Specifies whether the service is allowed to return an empty response or an empty array in a response.
   *
   * Default value: `false`
   */
  get allowEmptyResponse() {
    return this.getPropertyValue("allowEmptyResponse");
  }
  set allowEmptyResponse(val) {
    this.setPropertyValue("allowEmptyResponse", val);
  }
  get attachOriginalItems() {
    return this.getPropertyValue("attachOriginalItems");
  }
  set attachOriginalItems(val) {
    this.setPropertyValue("attachOriginalItems", val);
  }
  get itemValueType() {
    if (!this.owner) return "itemvalue";
    var prop = Serializer.findProperty(this.owner.getType(), "choices");
    if (!prop) return "itemvalue";
    if (prop.type == "itemvalue[]") return "itemvalue";
    return prop.type;
  }
  clear() {
    this.setData(void 0);
  }
  beforeSendRequest() {
    this.isRunningValue = true;
    if (!!this.beforeSendRequestCallback) {
      this.beforeSendRequestCallback();
    }
  }
  beforeLoadRequest() {
    this.isRunningValue = false;
  }
  onLoad(result, loadingObjHash = null) {
    if (!loadingObjHash) {
      loadingObjHash = this.objHash;
    }
    var items = new Array();
    var updatedResult = this.getResultAfterPath(result);
    if (updatedResult && updatedResult["length"]) {
      for (var i = 0; i < updatedResult.length; i++) {
        var itemValue = updatedResult[i];
        if (!itemValue) continue;
        var value = !!this.getItemValueCallback ? this.getItemValueCallback(itemValue) : this.getValue(itemValue);
        var item = this.createItemValue(value);
        this.setTitle(item, itemValue);
        this.setCustomProperties(item, itemValue);
        if (this.attachOriginalItems) {
          item.originalItem = itemValue;
        }
        var imageLink = this.getImageLink(itemValue);
        if (!!imageLink) {
          item.imageLink = imageLink;
        }
        items.push(item);
      }
    } else {
      if (!this.allowEmptyResponse) {
        this.error = new WebRequestEmptyError(null, this.owner);
      }
    }
    if (this.updateResultCallback) {
      items = this.updateResultCallback(items, result);
    }
    if (this.isUsingCache) {
      _ChoicesRestful.itemsResult[loadingObjHash] = items;
    }
    this.callResultCallback(items, loadingObjHash);
    _ChoicesRestful.unregisterSameRequests(this, items);
  }
  callResultCallback(items, loadingObjHash) {
    if (loadingObjHash != this.objHash) return;
    this.getResultCallback(items);
  }
  setCustomProperties(item, itemValue) {
    var properties = this.getCustomProperties();
    for (var i = 0; i < properties.length; i++) {
      var prop = properties[i];
      var val = this.getValueCore(itemValue, this.getPropertyBinding(prop.name));
      if (!this.isValueEmpty(val)) {
        item[prop.name] = val;
      }
    }
  }
  getPropertyBinding(propertyName) {
    if (this[this.getCustomPropertyName(propertyName)]) return this[this.getCustomPropertyName(propertyName)];
    if (this[propertyName]) return this[propertyName];
    return propertyName;
  }
  onError(status, response) {
    this.error = new WebRequestError(status, response, this.owner);
    this.doEmptyResultCallback(response);
    _ChoicesRestful.unregisterSameRequests(this, []);
  }
  getResultAfterPath(result) {
    if (!result) return result;
    if (!this.processedPath) return result;
    var pathes = this.getPathes();
    for (var i = 0; i < pathes.length; i++) {
      result = result[pathes[i]];
      if (!result) return null;
    }
    return result;
  }
  getPathes() {
    var pathes = [];
    if (this.processedPath.indexOf(";") > -1) {
      pathes = this.path.split(";");
    } else if (this.processedPath.indexOf(",") > -1) {
      pathes = this.processedPath.split(",");
    } else {
      pathes = this.processedPath.split(".");
    }
    if (pathes.length == 0) pathes.push(this.processedPath);
    return pathes;
  }
  getValue(item) {
    if (!item) return null;
    if (this.valueName) return this.getValueCore(item, this.valueName);
    if (!(item instanceof Object)) return item;
    var len = Object.keys(item).length;
    if (len < 1) return null;
    return item[Object.keys(item)[0]];
  }
  setTitle(item, itemValue) {
    var title = this.titleName ? this.titleName : "title";
    var val = this.getValueCore(itemValue, title);
    if (!val) return;
    if (typeof val === "string") {
      item.text = val;
    } else {
      item.locText.setJson(val);
    }
  }
  getImageLink(item) {
    var imageLink = this.imageLinkName ? this.imageLinkName : "imageLink";
    return this.getValueCore(item, imageLink);
  }
  getValueCore(item, property2) {
    if (!item) return null;
    if (property2.indexOf(".") < 0) return item[property2];
    var properties = property2.split(".");
    for (var i = 0; i < properties.length; i++) {
      item = item[properties[i]];
      if (!item) return null;
    }
    return item;
  }
  get objHash() {
    return this.processedUrl + ";" + this.processedPath + ";" + this.valueName + ";" + this.titleName + ";" + this.imageLinkName;
  }
};
ChoicesRestful.cacheText = "{CACHE}";
ChoicesRestful.noCacheText = "{NOCACHE}";
ChoicesRestful.itemsResult = {};
ChoicesRestful.sendingSameRequests = {};
Serializer.addClass("choicesByUrl", ["url", "path", "valueName", "titleName", {
  name: "imageLinkName",
  visibleIf: function(obj) {
    return !!obj && !!obj.owner && obj.owner.getType() == "imagepicker";
  }
}, {
  name: "allowEmptyResponse:boolean"
}, {
  name: "attachOriginalItems:boolean",
  visible: false
}], function() {
  return new ChoicesRestful();
});
var QuestionMatrixBaseModel = class extends Question {
  createColumnValues() {
    return this.createItemValues("columns");
  }
  constructor(name) {
    super(name);
    this.generatedVisibleRows = null;
    this.generatedTotalRow = null;
    this.filteredRows = null;
    this.columns = this.createColumnValues();
    this.rows = this.createItemValues("rows");
  }
  getType() {
    return "matrixbase";
  }
  endLoadingFromJson() {
    super.endLoadingFromJson();
    this.updateVisibilityBasedOnRows();
  }
  get isCompositeQuestion() {
    return true;
  }
  /**
   * Specifies whether to display the table header that contains column captions.
   *
   * Default value: `true`
   */
  get showHeader() {
    return this.getPropertyValue("showHeader");
  }
  set showHeader(val) {
    this.setPropertyValue("showHeader", val);
  }
  /**
   * An array of matrix columns.
   *
   * For a Single-Select Matrix, the `columns` array can contain configuration objects with the `text` (display value) and `value` (value to be saved in survey results) properties. Alternatively, the array can contain primitive values that will be used as both the display values and values to be saved in survey results.
   *
   * [View "Single-Select Matrix" Demo](https://surveyjs.io/form-library/examples/single-selection-matrix-table-question/ (linkStyle))
   *
   * For a Multi-Select Matrix or Dynamic Matrix, the `columns` array should contain configuration objects with properties described in the [`MatrixDropdownColumn`](https://surveyjs.io/form-library/documentation/api-reference/multi-select-matrix-column-values) API Reference section.
   *
   * [View "Multi-Select Matrix" Demo](https://surveyjs.io/form-library/examples/questiontype-matrixdropdown/ (linkStyle))
   */
  get columns() {
    return this.getPropertyValue("columns");
  }
  set columns(newValue) {
    this.setPropertyValue("columns", newValue);
  }
  get visibleColumns() {
    const res = [];
    this.columns.forEach((col) => {
      if (this.isColumnVisible(col)) {
        res.push(col);
      }
    });
    return res;
  }
  isColumnVisible(column) {
    return column.isVisible;
  }
  /**
   * An array of matrix rows.
   *
   * This array can contain primitive values or objects with the `text` (display value) and `value` (value to be saved in survey results) properties.
   *
   * [View Demo](https://surveyjs.io/form-library/examples/single-selection-matrix-table-question/ (linkStyle))
   */
  get rows() {
    return this.getPropertyValue("rows");
  }
  set rows(newValue) {
    var newRows = this.processRowsOnSet(newValue);
    this.setPropertyValue("rows", newRows);
  }
  processRowsOnSet(newRows) {
    return newRows;
  }
  getVisibleRows() {
    return [];
  }
  /**
   * Returns an array of visible matrix rows.
   * @see rowsVisibleIf
   */
  get visibleRows() {
    return this.getVisibleRows();
  }
  /**
   * A Boolean expression that is evaluated against each matrix row. If the expression evaluates to `false`, the row becomes hidden.
   *
   * A survey parses and runs all expressions on startup. If any values used in the expression change, the survey re-evaluates it.
   *
   * Use the `{item}` placeholder to reference the current row in the expression.
   *
   * Refer to the following help topic for more information: [Conditional Visibility](https://surveyjs.io/form-library/documentation/design-survey-conditional-logic#conditional-visibility).
   * @see visibleRows
   * @see columnsVisibleIf
   */
  get rowsVisibleIf() {
    return this.getPropertyValue("rowsVisibleIf", "");
  }
  set rowsVisibleIf(val) {
    this.setPropertyValue("rowsVisibleIf", val);
    if (!this.isLoadingFromJsonValue) {
      this.runCondition(this.getDataFilteredValues(), this.getDataFilteredProperties());
    }
  }
  /**
   * A Boolean expression that is evaluated against each matrix column. If the expression evaluates to `false`, the column becomes hidden.
   *
   * A survey parses and runs all expressions on startup. If any values used in the expression change, the survey re-evaluates it.
   *
   * Use the `{item}` placeholder to reference the current column in the expression.
   *
   * Refer to the following help topic for more information: [Conditional Visibility](https://surveyjs.io/form-library/documentation/design-survey-conditional-logic#conditional-visibility).
   * @see rowsVisibleIf
   */
  get columnsVisibleIf() {
    return this.getPropertyValue("columnsVisibleIf", "");
  }
  set columnsVisibleIf(val) {
    this.setPropertyValue("columnsVisibleIf", val);
    if (!this.isLoadingFromJson) {
      this.runCondition(this.getDataFilteredValues(), this.getDataFilteredProperties());
    }
  }
  runConditionCore(values, properties) {
    super.runConditionCore(values, properties);
    this.runItemsCondition(values, properties);
  }
  onColumnsChanged() {
  }
  onRowsChanged() {
    this.updateVisibilityBasedOnRows();
    this.fireCallback(this.visibleRowsChangedCallback);
  }
  updateVisibilityBasedOnRows() {
    if (this.hideIfRowsEmpty) {
      this.onVisibleChanged();
    }
  }
  isVisibleCore() {
    var _a;
    const res = super.isVisibleCore();
    if (!res || !this.hideIfRowsEmpty) return res;
    return ((_a = this.visibleRows) === null || _a === void 0 ? void 0 : _a.length) > 0;
  }
  shouldRunColumnExpression() {
    return !this.survey || !this.survey.areInvisibleElementsShowing;
  }
  hasRowsAsItems() {
    return true;
  }
  runItemsCondition(values, properties) {
    let hasChanges = this.hasRowsAsItems() && this.runConditionsForRows(values, properties);
    const hasColumnsChanged = this.runConditionsForColumns(values, properties);
    hasChanges = hasColumnsChanged || hasChanges;
    if (hasChanges) {
      if (this.isClearValueOnHidden && hasColumnsChanged) {
        this.clearInvisibleColumnValues();
      }
      this.clearGeneratedRows();
      if (hasColumnsChanged) {
        this.onColumnsChanged();
      }
      this.onRowsChanged();
    }
  }
  isRowsFiltered() {
    return !!this.filteredRows;
  }
  clearGeneratedRows() {
    this.generatedVisibleRows = null;
  }
  createRowsVisibleIfRunner() {
    return null;
  }
  runConditionsForRows(values, properties) {
    const showInvisibile = !!this.survey && this.survey.areInvisibleElementsShowing;
    const runner = !showInvisibile ? this.createRowsVisibleIfRunner() : null;
    this.filteredRows = [];
    const hasChanged = ItemValue.runConditionsForItems(this.rows, this.filteredRows, runner, values, properties, !showInvisibile);
    ItemValue.runEnabledConditionsForItems(this.rows, void 0, values, properties);
    if (this.filteredRows.length === this.rows.length) {
      this.filteredRows = null;
    }
    return hasChanged;
  }
  runConditionsForColumns(values, properties) {
    const useColumnsExpression = !!this.survey && !this.survey.areInvisibleElementsShowing;
    const runner = useColumnsExpression && !!this.columnsVisibleIf ? new ConditionRunner(this.columnsVisibleIf) : null;
    return ItemValue.runConditionsForItems(this.columns, void 0, runner, values, properties, this.shouldRunColumnExpression());
  }
  clearInvisibleColumnValues() {
  }
  clearInvisibleValuesInRows() {
  }
  needResponsiveWidth() {
    return true;
  }
  get columnsAutoWidth() {
    return !this.isMobile && !this.columns.some((col) => !!col.width);
  }
  getTableCss() {
    var _a;
    return new CssClassBuilder().append(this.cssClasses.root).append(this.cssClasses.columnsAutoWidth, this.columnsAutoWidth).append(this.cssClasses.noHeader, !this.showHeader).append(this.cssClasses.hasFooter, !!((_a = this.renderedTable) === null || _a === void 0 ? void 0 : _a.showAddRowOnBottom)).append(this.cssClasses.rootAlternateRows, this.alternateRows).append(this.cssClasses.rootVerticalAlignTop, this.verticalAlign === "top").append(this.cssClasses.rootVerticalAlignMiddle, this.verticalAlign === "middle").toString();
  }
  /**
   * Minimum column width in CSS values.
   *
   * @see width
   */
  get columnMinWidth() {
    return this.getPropertyValue("columnMinWidth") || "";
  }
  set columnMinWidth(val) {
    this.setPropertyValue("columnMinWidth", val);
  }
  /**
   * A width for the column that displays row titles (first column). Accepts CSS values.
   */
  get rowTitleWidth() {
    return this.getPropertyValue("rowTitleWidth") || "";
  }
  set rowTitleWidth(val) {
    this.setPropertyValue("rowTitleWidth", val);
  }
  /**
   * Specifies how to arrange matrix questions.
   *
   * Possible values:
   *
   * - `"table"` - Displays matrix questions in a table.
   * - `"list"` - Displays matrix questions one under another as a list.
   * - `"auto"` (default) - Uses the `"table"` mode if the survey has sufficient width to fit the table or the `"list"` mode otherwise.
   */
  set displayMode(val) {
    this.setPropertyValue("displayMode", val);
  }
  get displayMode() {
    return this.getPropertyValue("displayMode");
  }
  //a11y
  getCellAriaLabel(rowTitle, columnTitle) {
    const row = (this.getLocalizationString("matrix_row") || "row").toLocaleLowerCase();
    const column = (this.getLocalizationString("matrix_column") || "column").toLocaleLowerCase();
    return `${row} ${rowTitle}, ${column} ${columnTitle}`;
  }
  get isNewA11yStructure() {
    return true;
  }
  // EO a11y
  getIsMobile() {
    if (this.displayMode == "auto") return super.getIsMobile();
    return this.displayMode === "list";
  }
};
__decorate([property()], QuestionMatrixBaseModel.prototype, "verticalAlign", void 0);
__decorate([property()], QuestionMatrixBaseModel.prototype, "alternateRows", void 0);
Serializer.addClass("matrixbase", [{
  name: "showCommentArea:switch",
  layout: "row",
  visible: true,
  category: "general"
}, "columnsVisibleIf:condition", "rowsVisibleIf:condition", "columnMinWidth", {
  name: "showHeader:boolean",
  default: true
}, {
  name: "verticalAlign",
  choices: ["top", "middle"],
  default: "middle"
}, {
  name: "alternateRows:boolean",
  default: false
}, {
  name: "displayMode",
  default: "auto",
  choices: ["auto", "table", "list"],
  visible: false
}], void 0, "question");
var TextPreProcessorItem = class {
};
var TextPreProcessorValue = class {
  constructor(name, returnDisplayValue) {
    this.name = name;
    this.returnDisplayValue = returnDisplayValue;
    this.isExists = false;
    this.canProcess = true;
  }
};
var TextPreProcessor = class {
  constructor() {
    this._unObservableValues = [void 0];
  }
  get hasAllValuesOnLastRunValue() {
    return this._unObservableValues[0];
  }
  set hasAllValuesOnLastRunValue(val) {
    this._unObservableValues[0] = val;
  }
  process(text, returnDisplayValue, doEncoding, replaceUndefinedValues) {
    this.hasAllValuesOnLastRunValue = true;
    if (!text) return text;
    if (!this.onProcess) return text;
    const items = this.getItems(text);
    for (let i = items.length - 1; i >= 0; i--) {
      const item = items[i];
      const name = this.getName(text.substring(item.start + 1, item.end));
      if (!!name) {
        const textValue = new TextPreProcessorValue(name, returnDisplayValue === true);
        this.onProcess(textValue);
        if (!textValue.isExists) {
          if (textValue.canProcess) {
            this.hasAllValuesOnLastRunValue = false;
          }
        }
        if (textValue.isExists || replaceUndefinedValues) {
          if (Helpers.isValueEmpty(textValue.value)) {
            this.hasAllValuesOnLastRunValue = false;
          }
          var replacedValue = !Helpers.isValueEmpty(textValue.value) ? textValue.value : "";
          if (doEncoding) {
            replacedValue = encodeURIComponent(replacedValue);
          }
          text = text.substring(0, item.start) + replacedValue + text.substring(item.end + 1);
        }
      }
    }
    return text;
  }
  processValue(name, returnDisplayValue) {
    var textValue = new TextPreProcessorValue(name, returnDisplayValue);
    if (!!this.onProcess) {
      this.onProcess(textValue);
    }
    return textValue;
  }
  get hasAllValuesOnLastRun() {
    return !!this.hasAllValuesOnLastRunValue;
  }
  processText(text, returnDisplayValue) {
    return this.process(text, returnDisplayValue);
  }
  processTextEx(params) {
    const res = {
      hasAllValuesOnLastRun: true,
      text: params.text
    };
    res.text = this.process(params.text, params.returnDisplayValue, params.doEncoding, params.replaceUndefinedValues);
    res.hasAllValuesOnLastRun = this.hasAllValuesOnLastRun;
    return res;
  }
  getItems(text) {
    var items = [];
    var length = text.length;
    var start = -1;
    var ch = "";
    for (var i = 0; i < length; i++) {
      ch = text[i];
      if (ch == "{") start = i;
      if (ch == "}") {
        if (start > -1) {
          var item = new TextPreProcessorItem();
          item.start = start;
          item.end = i;
          if (this.isValidItemName(text.substring(start + 1, i - 1))) {
            items.push(item);
          }
        }
        start = -1;
      }
    }
    return items;
  }
  isValidItemName(name) {
    return !!name && name.indexOf(":") < 0;
  }
  getName(name) {
    if (!name) return;
    return name.trim();
  }
};
var QuestionTextProcessor = class {
  constructor(variableName) {
    this.variableName = variableName;
    this.textPreProcessor = new TextPreProcessor();
    this.textPreProcessor.onProcess = (textValue) => {
      this.getProcessedTextValue(textValue);
    };
  }
  processValue(name, returnDisplayValue) {
    return this.textPreProcessor.processValue(name, returnDisplayValue);
  }
  get survey() {
    return null;
  }
  get panel() {
    return null;
  }
  getValues() {
    return !!this.panel ? this.panel.getValue() : null;
  }
  getQuestionByName(name) {
    return !!this.panel ? this.panel.getQuestionByValueName(name) : null;
  }
  getParentTextProcessor() {
    return null;
  }
  onCustomProcessText(textValue) {
    return false;
  }
  getQuestionDisplayText(question) {
    return question.displayValue;
  }
  //ITextProcessor
  getProcessedTextValue(textValue) {
    if (!textValue) return;
    if (this.onCustomProcessText(textValue)) return;
    var firstName = new ProcessValue().getFirstName(textValue.name);
    textValue.isExists = firstName == this.variableName;
    textValue.canProcess = textValue.isExists;
    if (!textValue.canProcess) return;
    textValue.name = textValue.name.replace(this.variableName + ".", "");
    var firstName = new ProcessValue().getFirstName(textValue.name);
    var question = this.getQuestionByName(firstName);
    var values = {};
    if (question) {
      values[firstName] = textValue.returnDisplayValue ? this.getQuestionDisplayText(question) : question.value;
    } else {
      var allValues = !!this.panel ? this.getValues() : null;
      if (allValues) {
        values[firstName] = allValues[firstName];
      }
    }
    textValue.value = new ProcessValue().getValue(textValue.name, values);
  }
  processText(text, returnDisplayValue) {
    const params = {
      text,
      returnDisplayValue
    };
    return this.processTextEx(params).text;
  }
  processTextEx(params) {
    var _a;
    const res = {
      hasAllValuesOnLastRun: true,
      text: params.text
    };
    if (!params.runAtDesign && ((_a = this.survey) === null || _a === void 0 ? void 0 : _a.isDesignMode)) return res;
    const processors = new Array();
    this.addTextPreProcessor(processors, this.textPreProcessor);
    this.addTextPreProcessor(processors, this.getParentTextProcessor());
    this.addTextPreProcessor(processors, this.survey);
    for (let i = 0; i < processors.length; i++) {
      const processor = processors[i];
      params.text = res.text;
      const processorRes = processor.processTextEx(params);
      res.text = processorRes.text;
      res.hasAllValuesOnLastRun = res.hasAllValuesOnLastRun && processorRes.hasAllValuesOnLastRun;
    }
    return res;
  }
  addTextPreProcessor(list, textProcessor) {
    if (!textProcessor || list.indexOf(textProcessor) > -1) return;
    list.push(textProcessor);
  }
};
var ComponentQuestionJSON = class {
  constructor(name, json2) {
    this.name = name;
    this.json = json2;
    var self2 = this;
    Serializer.addClass(name, [], function(json3) {
      return ComponentCollection.Instance.createQuestion(!!json3 ? json3.name : "", self2);
    }, "question");
    this.onInit();
  }
  onInit() {
    if (!this.json.onInit) return;
    this.json.onInit();
  }
  onCreated(question) {
    if (!this.json.onCreated) return;
    this.json.onCreated(question);
  }
  onLoaded(question) {
    if (!this.json.onLoaded) return;
    this.json.onLoaded(question);
  }
  onAfterRender(question, htmlElement) {
    if (!this.json.onAfterRender) return;
    this.json.onAfterRender(question, htmlElement);
  }
  onAfterRenderContentElement(question, element, htmlElement) {
    if (!this.json.onAfterRenderContentElement) return;
    this.json.onAfterRenderContentElement(question, element, htmlElement);
  }
  onUpdateQuestionCssClasses(question, element, css) {
    if (!this.json.onUpdateQuestionCssClasses) return;
    this.json.onUpdateQuestionCssClasses(question, element, css);
  }
  onSetQuestionValue(question, newValue) {
    if (this.json.onSetQuestionValue) {
      this.json.onSetQuestionValue(question, newValue);
    }
    if (this.json.onValueSet) {
      this.json.onValueSet(question, newValue);
    }
  }
  onPropertyChanged(question, propertyName, newValue) {
    if (!this.json.onPropertyChanged) return;
    this.json.onPropertyChanged(question, propertyName, newValue);
  }
  onValueChanged(question, name, newValue) {
    if (!this.json.onValueChanged) return;
    this.json.onValueChanged(question, name, newValue);
  }
  onValueChanging(question, name, newValue) {
    if (!this.json.onValueChanging) return newValue;
    return this.json.onValueChanging(question, name, newValue);
  }
  onGetErrorText(question) {
    if (!this.json.getErrorText) return void 0;
    return this.json.getErrorText(question);
  }
  onItemValuePropertyChanged(question, item, propertyName, name, newValue) {
    if (!this.json.onItemValuePropertyChanged) return;
    this.json.onItemValuePropertyChanged(question, {
      obj: item,
      propertyName,
      name,
      newValue
    });
  }
  getDisplayValue(keyAsText, value, question) {
    if (!this.json.getDisplayValue) return question.getDisplayValue(keyAsText, value);
    return this.json.getDisplayValue(question);
  }
  get defaultQuestionTitle() {
    return this.json.defaultQuestionTitle;
  }
  setValueToQuestion(val) {
    const converter = this.json.valueToQuestion || this.json.setValue;
    return !!converter ? converter(val) : val;
  }
  getValueFromQuestion(val) {
    const converter = this.json.valueFromQuestion || this.json.getValue;
    return !!converter ? converter(val) : val;
  }
  get isComposite() {
    return !!this.json.elementsJSON || !!this.json.createElements;
  }
  getDynamicProperties() {
    if (!Array.isArray(this.dynamicProperties)) {
      this.dynamicProperties = this.calcDynamicProperties();
    }
    return this.dynamicProperties;
  }
  calcDynamicProperties() {
    const baseProps = this.json.inheritBaseProps;
    if (!baseProps || !this.json.questionJSON) return [];
    const type = this.json.questionJSON.type;
    if (!type) return [];
    if (Array.isArray(baseProps)) {
      const props = [];
      baseProps.forEach((name) => {
        const prop = Serializer.findProperty(type, name);
        if (prop) {
          props.push(prop);
        }
      });
      return props;
    }
    const invalidNames = [];
    for (let key in this.json.questionJSON) {
      invalidNames.push(key);
    }
    return Serializer.getDynamicPropertiesByTypes(this.name, type, invalidNames);
  }
};
var ComponentCollection = class {
  constructor() {
    this.customQuestionValues = [];
  }
  add(json2) {
    if (!json2) return;
    let name = json2.name;
    if (!name) {
      throw "Attribute name is missed";
    }
    name = name.toLowerCase();
    if (!!this.getCustomQuestionByName(name)) {
      throw "There is already registered custom question with name '" + name + "'";
    }
    if (!!Serializer.findClass(name)) {
      throw "There is already class with name '" + name + "'";
    }
    var customQuestion = new ComponentQuestionJSON(name, json2);
    if (!!this.onAddingJson) this.onAddingJson(name, customQuestion.isComposite);
    this.customQuestionValues.push(customQuestion);
  }
  remove(componentName) {
    if (!componentName) return false;
    const index = this.getCustomQuestionIndex(componentName.toLowerCase());
    if (index < 0) return false;
    this.removeByIndex(index);
    return true;
  }
  get items() {
    return this.customQuestionValues;
  }
  getCustomQuestionByName(name) {
    const index = this.getCustomQuestionIndex(name);
    return index >= 0 ? this.customQuestionValues[index] : void 0;
  }
  getCustomQuestionIndex(name) {
    for (var i = 0; i < this.customQuestionValues.length; i++) {
      if (this.customQuestionValues[i].name === name) return i;
    }
    return -1;
  }
  removeByIndex(index) {
    Serializer.removeClass(this.customQuestionValues[index].name);
    this.customQuestionValues.splice(index, 1);
  }
  clear(includeInternal) {
    for (let i = this.customQuestionValues.length - 1; i >= 0; i--) {
      if (includeInternal || !this.customQuestionValues[i].json.internal) {
        this.removeByIndex(i);
      }
    }
  }
  createQuestion(name, questionJSON) {
    if (!!questionJSON.isComposite) return this.createCompositeModel(name, questionJSON);
    return this.createCustomModel(name, questionJSON);
  }
  createCompositeModel(name, questionJSON) {
    if (!!this.onCreateComposite) return this.onCreateComposite(name, questionJSON);
    return new QuestionCompositeModel(name, questionJSON);
  }
  createCustomModel(name, questionJSON) {
    if (!!this.onCreateCustom) return this.onCreateCustom(name, questionJSON);
    return new QuestionCustomModel(name, questionJSON);
  }
};
ComponentCollection.Instance = new ComponentCollection();
var QuestionCustomModelBase = class extends Question {
  constructor(name, customQuestion) {
    super(name);
    this.customQuestion = customQuestion;
    CustomPropertiesCollection.createProperties(this);
    SurveyElement.CreateDisabledDesignElements = true;
    this.locQuestionTitle = this.createLocalizableString("questionTitle", this);
    this.locQuestionTitle.setJson(this.customQuestion.defaultQuestionTitle);
    this.createWrapper();
    SurveyElement.CreateDisabledDesignElements = false;
    if (!!this.customQuestion) {
      this.customQuestion.onCreated(this);
    }
  }
  getType() {
    return !!this.customQuestion ? this.customQuestion.name : "custom";
  }
  locStrsChanged() {
    super.locStrsChanged();
    if (!!this.getElement()) {
      this.getElement().locStrsChanged();
    }
  }
  localeChanged() {
    super.locStrsChanged();
    if (!!this.getElement()) {
      this.getElement().localeChanged();
    }
  }
  getDefaultTitle() {
    if (!this.locQuestionTitle.isEmpty) {
      return this.getProcessedText(this.locQuestionTitle.textOrHtml);
    }
    return super.getDefaultTitle();
  }
  addUsedLocales(locales) {
    super.addUsedLocales(locales);
    if (!!this.getElement()) {
      this.getElement().addUsedLocales(locales);
    }
  }
  needResponsiveWidth() {
    const el = this.getElement();
    return !!el ? el.needResponsiveWidth() : false;
  }
  createWrapper() {
  }
  onPropertyValueChanged(name, oldValue, newValue) {
    super.onPropertyValueChanged(name, oldValue, newValue);
    if (!!this.customQuestion && !this.isLoadingFromJson) {
      this.customQuestion.onPropertyChanged(this, name, newValue);
    }
  }
  itemValuePropertyChanged(item, name, oldValue, newValue) {
    super.itemValuePropertyChanged(item, name, oldValue, newValue);
    if (!!this.customQuestion && !this.isLoadingFromJson) {
      this.customQuestion.onItemValuePropertyChanged(this, item, item.ownerPropertyName, name, newValue);
    }
  }
  onFirstRenderingCore() {
    super.onFirstRenderingCore();
    const el = this.getElement();
    if (!!el) {
      el.onFirstRendering();
    }
  }
  onHidingContent() {
    super.onHidingContent();
    const el = this.getElement();
    if (!!el) {
      el.onHidingContent();
    }
  }
  getProgressInfo() {
    let res = super.getProgressInfo();
    if (!!this.getElement()) {
      res = this.getElement().getProgressInfo();
    }
    if (this.isRequired && res.requiredQuestionCount == 0) {
      res.requiredQuestionCount = 1;
      if (!this.isEmpty()) {
        res.answeredQuestionCount = 1;
      }
    }
    return res;
  }
  initElement(el) {
    if (!el) return;
    el.setSurveyImpl(this);
    el.disableDesignActions = true;
  }
  setSurveyImpl(value, isLight) {
    this.isSettingValOnLoading = true;
    super.setSurveyImpl(value, isLight);
    this.initElement(this.getElement());
    this.isSettingValOnLoading = false;
  }
  onSurveyLoad() {
    super.onSurveyLoad();
    if (!!this.getElement()) {
      this.getElement().onSurveyLoad();
      this.customQuestion.onLoaded(this);
    }
  }
  afterRenderQuestionElement(el) {
  }
  afterRenderCore(el) {
    super.afterRenderCore(el);
    if (!!this.customQuestion) {
      this.customQuestion.onAfterRender(this, el);
    }
  }
  onUpdateQuestionCssClasses(element, css) {
    if (!!this.customQuestion) {
      this.customQuestion.onUpdateQuestionCssClasses(this, element, css);
    }
  }
  setQuestionValue(newValue, updateIsAnswered = true) {
    super.setQuestionValue(newValue, updateIsAnswered);
    this.updateElementCss();
    if (!!this.customQuestion) {
      this.customQuestion.onSetQuestionValue(this, newValue);
    }
  }
  setNewValue(newValue) {
    super.setNewValue(newValue);
    this.updateElementCss();
  }
  onCheckForErrors(errors, isOnValueChanged, fireCallback) {
    super.onCheckForErrors(errors, isOnValueChanged, fireCallback);
    if (!!this.customQuestion) {
      const text = this.customQuestion.onGetErrorText(this);
      if (!!text) {
        errors.push(new CustomError(text, this));
      }
    }
  }
  //ISurveyImpl
  getSurveyData() {
    return this;
  }
  getTextProcessor() {
    return this.textProcessor;
  }
  //ISurveyData
  getValue(name) {
    return this.value;
  }
  setValue(name, newValue, locNotification, allowNotifyValueChanged) {
    if (!this.data) return;
    if (!!this.customQuestion) {
      this.customQuestion.onValueChanged(this, name, newValue);
    }
    var newName = this.convertDataName(name);
    let valueForSurvey = this.convertDataValue(name, newValue);
    if (this.valueToDataCallback) {
      valueForSurvey = this.valueToDataCallback(valueForSurvey);
    }
    this.data.setValue(newName, valueForSurvey, locNotification, allowNotifyValueChanged);
    this.updateIsAnswered();
    this.updateElementCss();
  }
  getQuestionByName(name) {
    return void 0;
  }
  isValueChanging(name, newValue) {
    if (!!this.customQuestion) {
      const qValue = newValue;
      newValue = this.customQuestion.onValueChanging(this, name, newValue);
      if (!Helpers.isTwoValueEquals(newValue, qValue)) {
        const q = this.getQuestionByName(name);
        if (!!q) {
          q.value = newValue;
          return true;
        }
      }
    }
    return false;
  }
  convertDataName(name) {
    return this.getValueName();
  }
  convertDataValue(name, newValue) {
    return newValue;
  }
  getVariable(name) {
    return !!this.data ? this.data.getVariable(name) : null;
  }
  setVariable(name, newValue) {
    if (!this.data) return;
    this.data.setVariable(name, newValue);
  }
  getComment(name) {
    return !!this.data ? this.data.getComment(this.getValueName()) : "";
  }
  setComment(name, newValue, locNotification) {
    if (!this.data) return;
    this.data.setComment(this.getValueName(), newValue, locNotification);
  }
  getAllValues() {
    return !!this.data ? this.data.getAllValues() : {};
  }
  getFilteredValues() {
    return !!this.data ? this.data.getFilteredValues() : {};
  }
  getFilteredProperties() {
    return !!this.data ? this.data.getFilteredProperties() : {};
  }
  findQuestionByName(name) {
    return !!this.data ? this.data.findQuestionByName(name) : null;
  }
  getEditingSurveyElement() {
    return void 0;
  }
  //IPanel
  addElement(element, index) {
  }
  removeElement(element) {
    return false;
  }
  getQuestionTitleLocation() {
    return "left";
  }
  getQuestionTitleWidth() {
    return void 0;
  }
  getColumsForElement(el) {
    return [];
  }
  updateColumns() {
  }
  getQuestionStartIndex() {
    return this.getStartIndex();
  }
  getChildrenLayoutType() {
    return "row";
  }
  elementWidthChanged(el) {
  }
  get elements() {
    return [];
  }
  indexOf(el) {
    return -1;
  }
  ensureRowsVisibility() {
  }
  validateContainerOnly() {
  }
  onQuestionValueChanged(el) {
  }
  getQuestionErrorLocation() {
    return this.getErrorLocation();
  }
  getContentDisplayValueCore(keyAsText, value, question) {
    if (!question) return super.getDisplayValueCore(keyAsText, value);
    return this.customQuestion.getDisplayValue(keyAsText, value, question);
  }
};
var QuestionCustomModel = class extends QuestionCustomModelBase {
  getTemplate() {
    return "custom";
  }
  getDynamicProperties() {
    return this.customQuestion.getDynamicProperties() || [];
  }
  getDynamicType() {
    return this.questionWrapper ? this.questionWrapper.getType() : "question";
  }
  getOriginalObj() {
    return this.questionWrapper;
  }
  createWrapper() {
    this.questionWrapper = this.createQuestion();
    this.createDynamicProperties(this.questionWrapper);
    if (this.getDynamicProperties().length > 0) {
      this.questionWrapper.onPropertyValueChangedCallback = (name, oldValue, newValue, sender, arrayChanges) => {
        const prop = this.getDynamicProperty(name);
        if (prop) {
          this.propertyValueChanged(name, oldValue, newValue, arrayChanges);
        }
      };
    }
  }
  getDynamicProperty(name) {
    const props = this.getDynamicProperties();
    for (let i = 0; i < props.length; i++) {
      if (props[i].name === name) return props[i];
    }
    return null;
  }
  getElement() {
    return this.contentQuestion;
  }
  onAnyValueChanged(name, questionName) {
    super.onAnyValueChanged(name, questionName);
    if (!!this.contentQuestion) {
      this.contentQuestion.onAnyValueChanged(name, questionName);
    }
  }
  getQuestionByName(name) {
    return this.contentQuestion;
  }
  getDefaultTitle() {
    if (this.hasJSONTitle && this.contentQuestion) {
      return this.getProcessedText(this.contentQuestion.title);
    }
    return super.getDefaultTitle();
  }
  setValue(name, newValue, locNotification, allowNotifyValueChanged) {
    if (this.isValueChanging(name, newValue)) return;
    super.setValue(name, newValue, locNotification, allowNotifyValueChanged);
  }
  onSetData() {
    super.onSetData();
    if (!!this.survey && !this.isEmpty()) {
      this.setValue(this.name, this.value, false, this.allowNotifyValueChanged);
    }
  }
  hasErrors(fireCallback = true, rec = null) {
    if (!this.contentQuestion) return false;
    var res = this.contentQuestion.hasErrors(fireCallback, rec);
    this.errors = [];
    for (var i = 0; i < this.contentQuestion.errors.length; i++) {
      this.errors.push(this.contentQuestion.errors[i]);
    }
    if (!res) {
      res = super.hasErrors(fireCallback, rec);
    }
    this.updateElementCss();
    return res;
  }
  focus(onError = false) {
    if (!!this.contentQuestion) {
      this.contentQuestion.focus(onError);
    } else {
      super.focus(onError);
    }
  }
  afterRenderCore(el) {
    super.afterRenderCore(el);
    if (!!this.contentQuestion) {
      this.contentQuestion.afterRender(el);
    }
  }
  get contentQuestion() {
    return this.questionWrapper;
  }
  createQuestion() {
    var json2 = this.customQuestion.json;
    var res = null;
    if (!!json2.questionJSON) {
      this.hasJSONTitle = !!json2.questionJSON.title;
      let qType = json2.questionJSON.type;
      if (!qType || !Serializer.findClass(qType)) throw "type attribute in questionJSON is empty or incorrect";
      res = Serializer.createClass(qType);
      res.fromJSON(json2.questionJSON);
      res = this.checkCreatedQuestion(res);
    } else {
      if (!!json2.createQuestion) {
        res = this.checkCreatedQuestion(json2.createQuestion());
      }
    }
    this.initElement(res);
    if (!!res) {
      res.isContentElement = true;
      if (!res.name) {
        res.name = "question";
      }
      res.onUpdateCssClassesCallback = (css) => {
        this.onUpdateQuestionCssClasses(res, css);
      };
      res.hasCssErrorCallback = () => this.errors.length > 0;
      res.setValueChangedDirectlyCallback = (val) => {
        this.setValueChangedDirectly(val);
      };
    }
    return res;
  }
  checkCreatedQuestion(res) {
    if (!res) return res;
    if (!res.isQuestion) {
      if (Array.isArray(res.questions) && res.questions.length > 0) {
        res = res.questions[0];
      } else {
        res = Serializer.createClass("text");
      }
      ConsoleWarnings.error("Could not create component: '" + this.getType() + "'. questionJSON should be a question.");
    }
    return res;
  }
  onSurveyLoad() {
    super.onSurveyLoad();
    if (!this.contentQuestion) return;
    if (this.isEmpty() && !this.contentQuestion.isEmpty()) {
      this.value = this.getContentQuestionValue();
    }
  }
  runConditionCore(values, properties) {
    super.runConditionCore(values, properties);
    if (!!this.contentQuestion) {
      this.contentQuestion.runCondition(values, properties);
    }
  }
  convertDataName(name) {
    const q = this.contentQuestion;
    if (!q || name === this.getValueName()) return super.convertDataName(name);
    var newName = name.replace(q.getValueName(), this.getValueName());
    return newName.indexOf(this.getValueName()) == 0 ? newName : super.convertDataName(name);
  }
  convertDataValue(name, newValue) {
    return this.convertDataName(name) == super.convertDataName(name) ? this.getContentQuestionValue() : newValue;
  }
  getContentQuestionValue() {
    if (!this.contentQuestion) return void 0;
    let val = this.contentQuestion.value;
    if (!!this.customQuestion) val = this.customQuestion.getValueFromQuestion(val);
    return val;
  }
  setContentQuestionValue(val) {
    if (!this.contentQuestion) return;
    if (!!this.customQuestion) val = this.customQuestion.setValueToQuestion(val);
    this.contentQuestion.value = val;
  }
  canSetValueToSurvey() {
    return false;
  }
  setQuestionValue(newValue, updateIsAnswered = true) {
    super.setQuestionValue(newValue, updateIsAnswered);
    if (!this.isLoadingFromJson && !!this.contentQuestion && !this.isTwoValueEquals(this.getContentQuestionValue(), newValue)) {
      this.setContentQuestionValue(this.getUnbindValue(newValue));
    }
  }
  onSurveyValueChanged(newValue) {
    super.onSurveyValueChanged(newValue);
    if (!!this.contentQuestion) {
      this.contentQuestion.onSurveyValueChanged(newValue);
    }
  }
  getValueCore() {
    if (!!this.contentQuestion) return this.getContentQuestionValue();
    return super.getValueCore();
  }
  setValueChangedDirectly(val) {
    if (this.isSettingValueChanged) return;
    this.isSettingValueChanged = true;
    super.setValueChangedDirectly(val);
    if (!!this.contentQuestion) {
      this.contentQuestion.setValueChangedDirectly(val);
    }
    this.isSettingValueChanged = false;
  }
  createDynamicProperties(el) {
    if (!el) return;
    const props = this.getDynamicProperties();
    if (Array.isArray(props)) {
      Serializer.addDynamicPropertiesIntoObj(this, el, props);
    }
  }
  initElement(el) {
    super.initElement(el);
    if (!!el) {
      el.parent = this;
      el.afterRenderQuestionCallback = (question, element) => {
        if (!!this.customQuestion) {
          this.customQuestion.onAfterRenderContentElement(this, question, element);
        }
      };
    }
  }
  updateElementCss(reNew) {
    if (!!this.contentQuestion) {
      this.questionWrapper.updateElementCss(reNew);
    }
    super.updateElementCss(reNew);
  }
  updateElementCssCore(cssClasses) {
    if (!!this.contentQuestion) {
      cssClasses = this.contentQuestion.cssClasses;
    }
    super.updateElementCssCore(cssClasses);
  }
  getDisplayValueCore(keyAsText, value) {
    return super.getContentDisplayValueCore(keyAsText, value, this.contentQuestion);
  }
};
var QuestionCompositeTextProcessor = class extends QuestionTextProcessor {
  constructor(composite, variableName) {
    super(variableName);
    this.composite = composite;
    this.variableName = variableName;
  }
  get survey() {
    return this.composite.survey;
  }
  get panel() {
    return this.composite.contentPanel;
  }
};
var QuestionCompositeModel = class _QuestionCompositeModel extends QuestionCustomModelBase {
  constructor(name, customQuestion) {
    super(name, customQuestion);
    this.customQuestion = customQuestion;
    this.settingNewValue = false;
    this.textProcessing = new QuestionCompositeTextProcessor(this, _QuestionCompositeModel.ItemVariableName);
  }
  createWrapper() {
    this.panelWrapper = this.createPanel();
  }
  getTemplate() {
    return "composite";
  }
  getElement() {
    return this.contentPanel;
  }
  getCssRoot(cssClasses) {
    return new CssClassBuilder().append(super.getCssRoot(cssClasses)).append(cssClasses.composite).toString();
  }
  get contentPanel() {
    return this.panelWrapper;
  }
  hasErrors(fireCallback = true, rec = null) {
    var res = super.hasErrors(fireCallback, rec);
    if (!this.contentPanel) return res;
    return this.contentPanel.hasErrors(fireCallback, false, rec) || res;
  }
  updateElementCss(reNew) {
    super.updateElementCss(reNew);
    if (this.contentPanel) {
      this.contentPanel.updateElementCss(reNew);
    }
  }
  dispose() {
    this.unConnectEditingObj();
    super.dispose();
  }
  updateEditingObj() {
    var _a;
    const obj = (_a = this.data) === null || _a === void 0 ? void 0 : _a.getEditingSurveyElement();
    if (!obj) return void 0;
    let newObj = obj[this.getValueName()];
    if (!!newObj && !newObj.onPropertyChanged) {
      newObj = void 0;
    }
    if (newObj !== this.editingObjValue) {
      this.unConnectEditingObj();
      this.editingObjValue = newObj;
      if (!!newObj) {
        this.onEditingObjPropertyChanged = (sender, options) => {
          this.setNewValueIntoQuestion(options.name, this.editingObjValue[options.name]);
        };
        newObj.onPropertyChanged.add(this.onEditingObjPropertyChanged);
      }
    }
    return this.editingObjValue;
  }
  unConnectEditingObj() {
    if (!!this.editingObjValue && !this.editingObjValue.isDisposed) {
      this.editingObjValue.onPropertyChanged.remove(this.onEditingObjPropertyChanged);
    }
  }
  getEditingSurveyElement() {
    return this.editingObjValue;
  }
  getTextProcessor() {
    return this.textProcessing;
  }
  findQuestionByName(name) {
    const res = this.getQuestionByName(name);
    if (!!res) return res;
    return super.findQuestionByName(name);
  }
  clearValueIfInvisibleCore(reason) {
    super.clearValueIfInvisibleCore(reason);
    const questions = this.contentPanel.questions;
    for (var i = 0; i < questions.length; i++) {
      questions[i].clearValueIfInvisible(reason);
    }
  }
  onAnyValueChanged(name, questionName) {
    super.onAnyValueChanged(name, questionName);
    var questions = this.contentPanel.questions;
    for (var i = 0; i < questions.length; i++) {
      questions[i].onAnyValueChanged(name, questionName);
    }
  }
  get hasSingleInput() {
    return false;
  }
  get isContainer() {
    return true;
  }
  createPanel() {
    var res = Serializer.createClass("panel");
    res.showQuestionNumbers = "off";
    res.renderWidth = "100%";
    var json2 = this.customQuestion.json;
    if (!!json2.elementsJSON) {
      res.fromJSON({
        elements: json2.elementsJSON
      });
    }
    if (!!json2.createElements) {
      json2.createElements(res, this);
    }
    this.initElement(res);
    res.readOnly = this.isReadOnly;
    res.questions.forEach((q) => {
      q.setParentQuestion(this);
      q.onUpdateCssClassesCallback = (css) => {
        this.onUpdateQuestionCssClasses(q, css);
      };
    });
    this.setAfterRenderCallbacks(res);
    return res;
  }
  onReadOnlyChanged() {
    if (!!this.contentPanel) {
      this.contentPanel.readOnly = this.isReadOnly;
    }
    super.onReadOnlyChanged();
  }
  updateValueFromSurvey(newValue, clearData = false) {
    this.updateEditingObj();
    super.updateValueFromSurvey(newValue, clearData);
  }
  onSurveyLoad() {
    this.isSettingValOnLoading = true;
    if (!!this.contentPanel) {
      this.contentPanel.readOnly = this.isReadOnly;
      this.setIsContentElement(this.contentPanel);
    }
    super.onSurveyLoad();
    if (!!this.contentPanel) {
      const val = this.getContentPanelValue();
      if (!Helpers.isValueEmpty(val)) {
        this.value = val;
      }
    }
    this.isSettingValOnLoading = false;
  }
  setIsContentElement(panel) {
    panel.isContentElement = true;
    var elements = panel.elements;
    for (var i = 0; i < elements.length; i++) {
      var el = elements[i];
      if (el.isPanel) {
        this.setIsContentElement(el);
      } else {
        el.isContentElement = true;
      }
    }
  }
  setVisibleIndex(val) {
    var res = super.setVisibleIndex(val);
    if (this.isVisible && !!this.contentPanel) {
      res += this.contentPanel.setVisibleIndex(val);
    }
    return res;
  }
  runConditionCore(values, properties) {
    super.runConditionCore(values, properties);
    if (!!this.contentPanel) {
      var oldComposite = values[_QuestionCompositeModel.ItemVariableName];
      values[_QuestionCompositeModel.ItemVariableName] = this.contentPanel.getValue();
      this.contentPanel.runCondition(values, properties);
      delete values[_QuestionCompositeModel.ItemVariableName];
      if (!!oldComposite) {
        values[_QuestionCompositeModel.ItemVariableName] = oldComposite;
      }
    }
  }
  onSurveyValueChanged(newValue) {
    super.onSurveyValueChanged(newValue);
    const val = !!newValue ? newValue : {};
    if (!!this.contentPanel) {
      this.contentPanel.questions.forEach((q) => {
        q.onSurveyValueChanged(val[q.getValueName()]);
      });
    }
  }
  getValue(name) {
    var val = this.value;
    return !!val ? val[name] : null;
  }
  getQuestionByName(name) {
    return !!this.contentPanel ? this.contentPanel.getQuestionByName(name) : void 0;
  }
  setValue(name, newValue, locNotification, allowNotifyValueChanged) {
    if (this.settingNewValue) {
      this.setNewValueIntoQuestion(name, newValue);
      return;
    }
    if (this.isValueChanging(name, newValue)) return;
    this.settingNewValue = true;
    if (!this.isEditingSurveyElement && !!this.contentPanel) {
      let index = 0;
      const maxTimes = this.contentPanel.questions.length + 1;
      while (index < maxTimes && this.updateValueCoreWithPanelValue()) index++;
    }
    this.setNewValueIntoQuestion(name, newValue);
    super.setValue(name, newValue, locNotification, allowNotifyValueChanged);
    this.settingNewValue = false;
    this.runPanelTriggers(_QuestionCompositeModel.ItemVariableName + "." + name, newValue);
  }
  setComment(name, newValue, locNotification) {
    let val = this.getUnbindValue(this.value);
    const commentName = this.getCommentName(name);
    if (!val && !newValue || !!newValue && !!val && val[commentName] === newValue) return;
    if (!!newValue) {
      if (!val) {
        val = {};
      }
      val[commentName] = newValue;
    } else {
      delete val[commentName];
    }
    const q = this.getQuestionByName(name);
    if (!!q && q.comment !== newValue) {
      q.comment = newValue;
    }
    this.value = val;
  }
  getComment(name) {
    const q = this.getQuestionByName(name);
    if (!!q) return q.comment;
    const val = this.value;
    return !!val && val[this.getCommentName(name)] || "";
  }
  getCommentName(name) {
    return name + settings.commentSuffix;
  }
  runPanelTriggers(name, value) {
    if (!!this.contentPanel) {
      this.contentPanel.questions.forEach((q) => {
        q.runTriggers(name, value);
      });
    }
  }
  getFilteredValues() {
    const values = !!this.data ? this.data.getFilteredValues() : {};
    if (!!this.contentPanel) {
      values[_QuestionCompositeModel.ItemVariableName] = this.contentPanel.getValue();
    }
    return values;
  }
  updateValueCoreWithPanelValue() {
    const panelValue = this.getContentPanelValue();
    if (this.isTwoValueEquals(this.getValueCore(), panelValue)) return false;
    this.setValueCore(panelValue);
    return true;
  }
  getContentPanelValue(val) {
    if (!val) val = this.contentPanel.getValue();
    return this.customQuestion.setValueToQuestion(val);
  }
  getValueForContentPanel(val) {
    return this.customQuestion.getValueFromQuestion(val);
  }
  setNewValueIntoQuestion(name, newValue) {
    var q = this.getQuestionByName(name);
    if (!!q && !this.isTwoValueEquals(newValue, q.value)) {
      q.value = newValue;
    }
  }
  addConditionObjectsByContext(objects, context) {
    if (!this.contentPanel) return;
    var questions = this.contentPanel.questions;
    var prefixName = this.name;
    var prefixText = this.title;
    for (var i = 0; i < questions.length; i++) {
      objects.push({
        name: prefixName + "." + questions[i].name,
        text: prefixText + "." + questions[i].title,
        question: questions[i]
      });
    }
  }
  collectNestedQuestionsCore(questions, visibleOnly) {
    if (!this.contentPanel) return;
    this.contentPanel.questions.forEach((q) => q.collectNestedQuestions(questions, visibleOnly));
  }
  convertDataValue(name, newValue) {
    var val = !!this.contentPanel && !this.isEditingSurveyElement ? this.contentPanel.getValue() : this.getValueForContentPanel(this.value);
    if (!val) val = {};
    if (!val.getType) {
      val = Helpers.getUnbindValue(val);
    }
    if (this.isValueEmpty(newValue) && !this.isEditingSurveyElement) {
      delete val[name];
    } else {
      val[name] = newValue;
    }
    return this.getContentPanelValue(val);
  }
  setQuestionValue(newValue, updateIsAnswered = true) {
    this.setValuesIntoQuestions(newValue);
    if (!this.isEditingSurveyElement && !!this.contentPanel) {
      newValue = this.getContentPanelValue();
    }
    super.setQuestionValue(newValue, updateIsAnswered);
  }
  setValuesIntoQuestions(newValue) {
    if (!this.contentPanel || this.settingNewValue) return;
    newValue = this.getValueForContentPanel(newValue);
    const oldSettingNewValue = this.settingNewValue;
    this.settingNewValue = true;
    const questions = this.contentPanel.questions;
    for (var i = 0; i < questions.length; i++) {
      const q = questions[i];
      const key = q.getValueName();
      const commentKey = this.getCommentName(key);
      const val = !!newValue ? newValue[key] : void 0;
      const commentVal = !!newValue && newValue[commentKey] || "";
      if (!this.isTwoValueEquals(q.value, val) && (val !== void 0 || !q.isEmpty())) {
        q.value = val;
      }
      if (q.comment !== commentVal) {
        q.comment = commentVal;
      }
    }
    this.settingNewValue = oldSettingNewValue;
  }
  getDisplayValueCore(keyAsText, value) {
    return super.getContentDisplayValueCore(keyAsText, value, this.contentPanel);
  }
  setAfterRenderCallbacks(panel) {
    if (!panel || !this.customQuestion) return;
    var questions = panel.questions;
    for (var i = 0; i < questions.length; i++) {
      questions[i].afterRenderQuestionCallback = (question, element) => {
        this.customQuestion.onAfterRenderContentElement(this, question, element);
      };
    }
  }
  get ariaRole() {
    return "group";
  }
};
QuestionCompositeModel.ItemVariableName = "composite";
var QuestionFactory = class {
  static get DefaultChoices() {
    const choice = getLocaleString("choices_Item");
    return [choice + "1", choice + "2", choice + "3"];
  }
  static get DefaultColums() {
    var colName = getLocaleString("matrix_column") + " ";
    return [colName + "1", colName + "2", colName + "3"];
  }
  static get DefaultRows() {
    var rowName = getLocaleString("matrix_row") + " ";
    return [rowName + "1", rowName + "2"];
  }
  static get DefaultMutlipleTextItems() {
    var itemName = getLocaleString("multipletext_itemname");
    return [itemName + "1", itemName + "2"];
  }
  registerQuestion(questionType2, questionCreator, showInToolbox = true) {
    ElementFactory.Instance.registerElement(questionType2, questionCreator, showInToolbox);
  }
  registerCustomQuestion(questionType2) {
    ElementFactory.Instance.registerCustomQuestion(questionType2);
  }
  unregisterElement(elementType, removeFromSerializer = false) {
    ElementFactory.Instance.unregisterElement(elementType, removeFromSerializer);
  }
  clear() {
    ElementFactory.Instance.clear();
  }
  getAllTypes() {
    return ElementFactory.Instance.getAllTypes();
  }
  createQuestion(questionType2, name) {
    return ElementFactory.Instance.createElement(questionType2, name);
  }
};
QuestionFactory.Instance = new QuestionFactory();
var ElementFactory = class {
  constructor() {
    this.creatorHash = {};
    this.registerCustomQuestion = (questionType2, showInToolbox = true) => {
      const creator = (name) => {
        const el = Serializer.createClass(questionType2);
        if (!!el) el.name = name;
        return el;
      };
      this.registerElement(questionType2, creator, showInToolbox);
    };
  }
  registerElement(elementType, elementCreator, showInToolbox = true) {
    this.creatorHash[elementType] = {
      showInToolbox,
      creator: elementCreator
    };
  }
  clear() {
    this.creatorHash = {};
  }
  unregisterElement(elementType, removeFromSerializer = false) {
    delete this.creatorHash[elementType];
    if (removeFromSerializer) {
      Serializer.removeClass(elementType);
    }
  }
  getAllToolboxTypes() {
    return this.getAllTypesCore(true);
  }
  getAllTypes() {
    return this.getAllTypesCore(false);
  }
  createElement(elementType, name) {
    var item = this.creatorHash[elementType];
    if (!!item && !!item.creator) return item.creator(name);
    const compJSON = ComponentCollection.Instance.getCustomQuestionByName(elementType);
    if (!!compJSON) return ComponentCollection.Instance.createQuestion(name, compJSON);
    return null;
  }
  getAllTypesCore(showInToolboxOnly) {
    var result = new Array();
    for (var key in this.creatorHash) {
      if (!showInToolboxOnly || this.creatorHash[key].showInToolbox) {
        result.push(key);
      }
    }
    return result.sort();
  }
};
ElementFactory.Instance = new ElementFactory();
var QuestionExpressionModel = class extends Question {
  constructor(name) {
    super(name);
    this.createLocalizableString("format", this);
    this.registerPropertyChangedHandlers(["expression"], () => {
      if (this.expressionRunner) {
        this.expressionRunner = this.createRunner();
      }
    });
    this.registerPropertyChangedHandlers(["format", "currency", "displayStyle"], () => {
      this.updateFormatedValue();
    });
  }
  getType() {
    return "expression";
  }
  get hasInput() {
    return false;
  }
  /**
   * A string that formats a question value. Use `{0}` to reference the question value in the format string.
   * @see displayStyle
   */
  get format() {
    return this.getLocalizableStringText("format", "");
  }
  set format(val) {
    this.setLocalizableStringText("format", val);
  }
  get locFormat() {
    return this.getLocalizableString("format");
  }
  /**
   * An expression used to calculate the question value.
   *
   * Refer to the following help topic for more information: [Expressions](https://surveyjs.io/form-library/documentation/design-survey-conditional-logic#expressions).
   */
  get expression() {
    return this.getPropertyValue("expression", "");
  }
  set expression(val) {
    this.setPropertyValue("expression", val);
  }
  locCalculation() {
    this.expressionIsRunning = true;
  }
  unlocCalculation() {
    this.expressionIsRunning = false;
  }
  runConditionCore(values, properties) {
    super.runConditionCore(values, properties);
    if (!this.expression || this.expressionIsRunning || !this.runIfReadOnly && this.isReadOnly) return;
    this.locCalculation();
    if (!this.expressionRunner) {
      this.expressionRunner = this.createRunner();
    }
    this.expressionRunner.run(values, properties);
  }
  canCollectErrors() {
    return true;
  }
  hasRequiredError() {
    return false;
  }
  createRunner() {
    const res = this.createExpressionRunner(this.expression);
    res.onRunComplete = (newValue) => {
      this.value = this.roundValue(newValue);
      this.unlocCalculation();
    };
    return res;
  }
  /**
   * The maximum number of fraction digits. Applies only if the `displayStyle` property is not `"none"`. Accepts values in the range from -1 to 20, where -1 disables the property.
   *
   * Default value: -1
   * @see displayStyle
   * @see minimumFractionDigits
   * @see precision
   */
  get maximumFractionDigits() {
    return this.getPropertyValue("maximumFractionDigits");
  }
  set maximumFractionDigits(val) {
    if (val < -1 || val > 20) return;
    this.setPropertyValue("maximumFractionDigits", val);
  }
  /**
   * The minimum number of fraction digits. Applies only if the `displayStyle` property is not `"none"`. Accepts values in the range from -1 to 20, where -1 disables the property.
   *
   * Default value: -1
   * @see displayStyle
   * @see maximumFractionDigits
   */
  get minimumFractionDigits() {
    return this.getPropertyValue("minimumFractionDigits");
  }
  set minimumFractionDigits(val) {
    if (val < -1 || val > 20) return;
    this.setPropertyValue("minimumFractionDigits", val);
  }
  get runIfReadOnly() {
    return this.runIfReadOnlyValue === true;
  }
  set runIfReadOnly(val) {
    this.runIfReadOnlyValue = val;
  }
  get formatedValue() {
    return this.getPropertyValue("formatedValue", "");
  }
  updateFormatedValue() {
    this.setPropertyValue("formatedValue", this.getDisplayValueCore(false, this.value));
  }
  onValueChanged() {
    this.updateFormatedValue();
  }
  updateValueFromSurvey(newValue, clearData) {
    super.updateValueFromSurvey(newValue, clearData);
    this.updateFormatedValue();
  }
  getDisplayValueCore(keysAsText, value) {
    var val = value === void 0 || value === null ? this.defaultValue : value;
    var res = "";
    if (!this.isValueEmpty(val)) {
      var str = this.getValueAsStr(val);
      res = !this.format ? str : this.format["format"](str);
    }
    if (!!this.survey) {
      res = this.survey.getExpressionDisplayValue(this, val, res);
    }
    return res;
  }
  /**
   * Specifies a display style for the question value.
   *
   * Possible values:
   *
   * - `"decimal"`
   * - `"currency"`
   * - `"percent"`
   * - `"date"`
   * - `"none"` (default)
   *
   * If you use the `"currency"` display style, you can also set the `currency` property to specify a currency other than USD.
   * @see currency
   * @see minimumFractionDigits
   * @see maximumFractionDigits
   * @see format
   */
  get displayStyle() {
    return this.getPropertyValue("displayStyle");
  }
  set displayStyle(val) {
    this.setPropertyValue("displayStyle", val);
  }
  /**
   * A three-letter currency code. Applies only if the `displayStyle` property is set to `"currency"`.
   *
   * Default value: "USD".
   * @see displayStyle
   * @see minimumFractionDigits
   * @see maximumFractionDigits
   * @see format
   */
  get currency() {
    return this.getPropertyValue("currency");
  }
  set currency(val) {
    if (getCurrecyCodes().indexOf(val) < 0) return;
    this.setPropertyValue("currency", val);
  }
  /**
   * Specifies whether to use grouping separators in number representation. Separators depend on the selected [locale](https://surveyjs.io/form-library/documentation/surveymodel#locale).
   *
   * Default value: `true`
   */
  get useGrouping() {
    return this.getPropertyValue("useGrouping");
  }
  set useGrouping(val) {
    this.setPropertyValue("useGrouping", val);
  }
  /**
   * Specifies how many decimal digits to keep in the expression value.
   *
   * Default value: -1 (unlimited)
   * @see maximumFractionDigits
   */
  get precision() {
    return this.getPropertyValue("precision");
  }
  set precision(val) {
    this.setPropertyValue("precision", val);
  }
  roundValue(val) {
    if (val === Infinity) return void 0;
    if (this.precision < 0) return val;
    if (!Helpers.isNumber(val)) return val;
    return parseFloat(val.toFixed(this.precision));
  }
  getValueAsStr(val) {
    if (this.displayStyle == "date") {
      const d = createDate("question-expression", val);
      if (!!d && !!d.toLocaleDateString) return d.toLocaleDateString();
    }
    if (this.displayStyle != "none" && Helpers.isNumber(val)) {
      var locale = this.getLocale();
      if (!locale) locale = "en";
      var options = {
        style: this.displayStyle,
        currency: this.currency,
        useGrouping: this.useGrouping
      };
      if (this.maximumFractionDigits > -1) {
        options["maximumFractionDigits"] = this.maximumFractionDigits;
      }
      if (this.minimumFractionDigits > -1) {
        options["minimumFractionDigits"] = this.minimumFractionDigits;
      }
      return val.toLocaleString(locale, options);
    }
    return val.toString();
  }
};
function getCurrecyCodes() {
  return ["AED", "AFN", "ALL", "AMD", "ANG", "AOA", "ARS", "AUD", "AWG", "AZN", "BAM", "BBD", "BDT", "BGN", "BHD", "BIF", "BMD", "BND", "BOB", "BOV", "BRL", "BSD", "BTN", "BWP", "BYN", "BZD", "CAD", "CDF", "CHE", "CHF", "CHW", "CLF", "CLP", "CNY", "COP", "COU", "CRC", "CUC", "CUP", "CVE", "CZK", "DJF", "DKK", "DOP", "DZD", "EGP", "ERN", "ETB", "EUR", "FJD", "FKP", "GBP", "GEL", "GHS", "GIP", "GMD", "GNF", "GTQ", "GYD", "HKD", "HNL", "HRK", "HTG", "HUF", "IDR", "ILS", "INR", "IQD", "IRR", "ISK", "JMD", "JOD", "JPY", "KES", "KGS", "KHR", "KMF", "KPW", "KRW", "KWD", "KYD", "KZT", "LAK", "LBP", "LKR", "LRD", "LSL", "LYD", "MAD", "MDL", "MGA", "MKD", "MMK", "MNT", "MOP", "MRO", "MUR", "MVR", "MWK", "MXN", "MXV", "MYR", "MZN", "NAD", "NGN", "NIO", "NOK", "NPR", "NZD", "OMR", "PAB", "PEN", "PGK", "PHP", "PKR", "PLN", "PYG", "QAR", "RON", "RSD", "RUB", "RWF", "SAR", "SBD", "SCR", "SDG", "SEK", "SGD", "SHP", "SLL", "SOS", "SRD", "SSP", "STD", "SVC", "SYP", "SZL", "THB", "TJS", "TMT", "TND", "TOP", "TRY", "TTD", "TWD", "TZS", "UAH", "UGX", "USD", "USN", "UYI", "UYU", "UZS", "VEF", "VND", "VUV", "WST", "XAF", "XAG", "XAU", "XBA", "XBB", "XBC", "XBD", "XCD", "XDR", "XOF", "XPD", "XPF", "XPT", "XSU", "XTS", "XUA", "XXX", "YER", "ZAR", "ZMW", "ZWL"];
}
Serializer.addClass("expression", ["expression:expression", {
  name: "format",
  serializationProperty: "locFormat"
}, {
  name: "displayStyle",
  default: "none",
  choices: ["none", "decimal", "currency", "percent", "date"]
}, {
  name: "currency",
  choices: () => {
    return getCurrecyCodes();
  },
  default: "USD",
  visibleIf: (obj) => {
    return obj.displayStyle === "currency";
  }
}, {
  name: "maximumFractionDigits:number",
  default: -1
}, {
  name: "minimumFractionDigits:number",
  default: -1
}, {
  name: "useGrouping:boolean",
  default: true
}, {
  name: "precision:number",
  default: -1,
  category: "data"
}, {
  name: "enableIf",
  visible: false,
  isSerializable: false
}, {
  name: "isRequired",
  visible: false,
  isSerializable: false
}, {
  name: "readOnly",
  visible: false,
  isSerializable: false
}, {
  name: "requiredErrorText",
  visible: false,
  isSerializable: false
}, {
  name: "resetValueIf",
  visible: false,
  isSerializable: false
}, {
  name: "setValueIf",
  visible: false,
  isSerializable: false
}, {
  name: "setValueExpression",
  visible: false,
  isSerializable: false
}, {
  name: "defaultValueExpression",
  visible: false,
  isSerializable: false
}, {
  name: "defaultValue",
  visible: false,
  isSerializable: false
}, {
  name: "correctAnswer",
  visible: false,
  isSerializable: false
}, {
  name: "requiredIf",
  visible: false,
  isSerializable: false
}], function() {
  return new QuestionExpressionModel("");
}, "question");
QuestionFactory.Instance.registerQuestion("expression", (name) => {
  return new QuestionExpressionModel(name);
});
function onUpdateSelectBaseCellQuestion(cellQuestion, column, question, data) {
  cellQuestion.storeOthersAsComment = !!question ? question.storeOthersAsComment : false;
  if ((!cellQuestion.choices || cellQuestion.choices.length == 0) && cellQuestion.choicesByUrl.isEmpty) {
    cellQuestion.choices = question.choices;
  }
  if (!cellQuestion.choicesByUrl.isEmpty) {
    cellQuestion.choicesByUrl.run(data.getTextProcessor());
  }
}
function onUpdateSelectDropdownCellQuestion(cellQuestion, column, question, data) {
  onUpdateSelectBaseCellQuestion(cellQuestion, column, question, data);
  if (!!cellQuestion.locPlaceholder && cellQuestion.locPlaceholder.isEmpty && !question.locPlaceholder.isEmpty) {
    cellQuestion.optionsCaption = question.optionsCaption;
  }
}
var matrixDropdownColumnTypes = {
  dropdown: {
    onCellQuestionUpdate: (cellQuestion, column, question, data) => {
      onUpdateSelectDropdownCellQuestion(cellQuestion, column, question, data);
    }
  },
  checkbox: {
    onCellQuestionUpdate: (cellQuestion, column, question, data) => {
      onUpdateSelectBaseCellQuestion(cellQuestion, column, question, data);
      cellQuestion.colCount = column.colCount > -1 ? column.colCount : question.columnColCount;
    }
  },
  radiogroup: {
    onCellQuestionUpdate: (cellQuestion, column, question, data) => {
      onUpdateSelectBaseCellQuestion(cellQuestion, column, question, data);
      cellQuestion.colCount = column.colCount > -1 ? column.colCount : question.columnColCount;
    }
  },
  tagbox: {
    onCellQuestionUpdate: (cellQuestion, column, question, data) => {
      onUpdateSelectBaseCellQuestion(cellQuestion, column, question, data);
    }
  },
  text: {},
  comment: {},
  boolean: {
    onCellQuestionUpdate: (cellQuestion, column, question, data) => {
      cellQuestion.renderAs = column.renderAs;
    }
  },
  expression: {},
  rating: {}
};
var MatrixDropdownColumn = class extends Base {
  static getColumnTypes() {
    var res = [];
    for (var key in matrixDropdownColumnTypes) {
      res.push(key);
    }
    return res;
  }
  constructor(name, title, colOwner) {
    super();
    this.indexValue = -1;
    this._hasVisibleCell = true;
    this.isColumnsVisibleIf = true;
    this.previousChoicesId = void 0;
    this.colOwnerValue = colOwner;
    this.createLocalizableString("totalFormat", this);
    this.createLocalizableString("cellHint", this);
    this.registerPropertyChangedHandlers(["showInMultipleColumns"], () => {
      this.doShowInMultipleColumnsChanged();
    });
    this.registerPropertyChangedHandlers(["visible"], () => {
      this.doColumnVisibilityChanged();
    });
    this.updateTemplateQuestion(void 0, name, title);
  }
  getOriginalObj() {
    return this.templateQuestion;
  }
  getClassNameProperty() {
    return "cellType";
  }
  getSurvey(live = false) {
    return !!this.colOwner ? this.colOwner.survey : null;
  }
  endLoadingFromJson() {
    super.endLoadingFromJson();
    this.templateQuestion.autoOtherMode = this.isShowInMultipleColumns;
    this.templateQuestion.endLoadingFromJson();
    this.templateQuestion.onGetSurvey = () => {
      return this.getSurvey();
    };
  }
  getDynamicPropertyName() {
    return "cellType";
  }
  getDynamicType() {
    if (this.cellType === "default") return "question";
    return this.calcCellQuestionType(null);
  }
  get colOwner() {
    return this.colOwnerValue;
  }
  set colOwner(value) {
    this.colOwnerValue = value;
    if (!!value) {
      this.updateTemplateQuestion();
      this.setParentQuestionToTemplate(this.templateQuestion);
    }
  }
  locStrsChanged() {
    super.locStrsChanged();
    this.locTitle.strChanged();
  }
  addUsedLocales(locales) {
    super.addUsedLocales(locales);
    this.templateQuestion.addUsedLocales(locales);
  }
  get index() {
    return this.indexValue;
  }
  setIndex(val) {
    this.indexValue = val;
  }
  getType() {
    return "matrixdropdowncolumn";
  }
  /**
   * Specifies the type of column cells.
   *
   * Possible values:
   *
   * - [`"dropdown"`](https://surveyjs.io/form-library/documentation/api-reference/dropdown-menu-model)
   * - [`"checkbox"`](https://surveyjs.io/form-library/documentation/api-reference/checkbox-question-model)
   * - [`"radiogroup"`](https://surveyjs.io/form-library/documentation/api-reference/radio-button-question-model)
   * - [`"tagbox"`](https://surveyjs.io/form-library/documentation/api-reference/dropdown-tag-box-model)
   * - [`"text"`](https://surveyjs.io/form-library/documentation/api-reference/text-entry-question-model)
   * - [`"comment"`](https://surveyjs.io/form-library/documentation/api-reference/comment-field-model)
   * - [`"boolean"`](https://surveyjs.io/form-library/documentation/api-reference/boolean-question-model)
   * - [`"expression"`](https://surveyjs.io/form-library/documentation/api-reference/expression-model)
   * - [`"rating"`](https://surveyjs.io/form-library/documentation/api-reference/rating-scale-question-model)
   * - `"default"` (default) - Inherits the input type from the [`cellType`](https://surveyjs.io/form-library/documentation/api-reference/matrix-table-with-dropdown-list#cellType) property specified for the parent matrix.
   *
   * The input types are based upon standalone question types. Depending on the selected input type, the matrix column can have additional configuration properties inherited from the corresponding question type. For instance, Dropdown, Checkboxes, Radio Button Group, and Tag Box columns can specify the [`choices`](https://surveyjs.io/form-library/documentation/api-reference/radio-button-question-model#choices) array, similar to the question types upon which they are based. Refer to the API Reference of these question types for a full list of available properties.
   *
   * [View Demo](https://surveyjs.io/form-library/examples/aggregate-data-within-form/ (linkStyle))
   */
  get cellType() {
    return this.getPropertyValue("cellType");
  }
  set cellType(val) {
    val = val.toLocaleLowerCase();
    this.updateTemplateQuestion(val);
    this.setPropertyValue("cellType", val);
    if (!!this.colOwner) {
      this.colOwner.onColumnCellTypeChanged(this);
    }
  }
  get templateQuestion() {
    return this.templateQuestionValue;
  }
  get value() {
    return this.templateQuestion.name;
  }
  //For filtering columns
  get isVisible() {
    return true;
  }
  get isColumnVisible() {
    if (this.isDesignMode) return true;
    return this.visible && this.hasVisibleCell;
  }
  /**
   * Gets or sets column visibility.
   *
   * If you want to display or hide a column based on a condition, specify the [`visibleIf`](#visibleIf) property.
   * @see isRequired
   * @see readOnly
   */
  get visible() {
    return this.templateQuestion.visible;
  }
  set visible(val) {
    this.templateQuestion.visible = val;
  }
  get hasVisibleCell() {
    return this._hasVisibleCell;
  }
  set hasVisibleCell(newVal) {
    this._hasVisibleCell = newVal;
  }
  getVisibleMultipleChoices() {
    const choices = this.templateQuestion.visibleChoices;
    if (!Array.isArray(choices)) return [];
    if (!Array.isArray(this._visiblechoices)) return choices;
    const res = new Array();
    for (let i = 0; i < choices.length; i++) {
      const item = choices[i];
      if (this._visiblechoices.indexOf(item.value) > -1) res.push(item);
    }
    return res;
  }
  get getVisibleChoicesInCell() {
    if (Array.isArray(this._visiblechoices)) return this._visiblechoices;
    const res = this.templateQuestion.visibleChoices;
    return Array.isArray(res) ? res : [];
  }
  setVisibleChoicesInCell(val) {
    this._visiblechoices = val;
  }
  get isFilteredMultipleColumns() {
    if (!this.showInMultipleColumns) return false;
    const choices = this.templateQuestion.choices;
    if (!Array.isArray(choices)) return false;
    for (let i = 0; i < choices.length; i++) {
      if (choices[i].visibleIf) return true;
    }
    return false;
  }
  /**
   * A column ID that is not visible to respondents.
   *
   * > Column IDs must be unique.
   * @see title
   */
  get name() {
    return this.templateQuestion.name;
  }
  set name(val) {
    this.templateQuestion.name = val;
  }
  /**
   * A user-friendly column caption to display. If `title` is undefined, [`name`](#name) is displayed instead.
   */
  get title() {
    return this.templateQuestion.title;
  }
  set title(val) {
    this.templateQuestion.title = val;
  }
  get locTitle() {
    return this.templateQuestion.locTitle;
  }
  get fullTitle() {
    return this.locTitle.textOrHtml;
  }
  /**
   * A value to show in HTML questions and in the dynamic titles and descriptions of survey elements when the cell value is empty.
   *
   * Default value: `""`
   *
   * [Dynamic Texts](https://surveyjs.io/form-library/documentation/design-survey/conditional-logic#dynamic-texts (linkStyle))
   */
  get defaultDisplayValue() {
    return this.templateQuestion.defaultDisplayValue;
  }
  set defaultDisplayValue(val) {
    this.templateQuestion.defaultDisplayValue = val;
  }
  get locDefaultDisplayValue() {
    return this.templateQuestion.locDefaultDisplayValue;
  }
  /**
   * Marks the column as required. If a respondent skips any cell in a required column, the matrix displays a [validation error](#requiredErrorText).
   *
   * If you want to mark the column as required based on a condition, specify the [`requiredIf`](#requiredIf) property.
   * @see visible
   * @see readOnly
   */
  get isRequired() {
    return this.templateQuestion.isRequired;
  }
  set isRequired(val) {
    this.templateQuestion.isRequired = val;
  }
  get isRenderedRequired() {
    return this.getPropertyValue("isRenderedRequired", this.isRequired);
  }
  set isRenderedRequired(val) {
    this.setPropertyValue("isRenderedRequired", val);
  }
  updateIsRenderedRequired(val) {
    this.isRenderedRequired = val || this.isRequired;
  }
  get requiredMark() {
    return this.isRenderedRequired && this.getSurvey() ? this.getSurvey().requiredMark : this.templateQuestion.requiredMark;
  }
  /**
   * Specifies a custom error message for a required column.
   * @see isRequired
   */
  get requiredErrorText() {
    return this.templateQuestion.requiredErrorText;
  }
  set requiredErrorText(val) {
    this.templateQuestion.requiredErrorText = val;
  }
  get locRequiredErrorText() {
    return this.templateQuestion.locRequiredErrorText;
  }
  /**
   * Makes the column read-only.
   *
   * If you want to switch the column to the read-only state based on a condition, specify the [`enableIf`](#enableIf) property.
   * @see visible
   * @see isRequired
   */
  get readOnly() {
    return this.templateQuestion.readOnly;
  }
  set readOnly(val) {
    this.templateQuestion.readOnly = val;
  }
  get hasOther() {
    return this.templateQuestion.hasOther;
  }
  set hasOther(val) {
    this.templateQuestion.hasOther = val;
  }
  /**
   * A Boolean expression. If it evaluates to `false`, this column becomes hidden.
   *
   * Refer to the following help topic for more information: [Conditional Visibility](https://surveyjs.io/form-library/documentation/design-survey-conditional-logic#conditional-visibility).
   * @see visible
   */
  get visibleIf() {
    return this.templateQuestion.visibleIf;
  }
  set visibleIf(val) {
    this.templateQuestion.visibleIf = val;
  }
  /**
   * A Boolean expression. If it evaluates to `false`, this column becomes read-only.
   *
   * Refer to the following help topic for more information: [Conditional Visibility](https://surveyjs.io/form-library/documentation/design-survey-conditional-logic#conditional-visibility).
   * @see readOnly
   */
  get enableIf() {
    return this.templateQuestion.enableIf;
  }
  set enableIf(val) {
    this.templateQuestion.enableIf = val;
  }
  /**
   * A Boolean expression. If it evaluates to `true`, this column becomes required.
   *
   * Refer to the following help topic for more information: [Conditional Visibility](https://surveyjs.io/form-library/documentation/design-survey-conditional-logic#conditional-visibility).
   * @see isRequired
   */
  get requiredIf() {
    return this.templateQuestion.requiredIf;
  }
  set requiredIf(val) {
    this.templateQuestion.requiredIf = val;
  }
  /**
   * A Boolean expression. If it evaluates to `true`, all cells in this column are set to a value calculated using the [`defaultValueExpression`](#defaultValueExpression).
   *
   * [Expressions](https://surveyjs.io/form-library/documentation/design-survey/conditional-logic#expressions (linkStyle))
   * @see setValueIf
   */
  get resetValueIf() {
    return this.templateQuestion.resetValueIf;
  }
  set resetValueIf(val) {
    this.templateQuestion.resetValueIf = val;
  }
  /**
   * An expression used to calculate the column's default value. This expression applies to all cells of this column until the cell value is specified by an end user or programmatically.
   *
   * [Expressions](https://surveyjs.io/form-library/documentation/design-survey/conditional-logic#expressions (linkStyle))
   * @see setValueExpression
   */
  get defaultValueExpression() {
    return this.templateQuestion.defaultValueExpression;
  }
  set defaultValueExpression(val) {
    this.templateQuestion.defaultValueExpression = val;
  }
  /**
   * A Boolean expression. If it evaluates to `true`, all cells in this column are set to a value calculated using the [`setValueExpression`](#setValueExpression).
   *
   * [Expressions](https://surveyjs.io/form-library/documentation/design-survey/conditional-logic#expressions (linkStyle))
   * @see resetValueIf
   */
  get setValueIf() {
    return this.templateQuestion.setValueIf;
  }
  set setValueIf(val) {
    this.templateQuestion.setValueIf = val;
  }
  /**
   * An expression used to calculate a value for all column cells.
   *
   * You can use `setValueExpression` as a standalone property or in conjunction with the [`setValueIf`](#setValueIf) expression, in which case the calculated cell value applies only when `setValueIf` evaluates to `true`.
   *
   * [Expressions](https://surveyjs.io/form-library/documentation/design-survey/conditional-logic#expressions (linkStyle))
   * @see defaultValueExpression
   * @see resetValueIf
   */
  get setValueExpression() {
    return this.templateQuestion.setValueExpression;
  }
  set setValueExpression(val) {
    this.templateQuestion.setValueExpression = val;
  }
  /**
   * Specifies whether a respondent is required to provide a unique response for each question within this column.
   *
   * Default value: `false`
   */
  get isUnique() {
    return this.getPropertyValue("isUnique");
  }
  set isUnique(val) {
    this.setPropertyValue("isUnique", val);
  }
  /**
   * Specifies whether to create an individual column for each choice option. Applies only to columns of `"checkbox"` or `"radiogroup"` [`cellType`](#cellType).
   */
  get showInMultipleColumns() {
    return this.getPropertyValue("showInMultipleColumns");
  }
  set showInMultipleColumns(val) {
    this.setPropertyValue("showInMultipleColumns", val);
  }
  get isSupportMultipleColumns() {
    return ["checkbox", "radiogroup"].indexOf(this.cellType) > -1;
  }
  get isShowInMultipleColumns() {
    return this.showInMultipleColumns && this.isSupportMultipleColumns;
  }
  /**
   * Column validators.
   *
   * [Data Validation](https://surveyjs.io/form-library/documentation/data-validation (linkStyle))
   * @see isRequired
   */
  get validators() {
    return this.templateQuestion.validators;
  }
  set validators(val) {
    this.templateQuestion.validators = val;
  }
  /**
   * An aggregation method used to calculate the column total.
   *
   * Possible values:
   *
   * - `"none"` (default) - Disables total calculations.
   * - `"sum"`
   * - `"count"`
   * - `"min"`
   * - `"max"`
   * - `"avg"`
   *
   * [View Demo](https://surveyjs.io/form-library/examples/aggregate-data-within-form/ (linkStyle))
   * @see totalFormat
   * @see totalDisplayStyle
   */
  get totalType() {
    return this.getPropertyValue("totalType");
  }
  set totalType(val) {
    this.setPropertyValue("totalType", val);
  }
  /**
   * An expression used to calculate total values. Overrides the [`totalType`](#totalType) property.
   *
   * [Expressions](https://surveyjs.io/form-library/documentation/design-survey/conditional-logic#expressions (linkStyle))
   */
  get totalExpression() {
    return this.getPropertyValue("totalExpression");
  }
  set totalExpression(val) {
    this.setPropertyValue("totalExpression", val);
  }
  get hasTotal() {
    return this.totalType != "none" || !!this.totalExpression;
  }
  /**
   * A string pattern used to display column totals. To reference a total value within this pattern, use the `{0}` placeholder.
   *
   * [View Demo](https://surveyjs.io/form-library/examples/aggregate-data-within-form/ (linkStyle))
   * @see totalType
   * @see totalDisplayStyle
   */
  get totalFormat() {
    return this.getLocalizableStringText("totalFormat", "");
  }
  set totalFormat(val) {
    this.setLocalizableStringText("totalFormat", val);
  }
  get locTotalFormat() {
    return this.getLocalizableString("totalFormat");
  }
  get cellHint() {
    return this.getLocalizableStringText("cellHint", "");
  }
  set cellHint(val) {
    this.setLocalizableStringText("cellHint", val);
  }
  get locCellHint() {
    return this.getLocalizableString("cellHint");
  }
  get renderAs() {
    return this.getPropertyValue("renderAs");
  }
  set renderAs(val) {
    this.setPropertyValue("renderAs", val);
    if (!!this.templateQuestion) {
      this.templateQuestion.renderAs = val;
    }
  }
  get totalMaximumFractionDigits() {
    return this.getPropertyValue("totalMaximumFractionDigits");
  }
  set totalMaximumFractionDigits(val) {
    if (val < -1 || val > 20) return;
    this.setPropertyValue("totalMaximumFractionDigits", val);
  }
  get totalMinimumFractionDigits() {
    return this.getPropertyValue("totalMinimumFractionDigits");
  }
  set totalMinimumFractionDigits(val) {
    if (val < -1 || val > 20) return;
    this.setPropertyValue("totalMinimumFractionDigits", val);
  }
  /**
   * A format for calculated total values.
   *
   * Possible values:
   *
   * - `"none"` (default)
   * - `"decimal"`
   * - `"currency"`
   * - `"percent"`
   *
   * [View Demo](https://surveyjs.io/form-library/examples/aggregate-data-within-form/ (linkStyle))
   * @see totalType
   * @see totalFormat
   * @see totalCurrency
   */
  get totalDisplayStyle() {
    return this.getPropertyValue("totalDisplayStyle");
  }
  set totalDisplayStyle(val) {
    this.setPropertyValue("totalDisplayStyle", val);
  }
  /**
   * An alignment for calculated total values.
   *
   * Possible values:
   *
   * - `"left"`
   * - `"center"`
   * - `"right"`
   * - `"auto"` (default) - Applies one of the values above based on the column's [cell type](#cellType).
   *
   * [View Demo](https://surveyjs.io/form-library/examples/aggregate-data-within-form/ (linkStyle))
   * @see totalType
   * @see totalFormat
   * @see totalCurrency
   * @see totalDisplayStyle
   */
  get totalAlignment() {
    return this.getPropertyValue("totalAlignment");
  }
  set totalAlignment(val) {
    this.setPropertyValue("totalAlignment", val);
  }
  /**
   * Specifies a currency used to display calculated total values. Applies only if [`totalDisplayStyle`](#totalDisplayStyle) is set to `"currency"`.
   * @see totalType
   */
  get totalCurrency() {
    return this.getPropertyValue("totalCurrency");
  }
  set totalCurrency(val) {
    if (getCurrecyCodes().indexOf(val) < 0) return;
    this.setPropertyValue("totalCurrency", val);
  }
  /**
   * Gets or sets minimum column width in CSS values. By default, the matrix calculates column widths to optimally fit the content of all columns.
   * @see width
   */
  get minWidth() {
    return this.getPropertyValue("minWidth", "");
  }
  set minWidth(val) {
    this.setPropertyValue("minWidth", val);
  }
  /**
   * Gets or sets column width in CSS values. By default, the matrix calculates column widths to optimally fit the content of all columns.
   * @see minWidth
  */
  get width() {
    return this.templateQuestion.width;
  }
  set width(val) {
    this.templateQuestion.width = val;
  }
  /**
   * Gets or sets the number of columns used to arrange choice options. Applies only to columns of `"checkbox"` or `"radiogroup"` [`cellType`](#cellType).
   *
   * Default value: -1 (inherits the actual value from the parent matrix's [`columnColCount`](https://surveyjs.io/form-library/documentation/api-reference/matrix-table-with-dropdown-list#columnColCount) property)
   */
  get colCount() {
    return this.getPropertyValue("colCount");
  }
  set colCount(val) {
    if (val < -1 || val > 4) return;
    this.setPropertyValue("colCount", val);
  }
  getLocale() {
    return this.colOwner ? this.colOwner.getLocale() : "";
  }
  getMarkdownHtml(text, name) {
    return this.colOwner ? this.colOwner.getMarkdownHtml(text, name) : void 0;
  }
  getRenderer(name) {
    return !!this.colOwner ? this.colOwner.getRenderer(name) : null;
  }
  getRendererContext(locStr) {
    return !!this.colOwner ? this.colOwner.getRendererContext(locStr) : locStr;
  }
  getProcessedText(text) {
    return this.colOwner ? this.colOwner.getProcessedText(text) : text;
  }
  createCellQuestion(row) {
    var qType = this.calcCellQuestionType(row);
    var cellQuestion = this.createNewQuestion(qType);
    this.callOnCellQuestionUpdate(cellQuestion, row);
    return cellQuestion;
  }
  startLoadingFromJson(json2) {
    super.startLoadingFromJson(json2);
    if (!!json2 && !json2.cellType && !!json2.choices) {
      json2.cellType = this.colOwner.getCellType();
    }
  }
  updateCellQuestion(cellQuestion, data, onUpdateJson = null) {
    this.setQuestionProperties(cellQuestion, onUpdateJson);
  }
  callOnCellQuestionUpdate(cellQuestion, data) {
    var qType = cellQuestion.getType();
    var qDefinition = matrixDropdownColumnTypes[qType];
    if (qDefinition && qDefinition["onCellQuestionUpdate"]) {
      qDefinition["onCellQuestionUpdate"](cellQuestion, this, this.colOwner, data);
    }
  }
  defaultCellTypeChanged() {
    this.updateTemplateQuestion();
  }
  calcCellQuestionType(row) {
    let cellType = this.getDefaultCellQuestionType();
    if (!!row && !!this.colOwner) {
      cellType = this.colOwner.getCustomCellType(this, row, cellType);
    }
    return cellType;
  }
  getDefaultCellQuestionType(cellType) {
    if (!cellType) cellType = this.cellType;
    if (cellType !== "default") return cellType;
    if (this.colOwner) return this.colOwner.getCellType();
    return settings.matrix.defaultCellType;
  }
  updateTemplateQuestion(newCellType, name, title) {
    const curCellType = this.getDefaultCellQuestionType(newCellType);
    const prevCellType = this.templateQuestion ? this.templateQuestion.getType() : "";
    if (curCellType === prevCellType) return;
    if (this.templateQuestion) {
      this.removeProperties(prevCellType);
    }
    this.templateQuestionValue = this.createNewQuestion(curCellType);
    this.templateQuestion.locOwner = this;
    this.addProperties(curCellType);
    if (!!name) {
      this.name = name;
    }
    if (!!title) {
      this.title = title;
    } else {
      this.templateQuestion.locTitle.strChanged();
    }
    if (settings.serialization.matrixDropdownColumnSerializeTitle) {
      this.templateQuestion.locTitle.serializeCallBackText = true;
    }
    this.templateQuestion.onPropertyChanged.add((sender, options) => {
      this.propertyValueChanged(options.name, options.oldValue, options.newValue, options.arrayChanges, options.target);
    });
    this.templateQuestion.onItemValuePropertyChanged.add((sender, options) => {
      this.doItemValuePropertyChanged(options.propertyName, options.obj, options.name, options.newValue, options.oldValue);
    });
    this.templateQuestion.isContentElement = true;
    if (!this.isLoadingFromJson) {
      this.templateQuestion.onGetSurvey = () => {
        return this.getSurvey();
      };
    }
    this.templateQuestion.locTitle.strChanged();
  }
  createNewQuestion(cellType) {
    var question = Serializer.createClass(cellType);
    if (!question) {
      question = Serializer.createClass("text");
    }
    question.loadingOwner = this;
    question.isEditableTemplateElement = true;
    question.autoOtherMode = this.isShowInMultipleColumns;
    this.setQuestionProperties(question);
    this.setParentQuestionToTemplate(question);
    return question;
  }
  setParentQuestionToTemplate(question) {
    if (!!this.colOwner && this.colOwner.isQuestion) {
      question.setParentQuestion(this.colOwner);
    }
  }
  setQuestionProperties(question, onUpdateJson = null) {
    if (this.templateQuestion) {
      var json2 = new JsonObject().toJsonObject(this.templateQuestion, true);
      if (onUpdateJson) {
        onUpdateJson(json2);
      }
      json2.type = question.getType();
      if (this.cellType === "default" && !!this.colOwner && this.colOwner.hasChoices()) {
        delete json2["choices"];
      }
      delete json2["itemComponent"];
      if (this.jsonObj && json2.type === "rating") {
        Object.keys(this.jsonObj).forEach((prop) => {
          json2[prop] = this.jsonObj[prop];
        });
      }
      if (json2["choicesOrder"] === "random") {
        json2["choicesOrder"] = "none";
        const visChoices = this.templateQuestion["visibleChoices"];
        if (Array.isArray(visChoices)) {
          json2["choices"] = visChoices;
        }
      }
      new JsonObject().toObject(json2, question);
      question.isContentElement = this.templateQuestion.isContentElement;
      this.previousChoicesId = void 0;
      question.loadedChoicesFromServerCallback = () => {
        if (!this.isShowInMultipleColumns) return;
        if (!!this.previousChoicesId && this.previousChoicesId !== question.id) return;
        this.previousChoicesId = question.id;
        const choices = question.visibleChoices;
        this.templateQuestion.choices = choices;
        this.propertyValueChanged("choices", choices, choices);
      };
    }
  }
  propertyValueChanged(name, oldValue, newValue, arrayChanges, target) {
    super.propertyValueChanged(name, oldValue, newValue, arrayChanges, target);
    if (name === "isRequired") {
      this.updateIsRenderedRequired(newValue);
    }
    if (!this.colOwner || this.isLoadingFromJson) return;
    if (this.isShowInMultipleColumns) {
      if (name === "choicesOrder") return;
      if (["visibleChoices", "choices"].indexOf(name) > -1) {
        this.colOwner.onShowInMultipleColumnsChanged(this);
      }
    }
    if (!Serializer.hasOriginalProperty(this, name)) return;
    this.colOwner.onColumnPropertyChanged(this, name, newValue);
  }
  doItemValuePropertyChanged(propertyName, obj, name, newValue, oldValue) {
    if (!Serializer.hasOriginalProperty(obj, name)) return;
    if (this.colOwner != null && !this.isLoadingFromJson) {
      this.colOwner.onColumnItemValuePropertyChanged(this, propertyName, obj, name, newValue, oldValue);
    }
  }
  doShowInMultipleColumnsChanged() {
    if (this.colOwner != null) {
      this.colOwner.onShowInMultipleColumnsChanged(this);
    }
    if (this.templateQuestion) {
      this.templateQuestion.autoOtherMode = this.isShowInMultipleColumns;
    }
  }
  doColumnVisibilityChanged() {
    if (this.colOwner != null && !this.isDesignMode) {
      this.colOwner.onColumnVisibilityChanged(this);
    }
  }
  getProperties(curCellType) {
    return Serializer.getDynamicPropertiesByObj(this, curCellType);
  }
  removeProperties(curCellType) {
    var properties = this.getProperties(curCellType);
    for (var i = 0; i < properties.length; i++) {
      var prop = properties[i];
      delete this[prop.name];
      if (prop.serializationProperty) {
        delete this[prop.serializationProperty];
      }
    }
  }
  addProperties(curCellType) {
    const props = this.getProperties(curCellType);
    Serializer.addDynamicPropertiesIntoObj(this, this.templateQuestion, props);
  }
};
Serializer.addClass("matrixdropdowncolumn", [{
  name: "!name",
  isUnique: true
}, {
  name: "title",
  serializationProperty: "locTitle",
  dependsOn: "name",
  onPropertyEditorUpdate: function(obj, editor) {
    if (!!obj && !!editor) {
      editor.placeholder = obj.name;
    }
  }
}, {
  name: "cellHint",
  serializationProperty: "locCellHint",
  visible: false
}, {
  name: "cellType",
  default: "default",
  choices: () => {
    var res = MatrixDropdownColumn.getColumnTypes();
    res.splice(0, 0, "default");
    return res;
  }
}, {
  name: "colCount",
  default: -1,
  choices: [-1, 0, 1, 2, 3, 4]
}, "isRequired:boolean", "isUnique:boolean", {
  name: "requiredErrorText:text",
  serializationProperty: "locRequiredErrorText"
}, "readOnly:boolean", {
  name: "minWidth",
  onPropertyEditorUpdate: function(obj, editor) {
    if (!!obj && !!editor) {
      editor.value = obj.minWidth;
    }
  }
}, "width", {
  name: "visible:switch",
  default: true,
  overridingProperty: "visibleIf"
}, "visibleIf:condition", "enableIf:condition", "requiredIf:condition", "resetValueIf:condition", "setValueIf:condition", "setValueExpression:expression", {
  name: "showInMultipleColumns:boolean",
  dependsOn: "cellType",
  visibleIf: (obj) => {
    return obj.isSupportMultipleColumns;
  }
}, {
  name: "validators:validators",
  baseClassName: "surveyvalidator",
  classNamePart: "validator"
}, {
  name: "totalType",
  visibleIf: (obj) => !obj.isShowInMultipleColumns,
  default: "none",
  choices: ["none", "sum", "count", "min", "max", "avg"]
}, {
  name: "totalExpression:expression",
  visibleIf: (obj) => !obj.isShowInMultipleColumns
}, {
  name: "totalFormat",
  serializationProperty: "locTotalFormat",
  visibleIf: (obj) => obj.hasTotal
}, {
  name: "totalDisplayStyle",
  visibleIf: (obj) => obj.hasTotal,
  default: "none",
  choices: ["none", "decimal", "currency", "percent"]
}, {
  name: "totalAlignment",
  visibleIf: (obj) => obj.hasTotal,
  default: "auto",
  choices: ["auto", "left", "center", "right"]
}, {
  name: "totalCurrency",
  visibleIf: (obj) => obj.hasTotal,
  choices: () => {
    return getCurrecyCodes();
  },
  default: "USD"
}, {
  name: "totalMaximumFractionDigits:number",
  default: -1,
  visibleIf: (obj) => obj.hasTotal
}, {
  name: "totalMinimumFractionDigits:number",
  default: -1,
  visibleIf: (obj) => obj.hasTotal
}, {
  name: "renderAs",
  default: "default",
  visible: false
}, {
  name: "defaultDisplayValue",
  serializationProperty: "locDefaultDisplayValue"
}], function() {
  return new MatrixDropdownColumn("");
});
function getId(id, isError, isDetail) {
  return id + (isError ? "-error" : "") + (isDetail ? "-detail" : "");
}
var QuestionMatrixDropdownRenderedCell = class _QuestionMatrixDropdownRenderedCell {
  constructor() {
    this.minWidth = "";
    this.width = "";
    this.colSpans = 1;
    this.isActionsCell = false;
    this.isErrorsCell = false;
    this.isDragHandlerCell = false;
    this.isDetailRowCell = false;
    this.classNameValue = "";
    this.idValue = _QuestionMatrixDropdownRenderedCell.counter++;
  }
  get requiredMark() {
    return this.column && this.column.isRenderedRequired ? this.column.requiredMark : void 0;
  }
  get hasQuestion() {
    return !!this.question && !this.isErrorsCell;
  }
  get hasTitle() {
    return !!this.locTitle;
  }
  get hasPanel() {
    return !!this.panel;
  }
  get id() {
    let id = this.question ? this.question.id : this.idValue.toString();
    if (this.isChoice) {
      id += "-" + (Number.isInteger(this.choiceIndex) ? "index" + this.choiceIndex.toString() : this.item.id);
    }
    return getId(id, this.isErrorsCell, this.isDetailRowCell);
  }
  get item() {
    return this.itemValue;
  }
  set item(val) {
    this.itemValue = val;
    if (!!val) {
      val.hideCaption = true;
    }
  }
  get isChoice() {
    return !!this.item;
  }
  get isItemChoice() {
    return this.isChoice && !this.isOtherChoice;
  }
  get choiceValue() {
    return this.isChoice ? this.item.value : null;
  }
  get isCheckbox() {
    return this.isItemChoice && this.question.isDescendantOf("checkbox");
  }
  get isRadio() {
    return this.isItemChoice && this.question.isDescendantOf("radiogroup");
  }
  get isFirstChoice() {
    return this.choiceIndex === 0;
  }
  set className(val) {
    this.classNameValue = val;
  }
  get className() {
    const builder = new CssClassBuilder().append(this.classNameValue);
    if (this.hasQuestion) {
      builder.append(this.question.cssClasses.hasError, this.question.errors.length > 0).append(this.question.cssClasses.answered, this.question.isAnswered);
    }
    return builder.toString();
  }
  get cellQuestionWrapperClassName() {
    return this.cell.getQuestionWrapperClassName(this.matrix.cssClasses.cellQuestionWrapper);
  }
  get isVisible() {
    var _a;
    return !this.hasQuestion && !this.isErrorsCell || !((_a = this.matrix) === null || _a === void 0 ? void 0 : _a.isMobile) || this.question.isVisible;
  }
  get showResponsiveTitle() {
    var _a;
    return this.hasQuestion && ((_a = this.matrix) === null || _a === void 0 ? void 0 : _a.isMobile);
  }
  get responsiveTitleCss() {
    return new CssClassBuilder().append(this.matrix.cssClasses.cellResponsiveTitle).toString();
  }
  get responsiveLocTitle() {
    return this.cell.column.locTitle;
  }
  get headers() {
    if (this.cell && this.cell.column) {
      if (this.matrix.IsMultiplyColumn(this.cell.column)) {
        if (!!this.item) {
          return this.item.locText.renderedHtml;
        } else {
          return "";
        }
      }
      let cellHint = this.cell.column.cellHint;
      if (!!cellHint) {
        if (cellHint.trim() === "") return "";
        return this.cell.column.locCellHint.renderedHtml;
      }
      if (this.hasQuestion && this.question.isVisible && this.question.title) return this.question.title;
      return this.cell.column.title;
    }
    if (this.hasQuestion && this.question.isVisible) {
      return this.question.locTitle.renderedHtml;
    }
    if (this.hasTitle) {
      return this.locTitle.renderedHtml || "";
    }
    return "";
  }
  getTitle() {
    return this.matrix && this.matrix.showHeader ? this.headers : "";
  }
  calculateFinalClassName(matrixCssClasses) {
    const questionCss = this.cell.question.cssClasses;
    const builder = new CssClassBuilder().append(questionCss.itemValue, !!questionCss).append(questionCss.asCell, !!questionCss);
    return builder.append(matrixCssClasses.cell, builder.isEmpty() && !!matrixCssClasses).append(matrixCssClasses.choiceCell, this.isChoice).toString();
  }
  focusIn() {
    if (this.question) {
      this.question.focusIn();
    }
  }
};
QuestionMatrixDropdownRenderedCell.counter = 1;
var QuestionMatrixDropdownRenderedRow = class _QuestionMatrixDropdownRenderedRow extends Base {
  constructor(cssClasses, isDetailRow = false) {
    super();
    this.cssClasses = cssClasses;
    this.isDetailRow = isDetailRow;
    this.hasEndActions = false;
    this.isErrorsRow = false;
    this.cells = [];
    this.idValue = _QuestionMatrixDropdownRenderedRow.counter++;
  }
  get id() {
    var _a;
    return getId(((_a = this.row) === null || _a === void 0 ? void 0 : _a.id) || this.idValue.toString(), this.isErrorsRow, this.isDetailRow);
  }
  get attributes() {
    if (!this.row) return {};
    return {
      "data-sv-drop-target-matrix-row": this.row.id
    };
  }
  get className() {
    var _a, _b;
    return new CssClassBuilder().append(this.cssClasses.row).append(this.cssClasses.detailRow, this.isDetailRow).append(this.cssClasses.rowHasPanel, (_a = this.row) === null || _a === void 0 ? void 0 : _a.hasPanel).append(this.cssClasses.expandedRow, ((_b = this.row) === null || _b === void 0 ? void 0 : _b.isDetailPanelShowing) && !this.isDetailRow).append(this.cssClasses.rowHasEndActions, this.hasEndActions).append(this.cssClasses.ghostRow, this.isGhostRow).append(this.cssClasses.rowAdditional, this.isAdditionalClasses).toString();
  }
  setRootElement(val) {
    this.rootElement = val;
  }
  getRootElement() {
    return this.rootElement;
  }
  focusCell(cellIndex) {
    if (this.rootElement) {
      const inputElementSelector = `:scope td:nth-of-type(${cellIndex + 1}) input, :scope td:nth-of-type(${cellIndex + 1}) button`;
      const inputElement = this.rootElement.querySelectorAll(inputElementSelector)[0];
      if (inputElement) {
        inputElement.focus();
      }
    }
  }
};
QuestionMatrixDropdownRenderedRow.counter = 1;
__decorate([property({
  defaultValue: false
})], QuestionMatrixDropdownRenderedRow.prototype, "isGhostRow", void 0);
__decorate([property({
  defaultValue: false
})], QuestionMatrixDropdownRenderedRow.prototype, "isAdditionalClasses", void 0);
__decorate([property({
  defaultValue: true
})], QuestionMatrixDropdownRenderedRow.prototype, "visible", void 0);
var QuestionMatrixDropdownRenderedErrorRow = class extends QuestionMatrixDropdownRenderedRow {
  constructor(cssClasses) {
    super(cssClasses);
    this.isErrorsRow = true;
  }
  get attributes() {
    return {};
  }
  get className() {
    return new CssClassBuilder().append(this.cssClasses.row).append(this.cssClasses.errorRow).toString();
  }
  onAfterCreated() {
    const callback = () => {
      this.visible = this.cells.some((cell) => cell.question && cell.question.hasVisibleErrors);
    };
    this.cells.forEach((cell) => {
      if (cell.question) {
        cell.question.registerFunctionOnPropertyValueChanged("hasVisibleErrors", callback);
      }
    });
    callback();
  }
};
var QuestionMatrixDropdownRenderedTable = class extends Base {
  getIsAnimationAllowed() {
    return super.getIsAnimationAllowed() && this.matrix.animationAllowed;
  }
  getRenderedRowsAnimationOptions() {
    const onBeforeRunAnimation = (el) => {
      el.querySelectorAll(":scope > td > *").forEach((el2) => {
        prepareElementForVerticalAnimation(el2);
      });
    };
    const onAfterRunAnimation = (el) => {
      el.querySelectorAll(":scope > td > *").forEach((el2) => {
        cleanHtmlElementAfterAnimation(el2);
      });
    };
    return {
      isAnimationEnabled: () => {
        return this.animationAllowed;
      },
      getRerenderEvent: () => this.onElementRerendered,
      getAnimatedElement(el) {
        return el.getRootElement();
      },
      getLeaveOptions: () => {
        return {
          cssClass: this.cssClasses.rowLeave,
          onBeforeRunAnimation,
          onAfterRunAnimation
        };
      },
      getEnterOptions: (_, info) => {
        return {
          cssClass: this.cssClasses.rowEnter,
          onBeforeRunAnimation,
          onAfterRunAnimation
        };
      },
      getKey: (item) => {
        return item.id;
      }
    };
  }
  updateRenderedRows() {
    this.renderedRows = this.rows;
  }
  get renderedRows() {
    return this._renderedRows;
  }
  set renderedRows(val) {
    this.renderedRowsAnimation.sync(val);
  }
  constructor(matrix) {
    super();
    this.matrix = matrix;
    this._renderedRows = [];
    this.renderedRowsAnimation = new AnimationGroup(this.getRenderedRowsAnimationOptions(), (val) => {
      this._renderedRows = val;
    }, () => this._renderedRows);
    this.hasActionCellInRowsValues = {};
    this.build();
  }
  get showTable() {
    return this.getPropertyValue("showTable", true);
  }
  get showHeader() {
    return this.getPropertyValue("showHeader");
  }
  get showAddRow() {
    return this.getPropertyValue("showAddRow", false);
  }
  get showAddRowOnTop() {
    return this.getPropertyValue("showAddRowOnTop", false);
  }
  get showAddRowOnBottom() {
    return this.getPropertyValue("showAddRowOnBottom", false);
  }
  get showFooter() {
    return this.matrix.hasFooter && this.matrix.isColumnLayoutHorizontal;
  }
  get hasFooter() {
    return !!this.footerRow;
  }
  get hasRemoveRows() {
    return this.hasRemoveRowsValue;
  }
  isRequireReset() {
    return this.hasRemoveRows != this.matrix.canRemoveRows || !this.matrix.isColumnLayoutHorizontal;
  }
  get headerRow() {
    return this.headerRowValue;
  }
  get footerRow() {
    return this.footerRowValue;
  }
  get isRowsDragAndDrop() {
    return this.matrix.isRowsDragAndDrop && this.matrix.isColumnLayoutHorizontal;
  }
  get showCellErrorsTop() {
    return this.matrix.getErrorLocation() === "top";
  }
  get showCellErrorsBottom() {
    return this.matrix.getErrorLocation() === "bottom";
  }
  build() {
    this.hasRemoveRowsValue = this.matrix.canRemoveRows;
    this.matrix.visibleRows;
    this.cssClasses = this.matrix.cssClasses;
    this.buildRowsActions();
    this.buildHeader();
    this.buildRows();
    this.buildFooter();
    this.updateShowTableAndAddRow();
  }
  updateShowTableAndAddRow() {
    var showTable = this.rows.length > 0 || this.matrix.isDesignMode || !this.matrix.getShowColumnsIfEmpty();
    this.setPropertyValue("showTable", showTable);
    var showAddRow = this.matrix.canAddRow && showTable;
    var showAddRowOnTop = showAddRow;
    var showAddRowOnBottom = showAddRow;
    if (showAddRowOnTop) {
      if (this.matrix.getAddRowLocation() === "default") {
        showAddRowOnTop = !this.matrix.isColumnLayoutHorizontal;
      } else {
        showAddRowOnTop = this.matrix.getAddRowLocation() !== "bottom";
      }
    }
    if (showAddRowOnBottom && this.matrix.getAddRowLocation() !== "topBottom") {
      showAddRowOnBottom = !showAddRowOnTop;
    }
    this.setPropertyValue("showAddRow", this.matrix.canAddRow);
    this.setPropertyValue("showAddRowOnTop", showAddRowOnTop);
    this.setPropertyValue("showAddRowOnBottom", showAddRowOnBottom);
  }
  onAddedRow(row, index) {
    if (this.getRenderedDataRowCount() >= this.matrix.visibleRows.length) return;
    let rowIndex = this.getRenderedRowIndexByIndex(index);
    this.rowsActions.splice(index, 0, this.buildRowActions(row));
    this.addHorizontalRow(this.rows, row, rowIndex);
    this.updateShowTableAndAddRow();
  }
  getRenderedRowIndexByIndex(index) {
    let res = 0;
    let dataRowIndex = 0;
    for (var i = 0; i < this.rows.length; i++) {
      if (dataRowIndex === index) {
        if (this.rows[i].isErrorsRow || this.rows[i].isDetailRow) {
          res++;
          if (i + 1 < this.rows.length && this.rows[i + 1].isDetailRow) {
            res++;
          }
        }
        break;
      }
      res++;
      if (!this.rows[i].isErrorsRow && !this.rows[i].isDetailRow) dataRowIndex++;
    }
    if (dataRowIndex < index) return this.rows.length;
    return res;
  }
  getRenderedDataRowCount() {
    var res = 0;
    for (var i = 0; i < this.rows.length; i++) {
      if (!this.rows[i].isErrorsRow && !this.rows[i].isDetailRow) res++;
    }
    return res;
  }
  onRemovedRow(row) {
    var rowIndex = this.getRenderedRowIndex(row);
    if (rowIndex < 0) return;
    this.rowsActions.splice(rowIndex, 1);
    var removeCount = 1;
    if (rowIndex < this.rows.length - 1 && this.showCellErrorsBottom && this.rows[rowIndex + 1].isErrorsRow) {
      removeCount++;
    }
    if (rowIndex < this.rows.length - 1 && (this.rows[rowIndex + 1].isDetailRow || this.showCellErrorsBottom && rowIndex + 1 < this.rows.length - 1 && this.rows[rowIndex + 2].isDetailRow)) {
      removeCount++;
    }
    if (rowIndex > 0 && this.showCellErrorsTop && this.rows[rowIndex - 1].isErrorsRow) {
      rowIndex--;
      removeCount++;
    }
    this.rows.splice(rowIndex, removeCount);
    this.updateShowTableAndAddRow();
  }
  onDetailPanelChangeVisibility(row, isShowing) {
    const rowIndex = this.getRenderedRowIndex(row);
    if (rowIndex < 0) return;
    let currentIndex = rowIndex;
    if (this.showCellErrorsBottom) currentIndex++;
    var panelRowIndex = currentIndex < this.rows.length - 1 && this.rows[currentIndex + 1].isDetailRow ? currentIndex + 1 : -1;
    if (isShowing && panelRowIndex > -1 || !isShowing && panelRowIndex < 0) return;
    if (isShowing) {
      var detailRow = this.createDetailPanelRow(row, this.rows[rowIndex]);
      this.rows.splice(currentIndex + 1, 0, detailRow);
    } else {
      this.rows.splice(panelRowIndex, 1);
    }
  }
  focusActionCell(row, actionCellIndex) {
    let row2Focus = this.rows[this.rows.length - 1];
    if (this.matrix.isColumnLayoutHorizontal) {
      const nextRenderedRowIndex = this.getRenderedRowIndex(row);
      row2Focus = this.rows[nextRenderedRowIndex];
    }
    row2Focus === null || row2Focus === void 0 ? void 0 : row2Focus.focusCell(actionCellIndex);
  }
  getRenderedRowIndex(row) {
    for (var i = 0; i < this.rows.length; i++) {
      if (this.rows[i].row == row) return i;
    }
    return -1;
  }
  buildRowsActions() {
    this.rowsActions = [];
    var rows = this.matrix.visibleRows;
    for (var i = 0; i < rows.length; i++) {
      this.rowsActions.push(this.buildRowActions(rows[i]));
    }
  }
  createRenderedRow(cssClasses, isDetailRow = false) {
    return new QuestionMatrixDropdownRenderedRow(cssClasses, isDetailRow);
  }
  createErrorRenderedRow(cssClasses) {
    return new QuestionMatrixDropdownRenderedErrorRow(cssClasses);
  }
  buildHeader() {
    var colHeaders = this.matrix.isColumnLayoutHorizontal && this.matrix.showHeader;
    var isShown = colHeaders || this.matrix.hasRowText && !this.matrix.isColumnLayoutHorizontal;
    this.setPropertyValue("showHeader", isShown);
    if (!isShown) return;
    this.headerRowValue = this.createRenderedRow(this.cssClasses);
    if (this.isRowsDragAndDrop) {
      this.headerRow.cells.push(this.createHeaderCell(null, "action", this.cssClasses.actionsCellDrag));
    }
    if (this.hasActionCellInRows("start")) {
      this.headerRow.cells.push(this.createHeaderCell(null, "action"));
    }
    if (this.matrix.hasRowText && this.matrix.showHeader) {
      this.headerRow.cells.push(this.createHeaderCell(null));
    }
    if (this.matrix.isColumnLayoutHorizontal) {
      for (var i = 0; i < this.matrix.columns.length; i++) {
        var column = this.matrix.columns[i];
        if (!column.isColumnVisible) continue;
        if (this.matrix.IsMultiplyColumn(column)) {
          this.createMutlipleColumnsHeader(column);
        } else {
          this.headerRow.cells.push(this.createHeaderCell(column));
        }
      }
    } else {
      var rows = this.matrix.visibleRows;
      for (var i = 0; i < rows.length; i++) {
        const cell = this.createTextCell(rows[i].locText);
        this.setHeaderCellCssClasses(cell);
        cell.row = rows[i];
        this.headerRow.cells.push(cell);
      }
      if (this.matrix.hasFooter) {
        const cell = this.createTextCell(this.matrix.getFooterText());
        this.setHeaderCellCssClasses(cell);
        this.headerRow.cells.push(cell);
      }
    }
    if (this.hasActionCellInRows("end")) {
      this.headerRow.cells.push(this.createHeaderCell(null, "action"));
    }
  }
  buildFooter() {
    if (!this.showFooter) return;
    this.footerRowValue = this.createRenderedRow(this.cssClasses);
    if (this.isRowsDragAndDrop) {
      this.footerRow.cells.push(this.createHeaderCell(null));
    }
    if (this.hasActionCellInRows("start")) {
      this.footerRow.cells.push(this.createHeaderCell(null, "action"));
    }
    if (this.matrix.hasRowText) {
      const cell2 = this.createTextCell(this.matrix.getFooterText());
      cell2.className = new CssClassBuilder().append(cell2.className).append(this.cssClasses.footerTotalCell).toString();
      this.footerRow.cells.push(cell2);
    }
    var cells = this.matrix.visibleTotalRow.cells;
    for (var i = 0; i < cells.length; i++) {
      var cell = cells[i];
      if (!cell.column.isColumnVisible) continue;
      if (this.matrix.IsMultiplyColumn(cell.column)) {
        this.createMutlipleColumnsFooter(this.footerRow, cell);
      } else {
        var editCell = this.createEditCell(cell);
        if (cell.column) {
          this.setCellWidth(cell.column, editCell);
        }
        editCell.className = new CssClassBuilder().append(editCell.className).append(this.cssClasses.footerCell).toString();
        this.footerRow.cells.push(editCell);
      }
    }
    if (this.hasActionCellInRows("end")) {
      this.footerRow.cells.push(this.createHeaderCell(null, "action"));
    }
  }
  buildRows() {
    this.blockAnimations();
    var rows = this.matrix.isColumnLayoutHorizontal ? this.buildHorizontalRows() : this.buildVerticalRows();
    this.rows = rows;
    this.releaseAnimations();
  }
  hasActionCellInRows(location) {
    if (this.hasActionCellInRowsValues[location] === void 0) {
      this.hasActionCellInRowsValues[location] = this.hasActionsCellInLocaltion(location);
    }
    return this.hasActionCellInRowsValues[location];
  }
  hasActionsCellInLocaltion(location) {
    if (location == "end" && this.hasRemoveRows) return true;
    return this.matrix.visibleRows.some((row, index) => !this.isValueEmpty(this.getRowActions(index, location)));
  }
  canRemoveRow(row) {
    return this.matrix.canRemoveRow(row);
  }
  buildHorizontalRows() {
    var rows = this.matrix.visibleRows;
    var renderedRows = [];
    for (var i = 0; i < rows.length; i++) {
      this.addHorizontalRow(renderedRows, rows[i]);
    }
    return renderedRows;
  }
  addHorizontalRow(renderedRows, row, index = -1) {
    const renderedRow = this.createHorizontalRow(row);
    const errorRow = this.createErrorRow(renderedRow);
    renderedRow.row = row;
    if (index < 0) {
      index = renderedRows.length;
    }
    if (this.matrix.isMobile) {
      const cells = [];
      for (let i = 0; i < renderedRow.cells.length; i++) {
        if (this.showCellErrorsTop && !errorRow.cells[i].isEmpty) {
          cells.push(errorRow.cells[i]);
        }
        cells.push(renderedRow.cells[i]);
        if (this.showCellErrorsBottom && !errorRow.cells[i].isEmpty) {
          cells.push(errorRow.cells[i]);
        }
      }
      renderedRow.cells = cells;
      renderedRows.splice(index, 0, renderedRow);
    } else {
      renderedRows.splice(index, 0, ...this.showCellErrorsTop ? [errorRow, renderedRow] : [renderedRow, errorRow]);
      index++;
    }
    if (row.isDetailPanelShowing) {
      renderedRows.splice(index + 1, 0, this.createDetailPanelRow(row, renderedRow));
    }
  }
  getRowDragCell(rowIndex) {
    const cell = new QuestionMatrixDropdownRenderedCell();
    const lockedRows = this.matrix.lockedRowCount;
    cell.isDragHandlerCell = lockedRows < 1 || rowIndex >= lockedRows;
    cell.isEmpty = !cell.isDragHandlerCell;
    cell.className = this.getActionsCellClassName(cell);
    cell.row = this.matrix.visibleRows[rowIndex];
    return cell;
  }
  getActionsCellClassName(cell = null) {
    const classBuilder = new CssClassBuilder().append(this.cssClasses.actionsCell).append(this.cssClasses.actionsCellDrag, cell === null || cell === void 0 ? void 0 : cell.isDragHandlerCell).append(this.cssClasses.detailRowCell, cell === null || cell === void 0 ? void 0 : cell.isDetailRowCell).append(this.cssClasses.verticalCell, !this.matrix.isColumnLayoutHorizontal);
    if (cell.isActionsCell) {
      const actions = cell.item.value.actions;
      if (this.cssClasses.actionsCellPrefix) {
        actions.forEach((action) => {
          classBuilder.append(this.cssClasses.actionsCellPrefix + "--" + action.id);
        });
      }
    }
    return classBuilder.toString();
  }
  getRowActionsCell(rowIndex, location, isDetailRow = false) {
    const rowActions = this.getRowActions(rowIndex, location);
    if (!this.isValueEmpty(rowActions)) {
      const cell = new QuestionMatrixDropdownRenderedCell();
      const actionContainer = this.matrix.allowAdaptiveActions ? new AdaptiveActionContainer() : new ActionContainer();
      if (!!this.matrix.survey && this.matrix.survey.getCss().actionBar) {
        actionContainer.cssClasses = this.matrix.survey.getCss().actionBar;
      }
      actionContainer.setItems(rowActions);
      const itemValue = new ItemValue(actionContainer);
      cell.item = itemValue;
      cell.isActionsCell = true;
      cell.isDragHandlerCell = false;
      cell.isDetailRowCell = isDetailRow;
      cell.className = this.getActionsCellClassName(cell);
      cell.row = this.matrix.visibleRows[rowIndex];
      return cell;
    }
    return null;
  }
  getRowActions(rowIndex, location) {
    var actions = this.rowsActions[rowIndex];
    if (!Array.isArray(actions)) return [];
    return actions.filter((action) => {
      if (!action.location) {
        action.location = "start";
      }
      return action.location === location;
    });
  }
  buildRowActions(row) {
    var actions = [];
    this.setDefaultRowActions(row, actions);
    if (!!this.matrix.survey) {
      actions = this.matrix.survey.getUpdatedMatrixRowActions(this.matrix, row, actions);
    }
    return actions;
  }
  get showRemoveButtonAsIcon() {
    return settings.matrix.renderRemoveAsIcon && this.matrix.survey && this.matrix.survey.css.root === "sd-root-modern";
  }
  setDefaultRowActions(row, actions) {
    const matrix = this.matrix;
    if (this.hasRemoveRows && this.canRemoveRow(row)) {
      if (!this.showRemoveButtonAsIcon) {
        actions.push(new Action({
          id: "remove-row",
          location: "end",
          enabled: !this.matrix.isInputReadOnly,
          component: "sv-matrix-remove-button",
          data: {
            row,
            question: this.matrix
          }
        }));
      } else {
        actions.push(new Action({
          id: "remove-row",
          iconName: "icon-delete-24x24",
          iconSize: "auto",
          component: "sv-action-bar-item",
          innerCss: new CssClassBuilder().append(this.matrix.cssClasses.button).append(this.matrix.cssClasses.buttonRemove).toString(),
          location: "end",
          showTitle: false,
          title: matrix.removeRowText,
          enabled: !matrix.isInputReadOnly,
          data: {
            row,
            question: matrix
          },
          action: () => {
            matrix.removeRowUI(row);
          }
        }));
      }
    }
    if (row.hasPanel) {
      if (this.matrix.isMobile) {
        actions.unshift(new Action({
          id: "show-detail-mobile",
          title: new ComputedUpdater(() => row.isDetailPanelShowing ? this.matrix.getLocalizationString("hideDetails") : this.matrix.getLocalizationString("showDetails")),
          showTitle: true,
          location: "end",
          action: (context) => {
            row.showHideDetailPanelClick();
          }
        }));
      } else {
        actions.push(new Action({
          id: "show-detail",
          title: this.matrix.getLocalizationString("editText"),
          showTitle: false,
          location: "start",
          component: "sv-matrix-detail-button",
          data: {
            row,
            question: this.matrix
          }
        }));
      }
    }
  }
  createErrorRow(row) {
    const res = this.createErrorRenderedRow(this.cssClasses);
    for (let i = 0; i < row.cells.length; i++) {
      const cell = row.cells[i];
      if (!cell.hasQuestion) {
        res.cells.push(this.createEmptyCell(true));
      } else if (this.matrix.IsMultiplyColumn(cell.cell.column)) {
        if (cell.isFirstChoice) {
          res.cells.push(this.createErrorCell(cell.cell));
        } else {
          res.cells.push(this.createEmptyCell(true));
        }
      } else {
        res.cells.push(this.createErrorCell(cell.cell));
      }
    }
    res.onAfterCreated();
    return res;
  }
  createHorizontalRow(row) {
    var res = this.createRenderedRow(this.cssClasses);
    if (this.isRowsDragAndDrop) {
      var rowIndex = this.matrix.visibleRows.indexOf(row);
      res.cells.push(this.getRowDragCell(rowIndex));
    }
    this.addRowActionsCell(row, res, "start");
    if (this.matrix.hasRowText) {
      var renderedCell = this.createTextCell(row.locText);
      renderedCell.row = row;
      res.cells.push(renderedCell);
      this.setCellWidth(null, renderedCell);
      renderedCell.className = new CssClassBuilder().append(renderedCell.className).append(this.cssClasses.rowTextCell).append(this.cssClasses.columnTitleCell, !this.matrix.isColumnLayoutHorizontal).append(this.cssClasses.detailRowText, row.hasPanel).toString();
    }
    for (var i = 0; i < row.cells.length; i++) {
      let cell = row.cells[i];
      if (!cell.column.isColumnVisible) continue;
      if (this.matrix.IsMultiplyColumn(cell.column)) {
        this.createMutlipleEditCells(res, cell);
      } else {
        if (cell.column.isShowInMultipleColumns) {
          cell.question.visibleChoices.map((c) => c.hideCaption = false);
        }
        var renderedCell = this.createEditCell(cell);
        res.cells.push(renderedCell);
        this.setCellWidth(cell.column, renderedCell);
      }
    }
    this.addRowActionsCell(row, res, "end");
    return res;
  }
  addRowActionsCell(row, renderedRow, location) {
    var rowIndex = this.matrix.visibleRows.indexOf(row);
    if (this.hasActionCellInRows(location)) {
      const actions = this.getRowActionsCell(rowIndex, location, renderedRow.isDetailRow);
      if (!!actions) {
        renderedRow.cells.push(actions);
        renderedRow.hasEndActions = true;
      } else {
        var cell = new QuestionMatrixDropdownRenderedCell();
        cell.isEmpty = true;
        cell.isDetailRowCell = renderedRow.isDetailRow;
        renderedRow.cells.push(cell);
      }
    }
  }
  createDetailPanelRow(row, renderedRow) {
    const panelFullWidth = this.matrix.isDesignMode;
    var res = this.createRenderedRow(this.cssClasses, true);
    res.row = row;
    var buttonCell = new QuestionMatrixDropdownRenderedCell();
    if (this.matrix.hasRowText) {
      buttonCell.colSpans = 2;
    }
    buttonCell.isEmpty = true;
    if (!panelFullWidth) res.cells.push(buttonCell);
    var actionsCell = null;
    if (this.hasActionCellInRows("end")) {
      actionsCell = new QuestionMatrixDropdownRenderedCell();
      actionsCell.isEmpty = true;
    }
    var cell = new QuestionMatrixDropdownRenderedCell();
    cell.panel = row.detailPanel;
    cell.colSpans = renderedRow.cells.length - (!panelFullWidth ? buttonCell.colSpans : 0) - (!!actionsCell ? actionsCell.colSpans : 0);
    cell.className = this.cssClasses.detailPanelCell;
    res.cells.push(cell);
    if (!!actionsCell) {
      if (this.matrix.isMobile) {
        this.addRowActionsCell(row, res, "end");
      } else {
        res.cells.push(actionsCell);
      }
    }
    if (typeof this.matrix.onCreateDetailPanelRenderedRowCallback === "function") {
      this.matrix.onCreateDetailPanelRenderedRowCallback(res);
    }
    return res;
  }
  buildVerticalRows() {
    var columns = this.matrix.columns;
    var renderedRows = [];
    for (var i = 0; i < columns.length; i++) {
      var col = columns[i];
      if (col.isColumnVisible) {
        if (this.matrix.IsMultiplyColumn(col)) {
          this.createMutlipleVerticalRows(renderedRows, col, i);
        } else {
          const renderedRow = this.createVerticalRow(col, i);
          const errorRow = this.createErrorRow(renderedRow);
          if (this.showCellErrorsTop) {
            renderedRows.push(errorRow);
            renderedRows.push(renderedRow);
          } else {
            renderedRows.push(renderedRow);
            renderedRows.push(errorRow);
          }
        }
      }
    }
    if (this.hasActionCellInRows("end")) {
      renderedRows.push(this.createEndVerticalActionRow());
    }
    return renderedRows;
  }
  createMutlipleVerticalRows(renderedRows, column, index) {
    var choices = this.getMultipleColumnChoices(column);
    if (!choices) return;
    for (var i = 0; i < choices.length; i++) {
      const renderedRow = this.createVerticalRow(column, index, choices[i], i);
      const errorRow = this.createErrorRow(renderedRow);
      if (this.showCellErrorsTop) {
        renderedRows.push(errorRow);
        renderedRows.push(renderedRow);
      } else {
        renderedRows.push(renderedRow);
        renderedRows.push(errorRow);
      }
    }
  }
  createVerticalRow(column, index, choice = null, choiceIndex = -1) {
    var res = this.createRenderedRow(this.cssClasses);
    if (this.matrix.showHeader) {
      var lTitle = !!choice ? choice.locText : column.locTitle;
      var hCell = this.createTextCell(lTitle);
      hCell.column = column;
      hCell.className = new CssClassBuilder().append(hCell.className).append(this.cssClasses.rowTextCell).append(this.cssClasses.columnTitleCell).toString();
      res.cells.push(hCell);
    }
    var rows = this.matrix.visibleRows;
    for (var i = 0; i < rows.length; i++) {
      var rChoice = choice;
      var rChoiceIndex = choiceIndex >= 0 ? choiceIndex : i;
      var cell = rows[i].cells[index];
      var visChoices = !!choice ? cell.question.visibleChoices : void 0;
      if (!!visChoices && rChoiceIndex < visChoices.length) {
        rChoice = visChoices[rChoiceIndex];
      }
      var rCell = this.createEditCell(cell, rChoice);
      rCell.item = rChoice;
      rCell.choiceIndex = rChoiceIndex;
      res.cells.push(rCell);
    }
    if (this.matrix.hasTotal) {
      res.cells.push(this.createEditCell(this.matrix.visibleTotalRow.cells[index]));
    }
    return res;
  }
  createEndVerticalActionRow() {
    var res = this.createRenderedRow(this.cssClasses);
    if (this.matrix.showHeader) {
      res.cells.push(this.createEmptyCell());
    }
    var rows = this.matrix.visibleRows;
    for (var i = 0; i < rows.length; i++) {
      res.cells.push(this.getRowActionsCell(i, "end"));
    }
    if (this.matrix.hasTotal) {
      res.cells.push(this.createEmptyCell());
    }
    return res;
  }
  createMutlipleEditCells(rRow, cell, isFooter = false) {
    var choices = isFooter ? this.getMultipleColumnChoices(cell.column) : cell.question.visibleChoices;
    if (!choices) return;
    for (var i = 0; i < choices.length; i++) {
      var rCell = this.createEditCell(cell, !isFooter ? choices[i] : void 0);
      if (!isFooter) {
        this.setItemCellCssClasses(rCell);
        rCell.choiceIndex = i;
      }
      rRow.cells.push(rCell);
    }
  }
  setItemCellCssClasses(cell) {
    cell.className = new CssClassBuilder().append(this.cssClasses.cell).append(this.cssClasses.itemCell).append(this.cssClasses.radioCell, cell.isRadio).append(this.cssClasses.checkboxCell, cell.isCheckbox).toString();
  }
  createEditCell(cell, choiceItem = void 0) {
    var res = new QuestionMatrixDropdownRenderedCell();
    res.cell = cell;
    res.row = cell.row;
    res.column = cell.column;
    res.question = cell.question;
    res.matrix = this.matrix;
    res.item = choiceItem;
    res.isOtherChoice = !!choiceItem && !!cell.question && cell.question.otherItem === choiceItem;
    res.className = res.calculateFinalClassName(this.cssClasses);
    return res;
  }
  createErrorCell(cell, choiceItem = void 0) {
    var res = new QuestionMatrixDropdownRenderedCell();
    res.question = cell.question;
    res.row = cell.row;
    res.matrix = this.matrix;
    res.isErrorsCell = true;
    res.className = new CssClassBuilder().append(this.cssClasses.cell).append(this.cssClasses.errorsCell).append(this.cssClasses.errorsCellTop, this.showCellErrorsTop).append(this.cssClasses.errorsCellBottom, this.showCellErrorsBottom).toString();
    return res;
  }
  createMutlipleColumnsFooter(rRow, cell) {
    this.createMutlipleEditCells(rRow, cell, true);
  }
  createMutlipleColumnsHeader(column) {
    var choices = this.getMultipleColumnChoices(column);
    if (!choices) return;
    for (var i = 0; i < choices.length; i++) {
      var cell = this.createTextCell(choices[i].locText);
      this.setHeaderCell(column, cell);
      this.setHeaderCellCssClasses(cell);
      this.headerRow.cells.push(cell);
    }
  }
  getMultipleColumnChoices(column) {
    var choices = column.templateQuestion.choices;
    if (!!choices && Array.isArray(choices) && choices.length == 0) return [].concat(this.matrix.choices, column.getVisibleMultipleChoices());
    choices = column.getVisibleMultipleChoices();
    if (!choices || !Array.isArray(choices)) return null;
    return choices;
  }
  setHeaderCellCssClasses(cell, cellType, classMod) {
    cell.className = new CssClassBuilder().append(this.cssClasses.headerCell).append(this.cssClasses.columnTitleCell, this.matrix.isColumnLayoutHorizontal).append(this.cssClasses.emptyCell, !!cell.isEmpty).append(this.cssClasses.cell + "--" + cellType, !!cellType).append(classMod, !!classMod).toString();
  }
  createHeaderCell(column, cellType = null, classMod) {
    let cell = !!column ? this.createTextCell(column.locTitle) : this.createEmptyCell();
    cell.column = column;
    this.setHeaderCell(column, cell);
    if (!cellType) cellType = !!column && column.cellType !== "default" ? column.cellType : this.matrix.cellType;
    this.setHeaderCellCssClasses(cell, cellType, classMod);
    return cell;
  }
  setHeaderCell(column, cell) {
    this.setCellWidth(column, cell);
  }
  setCellWidth(column, cell) {
    cell.minWidth = column != null ? this.matrix.getColumnWidth(column) : this.matrix.getRowTitleWidth();
    cell.width = column != null ? column.width : this.matrix.getRowTitleWidth();
  }
  createTextCell(locTitle) {
    var cell = new QuestionMatrixDropdownRenderedCell();
    cell.locTitle = locTitle;
    if (!!this.cssClasses.cell) {
      cell.className = this.cssClasses.cell;
    }
    return cell;
  }
  createEmptyCell(isError = false) {
    const res = this.createTextCell(null);
    res.isEmpty = true;
    res.className = new CssClassBuilder().append(this.cssClasses.cell).append(this.cssClasses.emptyCell).append(this.cssClasses.errorsCell, isError).toString();
    return res;
  }
};
__decorate([propertyArray({
  onPush: (_, i, target) => {
    target.updateRenderedRows();
  },
  onRemove: (_, i, target) => {
    target.updateRenderedRows();
  }
})], QuestionMatrixDropdownRenderedTable.prototype, "rows", void 0);
__decorate([propertyArray()], QuestionMatrixDropdownRenderedTable.prototype, "_renderedRows", void 0);
var MatrixDropdownCell = class {
  constructor(column, row, data) {
    this.column = column;
    this.row = row;
    this.data = data;
    this.questionValue = this.createQuestion(column, row, data);
    this.questionValue.updateCustomWidget();
    this.updateCellQuestionTitleDueToAccessebility(row);
  }
  updateCellQuestionTitleDueToAccessebility(row) {
    this.questionValue.locTitle.onGetTextCallback = (str) => {
      if (!row || !row.getSurvey()) return this.questionValue.title;
      const rowTitle = row.getAccessbilityText();
      if (!rowTitle) return this.questionValue.title;
      return this.column.colOwner.getCellAriaLabel(rowTitle, this.questionValue.title);
    };
  }
  locStrsChanged() {
    this.question.locStrsChanged();
  }
  createQuestion(column, row, data) {
    const res = data.createQuestion(this.row, this.column);
    res.readOnlyCallback = () => !this.row.isRowEnabled();
    res.validateValueCallback = function() {
      return data.validateCell(row, column.name, row.value);
    };
    CustomPropertiesCollection.getProperties(column.getType()).forEach((property2) => {
      let propertyName = property2.name;
      if (column[propertyName] !== void 0) {
        res[propertyName] = column[propertyName];
      }
    });
    return res;
  }
  get question() {
    return this.questionValue;
  }
  get value() {
    return this.question.value;
  }
  set value(value) {
    this.question.value = value;
  }
  getQuestionWrapperClassName(className) {
    return className;
  }
  runCondition(values, properties) {
    this.question.runCondition(values, properties);
  }
};
var MatrixDropdownTotalCell = class extends MatrixDropdownCell {
  constructor(column, row, data) {
    super(column, row, data);
    this.column = column;
    this.row = row;
    this.data = data;
    this.updateCellQuestion();
  }
  createQuestion(column, row, data) {
    var res = Serializer.createClass("expression");
    res.setSurveyImpl(row);
    return res;
  }
  locStrsChanged() {
    this.updateCellQuestion();
    super.locStrsChanged();
  }
  updateCellQuestion() {
    this.question.locCalculation();
    this.column.updateCellQuestion(this.question, null, function(json2) {
      delete json2["defaultValue"];
    });
    this.question.expression = this.getTotalExpression();
    this.question.format = this.column.totalFormat;
    this.question.currency = this.column.totalCurrency;
    this.question.displayStyle = this.column.totalDisplayStyle;
    this.question.maximumFractionDigits = this.column.totalMaximumFractionDigits;
    this.question.minimumFractionDigits = this.column.totalMinimumFractionDigits;
    this.question.unlocCalculation();
    this.question.runIfReadOnly = true;
  }
  getQuestionWrapperClassName(className) {
    let result = super.getQuestionWrapperClassName(className);
    if (!result) {
      return result;
    }
    if (this.question.expression && this.question.expression != "''") {
      result += " " + className + "--expression";
    }
    let alignment = this.column.totalAlignment;
    if (alignment === "auto") {
      if (this.column.cellType === "dropdown") {
        alignment = "left";
      }
    }
    return result + " " + className + "--" + alignment;
  }
  getTotalExpression() {
    if (!!this.column.totalExpression) return this.column.totalExpression;
    if (this.column.totalType == "none") return "''";
    var funName = this.column.totalType + "InArray";
    if (!FunctionFactory.Instance.hasFunction(funName)) return "";
    return funName + "({self}, '" + this.column.name + "')";
  }
};
var MatrixDropdownRowTextProcessor = class extends QuestionTextProcessor {
  constructor(row, variableName, parentTextProcessor) {
    super(variableName);
    this.row = row;
    this.variableName = variableName;
    this.parentTextProcessor = parentTextProcessor;
  }
  getParentTextProcessor() {
    return this.parentTextProcessor;
  }
  get survey() {
    return this.row.getSurvey();
  }
  getValues() {
    return this.row.value;
  }
  getQuestionByName(name) {
    return this.row.getQuestionByName(name);
  }
  onCustomProcessText(textValue) {
    if (textValue.name == MatrixDropdownRowModelBase.IndexVariableName) {
      textValue.isExists = true;
      textValue.value = this.row.rowIndex;
      return true;
    }
    if ([MatrixDropdownRowModelBase.RowValueVariableName, MatrixDropdownRowModelBase.RowNameVariableName].indexOf(textValue.name) > -1) {
      textValue.isExists = true;
      textValue.value = this.row.rowName;
      return true;
    }
    return false;
  }
};
var MatrixDropdownRowModelBase = class _MatrixDropdownRowModelBase {
  static getId() {
    return "srow_" + _MatrixDropdownRowModelBase.idCounter++;
  }
  constructor(data, value) {
    this.isSettingValue = false;
    this.detailPanelValue = null;
    this.visibleValue = true;
    this.cells = [];
    this.isCreatingDetailPanel = false;
    this.data = data;
    this.subscribeToChanges(value);
    this.textPreProcessor = new MatrixDropdownRowTextProcessor(this, _MatrixDropdownRowModelBase.RowVariableName, !!data ? data.getParentTextProcessor() : null);
    this.showHideDetailPanelClick = () => {
      if (this.getSurvey().isDesignMode) return true;
      this.showHideDetailPanel();
    };
    this.idValue = _MatrixDropdownRowModelBase.getId();
  }
  get id() {
    return this.idValue;
  }
  get rowName() {
    return null;
  }
  get dataName() {
    return this.rowName;
  }
  get text() {
    return this.rowName;
  }
  isRowEnabled() {
    return true;
  }
  isRowHasEnabledCondition() {
    return false;
  }
  get isVisible() {
    return this.visible && this.isItemVisible();
  }
  get visible() {
    return this.visibleValue;
  }
  set visible(val) {
    var _a;
    if (this.visible !== val) {
      this.visibleValue = val;
      (_a = this.data) === null || _a === void 0 ? void 0 : _a.onRowVisibilityChanged(this);
    }
  }
  isItemVisible() {
    return true;
  }
  get value() {
    var result = {};
    var questions = this.questions;
    for (var i = 0; i < questions.length; i++) {
      var question = questions[i];
      if (!question.isEmpty()) {
        result[question.getValueName()] = question.value;
      }
      if (!!question.comment && !!this.getSurvey() && this.getSurvey().storeOthersAsComment) {
        result[question.getValueName() + Base.commentSuffix] = question.comment;
      }
    }
    return result;
  }
  set value(value) {
    this.isSettingValue = true;
    this.subscribeToChanges(value);
    var questions = this.questions;
    for (var i = 0; i < questions.length; i++) {
      var question = questions[i];
      var val = this.getCellValue(value, question.getValueName());
      var oldComment = question.comment;
      var comment = !!value ? value[question.getValueName() + Base.commentSuffix] : "";
      if (comment == void 0) comment = "";
      question.updateValueFromSurvey(val);
      if (!!comment || this.isTwoValueEquals(oldComment, question.comment)) {
        question.updateCommentFromSurvey(comment);
      }
      question.onSurveyValueChanged(val);
    }
    this.isSettingValue = false;
  }
  get locText() {
    return null;
  }
  getAccessbilityText() {
    return this.locText && this.locText.renderedHtml;
  }
  get hasPanel() {
    if (!this.data) return false;
    return this.data.hasDetailPanel(this);
  }
  get detailPanel() {
    return this.detailPanelValue;
  }
  get detailPanelId() {
    return !!this.detailPanel ? this.detailPanel.id : "";
  }
  get isDetailPanelShowing() {
    return !!this.data ? this.data.getIsDetailPanelShowing(this) : false;
  }
  setIsDetailPanelShowing(val) {
    if (!val && this.detailPanel) {
      this.detailPanel.onHidingContent();
    }
    if (!!this.data) {
      this.data.setIsDetailPanelShowing(this, val);
    }
    if (!!this.onDetailPanelShowingChanged) {
      this.onDetailPanelShowingChanged();
    }
  }
  showHideDetailPanel() {
    if (this.isDetailPanelShowing) {
      this.hideDetailPanel();
    } else {
      this.showDetailPanel();
    }
  }
  showDetailPanel() {
    this.ensureDetailPanel();
    if (!this.detailPanelValue) return;
    this.setIsDetailPanelShowing(true);
  }
  hideDetailPanel(destroyPanel = false) {
    this.setIsDetailPanelShowing(false);
    if (destroyPanel) {
      this.detailPanelValue = null;
    }
  }
  ensureDetailPanel() {
    if (this.isCreatingDetailPanel) return;
    if (!!this.detailPanelValue || !this.hasPanel || !this.data) return;
    this.isCreatingDetailPanel = true;
    this.detailPanelValue = this.data.createRowDetailPanel(this);
    var questions = this.detailPanelValue.questions;
    var value = this.data.getRowValue(this.data.getRowIndex(this));
    if (!Helpers.isValueEmpty(value)) {
      for (var i = 0; i < questions.length; i++) {
        const key = questions[i].getValueName();
        const val = !!this.editingObj ? Serializer.getObjPropertyValue(this.editingObj, key) : value[key];
        if (!Helpers.isValueEmpty(val)) {
          questions[i].value = val;
        }
      }
    }
    this.detailPanelValue.setSurveyImpl(this);
    this.isCreatingDetailPanel = false;
  }
  getAllValues() {
    return this.value;
  }
  getFilteredValues() {
    const res = this.data ? this.data.getDataFilteredValues() : {};
    var values = this.validationValues;
    if (values) {
      for (var key in values) {
        res[key] = values[key];
      }
    }
    res.row = this.getAllValues();
    this.applyRowVariablesToValues(res, this.rowIndex);
    return res;
  }
  getFilteredProperties() {
    return {
      survey: this.getSurvey(),
      row: this
    };
  }
  applyRowVariablesToValues(res, rowIndex) {
    res[_MatrixDropdownRowModelBase.IndexVariableName] = rowIndex;
    res[_MatrixDropdownRowModelBase.RowValueVariableName] = this.rowName;
    res[_MatrixDropdownRowModelBase.RowNameVariableName] = this.rowName;
  }
  runCondition(values, properties, rowsVisibleIf) {
    if (!this.data) return;
    values[_MatrixDropdownRowModelBase.OwnerVariableName] = this.data.getFilteredData();
    const rowIndex = this.rowIndex;
    this.applyRowVariablesToValues(values, rowIndex);
    const newProps = Helpers.createCopy(properties);
    newProps[_MatrixDropdownRowModelBase.RowVariableName] = this;
    const rowValues = rowIndex > 0 ? this.data.getRowValue(this.rowIndex - 1) : this.value;
    if (!!rowsVisibleIf) {
      values[_MatrixDropdownRowModelBase.RowVariableName] = rowValues;
      this.setRowsVisibleIfValues(values);
      this.visible = new ConditionRunner(rowsVisibleIf).run(values, properties);
    } else {
      this.visible = true;
    }
    for (var i = 0; i < this.cells.length; i++) {
      if (i > 0) {
        mergeValues(this.value, rowValues);
      }
      values[_MatrixDropdownRowModelBase.RowVariableName] = rowValues;
      this.cells[i].runCondition(values, newProps);
    }
    if (!!this.detailPanel) {
      this.detailPanel.runCondition(values, newProps);
    }
    if (this.isRowHasEnabledCondition()) {
      this.onQuestionReadOnlyChanged();
    }
  }
  updateElementVisibility() {
    this.cells.forEach((cell) => cell.question.updateElementVisibility());
    if (!!this.detailPanel) {
      this.detailPanel.updateElementVisibility();
    }
  }
  setRowsVisibleIfValues(values) {
  }
  getNamesWithDefaultValues() {
    const res = [];
    this.questions.forEach((q) => {
      if (q.isValueDefault) {
        res.push(q.getValueName());
      }
    });
    return res;
  }
  clearValue(keepComment) {
    var questions = this.questions;
    for (var i = 0; i < questions.length; i++) {
      questions[i].clearValue(keepComment);
    }
  }
  onAnyValueChanged(name, questionName) {
    var questions = this.questions;
    for (var i = 0; i < questions.length; i++) {
      questions[i].onAnyValueChanged(name, questionName);
    }
  }
  getDataValueCore(valuesHash, key) {
    var survey = this.getSurvey();
    if (!!survey) {
      return survey.getDataValueCore(valuesHash, key);
    } else {
      return valuesHash[key];
    }
  }
  getValue(name) {
    var question = this.getQuestionByName(name);
    return !!question ? question.value : null;
  }
  setValue(name, newColumnValue) {
    this.setValueCore(name, newColumnValue, false);
  }
  getVariable(name) {
    return void 0;
  }
  setVariable(name, newValue) {
  }
  getComment(name) {
    var question = this.getQuestionByName(name);
    return !!question ? question.comment : "";
  }
  setComment(name, newValue, locNotification) {
    this.setValueCore(name, newValue, true);
  }
  findQuestionByName(name) {
    if (!name) return void 0;
    const prefix = _MatrixDropdownRowModelBase.RowVariableName + ".";
    if (name.indexOf(prefix) === 0) {
      return this.getQuestionByName(name.substring(prefix.length));
    }
    const survey = this.getSurvey();
    return !!survey ? survey.getQuestionByName(name) : null;
  }
  getEditingSurveyElement() {
    return void 0;
  }
  setValueCore(name, newColumnValue, isComment) {
    if (this.isSettingValue) return;
    this.updateQuestionsValue(name, newColumnValue, isComment);
    if (!isComment) {
      this.updateSharedQuestionsValue(name, newColumnValue);
    }
    var newValue = this.value;
    var changedName = isComment ? name + Base.commentSuffix : name;
    var changedValue = newColumnValue;
    var changedQuestion = this.getQuestionByName(name);
    var changingValue = this.data.onRowChanging(this, changedName, newValue);
    if (!!changedQuestion && !this.isTwoValueEquals(changingValue, changedValue)) {
      this.isSettingValue = true;
      if (isComment) {
        changedQuestion.comment = changingValue;
      } else {
        changedQuestion.value = changingValue;
      }
      this.isSettingValue = false;
      newValue = this.value;
    }
    if (this.data.isValidateOnValueChanging && this.hasQuestonError(changedQuestion)) return;
    const isDeleting = newColumnValue == null && !changedQuestion || isComment && !newColumnValue && !!changedQuestion;
    this.data.onRowChanged(this, changedName, newValue, isDeleting);
    if (changedName) {
      this.runTriggers(MatrixDropdownTotalRowModel.RowVariableName + "." + changedName, newValue);
    }
    this.onAnyValueChanged(_MatrixDropdownRowModelBase.RowVariableName, "");
  }
  updateQuestionsValue(name, newColumnValue, isComment) {
    if (!this.detailPanel) return;
    var colQuestion = this.getQuestionByColumnName(name);
    var detailQuestion = this.detailPanel.getQuestionByName(name);
    if (!colQuestion || !detailQuestion) return;
    var isColQuestion = this.isTwoValueEquals(newColumnValue, isComment ? colQuestion.comment : colQuestion.value);
    var question = isColQuestion ? detailQuestion : colQuestion;
    this.isSettingValue = true;
    if (!isComment) {
      question.value = newColumnValue;
    } else {
      question.comment = newColumnValue;
    }
    this.isSettingValue = false;
  }
  updateSharedQuestionsValue(name, value) {
    const questions = this.getQuestionsByValueName(name);
    if (questions.length > 1) {
      for (let i = 0; i < questions.length; i++) {
        if (!Helpers.isTwoValueEquals(questions[i].value, value)) {
          this.isSettingValue = true;
          questions[i].updateValueFromSurvey(value);
          this.isSettingValue = false;
        }
      }
    }
  }
  runTriggers(name, value) {
    if (!name) return;
    this.questions.forEach((q) => q.runTriggers(name, value));
  }
  hasQuestonError(question) {
    if (!question) return false;
    if (question.hasErrors(true, {
      isOnValueChanged: !this.data.isValidateOnValueChanging
    })) return true;
    if (question.isEmpty()) return false;
    var cell = this.getCellByColumnName(question.name);
    if (!cell || !cell.column || !cell.column.isUnique) return false;
    return this.data.checkIfValueInRowDuplicated(this, question);
  }
  get isEmpty() {
    var val = this.value;
    if (Helpers.isValueEmpty(val)) return true;
    for (var key in val) {
      if (val[key] !== void 0 && val[key] !== null) return false;
    }
    return true;
  }
  getQuestionByColumn(column) {
    var cell = this.getCellByColumn(column);
    return !!cell ? cell.question : null;
  }
  getCellByColumn(column) {
    for (var i = 0; i < this.cells.length; i++) {
      if (this.cells[i].column == column) return this.cells[i];
    }
    return null;
  }
  getCellByColumnName(columnName) {
    for (var i = 0; i < this.cells.length; i++) {
      if (this.cells[i].column.name == columnName) return this.cells[i];
    }
    return null;
  }
  getQuestionByColumnName(columnName) {
    var cell = this.getCellByColumnName(columnName);
    return !!cell ? cell.question : null;
  }
  get questions() {
    var res = [];
    for (var i = 0; i < this.cells.length; i++) {
      res.push(this.cells[i].question);
    }
    var detailQuestions = !!this.detailPanel ? this.detailPanel.questions : [];
    for (var i = 0; i < detailQuestions.length; i++) {
      res.push(detailQuestions[i]);
    }
    return res;
  }
  getQuestionByName(name) {
    var res = this.getQuestionByColumnName(name);
    if (!!res) return res;
    return !!this.detailPanel ? this.detailPanel.getQuestionByName(name) : null;
  }
  getQuestionsByName(name) {
    let res = [];
    let q = this.getQuestionByColumnName(name);
    if (!!q) res.push(q);
    if (!!this.detailPanel) {
      q = this.detailPanel.getQuestionByName(name);
      if (!!q) res.push(q);
    }
    return res;
  }
  getQuestionsByValueName(name) {
    let res = [];
    for (var i = 0; i < this.cells.length; i++) {
      const cell = this.cells[i];
      if (cell.question && cell.question.getValueName() === name) {
        res.push(cell.question);
      }
    }
    if (!!this.detailPanel) {
      res = res.concat(this.detailPanel.getQuestionsByValueName(name));
    }
    return res;
  }
  getSharedQuestionByName(columnName) {
    return !!this.data ? this.data.getSharedQuestionByName(columnName, this) : null;
  }
  clearIncorrectValues(val) {
    for (var key in val) {
      var question = this.getQuestionByName(key);
      if (question) {
        var qVal = question.value;
        question.clearIncorrectValues();
        if (!this.isTwoValueEquals(qVal, question.value)) {
          this.setValue(key, question.value);
        }
      } else {
        if (!this.getSharedQuestionByName(key) && key.indexOf(settings.matrix.totalsSuffix) < 0) {
          this.setValue(key, null);
        }
      }
    }
  }
  getLocale() {
    return this.data ? this.data.getLocale() : "";
  }
  getMarkdownHtml(text, name) {
    return this.data ? this.data.getMarkdownHtml(text, name) : void 0;
  }
  getRenderer(name) {
    return this.data ? this.data.getRenderer(name) : null;
  }
  getRendererContext(locStr) {
    return this.data ? this.data.getRendererContext(locStr) : locStr;
  }
  getProcessedText(text) {
    return this.data ? this.data.getProcessedText(text) : text;
  }
  locStrsChanged() {
    for (var i = 0; i < this.cells.length; i++) {
      this.cells[i].locStrsChanged();
    }
    if (!!this.detailPanel) {
      this.detailPanel.locStrsChanged();
    }
  }
  updateCellQuestionOnColumnChanged(column, name, newValue) {
    var cell = this.getCellByColumn(column);
    if (!cell) return;
    this.updateCellOnColumnChanged(cell, name, newValue);
  }
  updateCellQuestionOnColumnItemValueChanged(column, propertyName, obj, name, newValue, oldValue) {
    var cell = this.getCellByColumn(column);
    if (!cell) return;
    this.updateCellOnColumnItemValueChanged(cell, propertyName, obj, name, newValue, oldValue);
  }
  onQuestionReadOnlyChanged() {
    const questions = this.questions;
    for (var i = 0; i < questions.length; i++) {
      const q = questions[i];
      q.setPropertyValue("isReadOnly", q.isReadOnly);
    }
    if (!!this.detailPanel) {
      const parentIsReadOnly = !!this.data && this.data.isMatrixReadOnly();
      this.detailPanel.readOnly = parentIsReadOnly || !this.isRowEnabled();
    }
  }
  hasErrors(fireCallback, rec, raiseOnCompletedAsyncValidators) {
    var res = false;
    var cells = this.cells;
    if (!cells) return res;
    this.validationValues = rec.validationValues;
    for (var colIndex = 0; colIndex < cells.length; colIndex++) {
      if (!cells[colIndex]) continue;
      var question = cells[colIndex].question;
      if (!question || !question.visible) continue;
      question.onCompletedAsyncValidators = (hasErrors) => {
        raiseOnCompletedAsyncValidators();
      };
      if (!!rec && rec.isOnValueChanged === true && question.isEmpty()) continue;
      res = question.hasErrors(fireCallback, rec) || res;
    }
    if (this.hasPanel) {
      this.ensureDetailPanel();
      var panelHasError = this.detailPanel.hasErrors(fireCallback, false, rec);
      if (!rec.hideErroredPanel && panelHasError && fireCallback) {
        if (rec.isSingleDetailPanel) {
          rec.hideErroredPanel = true;
        }
        this.showDetailPanel();
      }
      res = panelHasError || res;
    }
    this.validationValues = void 0;
    return res;
  }
  updateCellOnColumnChanged(cell, name, newValue) {
    if (name === "choices" && Array.isArray(newValue) && newValue.length === 0 && this.data) {
      newValue = this.data.choices;
    }
    cell.question[name] = newValue;
  }
  updateCellOnColumnItemValueChanged(cell, propertyName, obj, name, newValue, oldValue) {
    var items = cell.question[propertyName];
    if (!Array.isArray(items)) return;
    var val = name === "value" ? oldValue : obj["value"];
    var item = ItemValue.getItemByValue(items, val);
    if (!item) return;
    item[name] = newValue;
  }
  buildCells(value) {
    this.isSettingValue = true;
    var columns = this.data.columns;
    for (var i = 0; i < columns.length; i++) {
      var column = columns[i];
      var cell = this.createCell(column);
      this.cells.push(cell);
      var cellValue = this.getCellValue(value, column.name);
      if (!Helpers.isValueEmpty(cellValue)) {
        cell.question.value = cellValue;
        var commentKey = column.name + Base.commentSuffix;
        if (!!value && !Helpers.isValueEmpty(value[commentKey])) {
          cell.question.comment = value[commentKey];
        }
      }
    }
    this.isSettingValue = false;
  }
  isTwoValueEquals(val1, val2) {
    return Helpers.isTwoValueEquals(val1, val2, false, true, false);
  }
  getCellValue(value, name) {
    if (!!this.editingObj) return Serializer.getObjPropertyValue(this.editingObj, name);
    return !!value ? value[name] : void 0;
  }
  createCell(column) {
    return new MatrixDropdownCell(column, this, this.data);
  }
  getSurveyData() {
    return this;
  }
  getSurvey() {
    return this.data ? this.data.getSurvey() : null;
  }
  getTextProcessor() {
    return this.textPreProcessor;
  }
  get rowIndex() {
    return this.getRowIndex();
  }
  getRowIndex() {
    return !!this.data ? this.data.getRowIndex(this) + 1 : -1;
  }
  get editingObj() {
    return this.editingObjValue;
  }
  dispose() {
    if (!!this.editingObj) {
      this.editingObj.onPropertyChanged.remove(this.onEditingObjPropertyChanged);
      this.editingObjValue = null;
    }
  }
  subscribeToChanges(value) {
    if (!value || !value.getType || !value.onPropertyChanged) return;
    if (value === this.editingObj) return;
    this.editingObjValue = value;
    this.onEditingObjPropertyChanged = (sender, options) => {
      this.updateOnSetValue(options.name, options.newValue);
    };
    this.editingObj.onPropertyChanged.add(this.onEditingObjPropertyChanged);
  }
  updateOnSetValue(name, newValue) {
    this.isSettingValue = true;
    let questions = this.getQuestionsByName(name);
    for (let i = 0; i < questions.length; i++) {
      questions[i].value = newValue;
    }
    this.isSettingValue = false;
  }
};
MatrixDropdownRowModelBase.RowVariableName = "row";
MatrixDropdownRowModelBase.OwnerVariableName = "self";
MatrixDropdownRowModelBase.IndexVariableName = "rowIndex";
MatrixDropdownRowModelBase.RowValueVariableName = "rowValue";
MatrixDropdownRowModelBase.RowNameVariableName = "rowName";
MatrixDropdownRowModelBase.idCounter = 1;
var MatrixDropdownTotalRowModel = class extends MatrixDropdownRowModelBase {
  constructor(data) {
    super(data, null);
    this.buildCells(null);
  }
  createCell(column) {
    return new MatrixDropdownTotalCell(column, this, this.data);
  }
  setValue(name, newValue) {
    if (!!this.data && !this.isSettingValue) {
      this.data.onTotalValueChanged();
    }
  }
  runCondition(values, properties, rowsVisibleIf) {
    var counter = 0;
    var prevValue;
    do {
      prevValue = Helpers.getUnbindValue(this.value);
      super.runCondition(values, properties, "");
      counter++;
    } while (!Helpers.isTwoValueEquals(prevValue, this.value) && counter < 3);
  }
  updateCellOnColumnChanged(cell, name, newValue) {
    cell.updateCellQuestion();
  }
};
var QuestionMatrixDropdownModelBase = class extends QuestionMatrixBaseModel {
  static get defaultCellType() {
    return settings.matrix.defaultCellType;
  }
  static set defaultCellType(val) {
    settings.matrix.defaultCellType = val;
  }
  static addDefaultColumns(matrix) {
    var colNames = QuestionFactory.DefaultColums;
    for (var i = 0; i < colNames.length; i++) matrix.addColumn(colNames[i]);
  }
  createColumnValues() {
    return this.createNewArray("columns", (item) => {
      item.colOwner = this;
      if (this.onAddColumn) this.onAddColumn(item);
      if (this.survey) {
        this.survey.matrixColumnAdded(this, item);
      }
    }, (item) => {
      item.colOwner = null;
      if (this.onRemoveColumn) this.onRemoveColumn(item);
    });
  }
  constructor(name) {
    super(name);
    this.isRowChanging = false;
    this.lockResetRenderedTable = false;
    this.isDoingonAnyValueChanged = false;
    this.createItemValues("choices");
    this.createLocalizableString("placeholder", this, false, true);
    this.createLocalizableString("keyDuplicationError", this, false, true);
    this.detailPanelValue = this.createNewDetailPanel();
    this.detailPanel.selectedElementInDesign = this;
    this.detailPanel.renderWidth = "100%";
    this.detailPanel.isInteractiveDesignElement = false;
    this.detailPanel.showTitle = false;
    this.registerPropertyChangedHandlers(["columns", "cellType"], () => {
      this.updateColumnsAndRows();
    });
    this.registerPropertyChangedHandlers(["placeholder", "columnColCount", "rowTitleWidth", "choices"], () => {
      this.clearRowsAndResetRenderedTable();
    });
    this.registerPropertyChangedHandlers(["transposeData", "addRowButtonLocation", "hideColumnsIfEmpty", "showHeader", "minRowCount", "isReadOnly", "rowCount", "hasFooter", "detailPanelMode", "displayMode"], () => {
      this.resetRenderedTable();
    });
  }
  getType() {
    return "matrixdropdownbase";
  }
  dispose() {
    super.dispose();
    this.clearGeneratedRows();
  }
  get hasSingleInput() {
    return false;
  }
  get isContainer() {
    return true;
  }
  get isRowsDynamic() {
    return false;
  }
  get isUpdateLocked() {
    return this.isLoadingFromJson || this.isUpdating;
  }
  beginUpdate() {
    this.isUpdating = true;
  }
  endUpdate() {
    this.isUpdating = false;
    this.updateColumnsAndRows();
  }
  updateColumnsAndRows() {
    this.updateColumnsIndexes(this.columns);
    this.updateColumnsCellType();
    this.generatedTotalRow = null;
    this.clearRowsAndResetRenderedTable();
  }
  itemValuePropertyChanged(item, name, oldValue, newValue) {
    super.itemValuePropertyChanged(item, name, oldValue, newValue);
    if (item.ownerPropertyName === "choices") {
      this.clearRowsAndResetRenderedTable();
    }
  }
  /**
   * Specifies whether to display [`columns`](#columns) as rows and [`rows`](#rows) as columns.
   *
   * Default value: `false`
   *
   * [View Demo](https://surveyjs.io/form-library/examples/transpose-dynamic-rows-to-columns-in-matrix/ (linkStyle))
   */
  get transposeData() {
    return this.getPropertyValue("transposeData");
  }
  set transposeData(val) {
    this.setPropertyValue("transposeData", val);
  }
  /**
   * @deprecated Use the [`transposeData`](#transposeData) property instead.
   */
  get columnLayout() {
    return this.transposeData ? "vertical" : "horizontal";
  }
  set columnLayout(val) {
    this.transposeData = val === "vertical";
  }
  get columnsLocation() {
    return this.columnLayout;
  }
  set columnsLocation(val) {
    this.columnLayout = val;
  }
  /**
   * Specifies the error message position for questions within detail sections.
   *
   * Possible values:
   *
   * - `"default"` (default) - Inherits the setting from the [`errorLocation`](#errorLocation) property.
   * - `"top"` - Displays error messages above questions.
   * - `"bottom"` - Displays error messages below questions.
   * @see cellErrorLocation
   */
  get detailErrorLocation() {
    return this.getPropertyValue("detailErrorLocation");
  }
  set detailErrorLocation(value) {
    this.setPropertyValue("detailErrorLocation", value.toLowerCase());
  }
  /**
   * Specifies the error message position relative to matrix cells.
   *
   * Possible values:
   *
   * - `"default"` (default) - Inherits the setting from the [`errorLocation`](#errorLocation) property.
   * - `"top"` - Displays error messages above matrix cells.
   * - `"bottom"` - Displays error messages below matrix cells.
   * @see detailErrorLocation
   */
  get cellErrorLocation() {
    return this.getPropertyValue("cellErrorLocation");
  }
  set cellErrorLocation(value) {
    this.setPropertyValue("cellErrorLocation", value.toLowerCase());
  }
  getChildErrorLocation(child) {
    const errLocation = !!child.parent ? this.detailErrorLocation : this.cellErrorLocation;
    if (errLocation !== "default") return errLocation;
    return super.getChildErrorLocation(child);
  }
  /**
   * Returns `true` if [`columns`](#columns) are placed in the horizontal direction and [`rows`](#columns) in the vertical direction.
   *
   * To specify the layout, use the [`transposeData`](#transposeData) property. If you set it to `true`, the survey applies it only when the screen has enough space. Otherwise, the survey falls back to the original layout, but the `transposeData` property remains set to `true`. Unlike `transposeData`, the `isColumnLayoutHorizontal` property always indicates the current layout.
   * @see transposeData
   */
  get isColumnLayoutHorizontal() {
    return this.isMobile ? true : !this.transposeData;
  }
  /**
   * Enables case-sensitive comparison in columns with the `isUnique` property set to `true`.
   *
   * When this property is `true`, `"ABC"` and `"abc"` are considered different values.
   *
   * Default value: `false`
   * @see keyDuplicationError
   */
  get useCaseSensitiveComparison() {
    return this.useCaseSensitiveComparisonValue !== void 0 ? this.useCaseSensitiveComparisonValue : settings.comparator.caseSensitive;
  }
  set useCaseSensitiveComparison(val) {
    this.useCaseSensitiveComparisonValue = val;
  }
  /**
   * @deprecated Use the [`useCaseSensitiveComparison`](#useCaseSensitiveComparison) property instead.
   */
  get isUniqueCaseSensitive() {
    return this.useCaseSensitiveComparison;
  }
  set isUniqueCaseSensitive(val) {
    this.useCaseSensitiveComparison = val;
  }
  /**
   * Specifies the location of detail sections.
   *
   * Possible values:
   *
   * - `"underRow"` - Displays detail sections under their respective rows. Users can expand any number of detail sections.
   * - `"underRowSingle"` - Displays detail sections under their respective rows, but only one detail section can be expanded at a time.
   * - `"none"` (default) - Hides detail sections.
   *
   * Use the `detailElements` property to specify content of detail sections.
   * @see detailElements
   * @see detailPanel
   */
  get detailPanelMode() {
    return this.getPropertyValue("detailPanelMode");
  }
  set detailPanelMode(val) {
    this.setPropertyValue("detailPanelMode", val);
  }
  /**
   * Contains a [`PanelModel`](https://surveyjs.io/form-library/documentation/panelmodel) instance that represents a detail section template.
   * @see detailElements
   * @see detailPanelMode
   */
  get detailPanel() {
    return this.detailPanelValue;
  }
  getPanel() {
    return this.detailPanel;
  }
  /**
   * An array of survey elements (questions and panels) to be displayed in detail sections.
   *
   * Detail sections are expandable panels displayed under each matrix row. You can use them to display questions that do not fit into the row.
   *
   * Set the `detailPanelMode` property to `"underRow"` or `"underRowSingle"` to display detail sections.
   * @see detailPanelMode
   * @see detailPanel
   */
  get detailElements() {
    return this.detailPanel.elements;
  }
  createNewDetailPanel() {
    return Serializer.createClass("panel");
  }
  get hasRowText() {
    return true;
  }
  getFooterText() {
    return null;
  }
  get canAddRow() {
    return false;
  }
  get canRemoveRows() {
    return false;
  }
  canRemoveRow(row) {
    return true;
  }
  onPointerDown(pointerDownEvent, row) {
  }
  onRowsChanged() {
    this.clearVisibleRows();
    this.resetRenderedTable();
    super.onRowsChanged();
  }
  onStartRowAddingRemoving() {
    this.lockResetRenderedTable = true;
    this.setValueChangedDirectly(true);
  }
  onEndRowAdding() {
    this.lockResetRenderedTable = false;
    if (!this.renderedTable) return;
    if (this.renderedTable.isRequireReset()) {
      this.resetRenderedTable();
    } else {
      const index = this.visibleRows.length - 1;
      this.renderedTable.onAddedRow(this.visibleRows[index], index);
    }
  }
  onEndRowRemoving(row) {
    this.lockResetRenderedTable = false;
    if (this.renderedTable.isRequireReset()) {
      this.resetRenderedTable();
    } else {
      if (!!row) {
        this.renderedTable.onRemovedRow(row);
      }
    }
  }
  get renderedTableValue() {
    return this.getPropertyValue("renderedTable", null);
  }
  set renderedTableValue(val) {
    this.setPropertyValue("renderedTable", val);
  }
  clearRowsAndResetRenderedTable() {
    this.clearGeneratedRows();
    this.resetRenderedTable();
    this.fireCallback(this.columnsChangedCallback);
  }
  //For internal use
  resetRenderedTable() {
    if (this.lockResetRenderedTable || this.isUpdateLocked) return;
    this.renderedTableValue = null;
    this.fireCallback(this.onRenderedTableResetCallback);
  }
  clearGeneratedRows() {
    this.clearVisibleRows();
    if (!this.generatedVisibleRows) return;
    for (var i = 0; i < this.generatedVisibleRows.length; i++) {
      this.generatedVisibleRows[i].dispose();
    }
    super.clearGeneratedRows();
  }
  get isRendredTableCreated() {
    return !!this.renderedTableValue;
  }
  get renderedTable() {
    if (!this.renderedTableValue) {
      this.renderedTableValue = this.createRenderedTable();
      if (!!this.onRenderedTableCreatedCallback) {
        this.onRenderedTableCreatedCallback(this.renderedTableValue);
      }
    }
    return this.renderedTableValue;
  }
  createRenderedTable() {
    return new QuestionMatrixDropdownRenderedTable(this);
  }
  onMatrixRowCreated(row) {
    if (!this.survey) return;
    var options = {
      rowValue: row.value,
      row,
      column: null,
      columnName: null,
      cell: null,
      cellQuestion: null,
      value: null
    };
    for (var i = 0; i < this.columns.length; i++) {
      options.column = this.columns[i];
      options.columnName = options.column.name;
      var cell = row.cells[i];
      options.cell = cell;
      options.cellQuestion = cell.question;
      options.value = cell.value;
      if (!!this.onCellCreatedCallback) {
        this.onCellCreatedCallback(options);
      }
      this.survey.matrixCellCreated(this, options);
    }
  }
  /**
   * Specifies the type of matrix cells. You can override this property for individual columns.
   *
   * Possible values:
   *
   * - [`"dropdown"`](https://surveyjs.io/form-library/documentation/api-reference/dropdown-menu-model)
   * - [`"checkbox"`](https://surveyjs.io/form-library/documentation/api-reference/checkbox-question-model)
   * - [`"radiogroup"`](https://surveyjs.io/form-library/documentation/api-reference/radio-button-question-model)
   * - [`"tagbox"`](https://surveyjs.io/form-library/documentation/api-reference/dropdown-tag-box-model)
   * - [`"text"`](https://surveyjs.io/form-library/documentation/api-reference/text-entry-question-model)
   * - [`"comment"`](https://surveyjs.io/form-library/documentation/api-reference/comment-field-model)
   * - [`"boolean"`](https://surveyjs.io/form-library/documentation/api-reference/boolean-question-model)
   * - [`"expression"`](https://surveyjs.io/form-library/documentation/api-reference/expression-model)
   * - [`"rating"`](https://surveyjs.io/form-library/documentation/api-reference/rating-scale-question-model)
   *
   * Default value: `"dropdown"` (inherited from [`settings.matrix.defaultCellType`](https://surveyjs.io/form-library/documentation/settings#matrixDefaultCellType))
   */
  get cellType() {
    return this.getPropertyValue("cellType", settings.matrix.defaultCellType);
  }
  set cellType(val) {
    val = val.toLowerCase();
    this.setPropertyValue("cellType", val);
  }
  isSelectCellType() {
    return Serializer.isDescendantOf(this.cellType, "selectbase");
  }
  updateColumnsCellType() {
    for (var i = 0; i < this.columns.length; i++) {
      this.columns[i].defaultCellTypeChanged();
    }
  }
  updateColumnsIndexes(cols) {
    for (var i = 0; i < cols.length; i++) {
      cols[i].setIndex(i);
    }
  }
  /**
   * Specifies the number of columns in Radiogroup and Checkbox cells.
   *
   * Default value: 0 (the number of columns is selected automatically based on the available column width)
   * @see cellType
   */
  get columnColCount() {
    return this.getPropertyValue("columnColCount");
  }
  set columnColCount(value) {
    if (value < 0 || value > 4) return;
    this.setPropertyValue("columnColCount", value);
  }
  get horizontalScroll() {
    return this.getPropertyValue("horizontalScroll");
  }
  set horizontalScroll(val) {
    this.setPropertyValue("horizontalScroll", val);
  }
  get allowAdaptiveActions() {
    return this.getPropertyValue("allowAdaptiveActions");
  }
  set allowAdaptiveActions(val) {
    this.setPropertyValue("allowAdaptiveActions", val);
    if (!!this.detailPanel) {
      this.detailPanel.allowAdaptiveActions = val;
    }
  }
  hasChoices() {
    return this.choices.length > 0;
  }
  onColumnPropertyChanged(column, name, newValue) {
    this.updateHasFooter();
    if (!this.generatedVisibleRows) return;
    for (var i = 0; i < this.generatedVisibleRows.length; i++) {
      this.generatedVisibleRows[i].updateCellQuestionOnColumnChanged(column, name, newValue);
    }
    if (!!this.generatedTotalRow) {
      this.generatedTotalRow.updateCellQuestionOnColumnChanged(column, name, newValue);
    }
    this.onColumnsChanged();
    if (name == "isRequired") {
      this.resetRenderedTable();
    }
  }
  onColumnItemValuePropertyChanged(column, propertyName, obj, name, newValue, oldValue) {
    if (!this.generatedVisibleRows) return;
    for (var i = 0; i < this.generatedVisibleRows.length; i++) {
      this.generatedVisibleRows[i].updateCellQuestionOnColumnItemValueChanged(column, propertyName, obj, name, newValue, oldValue);
    }
  }
  onShowInMultipleColumnsChanged(column) {
    this.resetTableAndRows();
  }
  onColumnVisibilityChanged(column) {
    this.resetTableAndRows();
  }
  onColumnCellTypeChanged(column) {
    this.resetTableAndRows();
  }
  resetTableAndRows() {
    this.clearGeneratedRows();
    this.resetRenderedTable();
  }
  getRowTitleWidth() {
    return "";
  }
  get hasFooter() {
    return this.getPropertyValue("hasFooter", false);
  }
  getAddRowLocation() {
    return "default";
  }
  getShowColumnsIfEmpty() {
    return false;
  }
  updateShowTableAndAddRow() {
    if (!!this.renderedTable) {
      this.renderedTable.updateShowTableAndAddRow();
    }
  }
  updateHasFooter() {
    this.setPropertyValue("hasFooter", this.hasTotal);
  }
  get hasTotal() {
    for (var i = 0; i < this.columns.length; i++) {
      if (this.columns[i].hasTotal) return true;
    }
    return false;
  }
  getCellType() {
    return this.cellType;
  }
  getCustomCellType(column, row, cellType) {
    if (!this.survey) return cellType;
    var options = {
      rowValue: row.value,
      row,
      column,
      columnName: column.name,
      cellType
    };
    this.survey.matrixCellCreating(this, options);
    return options.cellType;
  }
  getConditionJson(operator = null, path = null) {
    if (!path) return super.getConditionJson(operator);
    let columnName = "";
    for (let i = path.length - 1; i >= 0; i--) {
      if (path[i] == ".") break;
      columnName = path[i] + columnName;
    }
    let question = void 0;
    let column = this.getColumnByName(columnName);
    if (!!column) {
      question = column.createCellQuestion(null);
    } else {
      if (this.detailPanelMode !== "none") {
        question = this.detailPanel.getQuestionByName(columnName);
      }
    }
    return !!question ? question.getConditionJson(operator) : null;
  }
  clearIncorrectValues() {
    if (!Array.isArray(this.visibleRows)) return;
    const rows = this.generatedVisibleRows;
    for (let i = 0; i < rows.length; i++) {
      rows[i].clearIncorrectValues(this.getRowValue(i));
    }
  }
  clearErrors() {
    super.clearErrors();
    this.runFuncForCellQuestions((q) => {
      q.clearErrors();
    });
  }
  localeChanged() {
    super.localeChanged();
    this.runFuncForCellQuestions((q) => {
      q.localeChanged();
    });
  }
  runFuncForCellQuestions(func) {
    const rows = this.generatedVisibleRows;
    if (!!rows) {
      for (let i = 0; i < rows.length; i++) {
        const row = rows[i];
        if (row.isVisible) {
          for (let j = 0; j < row.cells.length; j++) {
            func(row.cells[j].question);
          }
        }
      }
    }
  }
  runConditionCore(values, properties) {
    const oldRowVariables = values[MatrixDropdownRowModelBase.RowVariableName];
    super.runConditionCore(values, properties);
    var counter = 0;
    var prevTotalValue;
    do {
      prevTotalValue = Helpers.getUnbindValue(this.totalValue);
      this.runCellsCondition(values, properties);
      this.runTotalsCondition(values, properties);
      counter++;
    } while (!Helpers.isTwoValueEquals(prevTotalValue, this.totalValue) && counter < 3);
    this.updateVisibilityBasedOnRows();
    values[MatrixDropdownRowModelBase.RowVariableName] = oldRowVariables;
  }
  runTriggers(name, value, keys) {
    super.runTriggers(name, value, keys);
    this.runFuncForCellQuestions((q) => {
      q.runTriggers(name, value, keys);
    });
  }
  updateElementVisibility() {
    super.updateElementVisibility();
    const rows = this.generatedVisibleRows;
    if (!!rows) {
      rows.forEach((row) => row.updateElementVisibility());
    }
  }
  shouldRunColumnExpression() {
    return false;
  }
  runCellsCondition(values, properties) {
    if (this.isDesignMode) return;
    const rows = this.generatedVisibleRows;
    if (!!rows) {
      const newValues = this.getRowConditionValues(values);
      for (var i = 0; i < rows.length; i++) {
        rows[i].runCondition(newValues, properties, this.rowsVisibleIf);
      }
    }
    this.checkColumnsVisibility();
    this.checkColumnsRenderedRequired();
  }
  runConditionsForColumns(values, properties) {
    this.columns.forEach((column) => {
      if (!this.columnsVisibleIf) {
        column.isColumnsVisibleIf = true;
      } else {
        const condition = new ConditionRunner(this.columnsVisibleIf);
        values["item"] = column.name;
        column.isColumnsVisibleIf = condition.run(values, properties) === true;
      }
    });
    return false;
  }
  checkColumnsVisibility() {
    if (this.isDesignMode) return;
    var hasChanged = false;
    for (var i = 0; i < this.columns.length; i++) {
      const column = this.columns[i];
      const isCellsVisibilty = !!column.visibleIf || column.isFilteredMultipleColumns;
      if (!isCellsVisibilty && !this.columnsVisibleIf && column.isColumnVisible) continue;
      hasChanged = this.isColumnVisibilityChanged(column, isCellsVisibilty) || hasChanged;
    }
    if (hasChanged) {
      this.resetRenderedTable();
    }
  }
  checkColumnsRenderedRequired() {
    const rows = this.generatedVisibleRows;
    if (!rows) return;
    for (var i = 0; i < this.columns.length; i++) {
      const column = this.columns[i];
      if (!column.requiredIf || !column.isColumnVisible) continue;
      let required = rows.length > 0;
      for (var j = 0; j < rows.length; j++) {
        if (!rows[j].cells[i].question.isRequired) {
          required = false;
          break;
        }
      }
      column.updateIsRenderedRequired(required);
    }
  }
  isColumnVisibilityChanged(column, checkCellsVisiblity) {
    const curVis = column.isColumnVisible;
    let hasVisCell = !checkCellsVisiblity;
    const rows = this.generatedVisibleRows;
    const checkRows = checkCellsVisiblity && rows;
    const isMultipleColumnsVisibility = checkRows && column.isFilteredMultipleColumns;
    const curVisibleChoices = isMultipleColumnsVisibility ? column.getVisibleChoicesInCell : [];
    const newVisibleChoices = new Array();
    if (checkRows) {
      for (let i = 0; i < rows.length; i++) {
        const cell = rows[i].cells[column.index];
        const q = cell === null || cell === void 0 ? void 0 : cell.question;
        if (!!q && q.isVisible) {
          hasVisCell = true;
          if (isMultipleColumnsVisibility) {
            this.updateNewVisibleChoices(q, newVisibleChoices);
          } else break;
        }
      }
    }
    column.hasVisibleCell = hasVisCell && column.isColumnsVisibleIf;
    if (isMultipleColumnsVisibility) {
      column.setVisibleChoicesInCell(newVisibleChoices);
      if (!Helpers.isArraysEqual(curVisibleChoices, newVisibleChoices, true, false, false)) return true;
    }
    return curVis !== column.isColumnVisible;
  }
  updateNewVisibleChoices(q, dest) {
    const choices = q.visibleChoices;
    if (!Array.isArray(choices)) return;
    for (let i = 0; i < choices.length; i++) {
      const ch = choices[i];
      if (dest.indexOf(ch.value) < 0) dest.push(ch.value);
    }
  }
  runTotalsCondition(values, properties) {
    if (!this.generatedTotalRow) return;
    this.generatedTotalRow.runCondition(this.getRowConditionValues(values), properties);
  }
  getRowConditionValues(values) {
    var newValues = values;
    if (!newValues) newValues = {};
    var totalRow = {};
    if (!this.isValueEmpty(this.totalValue)) {
      totalRow = JSON.parse(JSON.stringify(this.totalValue));
    }
    newValues["row"] = {};
    newValues["totalRow"] = totalRow;
    return newValues;
  }
  IsMultiplyColumn(column) {
    return column.isShowInMultipleColumns && !this.isMobile;
  }
  locStrsChanged() {
    super.locStrsChanged();
    var columns = this.columns;
    for (var i = 0; i < columns.length; i++) {
      columns[i].locStrsChanged();
    }
    var rows = this.generatedVisibleRows;
    if (!rows) return;
    for (var i = 0; i < rows.length; i++) {
      rows[i].locStrsChanged();
    }
    if (!!this.generatedTotalRow) {
      this.generatedTotalRow.locStrsChanged();
    }
  }
  /**
   * Returns a matrix column with a given `name` or `null` if a column with this is not found.
   * @param columnName A column name.
   */
  getColumnByName(columnName) {
    for (var i = 0; i < this.columns.length; i++) {
      if (this.columns[i].name == columnName) return this.columns[i];
    }
    return null;
  }
  getColumnName(columnName) {
    return this.getColumnByName(columnName);
  }
  getColumnWidth(column) {
    var _a;
    return column.minWidth ? column.minWidth : this.columnMinWidth ? this.columnMinWidth : ((_a = settings.matrix.columnWidthsByType[column.cellType]) === null || _a === void 0 ? void 0 : _a.minWidth) || "";
  }
  /**
   * Gets or sets choice items for Dropdown, Checkbox, and Radiogroup matrix cells. You can override this property for individual columns.
   *
   * This property accepts an array of objects with the following structure:
   *
   * ```js
   * {
   *   "value": any, // A value to be saved in survey results
   *   "text": String, // A display text. This property supports Markdown. When `text` is undefined, `value` is used.
   *   "customProperty": any // Any property that you find useful.
   * }
   * ```
   *
   * To enable Markdown support for the `text` property, implement Markdown-to-HTML conversion in the [onTextMarkdown](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#onTextMarkdown) event handler. For an example, refer to the following demo: [Convert Markdown to HTML with markdown-it](https://surveyjs.io/form-library/examples/edit-survey-questions-markdown/).
   *
   * If you add custom properties, refer to the following help topic to learn how to serialize them into JSON: [Add Custom Properties to Property Grid](https://surveyjs.io/survey-creator/documentation/property-grid#add-custom-properties-to-the-property-grid).
   *
   * If you need to specify only the `value` property, you can set the `choices` property to an array of primitive values, for example, `[ "item1", "item2", "item3" ]`. These values are both saved in survey results and used as display text.
   * @see cellType
   */
  get choices() {
    return this.getPropertyValue("choices");
  }
  set choices(val) {
    this.setPropertyValue("choices", val);
  }
  /**
   * A placeholder for Dropdown matrix cells.
   * @see cellType
   */
  get placeholder() {
    return this.getLocalizableStringText("placeholder");
  }
  set placeholder(val) {
    this.setLocalizableStringText("placeholder", val);
  }
  get locPlaceholder() {
    return this.getLocalizableString("placeholder");
  }
  get optionsCaption() {
    return this.placeholder;
  }
  set optionsCaption(val) {
    this.placeholder = val;
  }
  /**
   * An error message displayed when users enter a duplicate value into a column that accepts only unique values (`isUnique` is set to `true` or `keyName` is specified).
   *
   * A default value for this property is taken from a [localization dictionary](https://github.com/surveyjs/survey-library/tree/01bd8abd0c574719956d4d579d48c8010cd389d4/packages/survey-core/src/localization). Refer to the following help topic for more information: [Localization & Globalization](https://surveyjs.io/form-library/documentation/localization).
   * @see useCaseSensitiveComparison
   */
  get keyDuplicationError() {
    return this.getLocalizableStringText("keyDuplicationError");
  }
  set keyDuplicationError(val) {
    this.setLocalizableStringText("keyDuplicationError", val);
  }
  get locKeyDuplicationError() {
    return this.getLocalizableString("keyDuplicationError");
  }
  get storeOthersAsComment() {
    return !!this.survey ? this.survey.storeOthersAsComment : false;
  }
  addColumn(name, title) {
    var column = new MatrixDropdownColumn(name, title, this);
    this.columns.push(column);
    return column;
  }
  clearVisibleRows() {
    this.visibleRowsArray = null;
  }
  isColumnVisible(column) {
    return column.isColumnVisible;
  }
  getVisibleRows() {
    if (this.isUpdateLocked) return null;
    if (this.isGenereatingRows) return [];
    if (!!this.visibleRowsArray) return this.visibleRowsArray;
    this.generateVisibleRowsIfNeeded();
    this.visibleRowsArray = this.getVisibleFromGenerated(this.generatedVisibleRows);
    return this.visibleRowsArray;
  }
  generateVisibleRowsIfNeeded() {
    if (!this.isUpdateLocked && !this.generatedVisibleRows && !this.generatedVisibleRows) {
      this.isGenereatingRows = true;
      this.generatedVisibleRows = this.generateRows();
      this.isGenereatingRows = false;
      this.generatedVisibleRows.forEach((row) => this.onMatrixRowCreated(row));
      if (this.data) {
        this.runCellsCondition(this.data.getFilteredValues(), this.data.getFilteredProperties());
      }
      if (!!this.generatedVisibleRows) {
        this.updateValueOnRowsGeneration(this.generatedVisibleRows);
        this.updateIsAnswered();
      }
    }
  }
  getVisibleFromGenerated(rows) {
    const res = [];
    if (!rows) return res;
    rows.forEach((row) => {
      if (row.isVisible) res.push(row);
    });
    return res.length === rows.length ? rows : res;
  }
  updateValueOnRowsGeneration(rows) {
    var oldValue = this.createNewValue(true);
    var newValue = this.createNewValue();
    for (var i = 0; i < rows.length; i++) {
      var row = rows[i];
      if (!!row.editingObj) continue;
      var rowValue = this.getRowValue(i);
      var rValue = row.value;
      if (this.isTwoValueEquals(rowValue, rValue)) continue;
      newValue = this.getNewValueOnRowChanged(row, "", rValue, false, newValue).value;
    }
    if (this.isTwoValueEquals(oldValue, newValue)) return;
    this.isRowChanging = true;
    this.setNewValue(newValue);
    this.isRowChanging = false;
  }
  get totalValue() {
    if (!this.hasTotal || !this.visibleTotalRow) return {};
    return this.visibleTotalRow.value;
  }
  getVisibleTotalRow() {
    if (this.isUpdateLocked) return null;
    if (this.hasTotal) {
      if (!this.generatedTotalRow) {
        this.generatedTotalRow = this.generateTotalRow();
        if (this.data) {
          var properties = {
            survey: this.survey
          };
          this.runTotalsCondition(this.data.getAllValues(), properties);
        }
      }
    } else {
      this.generatedTotalRow = null;
    }
    return this.generatedTotalRow;
  }
  get visibleTotalRow() {
    return this.getVisibleTotalRow();
  }
  onSurveyLoad() {
    super.onSurveyLoad();
    this.updateColumnsIndexes(this.columns);
    this.clearGeneratedRows();
    this.generatedTotalRow = null;
    this.updateHasFooter();
  }
  /**
   * Returns an object with row values. If a row has no answers, this method returns an empty object.
   * @param rowIndex A zero-based row index.
   * @see setRowValue
   */
  getRowValue(rowIndex) {
    if (rowIndex < 0 || !Array.isArray(this.visibleRows)) return null;
    var rows = this.generatedVisibleRows;
    if (rowIndex >= rows.length) return null;
    const val = this.value;
    const rowVal = this.getRowValueCore(rows[rowIndex], val);
    if (this.isValueSurveyElement(val)) return rowVal;
    return Helpers.getUnbindValue(rowVal);
  }
  checkIfValueInRowDuplicated(checkedRow, cellQuestion) {
    if (!this.generatedVisibleRows) return false;
    return this.isValueInColumnDuplicated(cellQuestion.name, true, checkedRow);
  }
  /**
   * Assigns values to a row.
   * @param rowIndex A zero-based row index.
   * @param rowValue An object with the following structure: `{ "column_name": columnValue, ... }`
   * @see getRowValue
   */
  setRowValue(rowIndex, rowValue) {
    if (rowIndex < 0) return null;
    var visRows = this.visibleRows;
    if (rowIndex >= visRows.length) return null;
    visRows[rowIndex].value = rowValue;
    this.onRowChanged(visRows[rowIndex], "", rowValue, false);
  }
  generateRows() {
    return null;
  }
  generateTotalRow() {
    return new MatrixDropdownTotalRowModel(this);
  }
  createNewValue(nullOnEmpty = false) {
    var res = !this.value ? {} : this.createValueCopy();
    if (nullOnEmpty && this.isMatrixValueEmpty(res)) return null;
    return res;
  }
  getRowValueCore(row, questionValue, create = false) {
    var result = !!questionValue && !!questionValue[row.rowName] ? questionValue[row.rowName] : null;
    if (!result && create) {
      result = {};
      if (!!questionValue) {
        questionValue[row.rowName] = result;
      }
    }
    return result;
  }
  getRowObj(row) {
    var obj = this.getRowValueCore(row, this.value);
    return !!obj && !!obj.getType ? obj : null;
  }
  getRowDisplayValue(keysAsText, row, rowValue) {
    if (!rowValue) return rowValue;
    if (!!row.editingObj) return rowValue;
    var keys = Object.keys(rowValue);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var question = row.getQuestionByName(key);
      if (!question) {
        question = this.getSharedQuestionByName(key, row);
      }
      if (!!question) {
        var displayvalue = question.getDisplayValue(keysAsText, rowValue[key]);
        if (keysAsText && !!question.title && question.title !== key) {
          rowValue[question.title] = displayvalue;
          delete rowValue[key];
        } else {
          rowValue[key] = displayvalue;
        }
      }
    }
    return rowValue;
  }
  getPlainData(options = {
    includeEmpty: true
  }) {
    var questionPlainData = super.getPlainData(options);
    if (!!questionPlainData) {
      questionPlainData.isNode = true;
      const prevData = Array.isArray(questionPlainData.data) ? [].concat(questionPlainData.data) : [];
      questionPlainData.data = this.visibleRows.map((row) => {
        var rowDataItem = {
          name: row.dataName,
          title: row.text,
          value: row.value,
          displayValue: this.getRowDisplayValue(false, row, row.value),
          getString: (val) => typeof val === "object" ? JSON.stringify(val) : val,
          isNode: true,
          data: row.cells.map((cell) => cell.question.getPlainData(options)).filter((d) => !!d)
        };
        (options.calculations || []).forEach((calculation) => {
          rowDataItem[calculation.propertyName] = row[calculation.propertyName];
        });
        return rowDataItem;
      });
      questionPlainData.data = questionPlainData.data.concat(prevData);
    }
    return questionPlainData;
  }
  addConditionObjectsByContext(objects, context) {
    let rowElements = [].concat(this.columns);
    if (this.detailPanelMode !== "none") {
      rowElements = rowElements.concat(this.detailPanel.questions);
    }
    const hasColumnContext = !!context && rowElements.indexOf(context) > -1;
    const hasContext = context === true || hasColumnContext;
    const rowsIndeces = this.getConditionObjectsRowIndeces();
    if (hasContext) {
      rowsIndeces.push(-1);
    }
    for (var i = 0; i < rowsIndeces.length; i++) {
      const index = rowsIndeces[i];
      const rowName = index > -1 ? this.getConditionObjectRowName(index) : "row";
      if (!rowName) continue;
      const rowText = index > -1 ? this.getConditionObjectRowText(index) : "row";
      const hasQuestionPrefix = index > -1 || context === true;
      const dot = hasQuestionPrefix && index === -1 ? "." : "";
      const prefixName = (hasQuestionPrefix ? this.getValueName() : "") + dot + rowName + ".";
      const prefixTitle = (hasQuestionPrefix ? this.processedTitle : "") + dot + rowText + ".";
      for (var j = 0; j < rowElements.length; j++) {
        const rowElement = rowElements[j];
        if (index === -1 && context === rowElement) continue;
        const obj = {
          name: prefixName + rowElement.name,
          text: prefixTitle + rowElement.fullTitle,
          question: this
        };
        if (index === -1 && context === true) {
          obj.context = this;
        } else {
          if (hasColumnContext && prefixName.startsWith("row.")) {
            obj.context = context;
          }
        }
        objects.push(obj);
      }
    }
  }
  onHidingContent() {
    super.onHidingContent();
    if (!this.generatedVisibleRows) return;
    const questions = [];
    this.collectNestedQuestions(questions, true);
    questions.forEach((q) => q.onHidingContent());
  }
  getIsReadyNestedQuestions() {
    if (!this.generatedVisibleRows) return [];
    const res = new Array();
    this.collectNestedQuestonsInRows(this.generatedVisibleRows, res, false);
    if (!!this.generatedTotalRow) {
      this.collectNestedQuestonsInRows([this.generatedTotalRow], res, false);
    }
    return res;
  }
  collectNestedQuestionsCore(questions, visibleOnly) {
    this.collectNestedQuestonsInRows(this.visibleRows, questions, visibleOnly);
  }
  collectNestedQuestonsInRows(rows, questions, visibleOnly) {
    if (!Array.isArray(rows)) return;
    rows.forEach((row) => {
      row.questions.forEach((q) => q.collectNestedQuestions(questions, visibleOnly));
    });
  }
  getConditionObjectRowName(index) {
    return "";
  }
  getConditionObjectRowText(index) {
    return this.getConditionObjectRowName(index);
  }
  getConditionObjectsRowIndeces() {
    return [];
  }
  getProgressInfo() {
    this.getIsRequireToGenerateRows() && this.generateVisibleRowsIfNeeded();
    if (!!this.generatedVisibleRows) return SurveyElement.getProgressInfoByElements(this.getCellQuestions(), this.isRequired);
    const res = Base.createProgressInfo();
    this.updateProgressInfoByValues(res);
    if (res.requiredQuestionCount === 0 && this.isRequired) {
      res.requiredQuestionCount = 1;
      res.requiredAnsweredQuestionCount = !this.isEmpty() ? 1 : 0;
    }
    return res;
  }
  getIsRequireToGenerateRows() {
    return !!this.rowsVisibleIf;
  }
  updateProgressInfoByValues(res) {
  }
  updateProgressInfoByRow(res, rowValue) {
    for (var i = 0; i < this.columns.length; i++) {
      const col = this.columns[i];
      if (!col.templateQuestion.hasInput) continue;
      const hasValue = !Helpers.isValueEmpty(rowValue[col.name]);
      if (!hasValue && !!col.templateQuestion.visibleIf) continue;
      res.questionCount += 1;
      res.requiredQuestionCount += col.isRequired;
      res.answeredQuestionCount += hasValue ? 1 : 0;
      res.requiredAnsweredQuestionCount += hasValue && col.isRequired ? 1 : 0;
    }
  }
  getCellQuestions() {
    const res = [];
    this.runFuncForCellQuestions((q) => {
      res.push(q);
    });
    return res;
  }
  onBeforeValueChanged(val) {
  }
  onSetQuestionValue() {
    if (this.isRowChanging) return;
    this.onBeforeValueChanged(this.value);
    if (!this.generatedVisibleRows || this.generatedVisibleRows.length == 0) return;
    this.isRowChanging = true;
    var val = this.createNewValue();
    for (var i = 0; i < this.generatedVisibleRows.length; i++) {
      var row = this.generatedVisibleRows[i];
      this.generatedVisibleRows[i].value = this.getRowValueCore(row, val);
    }
    this.isRowChanging = false;
  }
  setQuestionValue(newValue) {
    super.setQuestionValue(newValue, false);
    this.onSetQuestionValue();
    this.updateIsAnswered();
  }
  supportAutoAdvance() {
    var rows = this.generatedVisibleRows;
    if (!rows) rows = this.visibleRows;
    if (!rows) return true;
    for (var i = 0; i < rows.length; i++) {
      var cells = this.generatedVisibleRows[i].cells;
      if (!cells) continue;
      for (var colIndex = 0; colIndex < cells.length; colIndex++) {
        var question = cells[colIndex].question;
        if (question && (!question.supportAutoAdvance() || !question.value)) return false;
      }
    }
    return true;
  }
  getContainsErrors() {
    return super.getContainsErrors() || this.checkForAnswersOrErrors((question) => question.containsErrors, false);
  }
  getIsAnswered() {
    return super.getIsAnswered() && this.checkForAnswersOrErrors((question) => question.isAnswered, true);
  }
  checkForAnswersOrErrors(predicate, every = false) {
    var rows = this.generatedVisibleRows;
    if (!rows) return false;
    for (var i = 0; i < rows.length; i++) {
      var cells = rows[i].cells;
      if (!cells) continue;
      for (var colIndex = 0; colIndex < cells.length; colIndex++) {
        if (!cells[colIndex]) continue;
        var question = cells[colIndex].question;
        if (question && question.isVisible) if (predicate(question)) {
          if (!every) return true;
        } else {
          if (every) return false;
        }
      }
    }
    return every ? true : false;
  }
  hasErrors(fireCallback = true, rec = null) {
    var errosInRows = this.hasErrorInRows(fireCallback, rec);
    var isDuplicated = this.isValueDuplicated();
    return super.hasErrors(fireCallback, rec) || errosInRows || isDuplicated;
  }
  getIsRunningValidators() {
    if (super.getIsRunningValidators()) return true;
    if (!this.generatedVisibleRows) return false;
    for (var i = 0; i < this.generatedVisibleRows.length; i++) {
      var cells = this.generatedVisibleRows[i].cells;
      if (!cells) continue;
      for (var colIndex = 0; colIndex < cells.length; colIndex++) {
        if (!cells[colIndex]) continue;
        var question = cells[colIndex].question;
        if (!!question && question.isRunningValidators) return true;
      }
    }
    return false;
  }
  getAllErrors() {
    var result = super.getAllErrors();
    var rows = this.generatedVisibleRows;
    if (rows === null) return result;
    for (var i = 0; i < rows.length; i++) {
      var row = rows[i];
      for (var j = 0; j < row.cells.length; j++) {
        var errors = row.cells[j].question.getAllErrors();
        if (errors && errors.length > 0) {
          result = result.concat(errors);
        }
      }
    }
    return result;
  }
  hasErrorInRows(fireCallback, rec) {
    let rows = this.generatedVisibleRows;
    if (!this.generatedVisibleRows) {
      rows = this.visibleRows;
    }
    var res = false;
    if (!rec) rec = {};
    if (!rows) return rec;
    rec.validationValues = this.getDataFilteredValues();
    rec.isSingleDetailPanel = this.detailPanelMode === "underRowSingle";
    for (var i = 0; i < rows.length; i++) {
      if (rows[i].isVisible) {
        res = rows[i].hasErrors(fireCallback, rec, () => {
          this.raiseOnCompletedAsyncValidators();
        }) || res;
      }
    }
    return res;
  }
  isValueDuplicated() {
    if (!this.generatedVisibleRows) return false;
    var names = this.getUniqueColumnsNames();
    var res = false;
    for (var i = 0; i < names.length; i++) {
      res = this.isValueInColumnDuplicated(names[i], true) || res;
    }
    return res;
  }
  getUniqueColumnsNames() {
    var res = new Array();
    for (var i = 0; i < this.columns.length; i++) {
      if (this.columns[i].isUnique) {
        res.push(this.columns[i].name);
      }
    }
    return res;
  }
  isValueInColumnDuplicated(columnName, showErrors, row) {
    const rows = this.getDuplicatedRows(columnName);
    if (showErrors) {
      this.showDuplicatedErrorsInRows(rows, columnName);
    }
    this.removeDuplicatedErrorsInRows(rows, columnName);
    return !!row ? rows.indexOf(row) > -1 : rows.length > 0;
  }
  getDuplicatedRows(columnName) {
    const keyValues = {};
    const res = [];
    const rows = this.generatedVisibleRows;
    for (var i = 0; i < rows.length; i++) {
      let val = void 0;
      const question = rows[i].getQuestionByName(columnName);
      if (!!question) {
        val = question.value;
      } else {
        const rowVal = this.getRowValue(i);
        val = !!rowVal ? rowVal[columnName] : void 0;
      }
      if (!this.isValueEmpty(val)) {
        if (!this.useCaseSensitiveComparison && typeof val === "string") {
          val = val.toLocaleLowerCase();
        }
        if (!keyValues[val]) {
          keyValues[val] = [];
        }
        keyValues[val].push(rows[i]);
      }
    }
    for (let key in keyValues) {
      if (keyValues[key].length > 1) {
        keyValues[key].forEach((row) => res.push(row));
      }
    }
    return res;
  }
  showDuplicatedErrorsInRows(duplicatedRows, columnName) {
    duplicatedRows.forEach((row) => {
      let question = row.getQuestionByName(columnName);
      const inDetailPanel = this.detailPanel.getQuestionByName(columnName);
      if (!question && inDetailPanel) {
        row.showDetailPanel();
        if (row.detailPanel) {
          question = row.detailPanel.getQuestionByName(columnName);
        }
      }
      if (question) {
        if (inDetailPanel) {
          row.showDetailPanel();
        }
        this.addDuplicationError(question);
      }
    });
  }
  removeDuplicatedErrorsInRows(duplicatedRows, columnName) {
    this.generatedVisibleRows.forEach((row) => {
      if (duplicatedRows.indexOf(row) < 0) {
        const question = row.getQuestionByName(columnName);
        if (question) {
          this.removeDuplicationError(row, question);
        }
      }
    });
  }
  getDuplicationError(question) {
    const errors = question.errors;
    for (let i = 0; i < errors.length; i++) {
      if (errors[i].getErrorType() === "keyduplicationerror") return errors[i];
    }
    return null;
  }
  addDuplicationError(question) {
    if (!this.getDuplicationError(question)) {
      question.addError(new KeyDuplicationError(this.keyDuplicationError, this));
    }
  }
  removeDuplicationError(row, question) {
    if (question.removeError(this.getDuplicationError(question)) && question.errors.length === 0 && !!row.editingObj) {
      row.editingObj[question.getValueName()] = question.value;
    }
  }
  getFirstQuestionToFocus(withError) {
    return this.getFirstCellQuestion(withError);
  }
  getFirstInputElementId() {
    var question = this.getFirstCellQuestion(false);
    return question ? question.inputId : super.getFirstInputElementId();
  }
  getFirstErrorInputElementId() {
    var question = this.getFirstCellQuestion(true);
    return question ? question.inputId : super.getFirstErrorInputElementId();
  }
  getFirstCellQuestion(onError) {
    if (!this.generatedVisibleRows) return null;
    for (var i = 0; i < this.generatedVisibleRows.length; i++) {
      var cells = this.generatedVisibleRows[i].cells;
      for (var colIndex = 0; colIndex < cells.length; colIndex++) {
        if (!onError) return cells[colIndex].question;
        if (cells[colIndex].question.currentErrorCount > 0) return cells[colIndex].question;
      }
    }
    return null;
  }
  onReadOnlyChanged() {
    super.onReadOnlyChanged();
    if (!this.generateRows) return;
    for (var i = 0; i < this.visibleRows.length; i++) {
      this.visibleRows[i].onQuestionReadOnlyChanged();
    }
  }
  //IMatrixDropdownData
  createQuestion(row, column) {
    return this.createQuestionCore(row, column);
  }
  createQuestionCore(row, column) {
    var question = column.createCellQuestion(row);
    question.setSurveyImpl(row);
    question.setParentQuestion(this);
    question.inMatrixMode = true;
    return question;
  }
  deleteRowValue(newValue, row) {
    if (!newValue) return newValue;
    delete newValue[row.rowName];
    return this.isObject(newValue) && Object.keys(newValue).length == 0 ? null : newValue;
  }
  onAnyValueChanged(name, questionName) {
    if (this.isUpdateLocked || this.isDoingonAnyValueChanged || !this.generatedVisibleRows) return;
    this.isDoingonAnyValueChanged = true;
    var rows = this.generatedVisibleRows;
    for (var i = 0; i < rows.length; i++) {
      rows[i].onAnyValueChanged(name, questionName);
    }
    var totalRow = this.visibleTotalRow;
    if (!!totalRow) {
      totalRow.onAnyValueChanged(name, questionName);
    }
    this.isDoingonAnyValueChanged = false;
  }
  isObject(value) {
    return value !== null && typeof value === "object";
  }
  getOnCellValueChangedOptions(row, columnName, rowValue) {
    const getQuestion = (colName) => {
      return row.getQuestionByName(colName);
    };
    return {
      row,
      columnName,
      rowValue,
      value: !!rowValue ? rowValue[columnName] : null,
      getCellQuestion: getQuestion,
      cellQuestion: row.getQuestionByName(columnName),
      column: this.getColumnByName(columnName)
    };
  }
  onCellValueChanged(row, columnName, rowValue) {
    if (!this.survey) return;
    var options = this.getOnCellValueChangedOptions(row, columnName, rowValue);
    if (!!this.onCellValueChangedCallback) {
      this.onCellValueChangedCallback(options);
    }
    this.survey.matrixCellValueChanged(this, options);
  }
  validateCell(row, columnName, rowValue) {
    if (!this.survey) return;
    var options = this.getOnCellValueChangedOptions(row, columnName, rowValue);
    return this.survey.matrixCellValidate(this, options);
  }
  get isValidateOnValueChanging() {
    return !!this.survey ? this.survey.isValidateOnValueChanging : false;
  }
  get hasInvisibleRows() {
    const rows = this.generatedVisibleRows;
    if (!Array.isArray(rows)) return false;
    for (let i = 0; i < rows.length; i++) {
      if (!rows[i].isVisible) return true;
    }
    return false;
  }
  getFilteredData() {
    if (this.isEmpty() || !this.generatedVisibleRows || !this.hasInvisibleRows) return this.value;
    return this.getFilteredDataCore();
  }
  getFilteredDataCore() {
    return this.value;
  }
  onRowChanging(row, columnName, rowValue) {
    if (!this.survey && !this.cellValueChangingCallback) return !!rowValue ? rowValue[columnName] : null;
    var options = this.getOnCellValueChangedOptions(row, columnName, rowValue);
    var oldRowValue = this.getRowValueCore(row, this.createNewValue(), true);
    options.oldValue = !!oldRowValue ? oldRowValue[columnName] : null;
    if (!!this.cellValueChangingCallback) {
      options.value = this.cellValueChangingCallback(row, columnName, options.value, options.oldValue);
    }
    if (!!this.survey) {
      this.survey.matrixCellValueChanging(this, options);
    }
    return options.value;
  }
  onRowChanged(row, columnName, newRowValue, isDeletingValue) {
    var rowObj = !!columnName ? this.getRowObj(row) : null;
    if (!!rowObj) {
      var columnValue = null;
      if (!!newRowValue && !isDeletingValue) {
        columnValue = newRowValue[columnName];
      }
      this.isRowChanging = true;
      Serializer.setObjPropertyValue(rowObj, columnName, columnValue);
      this.isRowChanging = false;
      this.onCellValueChanged(row, columnName, rowObj);
    } else {
      var oldValue = this.createNewValue(true);
      var combine = this.getNewValueOnRowChanged(row, columnName, newRowValue, isDeletingValue, this.createNewValue());
      if (this.isTwoValueEquals(oldValue, combine.value)) return;
      this.isRowChanging = true;
      this.setNewValue(combine.value);
      this.isRowChanging = false;
      if (columnName) {
        this.onCellValueChanged(row, columnName, combine.rowValue);
      }
    }
    if (this.getUniqueColumnsNames().indexOf(columnName) > -1) {
      this.isValueInColumnDuplicated(columnName, !!rowObj);
    }
  }
  getNewValueOnRowChanged(row, columnName, newRowValue, isDeletingValue, newValue) {
    const rowValue = this.getRowValueCore(row, newValue, true);
    if (isDeletingValue) {
      delete rowValue[columnName];
    }
    row.questions.forEach((q) => {
      delete rowValue[q.getValueName()];
    });
    if (newRowValue) {
      newRowValue = JSON.parse(JSON.stringify(newRowValue));
      for (var key in newRowValue) {
        if (!this.isValueEmpty(newRowValue[key])) {
          rowValue[key] = newRowValue[key];
        }
      }
    }
    if (this.isObject(rowValue) && Object.keys(rowValue).length === 0) {
      newValue = this.deleteRowValue(newValue, row);
    }
    return {
      value: newValue,
      rowValue
    };
  }
  getRowIndex(row) {
    if (!Array.isArray(this.generatedVisibleRows)) return -1;
    return this.generatedVisibleRows.indexOf(row);
  }
  getElementsInDesign(includeHidden = false) {
    let elements;
    if (this.detailPanelMode == "none") {
      elements = super.getElementsInDesign(includeHidden);
    } else {
      elements = includeHidden ? [this.detailPanel] : this.detailElements;
    }
    return this.columns.concat(elements);
  }
  hasDetailPanel(row) {
    if (this.detailPanelMode == "none") return false;
    if (this.isDesignMode) return true;
    if (!!this.onHasDetailPanelCallback) return this.onHasDetailPanelCallback(row);
    return this.detailElements.length > 0;
  }
  getIsDetailPanelShowing(row) {
    if (this.detailPanelMode == "none") return false;
    if (this.isDesignMode) {
      var res = this.visibleRows.indexOf(row) == 0;
      if (res) {
        if (!row.detailPanel) {
          row.showDetailPanel();
        }
      }
      return res;
    }
    return this.getPropertyValue("isRowShowing" + row.id, false);
  }
  setIsDetailPanelShowing(row, val) {
    if (val == this.getIsDetailPanelShowing(row)) return;
    this.setPropertyValue("isRowShowing" + row.id, val);
    this.updateDetailPanelButtonCss(row);
    if (!!this.renderedTable) {
      this.renderedTable.onDetailPanelChangeVisibility(row, val);
    }
    if (this.survey) {
      this.survey.matrixDetailPanelVisibleChanged(this, row.rowIndex - 1, row, val);
    }
    if (val && this.detailPanelMode === "underRowSingle") {
      var rows = this.visibleRows;
      for (var i = 0; i < rows.length; i++) {
        if (rows[i].id !== row.id && rows[i].isDetailPanelShowing) {
          rows[i].hideDetailPanel();
        }
      }
    }
  }
  getDetailPanelButtonCss(row) {
    const builder = new CssClassBuilder().append(this.getPropertyValue("detailButtonCss" + row.id));
    return builder.append(this.cssClasses.detailButton, builder.toString() === "").toString();
  }
  getDetailPanelIconCss(row) {
    const builder = new CssClassBuilder().append(this.getPropertyValue("detailIconCss" + row.id));
    return builder.append(this.cssClasses.detailIcon, builder.toString() === "").toString();
  }
  getDetailPanelIconId(row) {
    return this.getIsDetailPanelShowing(row) ? this.cssClasses.detailIconExpandedId : this.cssClasses.detailIconId;
  }
  updateDetailPanelButtonCss(row) {
    const classes = this.cssClasses;
    const isPanelShowing = this.getIsDetailPanelShowing(row);
    const iconBuilder = new CssClassBuilder().append(classes.detailIcon).append(classes.detailIconExpanded, isPanelShowing);
    this.setPropertyValue("detailIconCss" + row.id, iconBuilder.toString());
    const buttonBuilder = new CssClassBuilder().append(classes.detailButton).append(classes.detailButtonExpanded, isPanelShowing);
    this.setPropertyValue("detailButtonCss" + row.id, buttonBuilder.toString());
  }
  createRowDetailPanel(row) {
    if (this.isDesignMode) return this.detailPanel;
    var panel = this.createNewDetailPanel();
    panel.readOnly = this.isReadOnly || !row.isRowEnabled();
    panel.setSurveyImpl(row);
    var json2 = this.detailPanel.toJSON();
    new JsonObject().toObject(json2, panel);
    panel.renderWidth = "100%";
    panel.updateCustomWidgets();
    if (!!this.onCreateDetailPanelCallback) {
      this.onCreateDetailPanelCallback(row, panel);
    }
    panel.questions.forEach((q) => q.setParentQuestion(this));
    panel.onSurveyLoad();
    return panel;
  }
  getSharedQuestionByName(columnName, row) {
    if (!this.survey || !this.valueName) return null;
    var index = this.getRowIndex(row);
    if (index < 0) return null;
    return this.survey.getQuestionByValueNameFromArray(this.valueName, columnName, index);
  }
  onTotalValueChanged() {
    if (!!this.data && !!this.visibleTotalRow && !this.isUpdateLocked && !this.isSett) {
      this.data.setValue(this.getValueName() + settings.matrix.totalsSuffix, this.totalValue, false);
    }
  }
  getDataFilteredValues() {
    return this.data ? this.data.getFilteredValues() : {};
  }
  getParentTextProcessor() {
    if (!this.parentQuestion || !this.parent) return null;
    const data = this.parent.data;
    if (!!data && !!data.getTextProcessor) return data.getTextProcessor();
    return null;
  }
  isMatrixReadOnly() {
    return this.isReadOnly;
  }
  onRowVisibilityChanged(row) {
    this.clearVisibleRows();
    this.resetRenderedTable();
  }
  clearValueIfInvisibleCore(reason) {
    super.clearValueIfInvisibleCore(reason);
    this.clearInvisibleValuesInRows();
  }
  clearInvisibleValuesInRows() {
    var _a;
    if (this.isEmpty() || !this.isRowsFiltered()) return;
    const sharedQuestions = ((_a = this.survey) === null || _a === void 0 ? void 0 : _a.questionsByValueName(this.getValueName())) || [];
    if (sharedQuestions.length < 2) {
      this.value = this.getFilteredData();
    }
  }
  isRowsFiltered() {
    return super.isRowsFiltered() || this.visibleRows !== this.generatedVisibleRows;
  }
  getQuestionFromArray(name, index) {
    if (index >= this.visibleRows.length) return null;
    return this.visibleRows[index].getQuestionByName(name);
  }
  isMatrixValueEmpty(val) {
    if (!val) return;
    if (Array.isArray(val)) {
      for (var i = 0; i < val.length; i++) {
        if (this.isObject(val[i]) && Object.keys(val[i]).length > 0) return false;
      }
      return true;
    }
    return Object.keys(val).length == 0;
  }
  get SurveyModel() {
    return this.survey;
  }
  getCellTemplateData(cell) {
    return this.SurveyModel.getMatrixCellTemplateData(cell);
  }
  getCellWrapperComponentName(cell) {
    return this.SurveyModel.getElementWrapperComponentName(cell, cell.row instanceof MatrixDropdownTotalRowModel ? "row-footer" : "cell");
  }
  getCellWrapperComponentData(cell) {
    return this.SurveyModel.getElementWrapperComponentData(cell, cell.row instanceof MatrixDropdownTotalRowModel ? "row-footer" : "cell");
  }
  getColumnHeaderWrapperComponentName(cell) {
    return this.SurveyModel.getElementWrapperComponentName(cell, "column-header");
  }
  getColumnHeaderWrapperComponentData(cell) {
    return this.SurveyModel.getElementWrapperComponentData(cell, "column-header");
  }
  getRowHeaderWrapperComponentName(cell) {
    return this.SurveyModel.getElementWrapperComponentName(cell, "row-header");
  }
  getRowHeaderWrapperComponentData(cell) {
    return this.SurveyModel.getElementWrapperComponentData(cell, "row-header");
  }
  get showHorizontalScroll() {
    return !this.isDefaultV2Theme && this.horizontalScroll;
  }
  onMobileChanged() {
    super.onMobileChanged();
    this.resetRenderedTable();
  }
  getRootCss() {
    return new CssClassBuilder().append(super.getRootCss()).append(this.cssClasses.rootScroll, this.horizontalScroll).toString();
  }
  afterRenderQuestionElement(el) {
    super.afterRenderQuestionElement(el);
    this.setRootElement(el === null || el === void 0 ? void 0 : el.parentElement);
  }
  beforeDestroyQuestionElement(el) {
    super.beforeDestroyQuestionElement(el);
    this.setRootElement(void 0);
  }
  setRootElement(val) {
    this.rootElement = val;
  }
  getRootElement() {
    return this.rootElement;
  }
};
Serializer.addClass("matrixdropdownbase", [{
  name: "columns:matrixdropdowncolumns",
  className: "matrixdropdowncolumn",
  isArray: true
}, {
  name: "columnLayout",
  alternativeName: "columnsLocation",
  choices: ["horizontal", "vertical"],
  visible: false,
  isSerializable: false
}, {
  name: "transposeData:boolean",
  version: "1.9.130",
  oldName: "columnLayout"
}, {
  name: "detailElements",
  baseClassName: "question",
  visible: false,
  isLightSerializable: false
}, {
  name: "detailPanelMode",
  choices: ["none", "underRow", "underRowSingle"],
  default: "none"
}, {
  name: "cellErrorLocation",
  default: "default",
  choices: ["default", "top", "bottom"]
}, {
  name: "detailErrorLocation",
  default: "default",
  choices: ["default", "top", "bottom"],
  visibleIf: (obj) => {
    return !!obj && obj.detailPanelMode != "none";
  }
}, {
  name: "horizontalScroll:boolean",
  visible: false
}, {
  name: "choices:itemvalue[]",
  uniqueProperty: "value",
  visibleIf: (obj) => obj.isSelectCellType()
}, {
  name: "placeholder",
  alternativeName: "optionsCaption",
  serializationProperty: "locPlaceholder"
}, {
  name: "keyDuplicationError",
  serializationProperty: "locKeyDuplicationError"
}, {
  name: "cellType",
  default: "dropdown",
  choices: () => {
    return MatrixDropdownColumn.getColumnTypes();
  }
}, {
  name: "columnColCount",
  default: 0,
  choices: [0, 1, 2, 3, 4]
}, "columnMinWidth", {
  name: "allowAdaptiveActions:boolean",
  default: false,
  visible: false
}], function() {
  return new QuestionMatrixDropdownModelBase("");
}, "matrixbase");
var MatrixDropdownRowModel = class extends MatrixDropdownRowModelBase {
  constructor(name, item, data, value) {
    super(data, value);
    this.name = name;
    this.item = item;
    this.buildCells(value);
  }
  get rowName() {
    return this.name;
  }
  get text() {
    return this.item.text;
  }
  get locText() {
    return this.item.locText;
  }
  isItemVisible() {
    return this.item.isVisible;
  }
  isRowEnabled() {
    return this.item.isEnabled;
  }
  isRowHasEnabledCondition() {
    return !!this.item.enableIf;
  }
  setRowsVisibleIfValues(values) {
    values["item"] = this.item.value;
    values["choice"] = this.item.value;
  }
};
var QuestionMatrixDropdownModel = class extends QuestionMatrixDropdownModelBase {
  constructor(name) {
    super(name);
    this.defaultValuesInRows = {};
    this.createLocalizableString("totalText", this, true);
    this.registerPropertyChangedHandlers(["rows"], () => {
      if (!this.generatedVisibleRows) return;
      this.clearGeneratedRows();
      this.resetRenderedTable();
      this.getVisibleRows();
      this.clearIncorrectValues();
    });
    this.registerPropertyChangedHandlers(["hideIfRowsEmpty"], () => {
      this.updateVisibilityBasedOnRows();
    });
  }
  getType() {
    return "matrixdropdown";
  }
  /**
   * A title for the total row. Applies if at least one column displays total values.
   * @see rowTitleWidth
   * @see columns
   */
  get totalText() {
    return this.getLocalizableStringText("totalText", "");
  }
  set totalText(val) {
    this.setLocalizableStringText("totalText", val);
  }
  get locTotalText() {
    return this.getLocalizableString("totalText");
  }
  getFooterText() {
    return this.locTotalText;
  }
  getRowTitleWidth() {
    return this.rowTitleWidth;
  }
  /**
   * Specifies whether to hide the question when the matrix has no visible rows.
   * @see rowsVisibleIf
   */
  get hideIfRowsEmpty() {
    return this.getPropertyValue("hideIfRowsEmpty");
  }
  set hideIfRowsEmpty(val) {
    this.setPropertyValue("hideIfRowsEmpty", val);
  }
  getDisplayValueCore(keysAsText, value) {
    if (!value) return value;
    var rows = this.visibleRows;
    var res = {};
    if (!rows) return res;
    for (var i = 0; i < rows.length; i++) {
      var rowName = rows[i].rowName;
      var val = value[rowName];
      if (!val) continue;
      if (keysAsText) {
        var displayRowValue = ItemValue.getTextOrHtmlByValue(this.rows, rowName);
        if (!!displayRowValue) {
          rowName = displayRowValue;
        }
      }
      res[rowName] = this.getRowDisplayValue(keysAsText, rows[i], val);
    }
    return res;
  }
  getConditionObjectRowName(index) {
    return "." + this.rows[index].value;
  }
  getConditionObjectRowText(index) {
    return "." + this.rows[index].calculatedText;
  }
  getConditionObjectsRowIndeces() {
    const res = [];
    for (var i = 0; i < this.rows.length; i++) res.push(i);
    return res;
  }
  isNewValueCorrect(val) {
    return Helpers.isValueObject(val, true);
  }
  clearIncorrectValues() {
    if (!this.isEmpty()) {
      this.getVisibleRows();
      const newVal = {};
      const val = this.value;
      for (let key in val) {
        const row = this.getRowByKey(key);
        if (!!row && row.isVisible) {
          newVal[key] = val[key];
        }
      }
      this.value = newVal;
    }
    super.clearIncorrectValues();
  }
  getRowByKey(val) {
    const rows = this.generatedVisibleRows;
    if (!rows) return null;
    for (let i = 0; i < rows.length; i++) {
      if (rows[i].rowName === val) return rows[i];
    }
    return null;
  }
  clearGeneratedRows() {
    if (!this.generatedVisibleRows) return;
    if (!this.isDisposed) {
      this.generatedVisibleRows.forEach((row) => {
        this.defaultValuesInRows[row.rowName] = row.getNamesWithDefaultValues();
      });
    }
    super.clearGeneratedRows();
  }
  getRowValueForCreation(val, rowName) {
    const res = val[rowName];
    if (!res) return res;
    const names = this.defaultValuesInRows[rowName];
    if (!Array.isArray(names) || names.length === 0) return res;
    names.forEach((name) => {
      delete res[name];
    });
    return res;
  }
  generateRows() {
    var result = new Array();
    var rows = this.rows;
    if (!rows || rows.length === 0) return result;
    var val = this.value;
    if (!val) val = {};
    for (var i = 0; i < rows.length; i++) {
      const row = rows[i];
      if (this.isValueEmpty(row.value)) continue;
      result.push(this.createMatrixRow(row, this.getRowValueForCreation(val, row.value)));
    }
    return result;
  }
  createMatrixRow(item, value) {
    return new MatrixDropdownRowModel(item.value, item, this, value);
  }
  getFilteredDataCore() {
    const res = {};
    const val = this.createValueCopy();
    this.generatedVisibleRows.forEach((row) => {
      const rowVal = val[row.rowName];
      if (row.isVisible && !Helpers.isValueEmpty(rowVal)) {
        res[row.rowName] = rowVal;
      }
    });
    return res;
  }
  getSearchableItemValueKeys(keys) {
    keys.push("rows");
  }
  getIsRequireToGenerateRows() {
    if (super.getIsRequireToGenerateRows()) return true;
    for (let i = 0; i < this.rows.length; i++) {
      if (!!this.rows[i].visibleIf) return true;
    }
    return false;
  }
  updateProgressInfoByValues(res) {
    let val = this.value;
    if (!val) val = {};
    for (var i = 0; i < this.rows.length; i++) {
      const row = this.rows[i];
      const rowName = val[row.value];
      this.updateProgressInfoByRow(res, !!rowName ? rowName : {});
    }
  }
};
Serializer.addClass("matrixdropdown", [{
  name: "rows:itemvalue[]",
  uniqueProperty: "value"
}, "rowsVisibleIf:condition", "rowTitleWidth", {
  name: "totalText",
  serializationProperty: "locTotalText"
}, "hideIfRowsEmpty:boolean"], function() {
  return new QuestionMatrixDropdownModel("");
}, "matrixdropdownbase");
QuestionFactory.Instance.registerQuestion("matrixdropdown", (name) => {
  var q = new QuestionMatrixDropdownModel(name);
  q.choices = [1, 2, 3, 4, 5];
  q.rows = QuestionFactory.DefaultRows;
  QuestionMatrixDropdownModelBase.addDefaultColumns(q);
  return q;
});
var _isMobile = false;
var vendor = null;
if (typeof navigator !== "undefined" && !!navigator && DomWindowHelper.isAvailable()) {
  vendor = navigator.userAgent || navigator.vendor || DomWindowHelper.hasOwn("opera");
}
(function(a) {
  if (!a) return;
  if (navigator.platform === "MacIntel" && navigator.maxTouchPoints > 0 || navigator.platform === "iPad") {
    _isMobile = true;
  } else if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substring(0, 4))) _isMobile = true;
})(vendor);
var _IPad = false;
var IsMobile = _isMobile || _IPad;
var mouseInfo = {
  get isTouch() {
    return !this.hasMouse && this.hasTouchEvent;
  },
  get hasTouchEvent() {
    return DomWindowHelper.isAvailable() && (DomWindowHelper.hasOwn("ontouchstart") || navigator.maxTouchPoints > 0);
  },
  hasMouse: true
};
var matchMediaMethod = DomWindowHelper.matchMedia;
mouseInfo.hasMouse = detectMouseSupport(matchMediaMethod);
var IsTouch = mouseInfo.isTouch;
function detectMouseSupport(matchMedia) {
  if (!matchMedia) return false;
  if (IsMobile) return false;
  const pointerQuery = matchMedia("(pointer:fine)");
  const hoverQuery = matchMedia("(any-hover:hover)");
  return !!pointerQuery && pointerQuery.matches || !!hoverQuery && hoverQuery.matches;
}
if (typeof window !== "undefined") {
  window.addEventListener("touchmove", (event) => {
    if (!DragDropDOMAdapter.PreventScrolling) {
      return;
    }
    event.preventDefault();
  }, {
    passive: false
  });
}
var DragDropDOMAdapter = class _DragDropDOMAdapter {
  constructor(dd, longTap = true, fitToContainer = false) {
    this.dd = dd;
    this.longTap = longTap;
    this.fitToContainer = fitToContainer;
    this.scrollIntervalId = null;
    this.stopLongTapIfMoveEnough = (pointerMoveEvent) => {
      pointerMoveEvent.preventDefault();
      this.currentX = pointerMoveEvent.pageX;
      this.currentY = pointerMoveEvent.pageY;
      if (this.isMicroMovement) return;
      this.returnUserSelectBack();
      this.stopLongTap();
    };
    this.stopLongTap = (e) => {
      clearTimeout(this.timeoutID);
      this.timeoutID = null;
      document.removeEventListener("pointerup", this.stopLongTap);
      document.removeEventListener("pointermove", this.stopLongTapIfMoveEnough);
    };
    this.handlePointerCancel = (event) => {
      this.clear();
    };
    this.handleEscapeButton = (event) => {
      if (event.keyCode == 27) {
        this.clear();
      }
    };
    this.onContextMenu = (event) => {
      event.preventDefault();
      event.stopPropagation();
    };
    this.dragOver = (event) => {
      this.moveShortcutElement(event);
      this.draggedElementShortcut.style.cursor = "grabbing";
      this.dd.dragOver(event);
    };
    this.clear = () => {
      cancelAnimationFrame(this.scrollIntervalId);
      document.removeEventListener("pointermove", this.dragOver);
      document.removeEventListener("pointercancel", this.handlePointerCancel);
      document.removeEventListener("keydown", this.handleEscapeButton);
      document.removeEventListener("pointerup", this.drop);
      this.draggedElementShortcut.removeEventListener("pointerup", this.drop);
      if (IsTouch) {
        this.draggedElementShortcut.removeEventListener("contextmenu", this.onContextMenu);
      }
      this.draggedElementShortcut.parentElement.removeChild(this.draggedElementShortcut);
      this.dd.clear();
      this.draggedElementShortcut = null;
      this.scrollIntervalId = null;
      if (IsTouch) {
        this.savedTargetNode.style.cssText = null;
        this.savedTargetNode && this.savedTargetNode.parentElement.removeChild(this.savedTargetNode);
        this.insertNodeToParentAtIndex(this.savedTargetNodeParent, this.savedTargetNode, this.savedTargetNodeIndex);
        _DragDropDOMAdapter.PreventScrolling = false;
      }
      this.savedTargetNode = null;
      this.savedTargetNodeParent = null;
      this.savedTargetNodeIndex = null;
      this.returnUserSelectBack();
    };
    this.drop = () => {
      this.dd.drop();
      this.clear();
    };
    this.draggedElementShortcut = null;
  }
  get documentOrShadowRoot() {
    return settings.environment.root;
  }
  get rootElement() {
    if (isShadowDOM(settings.environment.root)) {
      return this.rootContainer || settings.environment.root.host;
    } else {
      return this.rootContainer || settings.environment.root.documentElement || document.body;
    }
  }
  // see https://stackoverflow.com/questions/6042202/how-to-distinguish-mouse-click-and-drag
  get isMicroMovement() {
    const delta = 5;
    const diffX = Math.abs(this.currentX - this.startX);
    const diffY = Math.abs(this.currentY - this.startY);
    return diffX < delta && diffY < delta;
  }
  startLongTapProcessing(event, draggedElement, parentElement, draggedElementNode, preventSaveTargetNode = false) {
    this.startX = event.pageX;
    this.startY = event.pageY;
    document.body.style.setProperty("touch-action", "none", "important");
    this.timeoutID = setTimeout(() => {
      this.doStartDrag(event, draggedElement, parentElement, draggedElementNode);
      if (!preventSaveTargetNode) {
        this.savedTargetNode = event.target;
        this.savedTargetNode.style.cssText = `
          position: absolute;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden;
          clip: rect(1px 1px 1px 1px);
          clip: rect(1px, 1px, 1px, 1px);
        `;
        this.savedTargetNodeParent = this.savedTargetNode.parentElement;
        this.savedTargetNodeIndex = this.getNodeIndexInParent(this.savedTargetNode);
        this.rootElement.appendChild(this.savedTargetNode);
      }
      this.stopLongTap();
    }, this.longTap ? 500 : 0);
    document.addEventListener("pointerup", this.stopLongTap);
    document.addEventListener("pointermove", this.stopLongTapIfMoveEnough);
  }
  moveShortcutElement(event) {
    let rootElementX = this.rootElement.getBoundingClientRect().x;
    let rootElementY = this.rootElement.getBoundingClientRect().y;
    let rootElementScrollLeft = this.rootElement.scrollLeft;
    let rootElementScrollTop = this.rootElement.scrollTop;
    this.doScroll(event.clientY, event.clientX);
    const shortcutHeight = this.draggedElementShortcut.offsetHeight;
    const shortcutWidth = this.draggedElementShortcut.offsetWidth;
    let shortcutXOffset = this.draggedElementShortcut.shortcutXOffset || shortcutWidth / 2;
    let shortcutYOffset = this.draggedElementShortcut.shortcutYOffset || shortcutHeight / 2;
    if (document.querySelectorAll("[dir='rtl']").length !== 0) {
      shortcutXOffset = shortcutWidth / 2;
      shortcutYOffset = shortcutHeight / 2;
    }
    const documentBottom = document.documentElement.clientHeight;
    const documentRight = document.documentElement.clientWidth;
    const pageX = event.pageX;
    const pageY = event.pageY;
    const clientX = event.clientX;
    const clientY = event.clientY;
    rootElementX -= rootElementScrollLeft;
    rootElementY -= rootElementScrollTop;
    const shortcutBottomCoordinate = this.getShortcutBottomCoordinate(clientY, shortcutHeight, shortcutYOffset);
    const shortcutRightCoordinate = this.getShortcutRightCoordinate(clientX, shortcutWidth, shortcutXOffset);
    if (shortcutRightCoordinate >= documentRight) {
      this.draggedElementShortcut.style.left = // pageX -
      // clientX +
      documentRight - shortcutWidth - rootElementX + "px";
      this.draggedElementShortcut.style.top = /*pageY*/
      clientY - shortcutYOffset - rootElementY + "px";
      return;
    }
    if (clientX - shortcutXOffset <= 0) {
      this.draggedElementShortcut.style.left = pageX - clientX - rootElementX + "px";
      this.draggedElementShortcut.style.top = /*pageY*/
      clientY - rootElementY - shortcutYOffset + "px";
      return;
    }
    if (shortcutBottomCoordinate >= documentBottom) {
      this.draggedElementShortcut.style.left = /*pageX*/
      clientX - shortcutXOffset - rootElementX + "px";
      this.draggedElementShortcut.style.top = // pageY -
      // clientY +
      documentBottom - shortcutHeight - rootElementY + "px";
      return;
    }
    if (clientY - shortcutYOffset <= 0) {
      this.draggedElementShortcut.style.left = clientX - shortcutXOffset - rootElementX + "px";
      this.draggedElementShortcut.style.top = pageY - clientY - rootElementY + "px";
      return;
    }
    this.draggedElementShortcut.style.left = clientX - rootElementX - shortcutXOffset + "px";
    this.draggedElementShortcut.style.top = clientY - rootElementY - shortcutYOffset + "px";
  }
  getShortcutBottomCoordinate(currentY, shortcutHeight, shortcutYOffset) {
    return currentY + shortcutHeight - shortcutYOffset;
  }
  getShortcutRightCoordinate(currentX, shortcutWidth, shortcutXOffset) {
    return currentX + shortcutWidth - shortcutXOffset;
  }
  requestAnimationFrame(callback) {
    return requestAnimationFrame(callback);
  }
  scrollByDrag(scrollableParentNode, clientY, clientX) {
    const startScrollBoundary = 100;
    let top;
    let bottom;
    let left;
    let right;
    if (scrollableParentNode.tagName === "HTML") {
      top = 0;
      bottom = document.documentElement.clientHeight;
      left = 0;
      right = document.documentElement.clientWidth;
    } else {
      top = scrollableParentNode.getBoundingClientRect().top;
      bottom = scrollableParentNode.getBoundingClientRect().bottom;
      left = scrollableParentNode.getBoundingClientRect().left;
      right = scrollableParentNode.getBoundingClientRect().right;
    }
    const repeat = () => {
      const isTop = clientY - top <= startScrollBoundary;
      const isBottom = bottom - clientY <= startScrollBoundary;
      const isLeft = clientX - left <= startScrollBoundary;
      const isRight = right - clientX <= startScrollBoundary;
      if (isTop && !isLeft && !isRight) {
        scrollableParentNode.scrollTop -= 15;
      } else if (isBottom && !isLeft && !isRight) {
        scrollableParentNode.scrollTop += 15;
      } else if (isRight && !isTop && !isBottom) {
        scrollableParentNode.scrollLeft += 15;
      } else if (isLeft && !isTop && !isBottom) {
        scrollableParentNode.scrollLeft -= 15;
      }
      this.scrollIntervalId = this.requestAnimationFrame(repeat);
    };
    this.scrollIntervalId = this.requestAnimationFrame(repeat);
  }
  doScroll(clientY, clientX) {
    cancelAnimationFrame(this.scrollIntervalId);
    const displayProp = this.draggedElementShortcut.style.display;
    this.draggedElementShortcut.style.display = "none";
    let dragOverNode = this.documentOrShadowRoot.elementFromPoint(clientX, clientY);
    this.draggedElementShortcut.style.display = displayProp || "block";
    let scrollableParentNode = findScrollableParent(dragOverNode);
    this.scrollByDrag(scrollableParentNode, clientY, clientX);
  }
  doStartDrag(event, draggedElement, parentElement, draggedElementNode) {
    if (IsTouch) {
      _DragDropDOMAdapter.PreventScrolling = true;
    }
    if (event.which === 3) return;
    this.dd.dragInit(event, draggedElement, parentElement, draggedElementNode);
    this.rootElement.append(this.draggedElementShortcut);
    this.moveShortcutElement(event);
    document.addEventListener("pointermove", this.dragOver);
    document.addEventListener("pointercancel", this.handlePointerCancel);
    document.addEventListener("keydown", this.handleEscapeButton);
    document.addEventListener("pointerup", this.drop);
    if (!IsTouch) {
      this.draggedElementShortcut.addEventListener("pointerup", this.drop);
    } else {
      this.draggedElementShortcut.addEventListener("contextmenu", this.onContextMenu);
    }
  }
  returnUserSelectBack() {
    document.body.style.setProperty("touch-action", "auto");
    document.body.style.setProperty("user-select", "auto");
    document.body.style.setProperty("-webkit-user-select", "auto");
  }
  startDrag(event, draggedElement, parentElement, draggedElementNode, preventSaveTargetNode = false) {
    document.body.style.setProperty("user-select", "none", "important");
    document.body.style.setProperty("-webkit-user-select", "none", "important");
    if (IsTouch) {
      this.startLongTapProcessing(event, draggedElement, parentElement, draggedElementNode, preventSaveTargetNode);
      return;
    }
    this.doStartDrag(event, draggedElement, parentElement, draggedElementNode);
  }
  getNodeIndexInParent(node) {
    return [...node.parentElement.childNodes].indexOf(node);
  }
  insertNodeToParentAtIndex(parent, node, index) {
    parent.insertBefore(node, parent.childNodes[index]);
  }
};
DragDropDOMAdapter.PreventScrolling = false;
var DragDropCore = class {
  get isBottom() {
    return !!this._isBottom;
  }
  set isBottom(val) {
    this._isBottom = val;
    this.ghostPositionChanged();
  }
  ghostPositionChanged() {
    this.onGhostPositionChanged.fire({}, {});
  }
  get dropTargetDataAttributeName() {
    return `[data-sv-drop-target-${this.draggedElementType}]`;
  }
  get survey() {
    var _a;
    return this.surveyValue || ((_a = this.creator) === null || _a === void 0 ? void 0 : _a.survey);
  }
  constructor(surveyValue, creator, longTap, domAdapter) {
    var _a;
    this.surveyValue = surveyValue;
    this.creator = creator;
    this._isBottom = null;
    this.onGhostPositionChanged = new EventBase();
    this.onDragStart = new EventBase();
    this.onDragEnd = new EventBase();
    this.onDragClear = new EventBase();
    this.onBeforeDrop = this.onDragStart;
    this.onAfterDrop = this.onDragEnd;
    this.draggedElement = null;
    this.dropTarget = null;
    this.prevDropTarget = null;
    this.allowDropHere = false;
    this.banDropHere = () => {
      this.allowDropHere = false;
      this.doBanDropHere();
      this.dropTarget = null;
      this.domAdapter.draggedElementShortcut.style.cursor = "not-allowed";
      this.isBottom = null;
    };
    this.doBanDropHere = () => {
    };
    this.domAdapter = domAdapter || new DragDropDOMAdapter(this, longTap, (_a = this.survey) === null || _a === void 0 ? void 0 : _a.fitToContainer);
  }
  startDrag(event, draggedElement, parentElement, draggedElementNode, preventSaveTargetNode = false) {
    this.domAdapter.rootContainer = this.getRootElement(this.survey, this.creator);
    this.domAdapter.startDrag(event, draggedElement, parentElement, draggedElementNode, preventSaveTargetNode);
  }
  getRootElement(survey, creator) {
    return creator ? creator.rootElement : survey.rootElement;
  }
  dragInit(event, draggedElement, parentElement, draggedElementNode) {
    this.draggedElement = draggedElement;
    this.parentElement = parentElement;
    const shortcutText = this.getShortcutText(this.draggedElement);
    this.domAdapter.draggedElementShortcut = this.createDraggedElementShortcut(shortcutText, draggedElementNode, event);
    this.onStartDrag(event);
    const fromElement = this.draggedElement && this.draggedElement.parent;
    this.onDragStart.fire(this, {
      fromElement,
      draggedElement: this.draggedElement
    });
  }
  onStartDrag(event) {
  }
  isDropTargetDoesntChanged(newIsBottom) {
    return this.dropTarget === this.prevDropTarget && newIsBottom === this.isBottom;
  }
  getShortcutText(draggedElement) {
    return draggedElement === null || draggedElement === void 0 ? void 0 : draggedElement.shortcutText;
  }
  createDraggedElementShortcut(text, draggedElementNode, event) {
    const draggedElementShortcut = DomDocumentHelper.createElement("div");
    if (!!draggedElementShortcut) {
      draggedElementShortcut.innerText = text;
      draggedElementShortcut.className = this.getDraggedElementClass();
    }
    return draggedElementShortcut;
  }
  getDraggedElementClass() {
    return "sv-dragged-element-shortcut";
  }
  doDragOver() {
  }
  afterDragOver(dropTargetNode) {
  }
  findDropTargetNodeFromPoint(clientX, clientY) {
    const displayProp = this.domAdapter.draggedElementShortcut.style.display;
    this.domAdapter.draggedElementShortcut.style.display = "none";
    if (!DomDocumentHelper.isAvailable()) return null;
    let dragOverNodes = this.domAdapter.documentOrShadowRoot.elementsFromPoint(clientX, clientY);
    this.domAdapter.draggedElementShortcut.style.display = displayProp || "block";
    let index = 0;
    let dragOverNode = dragOverNodes[index];
    while (dragOverNode && dragOverNode.className && typeof dragOverNode.className.indexOf == "function" && dragOverNode.className.indexOf("sv-drag-target-skipped") != -1) {
      index++;
      dragOverNode = dragOverNodes[index];
    }
    if (!dragOverNode) return null;
    return this.findDropTargetNodeByDragOverNode(dragOverNode);
  }
  getDataAttributeValueByNode(node) {
    let datasetName = "svDropTarget";
    const words = this.draggedElementType.split("-");
    words.forEach((word) => {
      datasetName += this.capitalizeFirstLetter(word);
    });
    return node.dataset[datasetName];
  }
  getDropTargetByNode(dropTargetNode, event) {
    let dataAttributeValue = this.getDataAttributeValueByNode(dropTargetNode);
    return this.getDropTargetByDataAttributeValue(dataAttributeValue, dropTargetNode, event);
  }
  capitalizeFirstLetter(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
  }
  calculateVerticalMiddleOfHTMLElement(HTMLElement) {
    const rect = HTMLElement.getBoundingClientRect();
    return rect.y + rect.height / 2;
  }
  calculateHorizontalMiddleOfHTMLElement(HTMLElement) {
    const rect = HTMLElement.getBoundingClientRect();
    return rect.x + rect.width / 2;
  }
  calculateIsBottom(clientY, dropTargetNode) {
    return false;
  }
  findDropTargetNodeByDragOverNode(dragOverNode) {
    const dropTargetNode = dragOverNode.closest(this.dropTargetDataAttributeName);
    return dropTargetNode;
  }
  dragOver(event) {
    const dropTargetNode = this.findDropTargetNodeFromPoint(event.clientX, event.clientY);
    if (!dropTargetNode) {
      this.banDropHere();
      return;
    }
    this.dropTarget = this.getDropTargetByNode(dropTargetNode, event);
    const isDropTargetValid = this.isDropTargetValid(this.dropTarget, dropTargetNode);
    this.doDragOver();
    if (!isDropTargetValid) {
      this.banDropHere();
      return;
    }
    let isBottom = this.calculateIsBottom(event.clientY, dropTargetNode);
    this.allowDropHere = true;
    if (this.isDropTargetDoesntChanged(isBottom)) return;
    this.isBottom = null;
    this.isBottom = isBottom;
    if (this.draggedElement != this.dropTarget) {
      this.afterDragOver(dropTargetNode);
    }
    this.prevDropTarget = this.dropTarget;
  }
  drop() {
    if (this.allowDropHere) {
      const fromElement = this.draggedElement.parent;
      const newElement = this.doDrop();
      this.onDragEnd.fire(this, {
        fromElement,
        draggedElement: newElement,
        toElement: this.dropTarget
      });
    }
  }
  clear() {
    const options = {
      draggedElement: this.draggedElement
    };
    this.dropTarget = null;
    this.prevDropTarget = null;
    this.draggedElement = null;
    this.isBottom = null;
    this.parentElement = null;
    this.onDragClear.fire(this, options);
  }
};
var DragDropMatrixRows = class extends DragDropCore {
  constructor() {
    super(...arguments);
    this.fromIndex = null;
    this.toIndex = null;
    this.doDrop = () => {
      this.parentElement.moveRowByIndex(this.fromIndex, this.toIndex);
      return this.parentElement;
    };
  }
  get draggedElementType() {
    return "matrix-row";
  }
  onStartDrag() {
    const _body = DomDocumentHelper.getBody();
    if (!!_body) {
      this.restoreUserSelectValue = _body.style.userSelect;
      _body.style.userSelect = "none";
    }
  }
  get shortcutClass() {
    return new CssClassBuilder().append(this.parentElement.cssClasses.draggedRow).toString();
  }
  createDraggedElementShortcut(text, draggedElementNode, event) {
    const draggedElementShortcut = DomDocumentHelper.createElement("div");
    if (!draggedElementShortcut) return;
    draggedElementShortcut.className = this.shortcutClass;
    const isDeepClone = true;
    if (!!draggedElementNode) {
      const row = draggedElementNode.closest("[data-sv-drop-target-matrix-row]");
      const clone = row.cloneNode(isDeepClone);
      clone.style.cssText = `
        width: ${row.offsetWidth}px;
      `;
      clone.classList.remove("sv-matrix__drag-drop--moveup");
      clone.classList.remove("sv-matrix__drag-drop--movedown");
      this.draggedElement.isDragDropMoveDown = false;
      this.draggedElement.isDragDropMoveUp = false;
      draggedElementShortcut.appendChild(clone);
      const rect = draggedElementNode.getBoundingClientRect();
      draggedElementShortcut.shortcutXOffset = event.clientX - rect.x;
      draggedElementShortcut.shortcutYOffset = event.clientY - rect.y;
    }
    const renderedRows = this.parentElement.renderedTable.rows;
    renderedRows.forEach((renderedRow, index) => {
      if (renderedRow.row === this.draggedElement) {
        renderedRow.isGhostRow = true;
      }
    });
    this.fromIndex = this.parentElement.visibleRows.indexOf(this.draggedElement);
    return draggedElementShortcut;
  }
  // protected ghostPositionChanged(): void {
  //   let ghostPosition;
  //   this.parentElement.renderedTable.rows.forEach(
  //     (renderedRow: QuestionMatrixDropdownRenderedRow) => {
  //       ghostPosition = this.getGhostPosition(
  //         renderedRow.row
  //       );
  //       renderedRow.isGhostRow = !ghostPosition;
  //     }
  //   );
  //   super.ghostPositionChanged();
  // }
  getDropTargetByDataAttributeValue(dataAttributeValue) {
    const matrix = this.parentElement;
    let dropTargetRenderedRow;
    dropTargetRenderedRow = matrix.renderedTable.rows.filter((renderedRow) => renderedRow.row && renderedRow.row.id === dataAttributeValue)[0];
    return dropTargetRenderedRow.row;
  }
  canInsertIntoThisRow(row) {
    const lockedRows = this.parentElement.lockedRowCount;
    return lockedRows <= 0 || row.rowIndex > lockedRows;
  }
  isDropTargetValid(dropTarget, dropTargetNode) {
    return this.canInsertIntoThisRow(dropTarget);
  }
  calculateIsBottom(clientY) {
    const rendreredRows = this.parentElement.renderedTable.rows;
    const rows = rendreredRows.map((rendredRow) => rendredRow.row);
    return rows.indexOf(this.dropTarget) - rows.indexOf(this.draggedElement) > 0;
  }
  afterDragOver(dropTargetNode) {
    if (this.isDropTargetDoesntChanged(this.isBottom)) return;
    let dropTargetIndex;
    let draggedElementIndex;
    let draggedRenderedRow;
    const renderedRows = this.parentElement.renderedTable.rows;
    renderedRows.forEach((renderedRow, index) => {
      if (renderedRow.row === this.dropTarget) {
        dropTargetIndex = index;
      }
      if (renderedRow.row === this.draggedElement) {
        draggedRenderedRow = renderedRow;
        draggedElementIndex = index;
        draggedRenderedRow.isGhostRow = true;
      }
    });
    renderedRows.splice(draggedElementIndex, 1);
    renderedRows.splice(dropTargetIndex, 0, draggedRenderedRow);
    this.toIndex = this.parentElement.visibleRows.indexOf(this.dropTarget);
    super.ghostPositionChanged();
  }
  clear() {
    const renderedRows = this.parentElement.renderedTable.rows;
    renderedRows.forEach((renderedRow) => {
      renderedRow.isGhostRow = false;
    });
    this.parentElement.clearOnDrop();
    this.fromIndex = null;
    this.toIndex = null;
    const _body = DomDocumentHelper.getBody();
    if (!!_body) {
      _body.style.userSelect = this.restoreUserSelectValue || "initial";
    }
    super.clear();
  }
};
var DragOrClickHelper = class {
  constructor(dragHandler) {
    this.dragHandler = dragHandler;
    this.onPointerUp = (pointerUpEvent) => {
      this.clearListeners();
    };
    this.tryToStartDrag = (pointerMoveEvent) => {
      this.currentX = pointerMoveEvent.pageX;
      this.currentY = pointerMoveEvent.pageY;
      if (this.isMicroMovement) return;
      this.clearListeners();
      this.dragHandler(this.pointerDownEvent, this.currentTarget, this.itemModel);
      return true;
    };
  }
  onPointerDown(pointerDownEvent, itemModel) {
    if (IsTouch) {
      this.dragHandler(pointerDownEvent, pointerDownEvent.currentTarget, itemModel);
      return;
    }
    this.pointerDownEvent = pointerDownEvent;
    this.currentTarget = pointerDownEvent.currentTarget;
    this.startX = pointerDownEvent.pageX;
    this.startY = pointerDownEvent.pageY;
    DomDocumentHelper.addEventListener("pointermove", this.tryToStartDrag);
    this.currentTarget.addEventListener("pointerup", this.onPointerUp);
    this.itemModel = itemModel;
  }
  // see https://stackoverflow.com/questions/6042202/how-to-distinguish-mouse-click-and-drag
  get isMicroMovement() {
    const delta = 10;
    const diffX = Math.abs(this.currentX - this.startX);
    const diffY = Math.abs(this.currentY - this.startY);
    return diffX < delta && diffY < delta;
  }
  clearListeners() {
    if (!this.pointerDownEvent) return;
    DomDocumentHelper.removeEventListener("pointermove", this.tryToStartDrag);
    this.currentTarget.removeEventListener("pointerup", this.onPointerUp);
  }
};
var MatrixDynamicRowModel = class extends MatrixDropdownRowModelBase {
  constructor(index, data, value) {
    super(data, value);
    this.index = index;
    this.buildCells(value);
  }
  getRowIndex() {
    const res = super.getRowIndex();
    return res > 0 ? res : this.index + 1;
  }
  get rowName() {
    return this.id;
  }
  get dataName() {
    return "row" + (this.index + 1);
  }
  get text() {
    return "row " + (this.index + 1);
  }
  getAccessbilityText() {
    return (this.index + 1).toString();
  }
  get shortcutText() {
    const matrix = this.data;
    const index = matrix.visibleRows.indexOf(this) + 1;
    const questionValue1 = this.cells.length > 1 ? this.cells[1]["questionValue"] : void 0;
    const questionValue0 = this.cells.length > 0 ? this.cells[0]["questionValue"] : void 0;
    return questionValue1 && questionValue1.value || questionValue0 && questionValue0.value || "" + index;
  }
};
var QuestionMatrixDynamicModel = class extends QuestionMatrixDropdownModelBase {
  constructor(name) {
    super(name);
    this.rowCounter = 0;
    this.setRowCountValueFromData = false;
    this.startDragMatrixRow = (event, currentTarget) => {
      this.dragDropMatrixRows.startDrag(event, this.draggedRow, this, event.target);
    };
    this.initialRowCount = this.getDefaultPropertyValue("rowCount");
    this.createLocalizableString("confirmDeleteText", this, false, "confirmDelete");
    var locAddRowText = this.createLocalizableString("addRowText", this);
    locAddRowText.onGetTextCallback = (text) => {
      return !!text ? text : this.defaultAddRowText;
    };
    this.createLocalizableString("removeRowText", this, false, "removeRow");
    this.createLocalizableString("noRowsText", this, false, true);
    this.registerPropertyChangedHandlers(["hideColumnsIfEmpty", "allowAddRows"], () => {
      this.updateShowTableAndAddRow();
    });
    this.registerPropertyChangedHandlers(["allowRowReorder", "isReadOnly", "lockedRowCount"], () => {
      this.resetRenderedTable();
    });
    this.registerPropertyChangedHandlers(["minRowCount"], () => {
      this.onMinRowCountChanged();
    });
    this.registerPropertyChangedHandlers(["maxRowCount"], () => {
      this.onMaxRowCountChanged();
    });
    this.dragOrClickHelper = new DragOrClickHelper(this.startDragMatrixRow);
  }
  setSurveyImpl(value, isLight) {
    super.setSurveyImpl(value, isLight);
    this.dragDropMatrixRows = new DragDropMatrixRows(this.survey, null, true);
  }
  isBanStartDrag(pointerDownEvent) {
    const target = pointerDownEvent.target;
    return target.getAttribute("contenteditable") === "true" || target.nodeName === "INPUT" || !this.isDragHandleAreaValid(target);
  }
  isDragHandleAreaValid(node) {
    if (this.survey.matrixDragHandleArea === "icon") {
      return node.classList.contains(this.cssClasses.dragElementDecorator);
    }
    return true;
  }
  onPointerDown(pointerDownEvent, row) {
    if (!row || !this.isRowsDragAndDrop || this.isDesignMode) return;
    if (this.isBanStartDrag(pointerDownEvent)) return;
    if (row.isDetailPanelShowing) return;
    this.draggedRow = row;
    this.dragOrClickHelper.onPointerDown(pointerDownEvent);
  }
  getType() {
    return "matrixdynamic";
  }
  get isRowsDynamic() {
    return true;
  }
  /**
   * Specifies whether to display a confirmation dialog when a respondent wants to delete a row.
   *
   * Default value: `false`
   * @see confirmDeleteText
   */
  get confirmDelete() {
    return this.getPropertyValue("confirmDelete");
  }
  set confirmDelete(val) {
    this.setPropertyValue("confirmDelete", val);
  }
  get isValueArray() {
    return true;
  }
  /**
   * Specifies a key column. Set this property to a column name, and the question will display `keyDuplicationError` if a user tries to enter a duplicate value in this column.
   * @see keyDuplicationError
   */
  get keyName() {
    return this.getPropertyValue("keyName", "");
  }
  set keyName(val) {
    this.setPropertyValue("keyName", val);
  }
  /**
   * If it is not empty, then this value is set to every new row, including rows created initially, unless the defaultValue is not empty
   * @see defaultValue
   * @see copyDefaultValueFromLastEntry
   */
  get defaultRowValue() {
    return this.getPropertyValue("defaultRowValue");
  }
  set defaultRowValue(val) {
    this.setPropertyValue("defaultRowValue", val);
  }
  /**
   * Specifies whether default values for a new row/column should be copied from the last row/column.
   *
   * If you also specify `defaultValue`, it will be merged with the copied values.
   * @see defaultValue
   */
  get copyDefaultValueFromLastEntry() {
    return this.getPropertyValue("copyDefaultValueFromLastEntry");
  }
  set copyDefaultValueFromLastEntry(val) {
    this.setPropertyValue("copyDefaultValueFromLastEntry", val);
  }
  /**
   * @deprecated Use the [`copyDefaultValueFromLastEntry`](https://surveyjs.io/form-library/documentation/api-reference/dynamic-matrix-table-question-model#copyDefaultValueFromLastEntry) property instead.
   */
  get defaultValueFromLastRow() {
    return this.copyDefaultValueFromLastEntry;
  }
  set defaultValueFromLastRow(val) {
    this.copyDefaultValueFromLastEntry = val;
  }
  isDefaultValueEmpty() {
    return super.isDefaultValueEmpty() && this.isValueEmpty(this.defaultRowValue);
  }
  valueFromData(val) {
    if (this.minRowCount < 1 || this.isEmpty()) return super.valueFromData(val);
    if (!Array.isArray(val)) val = [];
    for (var i = val.length; i < this.minRowCount; i++) val.push({});
    return val;
  }
  isNewValueCorrect(val) {
    return Array.isArray(val);
  }
  setDefaultValue() {
    if (this.isValueEmpty(this.defaultRowValue) || !this.isValueEmpty(this.defaultValue)) {
      super.setDefaultValue();
      return;
    }
    if (!this.isEmpty() || this.rowCount == 0) return;
    var newValue = [];
    for (var i = 0; i < this.rowCount; i++) {
      newValue.push(this.defaultRowValue);
    }
    this.value = newValue;
  }
  moveRowByIndex(fromIndex, toIndex) {
    const value = this.createNewValue();
    if (!Array.isArray(value) && Math.max(fromIndex, toIndex) >= value.length) return;
    const movableRow = value[fromIndex];
    value.splice(fromIndex, 1);
    value.splice(toIndex, 0, movableRow);
    this.value = value;
  }
  clearOnDrop() {
    if (!this.isEditingSurveyElement) {
      this.resetRenderedTable();
    }
  }
  initDataUI() {
    if (!this.generatedVisibleRows) {
      this.getVisibleRows();
    }
  }
  /**
   * The number of rows in the matrix.
   * @see minRowCount
   * @see maxRowCount
   */
  get rowCount() {
    return this.rowCountValue;
  }
  set rowCount(val) {
    val = Helpers.getNumber(val);
    if (val < 0 || val > settings.matrix.maxRowCount) return;
    this.setRowCountValueFromData = false;
    var prevValue = this.rowCountValue;
    this.rowCountValue = val;
    if (this.value && this.value.length > val) {
      var qVal = this.value;
      qVal.splice(val);
      this.value = qVal;
    }
    if (this.isUpdateLocked) {
      this.initialRowCount = val;
      return;
    }
    if (this.generatedVisibleRows || prevValue == 0) {
      if (!this.generatedVisibleRows) {
        this.clearGeneratedRows();
        this.generatedVisibleRows = [];
      }
      this.generatedVisibleRows.splice(val);
      for (var i = prevValue; i < val; i++) {
        var newRow = this.createMatrixRow(this.getValueForNewRow());
        this.generatedVisibleRows.push(newRow);
        this.onMatrixRowCreated(newRow);
      }
      this.runCondition(this.getDataFilteredValues(), this.getDataFilteredProperties());
    }
    this.onRowsChanged();
  }
  updateBindingProp(propName, value) {
    super.updateBindingProp(propName, value);
    const rows = this.generatedVisibleRows;
    if (propName !== "rowCount" || !Array.isArray(rows)) return;
    const val = this.getUnbindValue(this.value) || [];
    if (val.length < rows.length) {
      let hasValue = false;
      for (let i = val.length; i < rows.length; i++) {
        hasValue || (hasValue = !rows[i].isEmpty);
        val.push(rows[i].value || {});
      }
      if (hasValue) {
        this.value = val;
      }
    }
  }
  updateProgressInfoByValues(res) {
    let val = this.value;
    if (!Array.isArray(val)) val = [];
    for (var i = 0; i < this.rowCount; i++) {
      const rowValue = i < val.length ? val[i] : {};
      this.updateProgressInfoByRow(res, rowValue);
    }
  }
  getValueForNewRow() {
    var res = null;
    if (!!this.onGetValueForNewRowCallBack) {
      res = this.onGetValueForNewRowCallBack(this);
    }
    return res;
  }
  /**
   * Specifies whether users can drag and drop matrix rows to reorder them. Applies only if [`transposeData`](#transposeData) is `false`.
   *
   * Default value: `false`
   */
  get allowRowReorder() {
    return this.getPropertyValue("allowRowReorder");
  }
  set allowRowReorder(val) {
    this.setPropertyValue("allowRowReorder", val);
  }
  /**
   * @deprecated Use the [`allowRowReorder`](https://surveyjs.io/form-library/documentation/api-reference/dynamic-matrix-table-question-model#allowRowReorder) property instead.
   */
  get allowRowsDragAndDrop() {
    return this.allowRowReorder;
  }
  set allowRowsDragAndDrop(val) {
    this.allowRowReorder = val;
  }
  get isRowsDragAndDrop() {
    return this.allowRowReorder && !this.isReadOnly;
  }
  get lockedRowCount() {
    return this.getPropertyValue("lockedRowCount", 0);
  }
  set lockedRowCount(val) {
    this.setPropertyValue("lockedRowCount", val);
  }
  get iconDragElement() {
    return this.cssClasses.iconDragElement;
  }
  createRenderedTable() {
    return new QuestionMatrixDynamicRenderedTable(this);
  }
  get rowCountValue() {
    return this.getPropertyValue("rowCount");
  }
  set rowCountValue(val) {
    this.setPropertyValue("rowCount", val);
  }
  /**
   * A minimum number of rows in the matrix. Users cannot delete rows if `rowCount` equals `minRowCount`.
   *
   * Default value: 0
   * @see rowCount
   * @see maxRowCount
   * @see allowRemoveRows
   */
  get minRowCount() {
    return this.getPropertyValue("minRowCount");
  }
  set minRowCount(val) {
    if (val < 0) val = 0;
    this.setPropertyValue("minRowCount", val);
  }
  onMinRowCountChanged() {
    const val = this.minRowCount;
    if (val > this.maxRowCount) this.maxRowCount = val;
    if (this.initialRowCount < val) this.initialRowCount = val;
    if (this.rowCount < val) this.rowCount = val;
  }
  /**
   * A maximum number of rows in the matrix. Users cannot add new rows if `rowCount` equals `maxRowCount`.
   *
   * Default value: 1000 (inherited from [`settings.matrix.maxRowCount`](https://surveyjs.io/form-library/documentation/settings#matrixMaximumRowCount))
   * @see rowCount
   * @see minRowCount
   * @see allowAddRows
   */
  get maxRowCount() {
    return this.getPropertyValue("maxRowCount");
  }
  set maxRowCount(val) {
    if (val <= 0) return;
    if (val > settings.matrix.maxRowCount) val = settings.matrix.maxRowCount;
    if (val == this.maxRowCount) return;
    this.setPropertyValue("maxRowCount", val);
  }
  onMaxRowCountChanged() {
    const val = this.maxRowCount;
    if (val < this.minRowCount) this.minRowCount = val;
    if (this.rowCount > val) this.rowCount = val;
  }
  /**
   * Specifies whether users are allowed to add new rows.
   *
   * Default value: `true`
   * @see canAddRow
   * @see allowRemoveRows
   */
  get allowAddRows() {
    return this.getPropertyValue("allowAddRows");
  }
  set allowAddRows(val) {
    this.setPropertyValue("allowAddRows", val);
  }
  /**
   * Specifies whether users are allowed to delete rows.
   *
   * Default value: `true`
   * @see canRemoveRows
   * @see allowAddRows
   */
  get allowRemoveRows() {
    return this.getPropertyValue("allowRemoveRows");
  }
  set allowRemoveRows(val) {
    this.setPropertyValue("allowRemoveRows", val);
    if (!this.isUpdateLocked) {
      this.resetRenderedTable();
    }
  }
  /**
   * Indicates whether it is possible to add a new row.
   *
   * This property returns `true` when all of the following conditions apply:
   *
   * - Users are allowed to add new rows (`allowAddRows` is `true`).
   * - The question, its parent panel, or survey is not in read-only state.
   * - `rowCount` is less than `maxRowCount`.
   * @see allowAddRows
   * @see isReadOnly
   * @see rowCount
   * @see maxRowCount
   * @see canRemoveRows
   */
  get canAddRow() {
    return this.allowAddRows && !this.isReadOnly && this.rowCount < this.maxRowCount;
  }
  /**
   * Indicates whether it is possible to delete rows.
   *
   * This property returns `true` when all of the following conditions apply:
   *
   * - Users are allowed to delete rows (`allowRemoveRows` is `true`).
   * - The question, its parent panel, or survey is not in read-only state.
   * - `rowCount` exceeds `minRowCount`.
   * @see allowRemoveRows
   * @see isReadOnly
   * @see rowCount
   * @see minRowCount
   * @see canAddRow
   */
  get canRemoveRows() {
    var res = this.allowRemoveRows && !this.isReadOnly && this.rowCount > this.minRowCount;
    return !!this.canRemoveRowsCallback ? this.canRemoveRowsCallback(res) : res;
  }
  canRemoveRow(row) {
    if (!this.survey) return true;
    const index = row.rowIndex - 1;
    if (this.lockedRowCount > 0 && index < this.lockedRowCount) return false;
    return this.survey.matrixAllowRemoveRow(this, index, row);
  }
  addRowUI() {
    this.addRow(true);
  }
  getQuestionToFocusOnAddingRow() {
    if (this.visibleRows.length === 0) return null;
    var row = this.visibleRows[this.visibleRows.length - 1];
    for (var i = 0; i < row.cells.length; i++) {
      var q = row.cells[i].question;
      if (!!q && q.isVisible && !q.isReadOnly) {
        return q;
      }
    }
    return null;
  }
  /**
   * Creates and adds a new row to the matrix.
   * @param setFocus *(Optional)* Pass `true` to focus the cell in the first column.
   */
  addRow(setFocus) {
    const oldRowCount = this.rowCount;
    const allow = this.canAddRow;
    var options = {
      question: this,
      canAddRow: allow,
      allow
    };
    if (!!this.survey) {
      this.survey.matrixBeforeRowAdded(options);
    }
    const newAllow = allow !== options.allow ? options.allow : allow !== options.canAddRow ? options.canAddRow : allow;
    if (!newAllow) return;
    this.onStartRowAddingRemoving();
    this.addRowCore();
    this.onEndRowAdding();
    if (this.detailPanelShowOnAdding && this.visibleRows.length > 0) {
      this.visibleRows[this.visibleRows.length - 1].showDetailPanel();
    }
    if (setFocus && oldRowCount !== this.rowCount) {
      const q = this.getQuestionToFocusOnAddingRow();
      if (!!q) {
        q.focus();
      }
    }
  }
  /**
   * Specifies whether to expand the detail section immediately when a respondent adds a new row.
   * @see detailPanelMode
   */
  get detailPanelShowOnAdding() {
    return this.getPropertyValue("detailPanelShowOnAdding");
  }
  set detailPanelShowOnAdding(val) {
    this.setPropertyValue("detailPanelShowOnAdding", val);
  }
  hasRowsAsItems() {
    return false;
  }
  unbindValue() {
    this.clearGeneratedRows();
    this.clearPropertyValue("value");
    this.rowCountValue = 0;
    super.unbindValue();
  }
  isValueSurveyElement(val) {
    return this.isEditingSurveyElement || super.isValueSurveyElement(val);
  }
  addRowCore() {
    var prevRowCount = this.rowCount;
    this.rowCount = this.rowCount + 1;
    var defaultValue = this.getDefaultRowValue(true);
    var newValue = null;
    if (!this.isValueEmpty(defaultValue)) {
      newValue = this.createNewValue();
      if (newValue.length == this.rowCount) {
        newValue[newValue.length - 1] = defaultValue;
        this.value = newValue;
      }
    }
    if (this.data) {
      this.runCellsCondition(this.getDataFilteredValues(), this.getDataFilteredProperties());
      const rows = this.visibleRows;
      if (this.isValueEmpty(defaultValue) && rows.length > 0) {
        const row = rows[rows.length - 1];
        if (!this.isValueEmpty(row.value)) {
          if (!newValue) {
            newValue = this.createNewValue();
          }
          if (!this.isValueSurveyElement(newValue) && !this.isTwoValueEquals(newValue[newValue.length - 1], row.value)) {
            newValue[newValue.length - 1] = row.value;
            this.value = newValue;
          }
        }
      }
    }
    if (this.survey) {
      const rows = this.visibleRows;
      if (prevRowCount + 1 == this.rowCount && rows.length > 0) {
        const row = rows[rows.length - 1];
        this.survey.matrixRowAdded(this, row);
        this.onRowsChanged();
      }
    }
  }
  getDefaultRowValue(isRowAdded) {
    var res = null;
    for (var i = 0; i < this.columns.length; i++) {
      var q = this.columns[i].templateQuestion;
      if (!!q && !this.isValueEmpty(q.getDefaultValue())) {
        res = res || {};
        res[this.columns[i].name] = q.getDefaultValue();
      }
    }
    if (!this.isValueEmpty(this.defaultRowValue)) {
      for (var key in this.defaultRowValue) {
        res = res || {};
        res[key] = this.defaultRowValue[key];
      }
    }
    if (isRowAdded && this.copyDefaultValueFromLastEntry) {
      var val = this.value;
      if (!!val && Array.isArray(val) && val.length >= this.rowCount - 1) {
        var rowValue = val[this.rowCount - 2];
        for (var key in rowValue) {
          res = res || {};
          res[key] = rowValue[key];
        }
      }
    }
    return res;
  }
  focusAddBUtton() {
    const rootElement = this.getRootElement();
    if (!!rootElement && !!this.cssClasses.buttonAdd) {
      const addButton = rootElement.querySelectorAll("." + this.cssClasses.buttonAdd)[0];
      addButton && addButton.focus();
    }
  }
  getActionCellIndex(row) {
    const headerShift = this.showHeader ? 1 : 0;
    if (this.isColumnLayoutHorizontal) {
      return row.cells.length - 1 + headerShift;
    }
    return this.visibleRows.indexOf(row) + headerShift;
  }
  removeRowUI(value) {
    if (!!value && !!value.rowName) {
      var index = this.visibleRows.indexOf(value);
      if (index < 0) return;
      value = index;
    }
    this.removeRow(value, void 0, () => {
      const rowCount = this.visibleRows.length;
      const nextIndex = index >= rowCount ? rowCount - 1 : index;
      const nextRow = nextIndex > -1 ? this.visibleRows[nextIndex] : void 0;
      setTimeout(() => {
        if (nextRow) {
          this.renderedTable.focusActionCell(nextRow, this.getActionCellIndex(nextRow));
        } else {
          this.focusAddBUtton();
        }
      }, 10);
    });
  }
  isRequireConfirmOnRowDelete(index) {
    if (!this.confirmDelete) return false;
    if (index < 0 || index >= this.rowCount) return false;
    var value = this.createNewValue();
    if (this.isValueEmpty(value) || !Array.isArray(value)) return false;
    if (index >= value.length) return false;
    return !this.isValueEmpty(value[index]);
  }
  /**
   * Removes a matrix row with a specified index.
   * @param index A zero-based row index.
   * @param confirmDelete *(Optional)* A Boolean value that specifies whether to display a confirmation dialog. If you do not specify this parameter, the [`confirmDelete`](https://surveyjs.io/form-library/documentation/api-reference/dynamic-matrix-table-question-model#confirmDelete) property value is used.
   */
  removeRow(index, confirmDelete, onRowRemoved) {
    if (!this.canRemoveRows) return;
    if (index < 0 || index >= this.rowCount) return;
    var row = !!this.visibleRows && index < this.visibleRows.length ? this.visibleRows[index] : null;
    if (confirmDelete === void 0) {
      confirmDelete = this.isRequireConfirmOnRowDelete(index);
    }
    if (confirmDelete) {
      confirmActionAsync({
        message: this.confirmDeleteText,
        funcOnYes: () => {
          this.removeRowAsync(index, row);
          onRowRemoved && onRowRemoved();
        },
        locale: this.getLocale(),
        rootElement: this.survey.rootElement,
        cssClass: this.cssClasses.confirmDialog
      });
      return;
    }
    this.removeRowAsync(index, row);
    onRowRemoved && onRowRemoved();
  }
  removeRowAsync(index, row) {
    if (!!row && !!this.survey && !this.survey.matrixRowRemoving(this, index, row)) return;
    this.onStartRowAddingRemoving();
    this.removeRowCore(index);
    this.onEndRowRemoving(row);
  }
  removeRowCore(index) {
    var row = this.generatedVisibleRows ? this.generatedVisibleRows[index] : null;
    if (this.generatedVisibleRows && index < this.generatedVisibleRows.length) {
      this.generatedVisibleRows.splice(index, 1);
    }
    this.rowCountValue--;
    if (this.value) {
      var val = [];
      if (Array.isArray(this.value) && index < this.value.length) {
        val = this.createValueCopy();
      } else {
        val = this.createNewValue();
      }
      val.splice(index, 1);
      val = this.deleteRowValue(val, null);
      this.isRowChanging = true;
      this.value = val;
      this.isRowChanging = false;
    }
    this.onRowsChanged();
    if (this.survey) {
      this.survey.matrixRowRemoved(this, index, row);
    }
  }
  /**
   * A message displayed in a confirmation dialog that appears when a respondent wants to delete a row.
   * @see confirmDelete
   */
  get confirmDeleteText() {
    return this.getLocalizableStringText("confirmDeleteText");
  }
  set confirmDeleteText(val) {
    this.setLocalizableStringText("confirmDeleteText", val);
  }
  get locConfirmDeleteText() {
    return this.getLocalizableString("confirmDeleteText");
  }
  /**
   * A caption for the Add Row button.
   * @see addRowButtonLocation
   */
  get addRowText() {
    return this.getLocalizableStringText("addRowText", this.defaultAddRowText);
  }
  set addRowText(val) {
    this.setLocalizableStringText("addRowText", val);
  }
  get locAddRowText() {
    return this.getLocalizableString("addRowText");
  }
  get defaultAddRowText() {
    return this.getLocalizationString(this.isColumnLayoutHorizontal ? "addRow" : "addColumn");
  }
  /**
   * Specifies the location of the Add Row button.
   *
   * Possible values:
   *
   * - `"top"` - Displays the Add Row button at the top of the matrix.
   * - `"bottom"` - Displays the Add Row button at the bottom of the matrix.
   * - `"topBottom"` - Displays the Add Row button at the top and bottom of the matrix.
   *
   * Default value: `"top"` if [`transposeData`](#transposeData) is `true`; `"bottom"` if `transposeData` is `false` or the matrix is in compact mode.
   * @see addRowText
   */
  get addRowButtonLocation() {
    return this.getPropertyValue("addRowButtonLocation");
  }
  set addRowButtonLocation(val) {
    this.setPropertyValue("addRowButtonLocation", val);
  }
  /**
   * @deprecated Use the [`addRowButtonLocation`](https://surveyjs.io/form-library/documentation/api-reference/dynamic-matrix-table-question-model#addRowButtonLocation) property instead.
   */
  get addRowLocation() {
    return this.addRowButtonLocation;
  }
  set addRowLocation(val) {
    this.addRowButtonLocation = val;
  }
  getAddRowLocation() {
    return this.addRowButtonLocation;
  }
  /**
   * Specifies whether to hide columns when the matrix does not contain any rows. If you enable this property, the matrix displays the `noRowsText` message and the Add Row button.
   *
   * Default value: `false`
   * @see noRowsText
   */
  get hideColumnsIfEmpty() {
    return this.getPropertyValue("hideColumnsIfEmpty");
  }
  set hideColumnsIfEmpty(val) {
    this.setPropertyValue("hideColumnsIfEmpty", val);
  }
  getShowColumnsIfEmpty() {
    return this.hideColumnsIfEmpty;
  }
  /**
   * Use this property to change the default value of remove row button text.
   */
  get removeRowText() {
    return this.getLocalizableStringText("removeRowText");
  }
  set removeRowText(val) {
    this.setLocalizableStringText("removeRowText", val);
  }
  get locRemoveRowText() {
    return this.getLocalizableString("removeRowText");
  }
  /**
   * A message displayed when the matrix does not contain any rows. Applies only if `hideColumnsIfEmpty` is enabled.
   * @see hideColumnsIfEmpty
   */
  get noRowsText() {
    return this.getLocalizableStringText("noRowsText");
  }
  set noRowsText(val) {
    this.setLocalizableStringText("noRowsText", val);
  }
  get locNoRowsText() {
    return this.getLocalizableString("noRowsText");
  }
  /**
   * @deprecated Use the [`noRowsText`](https://surveyjs.io/form-library/documentation/api-reference/dynamic-matrix-table-question-model#noRowsText) property instead.
   */
  get emptyRowsText() {
    return this.noRowsText;
  }
  set emptyRowsText(val) {
    this.noRowsText = val;
  }
  get locEmptyRowsText() {
    return this.locNoRowsText;
  }
  getDisplayValueCore(keysAsText, value) {
    if (!value || !Array.isArray(value)) return value;
    var values = this.getUnbindValue(value);
    var rows = this.visibleRows;
    for (var i = 0; i < rows.length && i < values.length; i++) {
      var val = values[i];
      if (!val) continue;
      values[i] = this.getRowDisplayValue(keysAsText, rows[i], val);
    }
    return values;
  }
  getConditionObjectRowName(index) {
    return "[" + index.toString() + "]";
  }
  getConditionObjectsRowIndeces() {
    const res = [];
    const rowCount = Math.max(this.rowCount, 1);
    for (var i = 0; i < Math.min(settings.matrix.maxRowCountInCondition, rowCount); i++) {
      res.push(i);
    }
    return res;
  }
  supportAutoAdvance() {
    return false;
  }
  get hasRowText() {
    return false;
  }
  onCheckForErrors(errors, isOnValueChanged, fireCallback) {
    super.onCheckForErrors(errors, isOnValueChanged, fireCallback);
    if (!isOnValueChanged && this.hasErrorInMinRows()) {
      errors.push(new MinRowCountError(this.minRowCount, this));
    }
  }
  hasErrorInMinRows() {
    if (this.minRowCount <= 0 || !this.isRequired || !this.generatedVisibleRows) return false;
    var setRowCount = 0;
    for (var rowIndex = 0; rowIndex < this.generatedVisibleRows.length; rowIndex++) {
      var row = this.generatedVisibleRows[rowIndex];
      if (!row.isEmpty) setRowCount++;
    }
    return setRowCount < this.minRowCount;
  }
  getUniqueColumnsNames() {
    var res = super.getUniqueColumnsNames();
    const name = this.keyName;
    if (!!name && res.indexOf(name) < 0) {
      res.push(name);
    }
    return res;
  }
  generateRows() {
    var result = new Array();
    if (this.rowCount === 0) return result;
    var val = this.createNewValue();
    for (var i = 0; i < this.rowCount; i++) {
      result.push(this.createMatrixRow(this.getRowValueByIndex(val, i)));
    }
    if (!this.isValueEmpty(this.getDefaultRowValue(false))) {
      this.value = val;
    }
    return result;
  }
  createMatrixRow(value) {
    return new MatrixDynamicRowModel(this.rowCounter++, this, value);
  }
  getInsertedDeletedIndex(rows, val) {
    const len = Math.min(rows.length, val.length);
    for (let i = 0; i < len; i++) {
      if (val[i] !== rows[i].editingObj) return i;
    }
    return len;
  }
  isEditingObjectValueChanged() {
    const val = this.value;
    if (!this.generatedVisibleRows || !this.isValueSurveyElement(val)) return false;
    let lastDelRow = this.lastDeletedRow;
    this.lastDeletedRow = void 0;
    const rows = this.generatedVisibleRows;
    if (!Array.isArray(val) || Math.abs(rows.length - val.length) > 1 || rows.length === val.length) return false;
    const index = this.getInsertedDeletedIndex(rows, val);
    if (rows.length > val.length) {
      this.lastDeletedRow = rows[index];
      const row = rows[index];
      rows.splice(index, 1);
      if (this.isRendredTableCreated) {
        this.renderedTable.onRemovedRow(row);
      }
    } else {
      let newRow = void 0;
      if (!!lastDelRow && lastDelRow.editingObj === val[index]) {
        newRow = lastDelRow;
      } else {
        lastDelRow = void 0;
        newRow = this.createMatrixRow(val[index]);
      }
      rows.splice(index, 0, newRow);
      if (!lastDelRow) {
        this.onMatrixRowCreated(newRow);
      }
      if (this.isRendredTableCreated) {
        this.renderedTable.onAddedRow(newRow, index);
      }
    }
    this.setPropertyValueDirectly("rowCount", val.length);
    return true;
  }
  updateValueFromSurvey(newValue, clearData = false) {
    this.setRowCountValueFromData = true;
    if (this.minRowCount > 0 && Helpers.isValueEmpty(newValue) && !Helpers.isValueEmpty(this.defaultRowValue)) {
      newValue = [];
      for (let i = 0; i < this.minRowCount; i++) {
        newValue.push(Helpers.createCopy(this.defaultRowValue));
      }
    }
    super.updateValueFromSurvey(newValue, clearData);
    this.setRowCountValueFromData = false;
  }
  getFilteredDataCore() {
    const res = [];
    const val = this.createValueCopy();
    if (!Array.isArray(val)) return res;
    const rows = this.generatedVisibleRows;
    for (let i = 0; i < rows.length && i < val.length; i++) {
      const rowVal = val[i];
      if (rows[i].isVisible && !Helpers.isValueEmpty(rowVal)) {
        res.push(rowVal);
      }
    }
    return res;
  }
  onBeforeValueChanged(val) {
    if (!val || !Array.isArray(val)) return;
    var newRowCount = val.length;
    if (newRowCount == this.rowCount) return;
    if (!this.setRowCountValueFromData && newRowCount < this.initialRowCount) return;
    if (this.isEditingObjectValueChanged()) return;
    this.setRowCountValueFromData = true;
    this.rowCountValue = newRowCount;
    if (!this.generatedVisibleRows) return;
    if (newRowCount == this.generatedVisibleRows.length + 1) {
      this.onStartRowAddingRemoving();
      const newValue = this.getRowValueByIndex(val, newRowCount - 1);
      const newRow = this.createMatrixRow(newValue);
      this.generatedVisibleRows.push(newRow);
      this.onMatrixRowCreated(newRow);
      this.onEndRowAdding();
    } else {
      this.clearGeneratedRows();
      this.getVisibleRows();
      this.onRowsChanged();
    }
    this.setRowCountValueFromData = false;
  }
  createNewValue() {
    var result = this.createValueCopy();
    if (!result || !Array.isArray(result)) result = [];
    if (result.length > this.rowCount) result.splice(this.rowCount);
    var rowValue = this.getDefaultRowValue(false);
    rowValue = rowValue || {};
    for (var i = result.length; i < this.rowCount; i++) {
      result.push(this.getUnbindValue(rowValue));
    }
    return result;
  }
  deleteRowValue(newValue, row) {
    if (!Array.isArray(newValue)) return newValue;
    var isEmpty = true;
    for (var i = 0; i < newValue.length; i++) {
      if (this.isObject(newValue[i]) && Object.keys(newValue[i]).length > 0) {
        isEmpty = false;
        break;
      }
    }
    return isEmpty ? null : newValue;
  }
  getRowValueByIndex(questionValue, index) {
    return Array.isArray(questionValue) && index >= 0 && index < questionValue.length ? questionValue[index] : null;
  }
  getRowValueCore(row, questionValue, create = false) {
    if (!this.generatedVisibleRows) return {};
    var res = this.getRowValueByIndex(questionValue, this.generatedVisibleRows.indexOf(row));
    if (!res && create) res = {};
    return res;
  }
  getAddRowButtonCss(isEmptySection = false) {
    return new CssClassBuilder().append(this.cssClasses.button).append(this.cssClasses.buttonAdd).append(this.cssClasses.emptyRowsButton, isEmptySection).toString();
  }
  getRemoveRowButtonCss() {
    return new CssClassBuilder().append(this.cssClasses.button).append(this.cssClasses.buttonRemove).toString();
  }
  getRootCss() {
    var _a;
    return new CssClassBuilder().append(super.getRootCss()).append(this.cssClasses.empty, !((_a = this.renderedTable) === null || _a === void 0 ? void 0 : _a.showTable)).toString();
  }
};
var QuestionMatrixDynamicRenderedTable = class extends QuestionMatrixDropdownRenderedTable {
  setDefaultRowActions(row, actions) {
    super.setDefaultRowActions(row, actions);
  }
};
Serializer.addClass("matrixdynamic", [{
  name: "allowAddRows:boolean",
  default: true
}, {
  name: "allowRemoveRows:boolean",
  default: true
}, {
  name: "rowCount:number",
  default: 2,
  minValue: 0,
  isBindable: true
}, {
  name: "minRowCount:number",
  default: 0,
  minValue: 0
}, {
  name: "maxRowCount:number",
  default: settings.matrix.maxRowCount
}, {
  name: "keyName"
}, "defaultRowValue:rowvalue", {
  name: "copyDefaultValueFromLastEntry:boolean",
  alternativeName: "defaultValueFromLastRow"
}, {
  name: "confirmDelete:boolean"
}, {
  name: "confirmDeleteText",
  dependsOn: "confirmDelete",
  visibleIf: function(obj) {
    return !obj || obj.confirmDelete;
  },
  serializationProperty: "locConfirmDeleteText"
}, {
  name: "addRowButtonLocation",
  alternativeName: "addRowLocation",
  default: "default",
  choices: ["default", "top", "bottom", "topBottom"]
}, {
  name: "addRowText",
  serializationProperty: "locAddRowText"
}, {
  name: "removeRowText",
  serializationProperty: "locRemoveRowText"
}, "hideColumnsIfEmpty:boolean", {
  name: "noRowsText:text",
  alternativeName: "emptyRowsText",
  serializationProperty: "locNoRowsText",
  dependsOn: "hideColumnsIfEmpty",
  visibleIf: function(obj) {
    return !obj || obj.hideColumnsIfEmpty;
  }
}, {
  name: "detailPanelShowOnAdding:boolean",
  dependsOn: "detailPanelMode",
  visibleIf: function(obj) {
    return obj.detailPanelMode !== "none";
  }
}, {
  name: "allowRowReorder:switch",
  alternativeName: "allowRowsDragAndDrop"
}], function() {
  return new QuestionMatrixDynamicModel("");
}, "matrixdropdownbase");
QuestionFactory.Instance.registerQuestion("matrixdynamic", (name) => {
  var q = new QuestionMatrixDynamicModel(name);
  q.choices = [1, 2, 3, 4, 5];
  QuestionMatrixDropdownModelBase.addDefaultColumns(q);
  return q;
});
var surveyCss = {
  currentType: "default",
  getCss: function() {
    var loc = this.currentType ? this[this.currentType] : defaultCss;
    if (!loc) loc = defaultCss;
    return loc;
  },
  getAvailableThemes: function() {
    return Object.keys(this).filter((propertyName) => ["currentType", "getCss", "getAvailableThemes"].indexOf(propertyName) === -1);
  }
};
var defaultCss = {
  root: "sd-root-modern",
  rootProgress: "sd-progress",
  rootMobile: "sd-root-modern--mobile",
  rootAnimationDisabled: "sd-root-modern--animation-disabled",
  rootReadOnly: "sd-root--readonly",
  rootCompact: "sd-root--compact",
  rootFitToContainer: "sd-root-modern--full-container",
  rootWrapper: "sd-root-modern__wrapper",
  rootWrapperFixed: "sd-root-modern__wrapper--fixed",
  rootWrapperHasImage: "sd-root-modern__wrapper--has-image",
  rootBackgroundImage: "sd-root_background-image",
  container: "sd-container-modern",
  header: "sd-title sd-container-modern__title",
  bodyContainer: "sv-components-row",
  body: "sd-body",
  bodyWithTimer: "sd-body--with-timer",
  clockTimerRoot: "sd-timer",
  clockTimerRootTop: "sd-timer--top",
  clockTimerRootBottom: "sd-timer--bottom",
  clockTimerProgress: "sd-timer__progress",
  clockTimerProgressAnimation: "sd-timer__progress--animation",
  clockTimerTextContainer: "sd-timer__text-container",
  clockTimerMinorText: "sd-timer__text--minor",
  clockTimerMajorText: "sd-timer__text--major",
  bodyEmpty: "sd-body sd-body--empty",
  bodyLoading: "sd-body--loading",
  footer: "sd-footer sd-body__navigation sd-clearfix",
  title: "sd-title",
  description: "sd-description",
  logo: "sd-logo",
  logoImage: "sd-logo__image",
  headerText: "sd-header__text",
  headerClose: "sd-hidden",
  navigationButton: "",
  bodyNavigationButton: "sd-btn",
  completedPage: "sd-completedpage",
  completedBeforePage: "sd-completed-before-page",
  timerRoot: "sd-body__timer",
  navigation: {
    complete: "sd-btn--action sd-navigation__complete-btn",
    prev: "sd-navigation__prev-btn",
    next: "sd-navigation__next-btn",
    start: "sd-navigation__start-btn",
    preview: "sd-navigation__preview-btn",
    edit: "sd-btn sd-btn--small"
  },
  panel: {
    contentEnter: "sd-element__content--enter",
    contentLeave: "sd-element__content--leave",
    enter: "sd-element-wrapper--enter",
    leave: "sd-element-wrapper--leave",
    asPage: "sd-panel--as-page",
    number: "sd-element__num",
    title: "sd-title sd-element__title sd-panel__title",
    titleExpandable: "sd-element__title--expandable",
    titleExpandableSvg: "sd-element__title-expandable-svg",
    titleNumInline: "sd-element__title--num-inline",
    titleExpanded: "sd-element__title--expanded",
    titleCollapsed: "sd-element__title--collapsed",
    titleDisabled: "sd-element__title--disabled",
    titleOnExpand: "sd-panel__title--expanded",
    titleOnError: "sd-panel__title--error",
    titleBar: "sd-action-title-bar",
    description: "sd-description sd-panel__description",
    container: "sd-element sd-element--complex sd-panel sd-row__panel",
    withFrame: "sd-element--with-frame",
    content: "sd-element__content sd-panel__content",
    icon: "sd-panel__icon",
    iconExpanded: "sd-panel__icon--expanded",
    footer: "sd-panel__footer",
    requiredMark: "sd-panel__required-text",
    header: "sd-panel__header sd-element__header sd-element__header--location-top",
    collapsed: "sd-element--collapsed",
    expanded: "sd-element--expanded",
    expandable: "sd-element--expandable",
    expandableAnimating: "sd-elemenet--expandable--animating",
    nested: "sd-element--nested sd-element--nested-with-borders",
    invisible: "sd-element--invisible",
    navigationButton: "",
    compact: "sd-element--with-frame sd-element--compact",
    errorsContainer: "sd-panel__errbox sd-element__erbox sd-element__erbox--above-element"
  },
  paneldynamic: {
    mainRoot: "sd-element  sd-question sd-question--paneldynamic sd-element--complex sd-question--complex sd-row__question",
    empty: "sd-question--empty",
    root: "sd-paneldynamic",
    iconRemove: "sd-hidden",
    navigation: "sd-paneldynamic__navigation",
    title: "sd-title sd-element__title sd-question__title",
    header: "sd-paneldynamic__header sd-element__header",
    headerTab: "sd-paneldynamic__header-tab",
    button: "sd-action sd-paneldynamic__btn",
    buttonRemove: "sd-action--negative sd-paneldynamic__remove-btn",
    buttonAdd: "sd-paneldynamic__add-btn",
    buttonPrev: "sd-paneldynamic__prev-btn sd-action--icon sd-action",
    buttonPrevDisabled: "sd-action--disabled",
    buttonNextDisabled: "sd-action--disabled",
    buttonNext: "sd-paneldynamic__next-btn sd-action--icon sd-action",
    progressContainer: "sd-paneldynamic__progress-container",
    progress: "sd-progress",
    progressBar: "sd-progress__bar",
    nested: "sd-element--nested sd-element--nested-with-borders",
    progressText: "sd-paneldynamic__progress-text",
    separator: "sd-paneldynamic__separator",
    panelWrapper: "sd-paneldynamic__panel-wrapper",
    footer: "sd-paneldynamic__footer",
    panelFooter: "sd-paneldynamic__panel-footer",
    footerButtonsContainer: "sd-paneldynamic__buttons-container",
    panelsContainer: "sd-paneldynamic__panels-container",
    panelWrapperInRow: "sd-paneldynamic__panel-wrapper--in-row",
    panelWrapperEnter: "sd-paneldynamic__panel-wrapper--enter",
    panelWrapperLeave: "sd-paneldynamic__panel-wrapper--leave",
    panelWrapperList: "sd-paneldynamic__panel-wrapper--list",
    progressBtnIcon: "icon-progressbuttonv2",
    noEntriesPlaceholder: "sd-paneldynamic__placeholder sd-question__placeholder",
    compact: "sd-element--with-frame sd-element--compact",
    tabsContainer: "sd-paneldynamic__tabs-container",
    tabsContainerWithHeader: "sd-paneldynamic__tabs-container--with-header",
    tabsRoot: "sd-tabs-toolbar",
    tabsLeft: "sd-tabs-toolbar--left",
    tabsRight: "sd-tabs-toolbar--right",
    tabsCenter: "sd-tabs-toolbar--center",
    tabs: {
      item: "sd-tab-item",
      itemPressed: "sd-tab-item--pressed",
      itemAsIcon: "sd-tab-item--icon",
      itemIcon: "sd-tab-item__icon",
      itemTitle: "sd-tab-item__title"
    }
  },
  progress: "sd-progress sd-body__progress",
  progressTop: "sd-body__progress--top",
  progressBottom: "sd-body__progress--bottom",
  progressBar: "sd-progress__bar",
  progressText: "sd-progress__text",
  progressButtonsRoot: "sd-progress-buttons",
  progressButtonsNumbered: "sd-progress-buttons--numbered",
  progressButtonsFitSurveyWidth: "sd-progress-buttons--fit-survey-width",
  progressButtonsContainerCenter: "sd-progress-buttons__container-center",
  progressButtonsContainer: "sd-progress-buttons__container",
  progressButtonsConnector: "sd-progress-buttons__connector",
  progressButtonsButton: "sd-progress-buttons__button",
  progressButtonsButtonBackground: "sd-progress-buttons__button-background",
  progressButtonsButtonContent: "sd-progress-buttons__button-content",
  progressButtonsHeader: "sd-progress-buttons__header",
  progressButtonsFooter: "sd-progress-buttons__footer",
  progressButtonsImageButtonLeft: "sd-progress-buttons__image-button-left",
  progressButtonsImageButtonRight: "sd-progress-buttons__image-button-right",
  progressButtonsImageButtonHidden: "sd-progress-buttons__image-button--hidden",
  progressButtonsListContainer: "sd-progress-buttons__list-container",
  progressButtonsList: "sd-progress-buttons__list",
  progressButtonsListElementPassed: "sd-progress-buttons__list-element--passed",
  progressButtonsListElementCurrent: "sd-progress-buttons__list-element--current",
  progressButtonsListElementNonClickable: "sd-progress-buttons__list-element--nonclickable",
  progressButtonsPageTitle: "sd-progress-buttons__page-title",
  progressButtonsPageDescription: "sd-progress-buttons__page-description",
  progressTextInBar: "sd-hidden",
  page: {
    root: "sd-page sd-body__page",
    emptyHeaderRoot: "sd-page__empty-header",
    title: "sd-title sd-page__title",
    description: "sd-description sd-page__description",
    number: "sd-page__num",
    errorsContainer: "sd-page__errbox"
  },
  pageTitle: "sd-title sd-page__title",
  pageDescription: "sd-description sd-page__description",
  row: "sd-row sd-clearfix",
  rowMultiple: "sd-row--multiple",
  rowCompact: "sd-row--compact",
  rowEnter: "sd-row--enter",
  rowDelayedEnter: "sd-row--delayed-enter",
  rowLeave: "sd-row--leave",
  rowReplace: "sd-row--replace",
  pageRow: "sd-page__row",
  question: {
    contentEnter: "sd-element__content--enter",
    contentLeave: "sd-element__content--leave",
    enter: "sd-element-wrapper--enter",
    leave: "sd-element-wrapper--leave",
    mobile: "sd-question--mobile",
    mainRoot: "sd-element sd-question sd-row__question",
    flowRoot: "sd-element sd-question sd-row__question sd-row__question--flow",
    withFrame: "sd-element--with-frame",
    asCell: "sd-table__cell",
    answered: "sd-question--answered",
    header: "sd-question__header sd-element__header",
    headerLeft: "sd-question__header--location--left",
    headerTop: "sd-question__header--location-top sd-element__header--location-top",
    headerBottom: "sd-question__header--location--bottom",
    content: "sd-element__content sd-question__content",
    contentSupportContainerQueries: "sd-question__content--support-container-queries",
    contentLeft: "sd-question__content--left",
    titleNumInline: "sd-element__title--num-inline",
    titleLeftRoot: "sd-question--left",
    titleTopRoot: "sd-question--title-top",
    descriptionUnderInputRoot: "sd-question--description-under-input",
    titleBottomRoot: "sd-question--title-bottom",
    titleOnAnswer: "sd-question__title--answer",
    titleEmpty: "sd-question__title--empty",
    titleOnError: "sd-question__title--error",
    title: "sd-title sd-element__title sd-question__title",
    titleExpandable: "sd-element__title--expandable",
    titleExpandableSvg: "sd-element__title-expandable-svg",
    titleExpanded: "sd-element__title--expanded",
    titleCollapsed: "sd-element__title--collapsed",
    titleDisabled: "sd-element__title--disabled",
    titleReadOnly: "sd-element__title--readonly",
    titleBar: "sd-action-title-bar",
    requiredMark: "sd-question__required-text",
    number: "sd-element__num",
    description: "sd-description sd-question__description",
    descriptionUnderInput: "sd-question__description--under-input",
    comment: "sd-input sd-comment",
    other: "sd-input sd-comment",
    required: "sd-question--required",
    titleRequired: "sd-question__title--required",
    indent: 20,
    footer: "sd-question__footer",
    commentArea: "sd-question__comment-area",
    formGroup: "sd-question__form-group",
    hasError: "sd-question--error",
    hasErrorTop: "sd-question--error-top",
    hasErrorBottom: "sd-question--error-bottom",
    collapsed: "sd-element--collapsed",
    expandable: "sd-element--expandable",
    expandableAnimating: "sd-elemenet--expandable--animating",
    expanded: "sd-element--expanded",
    nested: "sd-element--nested",
    invisible: "sd-element--invisible",
    composite: "sd-element--complex sd-composite",
    disabled: "sd-question--disabled",
    readOnly: "sd-question--readonly",
    preview: "sd-question--preview",
    noPointerEventsMode: "sd-question--no-pointer-events",
    errorsContainer: "sd-element__erbox sd-question__erbox",
    errorsContainerTop: "sd-element__erbox--above-element sd-question__erbox--above-question",
    errorsContainerBottom: "sd-question__erbox--below-question",
    confirmDialog: "sd-popup--confirm sv-popup--confirm"
  },
  image: {
    mainRoot: "sd-element sd-question sd-question--image",
    root: "sd-image",
    image: "sd-image__image",
    adaptive: "sd-image__image--adaptive",
    noImage: "sd-image__no-image",
    noImageSvgIconId: "icon-no-image",
    withFrame: ""
  },
  html: {
    mainRoot: "sd-element sd-question sd-row__question sd-question--html",
    root: "sd-html",
    withFrame: "",
    nested: "sd-element--nested sd-html--nested"
  },
  error: {
    root: "sd-error",
    icon: "",
    item: "",
    locationTop: "",
    locationBottom: ""
  },
  checkbox: {
    root: "sd-selectbase",
    rootMobile: "sd-selectbase--mobile",
    rootRow: "sd-selectbase--row",
    rootMultiColumn: "sd-selectbase--multi-column",
    item: "sd-item sd-checkbox sd-selectbase__item",
    itemEnter: "sd-item--enter",
    itemLeave: "sd-item--leave",
    itemOnError: "sd-item--error",
    itemSelectAll: "sd-checkbox--selectall",
    itemNone: "sd-checkbox--none",
    itemDisabled: "sd-item--disabled sd-checkbox--disabled",
    itemReadOnly: "sd-item--readonly sd-checkbox--readonly",
    itemPreview: "sd-item--preview sd-checkbox--preview",
    itemPreviewSvgIconId: "#icon-check-16x16",
    itemChecked: "sd-item--checked sd-checkbox--checked",
    itemHover: "sd-item--allowhover sd-checkbox--allowhover",
    itemInline: "sd-selectbase__item--inline",
    label: "sd-selectbase__label",
    labelChecked: "",
    itemControl: "sd-visuallyhidden sd-item__control sd-checkbox__control",
    itemDecorator: "sd-item__svg sd-checkbox__svg",
    itemSvgIconId: "#icon-check-16x16",
    controlLabel: "sd-item__control-label",
    materialDecorator: "sd-item__decorator sd-checkbox__decorator",
    other: "sd-input sd-comment sd-selectbase__other",
    column: "sd-selectbase__column"
  },
  radiogroup: {
    root: "sd-selectbase",
    rootMobile: "sd-selectbase--mobile",
    rootRow: "sd-selectbase--row",
    rootMultiColumn: "sd-selectbase--multi-column",
    item: "sd-item sd-radio sd-selectbase__item",
    itemOnError: "sd-item--error",
    itemInline: "sd-selectbase__item--inline",
    label: "sd-selectbase__label",
    labelChecked: "",
    itemEnter: "sd-item--enter",
    itemLeave: "sd-item--leave",
    itemDisabled: "sd-item--disabled sd-radio--disabled",
    itemReadOnly: "sd-item--readonly sd-radio--readonly",
    itemPreview: "sd-item--preview sd-radio--preview",
    itemPreviewSvgIconId: "#icon-check-16x16",
    itemChecked: "sd-item--checked sd-radio--checked",
    itemHover: "sd-item--allowhover sd-radio--allowhover",
    itemControl: "sd-visuallyhidden sd-item__control sd-radio__control",
    itemDecorator: "sd-item__svg sd-radio__svg",
    controlLabel: "sd-item__control-label",
    materialDecorator: "sd-item__decorator sd-radio__decorator",
    other: "sd-input sd-comment sd-selectbase__other",
    clearButton: "",
    column: "sd-selectbase__column"
  },
  boolean: {
    mainRoot: "sd-element sd-question sd-row__question sd-question--boolean",
    root: "sv_qcbc sv_qbln sd-scrollable-container sd-boolean-root",
    rootRadio: "sv_qcbc sv_qbln sd-scrollable-container sd-scrollable-container--compact",
    item: "sd-boolean",
    itemOnError: "sd-boolean--error",
    control: "sd-boolean__control sd-visuallyhidden",
    itemChecked: "sd-boolean--checked",
    itemExchanged: "sd-boolean--exchanged",
    itemIndeterminate: "sd-boolean--indeterminate",
    itemDisabled: "sd-boolean--disabled",
    itemReadOnly: "sd-boolean--readonly",
    itemPreview: "sd-boolean--preview",
    itemHover: "sd-boolean--allowhover",
    label: "sd-boolean__label",
    labelTrue: "sd-boolean__label--true",
    labelFalse: "sd-boolean__label--false",
    switch: "sd-boolean__switch",
    disabledLabel: "sd-checkbox__label--disabled",
    labelReadOnly: "sd-checkbox__label--readonly",
    labelPreview: "sd-checkbox__label--preview",
    sliderText: "sd-boolean__thumb-text",
    slider: "sd-boolean__thumb",
    sliderGhost: "sd-boolean__thumb-ghost",
    //radio
    radioItem: "sd-item",
    radioItemChecked: "sd-item--checked sd-radio--checked",
    radioItemDisabled: "sd-item--disabled sd-radio--disabled",
    radioItemReadOnly: "sd-item--readonly sd-radio--readonly",
    radioItemPreview: "sd-item--preview sd-radio--preview",
    itemPreviewSvgIconId: "#icon-check-16x16",
    radioLabel: "sd-selectbase__label",
    radioControlLabel: "sd-item__control-label",
    radioFieldset: "sd-selectbase",
    itemRadioDecorator: "sd-item__svg sd-radio__svg",
    materialRadioDecorator: "sd-item__decorator sd-radio__decorator",
    itemRadioControl: "sd-visuallyhidden sd-item__control sd-radio__control",
    //end radio
    //checkbox
    rootCheckbox: "sd-selectbase",
    checkboxItem: "sd-item sd-selectbase__item sd-checkbox",
    checkboxLabel: "sd-selectbase__label",
    checkboxItemOnError: "sd-item--error",
    checkboxItemIndeterminate: "sd-checkbox--intermediate",
    checkboxItemChecked: "sd-item--checked sd-checkbox--checked",
    checkboxItemDecorator: "sd-item__svg sd-checkbox__svg",
    checkboxItemDisabled: "sd-item--disabled sd-checkbox--disabled",
    checkboxItemReadOnly: "sd-item--readonly sd-checkbox--readonly",
    checkboxItemPreview: "sd-item--preview sd-checkbox--preview",
    controlCheckbox: "sd-visuallyhidden sd-item__control sd-checkbox__control",
    checkboxMaterialDecorator: "sd-item__decorator sd-checkbox__decorator",
    checkboxControlLabel: "sd-item__control-label",
    svgIconCheckedId: "#icon-check-16x16"
  },
  text: {
    root: "sd-input sd-text",
    small: "sd-row__question--small",
    controlDisabled: "sd-input--disabled",
    controlReadOnly: "sd-input--readonly",
    controlPreview: "sd-input--preview",
    constrolWithCharacterCounter: "sd-text__character-counter",
    characterCounterBig: "sd-text__character-counter--big",
    content: "sd-text__content sd-question__content",
    remainingCharacterCounter: "sd-remaining-character-counter",
    onError: "sd-input--error"
  },
  multipletext: {
    root: "sd-multipletext",
    rootMobile: "sd-multipletext--mobile",
    itemLabel: "sd-multipletext__item-container sd-input",
    itemLabelReadOnly: "sd-input--readonly",
    itemLabelDisabled: "sd-input--disabled",
    itemLabelPreview: "sd-input--preview",
    itemLabelOnError: "sd-multipletext__item-container--error",
    itemLabelAllowFocus: "sd-multipletext__item-container--allow-focus",
    itemLabelAnswered: "sd-multipletext__item-container--answered",
    itemWithCharacterCounter: "sd-multipletext-item__character-counter",
    item: "sd-multipletext__item",
    itemTitle: "sd-multipletext__item-title",
    content: "sd-multipletext__content sd-question__content",
    row: "sd-multipletext__row",
    cell: "sd-multipletext__cell",
    cellError: "sd-multipletext__cell--error",
    cellErrorTop: "sd-multipletext__cell--error-top",
    cellErrorBottom: "sd-multipletext__cell--error-bottom"
  },
  dropdown: {
    root: "sd-selectbase",
    popup: "sv-dropdown-popup",
    small: "sd-row__question--small",
    selectWrapper: "sv-dropdown_select-wrapper",
    other: "sd-input sd-comment sd-selectbase__other",
    onError: "sd-input--error",
    label: "sd-selectbase__label",
    itemEnter: "sd-item--enter",
    itemLeave: "sd-item--leave",
    item: "sd-item sd-radio sd-selectbase__item",
    itemDisabled: "sd-item--disabled sd-radio--disabled",
    itemChecked: "sd-item--checked sd-radio--checked",
    itemHover: "sd-item--allowhover sd-radio--allowhover",
    itemControl: "sd-visuallyhidden sd-item__control sd-radio__control",
    itemDecorator: "sd-item__svg sd-radio__svg",
    cleanButton: "sd-dropdown_clean-button",
    cleanButtonSvg: "sd-dropdown_clean-button-svg",
    cleanButtonIconId: "icon-cancel",
    chevronButton: "sd-dropdown_chevron-button",
    chevronButtonSvg: "sd-dropdown_chevron-button-svg",
    chevronButtonIconId: "icon-chevron",
    control: "sd-input sd-dropdown",
    controlInputFieldComponent: "sd-dropdown__input-field-component",
    controlValue: "sd-dropdown__value",
    controlDisabled: "sd-input--disabled",
    controlReadOnly: "sd-input--readonly",
    controlPreview: "sd-input--preview",
    controlEmpty: "sd-dropdown--empty",
    controlLabel: "sd-item__control-label",
    filterStringInput: "sd-dropdown__filter-string-input",
    materialDecorator: "sd-item__decorator sd-radio__decorator",
    hintPrefix: "sd-dropdown__hint-prefix",
    hintSuffix: "sd-dropdown__hint-suffix"
  },
  imagepicker: {
    mainRoot: "sd-element sd-question sd-row__question",
    root: "sd-selectbase sd-imagepicker",
    rootResponsive: "sd-imagepicker--responsive",
    rootStatic: "sd-imagepicker--static",
    rootColumn: "sd-imagepicker--column",
    item: "sd-imagepicker__item",
    itemOnError: "sd-imagepicker__item--error",
    itemInline: "sd-imagepicker__item--inline",
    itemChecked: "sd-imagepicker__item--checked",
    itemDisabled: "sd-imagepicker__item--disabled",
    itemReadOnly: "sd-imagepicker__item--readonly",
    itemPreview: "sd-imagepicker__item--preview",
    itemHover: "sd-imagepicker__item--allowhover",
    label: "sd-imagepicker__label",
    itemDecorator: "sd-imagepicker__item-decorator",
    imageContainer: "sd-imagepicker__image-container",
    itemControl: "sd-imagepicker__control sd-visuallyhidden",
    image: "sd-imagepicker__image",
    itemText: "sd-imagepicker__text",
    other: "sd-input sd-comment",
    itemNoImage: "sd-imagepicker__no-image",
    itemNoImageSvgIcon: "sd-imagepicker__no-image-svg",
    itemNoImageSvgIconId: "icon-no-image",
    column: "sd-selectbase__column sd-imagepicker__column",
    checkedItemDecorator: "sd-imagepicker__check-decorator",
    checkedItemSvgIcon: "sd-imagepicker__check-icon",
    checkedItemSvgIconId: "icon-check-24x24"
  },
  matrix: {
    mainRoot: "sd-element sd-question sd-row__question sd-element--complex sd-question--complex sd-question--table",
    tableWrapper: "sd-matrix sd-table-wrapper",
    root: "sd-table sd-matrix__table",
    columnsAutoWidth: "sd-table--columnsautowidth",
    noHeader: "sd-table--no-header",
    rootVerticalAlignTop: "sd-table--align-top",
    rootVerticalAlignMiddle: "sd-table--align-middle",
    rootAlternateRows: "sd-table--alternate-rows",
    rowError: "sd-matrix__row--error",
    cell: "sd-table__cell sd-matrix__cell",
    row: "sd-table__row",
    rowDisabled: "sd-table__row-disabled",
    rowReadOnly: "sd-table__row-readonly",
    headerCell: "sd-table__cell sd-table__cell--header",
    rowTextCell: "sd-table__cell sd-matrix__cell sd-table__cell--row-text",
    label: "sd-item sd-radio sd-matrix__label",
    itemOnError: "sd-item--error",
    itemValue: "sd-visuallyhidden sd-item__control sd-radio__control",
    itemChecked: "sd-item--checked sd-radio--checked",
    itemDisabled: "sd-item--disabled sd-radio--disabled",
    itemReadOnly: "sd-item--readonly sd-radio--readonly",
    itemPreview: "sd-item--preview sd-radio--preview",
    itemPreviewSvgIconId: "#icon-check-16x16",
    itemHover: "sd-radio--allowhover",
    materialDecorator: "sd-item__decorator sd-radio__decorator",
    itemDecorator: "sd-item__svg sd-radio__svg",
    cellText: "sd-matrix__text",
    cellTextSelected: "sd-matrix__text--checked",
    cellTextDisabled: "sd-matrix__text--disabled",
    cellResponsiveTitle: "sd-matrix__responsive-title",
    compact: "sd-element--with-frame sd-element--compact"
  },
  matrixdropdown: {
    mainRoot: "sd-element sd-question sd-row__question sd-element--complex sd-question--complex sd-question--table",
    rootScroll: "sd-question--scroll",
    root: "sd-table sd-matrixdropdown",
    columnsAutoWidth: "sd-table--columnsautowidth",
    noHeader: "sd-table--no-header",
    hasFooter: "sd-table--has-footer",
    rootVerticalAlignTop: "sd-table--align-top",
    rootVerticalAlignMiddle: "sd-table--align-middle",
    tableWrapper: "sd-table-wrapper",
    rootAlternateRows: "sd-table--alternate-rows",
    cell: "sd-table__cell",
    cellResponsiveTitle: "sd-table__responsive-title",
    errorsCell: "sd-table__cell--error",
    errorsCellTop: "sd-table__cell--error-top",
    errorsCellBottom: "sd-table__cell--error-bottom",
    itemCell: "sd-table__cell--item",
    row: "sd-table__row",
    rowDelayedEnter: "sd-table__row--delayed-enter",
    rowEnter: "sd-table__row--enter",
    rowLeave: "sd-table__row--leave",
    expandedRow: "sd-table__row--expanded",
    rowHasPanel: "sd-table__row--has-panel",
    rowHasEndActions: "sd-table__row--has-end-actions",
    headerCell: "sd-table__cell sd-table__cell--header",
    rowTextCell: "sd-table__cell sd-table__cell--row-text",
    footerCell: "sd-table__cell sd-table__cell--footer",
    footerTotalCell: "sd-table__cell sd-table__cell--footer-total",
    columnTitleCell: "sd-table__cell--column-title",
    cellRequiredMark: "sd-question__required-text",
    detailButton: "sd-table__cell--detail-button",
    detailButtonExpanded: "sd-table__cell--detail-button--expanded",
    detailIcon: "sd-detail-panel__icon",
    detailIconExpanded: "sd-detail-panel__icon--expanded",
    detailIconId: "icon-expanddetail",
    detailIconExpandedId: "icon-collapsedetail",
    detailPanelCell: "sd-table__cell--detail-panel",
    detailRowCell: "sd-table__cell--detail",
    actionsCellPrefix: "sd-table__cell-action",
    actionsCell: "sd-table__cell sd-table__cell--actions",
    actionsCellDrag: "sd-table__cell--drag",
    emptyCell: "sd-table__cell--empty",
    verticalCell: "sd-table__cell--vertical",
    cellQuestionWrapper: "sd-matrix__question-wrapper sd-table__question-wrapper",
    compact: "sd-element--with-frame sd-element--compact"
  },
  matrixdynamic: {
    mainRoot: "sd-element sd-question sd-row__question sd-element--complex sd-question--complex sd-question--table",
    rootScroll: "sd-question--scroll",
    empty: "sd-question--empty",
    root: "sd-table sd-matrixdynamic",
    columnsAutoWidth: "sd-table--columnsautowidth",
    noHeader: "sd-table--no-header",
    hasFooter: "sd-table--has-footer",
    tableWrapper: "sd-table-wrapper",
    rootAlternateRows: "sd-table--alternate-rows",
    content: "sd-matrixdynamic__content sd-question__content",
    cell: "sd-table__cell",
    cellResponsiveTitle: "sd-table__responsive-title",
    row: "sd-table__row",
    rowDelayedEnter: "sd-table__row--delayed-enter",
    rowEnter: "sd-table__row--enter",
    rowLeave: "sd-table__row--leave",
    rowHasPanel: "sd-table__row--has-panel",
    rowHasEndActions: "sd-table__row--has-end-actions",
    expandedRow: "sd-table__row--expanded",
    itemCell: "sd-table__cell--item",
    headerCell: "sd-table__cell sd-table__cell--header",
    rowTextCell: "sd-table__cell sd-table__cell--row-text",
    footerCell: "sd-table__cell sd-table__cell--footer",
    columnTitleCell: "sd-table__cell--column-title",
    cellRequiredMark: "sd-question__required-text",
    button: "sd-action sd-matrixdynamic__btn",
    detailRow: "sd-table__row sd-table__row--detail",
    detailButton: "sd-table__cell--detail-button",
    detailButtonExpanded: "sd-table__cell--detail-button--expanded",
    detailIcon: "sd-detail-panel__icon",
    detailIconExpanded: "sd-detail-panel__icon--expanded",
    detailIconId: "icon-expanddetail",
    detailIconExpandedId: "icon-collapsedetail",
    detailPanelCell: "sd-table__cell--detail-panel",
    detailRowCell: "sd-table__cell--detail",
    actionsCellPrefix: "sd-table__cell-action",
    actionsCell: "sd-table__cell sd-table__cell--actions",
    actionsCellDrag: "sd-table__cell--drag",
    buttonAdd: "sd-matrixdynamic__add-btn",
    buttonRemove: "sd-action--negative sd-matrixdynamic__remove-btn",
    iconAdd: "sd-hidden",
    iconRemove: "",
    dragElementDecorator: "sd-drag-element__svg",
    iconDragElement: "#icon-drag-24x24",
    footer: "sd-matrixdynamic__footer",
    footerTotalCell: "sd-table__cell sd-table__cell--footer-total",
    noRowsSection: "sd-matrixdynamic__placeholder sd-question__placeholder",
    iconDrag: "sv-matrixdynamic__drag-icon",
    ghostRow: "sv-matrix-row--drag-drop-ghost-mod",
    draggedRow: "sv-matrixdynamic-dragged-row",
    emptyCell: "sd-table__cell--empty",
    verticalCell: "sd-table__cell--vertical",
    cellQuestionWrapper: "sd-matrix__question-wrapper sd-table__question-wrapper",
    errorsCell: "sd-table__cell--error",
    errorsCellTop: "sd-table__cell--error-top",
    errorsCellBottom: "sd-table__cell--error-bottom",
    compact: "sd-element--with-frame sd-element--compact"
  },
  rating: {
    rootDropdown: "sd-scrollable-container sd-scrollable-container--compact sd-selectbase",
    root: "sd-scrollable-container sd-rating",
    rootWrappable: "sd-rating--wrappable",
    rootLabelsTop: "sd-rating--labels-top",
    rootLabelsBottom: "sd-rating--labels-bottom",
    rootLabelsDiagonal: "sd-rating--labels-diagonal",
    item: "sd-rating__item",
    itemOnError: "sd-rating__item--error",
    itemHover: "sd-rating__item--allowhover",
    selected: "sd-rating__item--selected",
    itemStar: "sd-rating__item-star",
    itemStarOnError: "sd-rating__item-star--error",
    itemStarHover: "sd-rating__item-star--allowhover",
    itemStarSelected: "sd-rating__item-star--selected",
    itemStarDisabled: "sd-rating__item-star--disabled",
    itemStarReadOnly: "sd-rating__item-star--readonly",
    itemStarPreview: "sd-rating__item-star--preview",
    itemStarHighlighted: "sd-rating__item-star--highlighted",
    itemStarUnhighlighted: "sd-rating__item-star--unhighlighted",
    itemStarSmall: "sd-rating__item-star--small",
    itemSmiley: "sd-rating__item-smiley",
    itemSmileyOnError: "sd-rating__item-smiley--error",
    itemSmileyHover: "sd-rating__item-smiley--allowhover",
    itemSmileySelected: "sd-rating__item-smiley--selected",
    itemSmileyDisabled: "sd-rating__item-smiley--disabled",
    itemSmileyReadOnly: "sd-rating__item-smiley--readonly",
    itemSmileyPreview: "sd-rating__item-smiley--preview",
    itemSmileyHighlighted: "sd-rating__item-star--highlighted",
    itemSmileyScaleColored: "sd-rating__item-smiley--scale-colored",
    itemSmileyRateColored: "sd-rating__item-smiley--rate-colored",
    itemSmileySmall: "sd-rating__item-smiley--small",
    minText: "sd-rating__item-text sd-rating__min-text",
    itemText: "sd-rating__item-text",
    maxText: "sd-rating__item-text sd-rating__max-text",
    itemDisabled: "sd-rating__item--disabled",
    itemReadOnly: "sd-rating__item--readonly",
    itemPreview: "sd-rating__item--preview",
    itemFixedSize: "sd-rating__item--fixed-size",
    control: "sd-input sd-dropdown",
    itemSmall: "sd-rating--small",
    selectWrapper: "sv-dropdown_select-wrapper",
    controlValue: "sd-dropdown__value",
    controlDisabled: "sd-input--disabled",
    controlReadOnly: "sd-input--readonly",
    controlPreview: "sd-input--preview",
    controlEmpty: "sd-dropdown--empty",
    filterStringInput: "sd-dropdown__filter-string-input",
    chevronButton: "sd-dropdown_chevron-button",
    chevronButtonSvg: "sd-dropdown_chevron-button-svg",
    chevronButtonIconId: "icon-chevron",
    popup: "sv-dropdown-popup",
    onError: "sd-input--error"
  },
  comment: {
    root: "sd-input sd-comment",
    small: "sd-row__question--small",
    controlDisabled: "sd-input--disabled",
    controlReadOnly: "sd-input--readonly",
    controlPreview: "sd-input--preview",
    content: "sd-comment__content sd-question__content",
    remainingCharacterCounter: "sd-remaining-character-counter",
    onError: "sd-input--error"
  },
  expression: "sd-expression",
  file: {
    root: "sd-file",
    rootDragging: "sd-file--dragging",
    rootAnswered: "sd-file--answered",
    rootDisabled: "sd-file--disabled",
    rootReadOnly: "sd-file--readonly",
    rootPreview: "sd-file--preview",
    other: "sd-input sd-comment",
    placeholderInput: "sd-visuallyhidden",
    previewItem: "sd-file__preview-item",
    fileSign: "",
    fileList: "sd-file__list",
    fileSignBottom: "sd-file__sign",
    dragArea: "sd-file__drag-area",
    dragAreaActive: "sd-file__drag-area--active",
    fileDecorator: "sd-file__decorator",
    onError: "sd-file__decorator--error",
    fileDecoratorDrag: "sd-file__decorator--drag",
    fileInput: "sd-visuallyhidden",
    noFileChosen: "sd-description sd-file__no-file-chosen",
    chooseFile: "sd-file__choose-btn",
    chooseFileAsText: "sd-action sd-file__choose-btn--text",
    chooseFileAsTextDisabled: "sd-action--disabled",
    chooseFileAsIcon: "sd-file__choose-btn--icon",
    chooseFileIconId: "icon-choosefile",
    disabled: "sd-file__choose-btn--disabled",
    controlDisabled: "sd-file__choose-file-btn--disabled",
    //todo: remove it in v2
    removeButton: "sd-context-btn--negative",
    removeButtonBottom: "",
    //
    removeButtonIconId: "icon-clear",
    removeFile: "sd-hidden",
    removeFileSvg: "",
    removeFileSvgIconId: "icon-close_16x16",
    wrapper: "sd-file__wrapper",
    defaultImage: "sd-file__default-image",
    defaultImageIconId: "icon-defaultfile",
    leftIconId: "icon-arrowleft",
    rightIconId: "icon-arrowright",
    removeFileButton: "sd-context-btn--small sd-context-btn--with-border sd-context-btn--colorful sd-context-btn--negative sd-file__remove-file-button",
    dragAreaPlaceholder: "sd-file__drag-area-placeholder",
    imageWrapper: "sd-file__image-wrapper",
    imageWrapperDefaultImage: "sd-file__image-wrapper--default-image",
    single: "sd-file--single",
    singleImage: "sd-file--single-image",
    mobile: "sd-file--mobile",
    videoContainer: "sd-file__video-container",
    contextButton: "sd-context-btn",
    video: "sd-file__video",
    actionsContainer: "sd-file__actions-container",
    closeCameraButton: "sd-file__close-camera-button",
    changeCameraButton: "sd-file__change-camera-button",
    takePictureButton: "sd-file__take-picture-button",
    loadingIndicator: "sd-file__loading-indicator",
    page: "sd-file__page"
  },
  signaturepad: {
    mainRoot: "sd-element sd-question sd-question--signature sd-row__question",
    root: "sd-signaturepad sjs_sp_container",
    small: "sd-row__question--small",
    controls: "sjs_sp_controls sd-signaturepad__controls",
    placeholder: "sjs_sp_placeholder",
    canvas: "sjs_sp_canvas sd-signaturepad__canvas",
    backgroundImage: "sjs_sp__background-image sd-signaturepad__background-image",
    clearButton: "sjs_sp_clear sd-context-btn sd-context-btn--negative sd-signaturepad__clear",
    clearButtonIconId: "icon-clear",
    loadingIndicator: "sd-signaturepad__loading-indicator"
  },
  saveData: {
    root: "sv-save-data_root",
    rootWithButtons: "sv-save-data_root--with-buttons",
    info: "sv-save-data_info",
    error: "sv-save-data_error",
    success: "sv-save-data_success",
    button: "sv-save-data_button",
    shown: "sv-save-data_root--shown"
  },
  window: {
    root: "sv_window",
    rootCollapsedMod: "sv_window--collapsed",
    rootFullScreenMode: "sv_window--full-screen",
    rootContent: "sv_window_root-content",
    body: "sv_window_content",
    header: {
      root: "sv_window_header",
      titleCollapsed: "sv_window_header_title_collapsed",
      buttonsContainer: "sv_window_buttons_container",
      button: "sv_window_button",
      buttonExpanded: "",
      buttonCollapsed: "",
      collapseButton: "sv_window_button sv_window_button_collapse",
      closeButton: "sv_window_button sv_window_button_close",
      fullScreenButton: "sv_window_button sv_window_button_full_screen"
    }
  },
  ranking: {
    root: "sv-ranking",
    rootMobileMod: "sv-ranking--mobile",
    rootDragMod: "sv-ranking--drag",
    rootDisabled: "sd-ranking--disabled",
    rootReadOnly: "sd-ranking--readonly",
    rootPreview: "sd-ranking--preview",
    rootDesignMode: "sv-ranking--design-mode",
    rootDragHandleAreaIcon: "sv-ranking--drag-handle-area-icon",
    rootSelectToRankMod: "sv-ranking--select-to-rank",
    rootSelectToRankEmptyValueMod: "sv-ranking--select-to-rank-empty-value",
    rootSelectToRankAlignVertical: "sv-ranking--select-to-rank-vertical",
    rootSelectToRankAlignHorizontal: "sv-ranking--select-to-rank-horizontal",
    rootSelectToRankSwapAreas: "sv-ranking--select-to-rank-swap-areas",
    item: "sv-ranking-item",
    itemContent: "sv-ranking-item__content sd-ranking-item__content",
    itemIndex: "sv-ranking-item__index sd-ranking-item__index",
    itemIndexEmptyMode: "sv-ranking-item__index--empty sd-ranking-item__index--empty",
    // itemText: "sv-ranking-item__text",
    itemDisabled: "sv-ranking-item--disabled",
    itemReadOnly: "sv-ranking-item--readonly",
    itemPreview: "sv-ranking-item--preview",
    controlLabel: "sv-ranking-item__text",
    itemGhostNode: "sv-ranking-item__ghost",
    itemIconContainer: "sv-ranking-item__icon-container",
    itemIcon: "sv-ranking-item__icon",
    itemIconHoverMod: "sv-ranking-item__icon--hover",
    itemIconFocusMod: "sv-ranking-item__icon--focus",
    itemGhostMod: "sv-ranking-item--ghost",
    itemDragMod: "sv-ranking--drag",
    itemOnError: "sv-ranking-item--error",
    container: "sv-ranking__container",
    containerEmptyMode: "sv-ranking__container--empty",
    containerFromMode: "sv-ranking__container--from",
    containerToMode: "sv-ranking__container--to",
    containerPlaceholder: "sv-ranking__container-placeholder",
    containersDivider: "sv-ranking__containers-divider"
  },
  buttongroup: {
    root: "sv-button-group",
    item: "sv-button-group__item",
    itemIcon: "sv-button-group__item-icon",
    itemDecorator: "sv-button-group__item-decorator",
    itemCaption: "sv-button-group__item-caption",
    itemHover: "sv-button-group__item--hover",
    itemSelected: "sv-button-group__item--selected",
    itemDisabled: "sv-button-group__item--disabled",
    itemControl: "sv-visuallyhidden"
  },
  list: {
    root: "sv-list__container sd-list",
    item: "sv-list__item sd-list__item",
    itemBody: "sv-list__item-body sd-list__item-body",
    itemSelected: "sv-list__item--selected sd-list__item--selected",
    itemFocused: "sv-list__item--focused sd-list__item--focused",
    itemHovered: "sv-list__item--hovered sd-list__item--hovered"
  },
  actionBar: {
    root: "sd-action-bar",
    item: "sd-action",
    defaultSizeMode: "",
    smallSizeMode: "",
    itemPressed: "sd-action--pressed",
    itemAsIcon: "sd-action--icon",
    itemIcon: "sd-action__icon",
    itemTitle: "sd-action__title"
  },
  variables: {
    mobileWidth: "--sd-mobile-width",
    themeMark: "--sv-defaultV2-mark"
  },
  tagbox: {
    root: "sd-selectbase",
    popup: "sv-dropdown-popup",
    small: "sd-row__question--small",
    selectWrapper: "sv-dropdown_select-wrapper",
    other: "sd-input sd-comment sd-selectbase__other",
    onError: "sd-input--error",
    label: "sd-selectbase__label",
    itemSvgIconId: "#icon-check-16x16",
    item: "sd-item sd-checkbox sd-selectbase__item",
    itemDisabled: "sd-item--disabled sd-checkbox--disabled",
    itemChecked: "sd-item--checked sd-checkbox--checked",
    itemHover: "sd-item--allowhover sd-checkbox--allowhover",
    itemControl: "sd-visuallyhidden sd-item__control sd-checkbox__control",
    itemDecorator: "sd-item__svg sd-checkbox__svg",
    itemEnter: "sd-item--enter",
    itemLeave: "sd-item--leave",
    cleanButton: "sd-tagbox_clean-button sd-dropdown_clean-button",
    cleanButtonSvg: "sd-tagbox_clean-button-svg sd-dropdown_clean-button-svg",
    cleanButtonIconId: "icon-cancel-24x24",
    cleanItemButton: "sd-tagbox-item_clean-button",
    cleanItemButtonSvg: "sd-tagbox-item_clean-button-svg",
    cleanItemButtonIconId: "icon-clear_16x16",
    chevronButton: "sd-dropdown_chevron-button",
    chevronButtonSvg: "sd-dropdown_chevron-button-svg",
    chevronButtonIconId: "icon-chevron",
    control: "sd-input sd-tagbox sd-dropdown",
    controlValue: "sd-tagbox__value sd-dropdown__value",
    controlValueItems: "sd-tagbox__value-items",
    placeholderInput: "sd-tagbox__placeholder",
    controlEditable: "sd-input--editable",
    controlDisabled: "sd-input--disabled",
    controlReadOnly: "sd-input--readonly",
    controlPreview: "sd-input--preview",
    controlEmpty: "sd-dropdown--empty sd-tagbox--empty",
    controlLabel: "sd-item__control-label",
    filterStringInput: "sd-tagbox__filter-string-input sd-dropdown__filter-string-input",
    materialDecorator: "sd-item__decorator sd-checkbox__decorator",
    hint: "sd-tagbox__hint",
    hintPrefix: "sd-dropdown__hint-prefix sd-tagbox__hint-prefix",
    hintSuffix: "sd-dropdown__hint-suffix sd-tagbox__hint-suffix",
    hintSuffixWrapper: "sd-tagbox__hint-suffix-wrapper"
  }
};
var defaultThemeName = "default";
surveyCss[defaultThemeName] = defaultCss;
var surveyTimerFunctions = {
  setTimeout: (func) => {
    return surveyTimerFunctions.safeTimeOut(func, 1e3);
  },
  clearTimeout: (timerId) => {
    clearTimeout(timerId);
  },
  safeTimeOut: (func, delay) => {
    if (delay <= 0) {
      func();
      return 0;
    } else {
      return setTimeout(func, delay);
    }
  },
  now() {
    return Date.now();
  }
};
var SurveyTimer = class _SurveyTimer {
  constructor() {
    this.listenerCounter = 0;
    this.timerId = -1;
    this.onTimerTick = new EventBase();
    this.onTimer = this.onTimerTick;
  }
  static get instance() {
    if (!_SurveyTimer.instanceValue) {
      _SurveyTimer.instanceValue = new _SurveyTimer();
    }
    return _SurveyTimer.instanceValue;
  }
  start(func = null) {
    if (func) {
      this.onTimerTick.add(func);
    }
    this.prevTimeInMs = surveyTimerFunctions.now();
    if (this.timerId < 0) {
      this.timerId = surveyTimerFunctions.setTimeout(() => {
        this.doTimer();
      });
    }
    this.listenerCounter++;
  }
  stop(func = null) {
    if (func) {
      this.onTimerTick.remove(func);
    }
    this.listenerCounter--;
    if (this.listenerCounter == 0 && this.timerId > -1) {
      surveyTimerFunctions.clearTimeout(this.timerId);
      this.timerId = -1;
    }
  }
  doTimer() {
    if (this.onTimerTick.isEmpty || this.listenerCounter == 0) {
      this.timerId = -1;
    }
    if (this.timerId < 0) return;
    const newTimer = surveyTimerFunctions.now();
    let seconds = Math.floor((newTimer - this.prevTimeInMs) / 1e3);
    this.prevTimeInMs = newTimer;
    if (seconds < 0) {
      seconds = 1;
    }
    const prevItem = this.timerId;
    this.onTimerTick.fire(this, {
      seconds
    });
    if (prevItem !== this.timerId) return;
    this.timerId = surveyTimerFunctions.setTimeout(() => {
      this.doTimer();
    });
  }
};
SurveyTimer.instanceValue = null;
var SurveyTimerModel = class extends Base {
  constructor(survey) {
    super();
    this.timerFunc = null;
    this.surveyValue = survey;
    this.onCreating();
  }
  get survey() {
    return this.surveyValue;
  }
  onCreating() {
  }
  start() {
    if (!this.survey) return;
    if (this.isRunning || this.isDesignMode) return;
    this.survey.onCurrentPageChanged.add(() => {
      this.update();
    });
    this.timerFunc = (sender, options) => {
      this.doTimer(options.seconds);
    };
    this.setIsRunning(true);
    this.update();
    SurveyTimer.instance.start(this.timerFunc);
  }
  stop() {
    if (!this.isRunning) return;
    this.setIsRunning(false);
    SurveyTimer.instance.stop(this.timerFunc);
  }
  get isRunning() {
    return this.getPropertyValue("isRunning", false);
  }
  setIsRunning(val) {
    this.setPropertyValue("isRunning", val);
  }
  update() {
    this.updateText();
    this.updateProgress();
  }
  doTimer(seconds) {
    var page = this.survey.currentPage;
    if (page) {
      const pageMaxTime = page.getMaxTimeToFinish();
      if (pageMaxTime > 0 && pageMaxTime < page.timeSpent + seconds) {
        seconds = pageMaxTime - page.timeSpent;
      }
      page.timeSpent = page.timeSpent + seconds;
    }
    this.spent = this.spent + seconds;
    this.update();
    if (this.onTimerTick) {
      this.onTimerTick(page);
    }
  }
  updateProgress() {
    let {
      spent,
      limit
    } = this.survey.timerInfo;
    if (!limit) {
      this.progress = void 0;
    } else {
      if (spent == 0) {
        this.progress = 0;
        setTimeout(() => {
          this.progress = Math.floor((spent + 1) / limit * 100) / 100;
        }, 0);
      } else if (spent <= limit) {
        this.progress = Math.floor((spent + 1) / limit * 100) / 100;
      }
      if (this.progress > 1) {
        this.progress = void 0;
      }
    }
  }
  updateText() {
    let timerClock = this.survey.timerClock;
    this.clockMajorText = timerClock.majorText;
    this.clockMinorText = timerClock.minorText;
    this.text = this.survey.timerInfoText;
  }
  get showProgress() {
    return this.progress !== void 0;
  }
  get showTimerAsClock() {
    return !!this.survey.getCss().clockTimerRoot;
  }
  get rootCss() {
    return new CssClassBuilder().append(this.survey.getCss().clockTimerRoot).append(this.survey.getCss().clockTimerRootTop, this.survey.isTimerPanelShowingOnTop).append(this.survey.getCss().clockTimerRootBottom, this.survey.isTimerPanelShowingOnBottom).toString();
  }
  getProgressCss() {
    return new CssClassBuilder().append(this.survey.getCss().clockTimerProgress).append(this.survey.getCss().clockTimerProgressAnimation, this.progress > 0).toString();
  }
  get textContainerCss() {
    return this.survey.getCss().clockTimerTextContainer;
  }
  get minorTextCss() {
    return this.survey.getCss().clockTimerMinorText;
  }
  get majorTextCss() {
    return this.survey.getCss().clockTimerMajorText;
  }
};
__decorate([property()], SurveyTimerModel.prototype, "text", void 0);
__decorate([property()], SurveyTimerModel.prototype, "progress", void 0);
__decorate([property()], SurveyTimerModel.prototype, "clockMajorText", void 0);
__decorate([property()], SurveyTimerModel.prototype, "clockMinorText", void 0);
__decorate([property({
  defaultValue: 0
})], SurveyTimerModel.prototype, "spent", void 0);
var Notifier = class extends Base {
  constructor(cssClasses) {
    super();
    this.cssClasses = cssClasses;
    this.timeout = settings.notifications.lifetime;
    this.timer = void 0;
    this.actionsVisibility = {};
    this.showActions = true;
    this.actionBar = new ActionContainer();
    this.actionBar.updateCallback = (isResetInitialized) => {
      this.actionBar.actions.forEach((action) => action.cssClasses = {});
    };
    this.css = this.cssClasses.root;
  }
  getCssClass(type) {
    return new CssClassBuilder().append(this.cssClasses.root).append(this.cssClasses.rootWithButtons, this.actionBar.visibleActions.length > 0).append(this.cssClasses.info, type !== "error" && type !== "success").append(this.cssClasses.error, type === "error").append(this.cssClasses.success, type === "success").append(this.cssClasses.shown, this.active).toString();
  }
  updateActionsVisibility(type) {
    this.actionBar.actions.forEach((action) => action.visible = this.showActions && this.actionsVisibility[action.id] === type);
  }
  notify(message, type = "info", waitUserAction = false) {
    this.isDisplayed = true;
    setTimeout(() => {
      this.updateActionsVisibility(type);
      this.message = message;
      this.active = true;
      this.css = this.getCssClass(type);
      if (!!this.timer) {
        clearTimeout(this.timer);
        this.timer = void 0;
      }
      if (!waitUserAction) {
        this.timer = setTimeout(() => {
          this.timer = void 0;
          this.active = false;
          this.css = this.getCssClass(type);
        }, this.timeout);
      }
    }, 1);
  }
  addAction(action, notificationType) {
    action.visible = false;
    action.innerCss = this.cssClasses.button;
    const res = this.actionBar.addAction(action);
    this.actionsVisibility[res.id] = notificationType;
  }
};
__decorate([property({
  defaultValue: false
})], Notifier.prototype, "active", void 0);
__decorate([property({
  defaultValue: false
})], Notifier.prototype, "isDisplayed", void 0);
__decorate([property()], Notifier.prototype, "message", void 0);
__decorate([property()], Notifier.prototype, "css", void 0);
var CoverCell = class _CoverCell {
  calcRow(positionY) {
    return positionY === "top" ? 1 : positionY === "middle" ? 2 : 3;
  }
  calcColumn(positionX) {
    return positionX === "left" ? 1 : positionX === "center" ? 2 : 3;
  }
  calcAlignItems(positionX) {
    return positionX === "left" ? "flex-start" : positionX === "center" ? "center" : "flex-end";
  }
  calcAlignText(positionX) {
    return positionX === "left" ? "start" : positionX === "center" ? "center" : "end";
  }
  calcJustifyContent(positionY) {
    return positionY === "top" ? "flex-start" : positionY === "middle" ? "center" : "flex-end";
  }
  constructor(cover, positionX, positionY) {
    this.cover = cover;
    this.positionX = positionX;
    this.positionY = positionY;
  }
  get survey() {
    return this.cover.survey;
  }
  get css() {
    const result = new CssClassBuilder().append(_CoverCell.CLASSNAME).append(`${_CoverCell.CLASSNAME}--${this.positionX}`).append(`${_CoverCell.CLASSNAME}--${this.positionY}`).append(_CoverCell.CLASSNAME + "--empty", this.isEmpty).toString();
    return result;
  }
  get style() {
    const result = {};
    result["gridColumn"] = this.calcColumn(this.positionX);
    result["gridRow"] = this.calcRow(this.positionY);
    result["width"] = !!this.width ? this.width + "px" : void 0;
    return result;
  }
  get contentStyle() {
    const result = {};
    result["textAlign"] = this.calcAlignText(this.positionX);
    result["alignItems"] = this.calcAlignItems(this.positionX);
    result["justifyContent"] = this.calcJustifyContent(this.positionY);
    result["maxWidth"] = this.contentMaxWidth;
    return result;
  }
  get showLogo() {
    return this.survey.hasLogo && this.positionX === this.cover.logoPositionX && this.positionY === this.cover.logoPositionY;
  }
  get showTitle() {
    return this.survey.hasTitle && this.positionX === this.cover.titlePositionX && this.positionY === this.cover.titlePositionY;
  }
  get showDescription() {
    return this.survey.renderedHasDescription && this.positionX === this.cover.descriptionPositionX && this.positionY === this.cover.descriptionPositionY;
  }
  get isEmpty() {
    return !this.showLogo && !this.showTitle && !this.showDescription;
  }
  get textAreaWidth() {
    return this.cover.renderedTextAreaWidth;
  }
  get width() {
    if (this.cover.width) {
      return Math.ceil(this.cover.width / 3);
    }
    return void 0;
  }
  get contentMaxWidth() {
    return this.cover.getContentMaxWidth(this);
  }
};
CoverCell.CLASSNAME = "sv-header__cell";
var Cover = class extends Base {
  calcBackgroundSize(backgroundImageFit) {
    if (backgroundImageFit === "fill") {
      return "100% 100%";
    }
    if (backgroundImageFit === "tile") {
      return "auto";
    }
    return backgroundImageFit;
  }
  updateHeaderClasses() {
    const backgroundColorNone = !this.backgroundColor || this.backgroundColor === "transparent";
    const backgroundColorAccent = this.backgroundColor === "var(--sjs-primary-backcolor)";
    const backgroundColorCustom = !backgroundColorNone && !backgroundColorAccent;
    this.headerClasses = new CssClassBuilder().append("sv-header").append("sv-header--height-auto", !this.renderedHeight).append("sv-header__without-background", backgroundColorNone && !this.backgroundImage).append("sv-header__background-color--none", backgroundColorNone && !this.titleColor && !this.descriptionColor).append("sv-header__background-color--accent", backgroundColorAccent && !this.titleColor && !this.descriptionColor).append("sv-header__background-color--custom", backgroundColorCustom && !this.titleColor && !this.descriptionColor).append("sv-header__overlap", this.overlapEnabled).toString();
  }
  updateContentClasses() {
    const surveyWidthMode = !!this.survey && this.survey.calculateWidthMode();
    this.maxWidth = this.inheritWidthFrom === "survey" && !!surveyWidthMode && surveyWidthMode === "static" && this.survey.renderedWidth;
    this.contentClasses = new CssClassBuilder().append("sv-header__content").append("sv-header__content--static", this.inheritWidthFrom === "survey" && !!surveyWidthMode && surveyWidthMode === "static").append("sv-header__content--responsive", this.inheritWidthFrom === "container" || !!surveyWidthMode && surveyWidthMode === "responsive").toString();
  }
  updateBackgroundImageClasses() {
    this.backgroundImageClasses = new CssClassBuilder().append("sv-header__background-image").append("sv-header__background-image--contain", this.backgroundImageFit === "contain").append("sv-header__background-image--tile", this.backgroundImageFit === "tile").toString();
  }
  fromTheme(theme) {
    super.fromJSON(theme.header || {});
    if (!!theme.cssVariables) {
      this.backgroundColor = theme.cssVariables["--sjs-header-backcolor"];
      this.titleColor = theme.cssVariables["--sjs-font-headertitle-color"];
      this.descriptionColor = theme.cssVariables["--sjs-font-headerdescription-color"];
    }
    this.init();
  }
  init() {
    this.renderBackgroundImage = wrapUrlForBackgroundImage(this.backgroundImage);
    this.updateHeaderClasses();
    this.updateContentClasses();
    this.updateBackgroundImageClasses();
  }
  constructor() {
    super();
    this.cells = [];
    ["top", "middle", "bottom"].forEach((positionY) => ["left", "center", "right"].forEach((positionX) => this.cells.push(new CoverCell(this, positionX, positionY))));
    this.init();
  }
  getType() {
    return "cover";
  }
  get renderedHeight() {
    if (this.survey && !this.survey.isMobile || !this.survey) {
      return this.height ? this.height + "px" : void 0;
    }
    if (this.survey && this.survey.isMobile) {
      return this.mobileHeight ? this.mobileHeight + "px" : void 0;
    }
    return void 0;
  }
  get renderedTextAreaWidth() {
    return this.textAreaWidth ? this.textAreaWidth + "px" : void 0;
  }
  get isEmpty() {
    return !this.survey.hasLogo && !this.survey.hasTitle && !this.survey.renderedHasDescription;
  }
  get survey() {
    return this._survey;
  }
  set survey(newValue) {
    if (this._survey === newValue) return;
    this._survey = newValue;
    if (!!newValue) {
      this.updateContentClasses();
      this._survey.onPropertyChanged.add((sender, options) => {
        if (options.name == "widthMode" || options.name == "width") {
          this.updateContentClasses();
        }
      });
    }
  }
  get backgroundImageStyle() {
    if (!this.backgroundImage) return null;
    return {
      opacity: this.backgroundImageOpacity,
      backgroundImage: this.renderBackgroundImage,
      backgroundSize: this.calcBackgroundSize(this.backgroundImageFit)
    };
  }
  propertyValueChanged(name, oldValue, newValue, arrayChanges, target) {
    super.propertyValueChanged(name, oldValue, newValue);
    if (name === "height" || name === "backgroundColor" || name === "backgroundImage" || name === "overlapEnabled") {
      this.updateHeaderClasses();
    }
    if (name === "inheritWidthFrom") {
      this.updateContentClasses();
    }
    if (name === "backgroundImageFit") {
      this.updateBackgroundImageClasses();
    }
  }
  // public calculateActualHeight(logoHeight: number, titleHeight: number, descriptionHeight: number): number {
  //   const positionsY = ["top", "middle", "bottom"];
  //   const logoIndex = positionsY.indexOf(this.logoPositionY);
  //   const titleIndex = positionsY.indexOf(this.titlePositionY);
  //   const descriptionIndex = positionsY.indexOf(this.descriptionPositionY);
  //   const positionsX = ["left", "center", "right"];
  //   const logoIndexX = positionsX.indexOf(this.logoPositionX);
  //   const titleIndexX = positionsX.indexOf(this.titlePositionX);
  //   const descriptionIndexX = positionsX.indexOf(this.descriptionPositionX);
  //   const heights = [
  //     [0, 0, 0],
  //     [0, 0, 0],
  //     [0, 0, 0]
  //   ];
  //   heights[logoIndex][logoIndexX] = logoHeight;
  //   heights[titleIndex][titleIndexX] += titleHeight;
  //   heights[descriptionIndex][descriptionIndexX] += descriptionHeight;
  //   return heights.reduce((total, rowArr) => total + Math.max(...rowArr), 0);
  // }
  getContentMaxWidth(cell) {
    if (cell.isEmpty || cell.showLogo) {
      return void 0;
    }
    const cellIndex = this.cells.indexOf(cell);
    const rowIndex = Math.floor(cellIndex / 3);
    const colIndex = cellIndex % 3;
    if (colIndex == 1) {
      if (!this.cells[rowIndex * 3].isEmpty || !this.cells[rowIndex * 3 + 2].isEmpty) {
        return "100%";
      }
    } else if (colIndex == 0) {
      let rightFreeCells = 0;
      let index = colIndex + 1;
      while (index < 3 && this.cells[rowIndex * 3 + index].isEmpty) {
        if (this.cells[rowIndex * 3 + index].isEmpty) {
          rightFreeCells++;
        }
        index++;
      }
      return 100 * (rightFreeCells + 1) + "%";
    } else if (colIndex == 2) {
      let leftFreeCells = 0;
      let index = colIndex - 1;
      while (index > 0 && this.cells[rowIndex * 3 + index].isEmpty) {
        if (this.cells[rowIndex * 3 + index].isEmpty) {
          leftFreeCells++;
        }
        index--;
      }
      return 100 * (leftFreeCells + 1) + "%";
    }
    return void 0;
  }
  processResponsiveness() {
    if (this.survey && this.survey.rootElement) {
      if (!this.survey.isMobile) {
        const headerEl = this.survey.rootElement.querySelectorAll(".sv-header__content")[0];
        if (!headerEl) return;
        let elWidth = headerEl.getBoundingClientRect().width;
        const headerComputedStyle = DomDocumentHelper.getComputedStyle(headerEl);
        const paddingLeft = parseFloat(headerComputedStyle.paddingLeft) || 0;
        const paddingRight = parseFloat(headerComputedStyle.paddingRight) || 0;
        const columnGap = parseFloat(headerComputedStyle.columnGap) || 0;
        this.width = elWidth - paddingLeft - paddingRight - 2 * columnGap;
      }
    }
  }
  get hasBackground() {
    return !!this.backgroundImage || this.backgroundColor !== "transparent";
  }
};
__decorate([property()], Cover.prototype, "height", void 0);
__decorate([property()], Cover.prototype, "mobileHeight", void 0);
__decorate([property()], Cover.prototype, "inheritWidthFrom", void 0);
__decorate([property()], Cover.prototype, "textAreaWidth", void 0);
__decorate([property()], Cover.prototype, "textGlowEnabled", void 0);
__decorate([property()], Cover.prototype, "overlapEnabled", void 0);
__decorate([property({
  defaultValue: "transparent"
})], Cover.prototype, "backgroundColor", void 0);
__decorate([property()], Cover.prototype, "titleColor", void 0);
__decorate([property()], Cover.prototype, "descriptionColor", void 0);
__decorate([property({
  onSet: (newVal, target) => {
    target.renderBackgroundImage = wrapUrlForBackgroundImage(newVal);
  }
})], Cover.prototype, "backgroundImage", void 0);
__decorate([property()], Cover.prototype, "renderBackgroundImage", void 0);
__decorate([property()], Cover.prototype, "backgroundImageFit", void 0);
__decorate([property()], Cover.prototype, "backgroundImageOpacity", void 0);
__decorate([property()], Cover.prototype, "logoPositionX", void 0);
__decorate([property()], Cover.prototype, "logoPositionY", void 0);
__decorate([property()], Cover.prototype, "titlePositionX", void 0);
__decorate([property()], Cover.prototype, "titlePositionY", void 0);
__decorate([property()], Cover.prototype, "descriptionPositionX", void 0);
__decorate([property()], Cover.prototype, "descriptionPositionY", void 0);
__decorate([property()], Cover.prototype, "logoStyle", void 0);
__decorate([property()], Cover.prototype, "titleStyle", void 0);
__decorate([property()], Cover.prototype, "descriptionStyle", void 0);
__decorate([property()], Cover.prototype, "headerClasses", void 0);
__decorate([property()], Cover.prototype, "contentClasses", void 0);
__decorate([property()], Cover.prototype, "width", void 0);
__decorate([property()], Cover.prototype, "maxWidth", void 0);
__decorate([property()], Cover.prototype, "backgroundImageClasses", void 0);
Serializer.addClass("cover", [{
  name: "height:number",
  minValue: 0,
  default: 0
}, {
  name: "mobileHeight:number",
  minValue: 0,
  default: 0
}, {
  name: "inheritWidthFrom",
  default: "survey"
}, {
  name: "textAreaWidth:number",
  minValue: 0,
  default: 0
}, {
  name: "textGlowEnabled:boolean"
}, {
  name: "overlapEnabled:boolean"
}, {
  name: "backgroundImage:file"
}, {
  name: "backgroundImageOpacity:number",
  minValue: 0,
  maxValue: 1,
  default: 1
}, {
  name: "backgroundImageFit",
  default: "cover",
  choices: ["cover", "fill", "contain"]
}, {
  name: "logoPositionX",
  default: "left"
}, {
  name: "logoPositionY",
  default: "top"
}, {
  name: "titlePositionX",
  default: "left"
}, {
  name: "titlePositionY",
  default: "bottom"
}, {
  name: "descriptionPositionX",
  default: "left"
}, {
  name: "descriptionPositionY",
  default: "bottom"
}], function() {
  return new Cover();
});
var SurveyTaskModel = class {
  constructor(type) {
    this.type = type;
    this.timestamp = /* @__PURE__ */ new Date();
  }
};
var SurveyTaskManagerModel = class extends Base {
  constructor() {
    super();
    this.taskList = [];
    this.onAllTasksCompleted = this.addEvent();
  }
  runTask(type, func) {
    const task = new SurveyTaskModel(type);
    this.taskList.push(task);
    this.hasActiveTasks = true;
    func(() => this.taskFinished(task));
    return task;
  }
  waitAndExecute(action) {
    if (!this.hasActiveTasks) {
      action();
      return;
    }
    this.onAllTasksCompleted.add(() => {
      action();
    });
  }
  taskFinished(task) {
    const index = this.taskList.indexOf(task);
    if (index > -1) {
      this.taskList.splice(index, 1);
    }
    if (this.hasActiveTasks && this.taskList.length == 0) {
      this.hasActiveTasks = false;
      this.onAllTasksCompleted.fire(this, {});
    }
  }
};
__decorate([property({
  defaultValue: false
})], SurveyTaskManagerModel.prototype, "hasActiveTasks", void 0);
var PanelLayoutColumnModel = class extends Base {
  constructor(width, questionTitleWidth) {
    super();
    this.effectiveWidth = width;
    this.questionTitleWidth = questionTitleWidth;
  }
  getType() {
    return "panellayoutcolumn";
  }
  isEmpty() {
    return !this.width && !this.questionTitleWidth;
  }
};
__decorate([property()], PanelLayoutColumnModel.prototype, "width", void 0);
__decorate([property({
  onSet: (newValue, target, prevVal) => {
    if (newValue !== prevVal) {
      target.width = newValue;
    }
  }
})], PanelLayoutColumnModel.prototype, "effectiveWidth", void 0);
__decorate([property()], PanelLayoutColumnModel.prototype, "questionTitleWidth", void 0);
Serializer.addClass("panellayoutcolumn", [{
  name: "effectiveWidth:number",
  isSerializable: false,
  minValue: 0
}, {
  name: "width:number",
  visible: false
}, "questionTitleWidth"], (value) => new PanelLayoutColumnModel());
var QuestionRowModel = class _QuestionRowModel extends Base {
  static getRowId() {
    return "pr_" + _QuestionRowModel.rowCounter++;
  }
  get allowRendering() {
    return !this.panel || !this.panel.survey || !this.panel.survey["isLazyRenderingSuspended"];
  }
  startLazyRendering(rowContainerDiv, findScrollableContainer = findScrollableParent) {
    if (!DomDocumentHelper.isAvailable()) return;
    this._scrollableParent = findScrollableContainer(rowContainerDiv);
    if (this._scrollableParent === DomDocumentHelper.getDocumentElement()) {
      this._scrollableParent = DomWindowHelper.getWindow();
    }
    const hasScroll = this._scrollableParent.scrollHeight > this._scrollableParent.clientHeight;
    this.isNeedRender = !hasScroll;
    if (hasScroll) {
      this._updateVisibility = () => {
        if (!this.allowRendering) {
          return;
        }
        var isRowContainerDivVisible = isElementVisible(rowContainerDiv, 50);
        if (!this.isNeedRender && isRowContainerDivVisible) {
          this.isNeedRender = true;
          this.stopLazyRendering();
        }
      };
      setTimeout(() => {
        if (!!this._scrollableParent && !!this._scrollableParent.addEventListener) {
          this._scrollableParent.addEventListener("scroll", this._updateVisibility);
        }
        this.ensureVisibility();
      }, 10);
    }
  }
  ensureVisibility() {
    if (!!this._updateVisibility) {
      this._updateVisibility();
    }
  }
  stopLazyRendering() {
    if (!!this._scrollableParent && !!this._updateVisibility && !!this._scrollableParent.removeEventListener) {
      this._scrollableParent.removeEventListener("scroll", this._updateVisibility);
    }
    this._scrollableParent = void 0;
    this._updateVisibility = void 0;
  }
  constructor(panel) {
    super();
    this.panel = panel;
    this._scrollableParent = void 0;
    this._updateVisibility = void 0;
    this.visibleElementsAnimation = new AnimationGroup(this.getVisibleElementsAnimationOptions(), (value) => {
      this.setWidth(value);
      this.setPropertyValue("visibleElements", value);
    }, () => this.visibleElements);
    this.idValue = _QuestionRowModel.getRowId();
    this.visible = panel.areInvisibleElementsShowing;
    this.createNewArray("elements");
    this.createNewArray("visibleElements");
  }
  setIsLazyRendering(val) {
    this.isLazyRenderingValue = val;
    this.isNeedRender = !val;
  }
  isLazyRendering() {
    return this.isLazyRenderingValue === true;
  }
  get id() {
    return this.idValue;
  }
  equalsCore(obj) {
    return this == obj;
  }
  get elements() {
    return this.getPropertyValue("elements");
  }
  getIsAnimationAllowed() {
    var _a;
    return super.getIsAnimationAllowed() && this.visible && ((_a = this.panel) === null || _a === void 0 ? void 0 : _a.animationAllowed);
  }
  getVisibleElementsAnimationOptions() {
    const beforeRunAnimation = (el) => {
      prepareElementForVerticalAnimation(el);
      setPropertiesOnElementForAnimation(el, {
        width: getElementWidth(el) + "px"
      });
    };
    return {
      getRerenderEvent: () => this.onElementRerendered,
      isAnimationEnabled: () => this.animationAllowed,
      allowSyncRemovalAddition: false,
      getAnimatedElement: (element) => element.getWrapperElement(),
      getLeaveOptions: (element) => {
        const surveyElement = element;
        const cssClasses = element.isPanel ? surveyElement.cssClasses.panel : surveyElement.cssClasses;
        return {
          cssClass: cssClasses.leave,
          onBeforeRunAnimation: beforeRunAnimation,
          onAfterRunAnimation: cleanHtmlElementAfterAnimation
        };
      },
      getEnterOptions: (element) => {
        const surveyElement = element;
        const cssClasses = element.isPanel ? surveyElement.cssClasses.panel : surveyElement.cssClasses;
        return {
          cssClass: cssClasses.enter,
          onBeforeRunAnimation: beforeRunAnimation,
          onAfterRunAnimation: cleanHtmlElementAfterAnimation
        };
      }
    };
  }
  set visibleElements(val) {
    if (!val.length) {
      this.visible = false;
      this.visibleElementsAnimation.cancel();
      return;
    } else {
      this.visible = true;
    }
    this.visibleElementsAnimation.sync(val);
  }
  get visibleElements() {
    return this.getPropertyValue("visibleElements");
  }
  get visible() {
    return this.getPropertyValue("visible", true);
  }
  set visible(val) {
    this.setPropertyValue("visible", val);
    this.onVisibleChangedCallback && this.onVisibleChangedCallback();
  }
  get isNeedRender() {
    return this.getPropertyValue("isneedrender", true);
  }
  set isNeedRender(val) {
    this.setPropertyValue("isneedrender", val);
  }
  updateVisible() {
    var visElements = [];
    for (var i = 0; i < this.elements.length; i++) {
      if (this.elements[i].isVisible) {
        visElements.push(this.elements[i]);
      }
      if (this.elements[i].isPanel || this.elements[i].getType() === "paneldynamic") {
        this.setIsLazyRendering(false);
        this.stopLazyRendering();
      }
    }
    this.visibleElements = visElements;
    return;
  }
  addElement(q) {
    this.elements.push(q);
    this.updateVisible();
  }
  get index() {
    return this.panel.rows.indexOf(this);
  }
  setWidth(visibleElement) {
    var _a;
    var visCount = visibleElement.length;
    if (visCount == 0) return;
    const isSingleInRow = visibleElement.length === 1;
    var counter = 0;
    var preSetWidthElements = [];
    for (var i = 0; i < this.elements.length; i++) {
      var el = this.elements[i];
      if (el.isVisible) {
        el.isSingleInRow = isSingleInRow;
        var width = this.getElementWidth(el);
        if (!!width) {
          el.renderWidth = this.getRenderedWidthFromWidth(width);
          preSetWidthElements.push(el);
        }
        if (counter < visCount - 1 && !(this.panel.isDefaultV2Theme || ((_a = this.panel.parentQuestion) === null || _a === void 0 ? void 0 : _a.isDefaultV2Theme))) {
          el.rightIndent = 1;
        } else {
          el.rightIndent = 0;
        }
        counter++;
      } else {
        el.renderWidth = "";
      }
    }
    for (var i = 0; i < this.elements.length; i++) {
      var el = this.elements[i];
      if (!el.isVisible || preSetWidthElements.indexOf(el) > -1) continue;
      if (preSetWidthElements.length == 0) {
        el.renderWidth = `${Number.parseFloat((100 / visCount).toFixed(6))}%`;
      } else {
        el.renderWidth = this.getRenderedCalcWidth(el, preSetWidthElements, visCount);
      }
    }
  }
  getRenderedCalcWidth(el, preSetWidthElements, visCount) {
    var expression = "100%";
    for (var i = 0; i < preSetWidthElements.length; i++) {
      expression += " - " + preSetWidthElements[i].renderWidth;
    }
    var calcWidthEl = visCount - preSetWidthElements.length;
    if (calcWidthEl > 1) {
      expression = "(" + expression + ")/" + calcWidthEl.toString();
    }
    return "calc(" + expression + ")";
  }
  getElementWidth(el) {
    var width = el.width;
    if (!width || typeof width !== "string") return "";
    return width.trim();
  }
  getRenderedWidthFromWidth(width) {
    return Helpers.isNumber(width) ? width + "px" : width;
  }
  dispose() {
    super.dispose();
    this.stopLazyRendering();
  }
  getRowCss() {
    return new CssClassBuilder().append(this.panel.cssClasses.row).append(this.panel.cssClasses.rowCompact, this.panel["isCompact"]).append(this.panel.cssClasses.pageRow, this.panel.isPage || this.panel.showPanelAsPage).append(this.panel.cssClasses.rowMultiple, this.visibleElements.length > 1).toString();
  }
  setRootElement(element) {
    this.rootElement = element;
  }
  getRootElement() {
    return this.rootElement;
  }
};
QuestionRowModel.rowCounter = 100;
__decorate([property({
  defaultValue: null
})], QuestionRowModel.prototype, "dragTypeOverMe", void 0);
var PanelModelBase = class _PanelModelBase extends SurveyElement {
  static getPanelId() {
    return "sp_" + _PanelModelBase.panelCounter++;
  }
  /**
   * An array of columns used to arrange survey elements within this page or panel. Applies only if you set the `SurveyModel`'s [`gridLayoutEnabled`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#gridLayoutEnabled) property to `true`.
   *
   * Each object in this array configures a single layout column and has the following properties:
   *
   * - `width`: `number`\
   * Column width, in percentage.
   *
   * - `questionTitleWidth`: `string`\
   * The width of question titles, in pixels.
   *
   * The `gridLayoutColumns` array is generated automatically based on the maximum number of questions and panels in the same row. To arrange the survey elements in one or several rows, disable the [`startWithNewLine`](https://surveyjs.io/form-library/documentation/api-reference/question#startWithNewLine) property for those elements that should occupy the same row as the previous question or panel. You can also set the [`colSpan`](https://surveyjs.io/form-library/documentation/api-reference/question#colSpan) property for individual questions and panels to specify how many layout columns they span.
   */
  get gridLayoutColumns() {
    let res = this.getPropertyValue("gridLayoutColumns");
    if (!this._columns) {
      this.generateColumns([].concat(res));
      res = this._columns;
      this.gridLayoutColumns = res;
    }
    return res;
  }
  set gridLayoutColumns(val) {
    this.setPropertyValue("gridLayoutColumns", val);
  }
  onAddRow(row) {
    this.onRowVisibleChanged();
    row.onVisibleChangedCallback = () => this.onRowVisibleChanged();
  }
  getRowsAnimationOptions() {
    return {
      getRerenderEvent: () => this.onElementRerendered,
      isAnimationEnabled: () => this.animationAllowed,
      getAnimatedElement: (row) => row.getRootElement(),
      getLeaveOptions: (row, info) => {
        return {
          cssClass: this.cssClasses.rowLeave,
          onBeforeRunAnimation: prepareElementForVerticalAnimation,
          onAfterRunAnimation: cleanHtmlElementAfterAnimation
        };
      },
      getEnterOptions: (_, animationInfo) => {
        const cssClasses = this.cssClasses;
        return {
          cssClass: new CssClassBuilder().append(cssClasses.rowEnter).append(cssClasses.rowDelayedEnter, animationInfo.isDeletingRunning).toString(),
          onBeforeRunAnimation: prepareElementForVerticalAnimation,
          onAfterRunAnimation: cleanHtmlElementAfterAnimation
        };
      }
    };
  }
  get visibleRows() {
    return this.getPropertyValue("visibleRows");
  }
  set visibleRows(val) {
    this.rowsAnimation.sync(val);
  }
  onRemoveRow(row) {
    row.visibleElementsAnimation.cancel();
    this.visibleRows = this.rows.filter((row2) => row2.visible);
    row.onVisibleChangedCallback = void 0;
  }
  onRowVisibleChanged() {
    this.visibleRows = this.rows.filter((row) => row.visible);
  }
  constructor(name = "") {
    super(name);
    this.isQuestionsReady = false;
    this.questionsValue = new Array();
    this._columns = void 0;
    this._columnsReady = false;
    this.rowsAnimation = new AnimationGroup(this.getRowsAnimationOptions(), (value) => {
      this.setPropertyValue("visibleRows", value);
    }, () => this.visibleRows);
    this.isRandomizing = false;
    this.onColumnPropertyValueChangedCallback = (name2, oldValue, newValue, sender, arrayChanges) => {
      if (this._columnsReady) {
        this.updateColumnWidth(this.gridLayoutColumns);
        this.updateRootStyle();
      }
    };
    this.locCountRowUpdates = 0;
    this.createNewArray("rows", (el, index) => {
      this.onAddRow(el);
    }, (el) => {
      this.onRemoveRow(el);
    });
    this.createNewArray("visibleRows");
    this.createNewArray("gridLayoutColumns", (col) => {
      col.onPropertyValueChangedCallback = this.onColumnPropertyValueChangedCallback;
    });
    this.elementsValue = this.createNewArray("elements", this.onAddElement.bind(this), this.onRemoveElement.bind(this));
    this.setPropertyValueDirectly("id", _PanelModelBase.getPanelId());
    this.addExpressionProperty("visibleIf", (obj, res) => {
      this.visible = res === true;
    }, (obj) => {
      return !this.areInvisibleElementsShowing;
    });
    this.addExpressionProperty("enableIf", (obj, res) => {
      this.readOnly = res === false;
    });
    this.addExpressionProperty("requiredIf", (obj, res) => {
      this.isRequired = res === true;
    });
    this.createLocalizableString("requiredErrorText", this);
    this.createLocalizableString("navigationTitle", this, true).onGetTextCallback = (text) => {
      return text || this.title || this.name;
    };
    this.registerPropertyChangedHandlers(["questionTitleLocation"], () => {
      this.onVisibleChanged.bind(this);
      this.updateElementCss(true);
    });
    this.registerPropertyChangedHandlers(["questionStartIndex", "showQuestionNumbers"], () => {
      this.updateVisibleIndexes();
    });
    this.registerPropertyChangedHandlers(["title"], () => {
      this.resetHasTextInTitle();
    });
  }
  getType() {
    return "panelbase";
  }
  setSurveyImpl(value, isLight) {
    this.blockAnimations();
    super.setSurveyImpl(value, isLight);
    if (this.isDesignMode) this.onVisibleChanged();
    for (var i = 0; i < this.elements.length; i++) {
      this.elements[i].setSurveyImpl(value, isLight);
    }
    this.releaseAnimations();
  }
  endLoadingFromJson() {
    super.endLoadingFromJson();
    this.markQuestionListDirty();
    this.onRowsChanged();
  }
  get hasTextInTitle() {
    return this.getPropertyValue("hasTextInTitle", void 0, () => !!this.title);
  }
  resetHasTextInTitle() {
    this.resetPropertyValue("hasTextInTitle");
  }
  get hasTitle() {
    return this.canShowTitle(this.survey) && (this.hasTextInTitle || this.locTitle.textOrHtml.length > 0) || this.isDesignMode && !this.isPanel && this.showTitle && settings.designMode.showEmptyTitles;
  }
  delete(doDispose = true) {
    this.deletePanel();
    this.removeFromParent();
    if (doDispose) {
      this.dispose();
    }
  }
  deletePanel() {
    const els = this.elements;
    for (let i = 0; i < els.length; i++) {
      const el = els[i];
      if (el.isPanel) {
        el.deletePanel();
      }
      this.onRemoveElementNotifySurvey(el);
    }
  }
  removeFromParent() {
  }
  canShowTitle(survey) {
    return true;
  }
  get _showDescription() {
    if (!this.hasTitle && this.isDesignMode) return false;
    return this.survey && this.survey.showPageTitles && this.hasDescription || this.showDescription && this.isDesignMode && settings.designMode.showEmptyDescriptions;
  }
  localeChanged() {
    super.localeChanged();
    for (var i = 0; i < this.elements.length; i++) {
      this.elements[i].localeChanged();
    }
  }
  locStrsChanged() {
    super.locStrsChanged();
    for (var i = 0; i < this.elements.length; i++) {
      this.elements[i].locStrsChanged();
    }
  }
  getMarkdownHtml(text, name) {
    if (name === "navigationTitle" && this.locNavigationTitle.isEmpty) {
      return this.locTitle.renderedHtml || this.name;
    }
    return super.getMarkdownHtml(text, name);
  }
  get locNavigationTitle() {
    return this.getLocalizableString("navigationTitle");
  }
  get renderedNavigationTitle() {
    return this.locNavigationTitle.renderedHtml;
  }
  /**
   * Returns a character or text string that indicates a required panel/page.
   * @see SurveyModel.requiredMark
   * @see isRequired
   */
  get requiredMark() {
    return !!this.survey && this.isRequired ? this.survey.requiredMark : "";
  }
  /**
   * @deprecated Use the [`requiredMark`](https://surveyjs.io/form-library/documentation/api-reference/panel-model#requiredMark) property instead.
   */
  get requiredText() {
    return this.requiredMark;
  }
  get titlePattern() {
    return !!this.survey ? this.survey.questionTitlePattern : "numTitleRequire";
  }
  get isRequireTextOnStart() {
    return this.isRequired && this.titlePattern == "requireNumTitle";
  }
  get isRequireTextBeforeTitle() {
    return this.isRequired && this.titlePattern == "numRequireTitle";
  }
  get isRequireTextAfterTitle() {
    return this.isRequired && this.titlePattern == "numTitleRequire";
  }
  /**
   * Specifies a custom error message for a required panel/page.
   * @see isRequired
   * @see requiredIf
   */
  get requiredErrorText() {
    return this.getLocalizableStringText("requiredErrorText");
  }
  set requiredErrorText(val) {
    this.setLocalizableStringText("requiredErrorText", val);
  }
  get locRequiredErrorText() {
    return this.getLocalizableString("requiredErrorText");
  }
  /**
   * Specifies the sort order of questions in the panel/page.
   *
   * Possible values:
   *
   * - `"initial"` - Preserves the original order of questions.
   * - `"random"` - Displays questions in random order.
   * - `"default"` (default) - Inherits the setting from the `SurveyModel`'s [`questionOrder`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#questionOrder) property.
   * @see areQuestionsRandomized
   */
  get questionOrder() {
    return this.getPropertyValue("questionOrder");
  }
  set questionOrder(val) {
    this.setPropertyValue("questionOrder", val);
  }
  /**
   * @deprecated Use the [`questionOrder`](https://surveyjs.io/form-library/documentation/api-reference/panel-model#questionOrder) property instead.
   */
  get questionsOrder() {
    return this.questionOrder;
  }
  set questionsOrder(val) {
    this.questionOrder = val;
  }
  canRandomize(isRandom) {
    return isRandom && this.questionOrder !== "initial" || this.questionOrder === "random";
  }
  randomizeElements(isRandom) {
    if (!this.canRandomize(isRandom) || this.isRandomizing) return false;
    this.isRandomizing = true;
    var oldElements = [];
    var elements = this.elements;
    for (var i = 0; i < elements.length; i++) {
      oldElements.push(elements[i]);
    }
    const newElements = Helpers.randomizeArray(oldElements);
    this.setArrayPropertyDirectly("elements", newElements, false);
    this.updateRows();
    this.updateVisibleIndexes();
    this.isRandomizing = false;
    return true;
  }
  /**
   * Returns `true` if elements in this panel/page are arranged in random order.
   * @see questionOrder
   */
  get areQuestionsRandomized() {
    var order = this.questionOrder == "default" && this.survey ? this.survey.questionOrder : this.questionOrder;
    return order == "random";
  }
  /**
   * Returns a survey element (panel or page) that contains this panel and allows you to move the panel to a different survey element.
   *
   * For `PageModel` objects, the `parent` property is `null`, except in the following cases:
   *
   * - `SurveyModel`'s [`questionsOnPageMode`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#questionsOnPageMode) is set to `"singlePage"`.
   * - The page is included in a [preview of given answers](https://surveyjs.io/form-library/documentation/design-survey/create-a-multi-page-survey#preview-page).
   *
   * In those cases, the survey creates an internal `PageModel` object to show all questions on one page, and the `parent` property contains this object.
   */
  get parent() {
    return this.getPropertyValue("parent", null);
  }
  set parent(val) {
    this.setPropertyValue("parent", val);
  }
  get depth() {
    if (this.parent == null) return 0;
    return this.parent.depth + 1;
  }
  /**
   * A Boolean expression. If it evaluates to `false`, this panel/page becomes hidden.
   *
   * A survey parses and runs all expressions on startup. If any values used in the expression change, the survey re-evaluates it.
   *
   * Refer to the following help topic for more information: [Conditional Visibility](https://surveyjs.io/form-library/documentation/design-survey-conditional-logic#conditional-visibility).
   * @see visible
   * @see isVisible
   */
  get visibleIf() {
    return this.getPropertyValue("visibleIf", "");
  }
  set visibleIf(val) {
    this.setPropertyValue("visibleIf", val);
  }
  calcCssClasses(css) {
    var classes = {
      panel: {},
      error: {},
      row: "",
      rowEnter: "",
      rowLeave: "",
      rowDelayedEnter: "",
      rowMultiple: "",
      pageRow: "",
      rowCompact: ""
    };
    this.copyCssClasses(classes.panel, css.panel);
    this.copyCssClasses(classes.error, css.error);
    if (!!css.pageRow) {
      classes.pageRow = css.pageRow;
    }
    if (!!css.rowCompact) {
      classes.rowCompact = css.rowCompact;
    }
    if (!!css.row) {
      classes.row = css.row;
    }
    if (!!css.rowEnter) {
      classes.rowEnter = css.rowEnter;
    }
    if (!!css.rowLeave) {
      classes.rowLeave = css.rowLeave;
    }
    if (!!css.rowDelayedEnter) {
      classes.rowDelayedEnter = css.rowDelayedEnter;
    }
    if (!!css.rowMultiple) {
      classes.rowMultiple = css.rowMultiple;
    }
    if (this.survey) {
      this.survey.updatePanelCssClasses(this, classes);
    }
    return classes;
  }
  /**
   * An auto-generated unique element identifier.
   */
  get id() {
    return this.getPropertyValue("id");
  }
  set id(val) {
    this.setPropertyValue("id", val);
  }
  get isPanel() {
    return false;
  }
  getPanel() {
    return this;
  }
  getLayoutType() {
    return "row";
  }
  isLayoutTypeSupported(layoutType) {
    return layoutType !== "flow";
  }
  /**
   * An array of all questions within this panel/page. Includes questions within nested panels.
   * @see elements
   */
  get questions() {
    if (!this.isQuestionsReady) {
      this.questionsValue = [];
      for (var i = 0; i < this.elements.length; i++) {
        var el = this.elements[i];
        if (el.isPanel) {
          var qs = el.questions;
          for (var j = 0; j < qs.length; j++) {
            this.questionsValue.push(qs[j]);
          }
        } else {
          this.questionsValue.push(el);
        }
      }
      this.isQuestionsReady = true;
    }
    return this.questionsValue;
  }
  getQuestions(includeNested) {
    const res = this.questions;
    if (!includeNested) return res;
    const res2 = [];
    res.forEach((q) => {
      res2.push(q);
      q.getNestedQuestions().forEach((nQ) => res2.push(nQ));
    });
    return res2;
  }
  getValidName(name) {
    if (!!name) return name.trim();
    return name;
  }
  /**
   * Returns a question with a specified `name`. This method does not find questions within nested panels.
   * @param name A question name.
   */
  getQuestionByName(name) {
    var questions = this.questions;
    for (var i = 0; i < questions.length; i++) {
      if (questions[i].name == name) return questions[i];
    }
    return null;
  }
  /**
   * Returns a survey element with a specified `name`. This method can find survey elements within nested elements.
   * @param name An element name.
   */
  getElementByName(name) {
    var elements = this.elements;
    for (var i = 0; i < elements.length; i++) {
      var el = elements[i];
      if (el.name == name) return el;
      var pnl = el.getPanel();
      if (!!pnl) {
        var res = pnl.getElementByName(name);
        if (!!res) return res;
      }
    }
    return null;
  }
  getQuestionByValueName(valueName) {
    const res = this.getQuestionsByValueName(valueName);
    return res.length > 0 ? res[0] : null;
  }
  getQuestionsByValueName(valueName) {
    const res = [];
    var questions = this.questions;
    for (var i = 0; i < questions.length; i++) {
      if (questions[i].getValueName() == valueName) res.push(questions[i]);
    }
    return res;
  }
  /**
   * Returns a JSON object with question values nested in the panel/page.
   * @see getDisplayValue
   */
  getValue() {
    var data = {};
    this.collectValues(data, 0);
    return Helpers.getUnbindValue(data);
  }
  collectValues(data, level) {
    let elements = this.elements;
    if (level === 0) {
      elements = this.questions;
    }
    for (var i = 0; i < elements.length; i++) {
      const el = elements[i];
      if (el.isPanel || el.isPage) {
        const panelData = {};
        if (el.collectValues(panelData, level - 1)) {
          data[el.name] = panelData;
        }
      } else {
        const q = el;
        if (!q.isEmpty()) {
          var valueName = q.getValueName();
          data[valueName] = q.value;
          if (!!this.data) {
            var comment = this.data.getComment(valueName);
            if (!!comment) {
              data[valueName + Base.commentSuffix] = comment;
            }
          }
        }
      }
    }
    return true;
  }
  /**
   * Returns a JSON object with display texts that correspond to question values nested in the panel/page.
   * @param keysAsText Pass `true` if not only values in the object should be display texts, but also keys. Default value: `false`.
   * @see getValue
   */
  getDisplayValue(keysAsText) {
    var data = {};
    var questions = this.questions;
    for (var i = 0; i < questions.length; i++) {
      var q = questions[i];
      if (q.isEmpty()) continue;
      var valueName = keysAsText ? q.title : q.getValueName();
      data[valueName] = q.getDisplayValue(keysAsText);
    }
    return data;
  }
  /**
   * Returns a JSON object with comments left to questions within this panel/page. Question names are used as keys.
   */
  getComments() {
    var comments = {};
    if (!this.data) return comments;
    var questions = this.questions;
    for (var i = 0; i < questions.length; i++) {
      var q = questions[i];
      var comment = this.data.getComment(q.getValueName());
      if (!!comment) {
        comments[q.getValueName()] = comment;
      }
    }
    return comments;
  }
  /**
   * Removes values that cannot be assigned to nested questions, for example, choices unlisted in the `choices` array.
   *
   * Call this method after you assign new question values in code to ensure that they are acceptable.
   *
   * > This method does not remove values for invisible questions and values that fail validation. Call the `validate()` method to validate newly assigned values.
   *
   * @see validate
   */
  clearIncorrectValues() {
    for (var i = 0; i < this.elements.length; i++) {
      this.elements[i].clearIncorrectValues();
    }
  }
  /**
   * Empties the `errors` array for this panel/page and all its child elements (panels and questions).
   * @see errors
   */
  clearErrors() {
    for (var i = 0; i < this.elements.length; i++) {
      this.elements[i].clearErrors();
    }
    this.errors = [];
  }
  markQuestionListDirty() {
    this.isQuestionsReady = false;
    if (this.parent) this.parent.markQuestionListDirty();
  }
  /**
   * An array of all survey elements (questions or panels) within this panel/page. Does not include questions within nested panels.
   * @see questions
   */
  get elements() {
    Base.collectDependency(this, "elements");
    return this.elementsValue;
  }
  getElementsInDesign(includeHidden = false) {
    return this.elements;
  }
  /**
   * Checks whether a given element belongs to this panel/page or nested panels.
   * @param element A survey element to check.
   */
  containsElement(element) {
    for (var i = 0; i < this.elements.length; i++) {
      var el = this.elements[i];
      if (el == element) return true;
      var pnl = el.getPanel();
      if (!!pnl) {
        if (pnl.containsElement(element)) return true;
      }
    }
    return false;
  }
  /**
   * Makes the panel/page require an answer at least in one nested question. If a respondent leaves the panel/page without any answers, the survey displays a validation error.
   * @see requiredIf
   * @see [Data Validation](https://surveyjs.io/form-library/documentation/data-validation)
   */
  get isRequired() {
    return this.getPropertyValue("isRequired");
  }
  set isRequired(val) {
    this.setPropertyValue("isRequired", val);
  }
  /**
   * A Boolean expression. If it evaluates to `true`, this panel/page becomes required (at least one question in the panel/page should have an answer).
   *
   * A survey parses and runs all expressions on startup. If any values used in the expression change, the survey re-evaluates it.
   *
   * Refer to the following help topic for more information: [Conditional Visibility](https://surveyjs.io/form-library/documentation/design-survey-conditional-logic#conditional-visibility).
   * @see isRequired
   */
  get requiredIf() {
    return this.getPropertyValue("requiredIf", "");
  }
  set requiredIf(val) {
    this.setPropertyValue("requiredIf", val);
  }
  searchText(text, founded) {
    super.searchText(text, founded);
    for (var i = 0; i < this.elements.length; i++) {
      this.elements[i].searchText(text, founded);
    }
  }
  hasErrors(fireCallback = true, focusOnFirstError = false, rec = null) {
    return !this.validate(fireCallback, focusOnFirstError, rec);
  }
  /**
   * Validates questions within this panel or page and returns `false` if the validation fails.
   * @param fireCallback *(Optional)* Pass `false` if you do not want to show validation errors in the UI.
   * @param focusFirstError *(Optional)* Pass `true` if you want to focus the first question with a validation error.
   * @see [Data Validation](https://surveyjs.io/form-library/documentation/data-validation)
   */
  validate(fireCallback = true, focusFirstError = false, rec = null) {
    rec = !!rec ? rec : {
      fireCallback,
      focusOnFirstError: focusFirstError,
      firstErrorQuestion: null,
      result: false
    };
    if (rec.result !== true) rec.result = false;
    this.hasErrorsCore(rec);
    return !rec.result;
  }
  validateContainerOnly() {
    this.hasErrorsInPanels({
      fireCallback: true
    });
    if (!!this.parent) {
      this.parent.validateContainerOnly();
    }
  }
  onQuestionValueChanged(el) {
    const index = this.questions.indexOf(el);
    if (index < 0) return;
    const dif = 5;
    const max2 = this.questions.length - 1;
    const start = index - dif > 0 ? index - dif : 0;
    const end = index + dif < max2 ? index + dif : max2;
    for (let i = start; i <= end; i++) {
      if (i === index) continue;
      const q = this.questions[i];
      if (q.errors.length > 0 && q.validate(false)) {
        q.validate(true);
      }
    }
  }
  hasErrorsInPanels(rec) {
    var errors = [];
    this.hasRequiredError(rec, errors);
    if (this.survey) {
      this.survey.validatePanel(this, errors, rec.fireCallback);
      if (errors.length > 0) {
        rec.result = true;
      }
    }
    if (!!rec.fireCallback) {
      this.errors = errors;
    }
  }
  //ISurveyErrorOwner
  getErrorCustomText(text, error) {
    if (!!this.survey) return this.survey.getSurveyErrorCustomText(this, text, error);
    return text;
  }
  hasRequiredError(rec, errors) {
    if (!this.isRequired) return;
    var visQuestions = [];
    this.addQuestionsToList(visQuestions, true);
    if (visQuestions.length == 0) return;
    for (var i = 0; i < visQuestions.length; i++) {
      if (!visQuestions[i].isEmpty()) return;
    }
    rec.result = true;
    errors.push(new OneAnswerRequiredError(this.requiredErrorText, this));
    if (rec.focusOnFirstError && !rec.firstErrorQuestion) {
      rec.firstErrorQuestion = visQuestions[0];
    }
  }
  hasErrorsCore(rec) {
    const elements = this.elements;
    let element = null;
    let firstErroredEl = null;
    for (var i = 0; i < elements.length; i++) {
      element = elements[i];
      if (!element.isVisible) continue;
      if (element.isPanel) {
        element.hasErrorsCore(rec);
      } else {
        var question = element;
        if (!question.validate(rec.fireCallback, rec)) {
          if (!firstErroredEl) {
            firstErroredEl = question;
          }
          if (!rec.firstErrorQuestion) {
            rec.firstErrorQuestion = question;
          }
          rec.result = true;
        }
      }
    }
    this.hasErrorsInPanels(rec);
    this.updateContainsErrors();
    if (!firstErroredEl && this.errors.length > 0) {
      firstErroredEl = this.getFirstQuestionToFocus(false, true);
      if (!rec.firstErrorQuestion) {
        rec.firstErrorQuestion = firstErroredEl;
      }
    }
    if (rec.fireCallback && firstErroredEl) {
      if (firstErroredEl === rec.firstErrorQuestion && rec.focusOnFirstError) {
        firstErroredEl.focus(true);
      } else {
        firstErroredEl.expandAllParents();
      }
    }
  }
  getContainsErrors() {
    var res = super.getContainsErrors();
    if (res) return res;
    var elements = this.elements;
    for (var i = 0; i < elements.length; i++) {
      if (elements[i].containsErrors) return true;
    }
    return false;
  }
  updateElementVisibility() {
    for (let i = 0; i < this.elements.length; i++) {
      this.elements[i].updateElementVisibility();
    }
    super.updateElementVisibility();
  }
  getFirstQuestionToFocus(withError = false, ignoreCollapseState = false) {
    if (!withError && !ignoreCollapseState && this.isCollapsed) return null;
    var elements = this.elements;
    for (var i = 0; i < elements.length; i++) {
      var el = elements[i];
      if (!el.isVisible || !ignoreCollapseState && el.isCollapsed) continue;
      if (el.isPanel) {
        var res = el.getFirstQuestionToFocus(withError, ignoreCollapseState);
        if (!!res) return res;
      } else {
        const q = el.getFirstQuestionToFocus(withError);
        if (!!q) return q;
      }
    }
    return null;
  }
  getFirstVisibleQuestion() {
    const qs = this.questions;
    for (let i = 0; i < qs.length; i++) {
      if (qs[i].isVisible) return qs[i];
    }
    return null;
  }
  /**
   * Focuses the first question in this panel/page.
   * @see focusFirstErrorQuestion
   */
  focusFirstQuestion() {
    const q = this.getFirstQuestionToFocus();
    if (!!q) {
      q.focus();
    }
  }
  /**
   * Focuses the first question with a validation error in this panel/page.
   * @see validate
   * @see focusFirstQuestion
   */
  focusFirstErrorQuestion() {
    var q = this.getFirstQuestionToFocus(true);
    if (!!q) {
      q.focus();
    }
  }
  addQuestionsToList(list, visibleOnly = false, includingDesignTime = false) {
    this.addElementsToList(list, visibleOnly, includingDesignTime, false);
  }
  addPanelsIntoList(list, visibleOnly = false, includingDesignTime = false) {
    this.addElementsToList(list, visibleOnly, includingDesignTime, true);
  }
  addElementsToList(list, visibleOnly, includingDesignTime, isPanel) {
    if (visibleOnly && !this.visible) return;
    this.addElementsToListCore(list, this.elements, visibleOnly, includingDesignTime, isPanel);
  }
  addElementsToListCore(list, elements, visibleOnly, includingDesignTime, isPanel) {
    for (var i = 0; i < elements.length; i++) {
      var el = elements[i];
      if (visibleOnly && !el.visible) continue;
      if (isPanel && el.isPanel || !isPanel && !el.isPanel) {
        list.push(el);
      }
      if (el.isPanel) {
        el.addElementsToListCore(list, el.elements, visibleOnly, includingDesignTime, isPanel);
      } else {
        if (includingDesignTime) {
          this.addElementsToListCore(list, el.getElementsInDesign(false), visibleOnly, includingDesignTime, isPanel);
        }
      }
    }
  }
  calcMaxRowColSpan() {
    let maxRowColSpan = 0;
    this.rows.forEach((row) => {
      let curRowSpan = 0;
      let userDefinedRow = false;
      row.elements.forEach((el) => {
        if (!!el.width) {
          userDefinedRow = true;
        }
        curRowSpan += el.colSpan || 1;
      });
      if (!userDefinedRow && curRowSpan > maxRowColSpan) maxRowColSpan = curRowSpan;
    });
    return maxRowColSpan;
  }
  updateColumnWidth(columns) {
    let remainingSpace = 0, remainingColCount = 0;
    columns.forEach((col) => {
      if (!col.width) {
        remainingColCount++;
      } else {
        remainingSpace += col.width;
        col.setPropertyValue("effectiveWidth", col.width);
      }
    });
    if (!!remainingColCount) {
      const oneColumnWidth = floorTo2Decimals((100 - remainingSpace) / remainingColCount);
      for (let index = 0; index < columns.length; index++) {
        if (!columns[index].width) {
          columns[index].setPropertyValue("effectiveWidth", oneColumnWidth);
        }
      }
    }
  }
  updateColumns() {
    this._columns = void 0;
    this.updateRootStyle();
  }
  updateRootStyle() {
    var _a;
    super.updateRootStyle();
    (_a = this.elements) === null || _a === void 0 ? void 0 : _a.forEach((el) => el.updateRootStyle());
  }
  updateCustomWidgets() {
    for (var i = 0; i < this.elements.length; i++) {
      this.elements[i].updateCustomWidgets();
    }
  }
  /**
   * Sets a title location relative to the input field for questions that belong to this panel/page.
   *
   * Use this property to override the [`questionTitleLocation`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#questionTitleLocation) property specified for the survey or parent page. You can also set the [`titleLocation`](https://surveyjs.io/form-library/documentation/api-reference/question#titleLocation) property for individual questions.
   *
   * Possible values:
   *
   * - `"default"` (default) - Inherits the setting from the `questionTitleLocation` property specified for the survey or parent page.
   * - `"top"` - Displays the title above the input field.
   * - `"bottom"` - Displays the title below the input field.
   * - `"left"` - Displays the title to the left of the input field.
   * - `"hidden"` - Hides the question title.
   *
   * > Certain question types (Matrix, Multiple Text) do not support the `"left"` value. For them, the `"top"` value is used.
   */
  get questionTitleLocation() {
    return this.getPropertyValue("questionTitleLocation");
  }
  set questionTitleLocation(value) {
    this.setPropertyValue("questionTitleLocation", value.toLowerCase());
  }
  getQuestionTitleLocation() {
    if (this.onGetQuestionTitleLocation) return this.onGetQuestionTitleLocation();
    if (this.questionTitleLocation != "default") return this.questionTitleLocation;
    if (this.parent) return this.parent.getQuestionTitleLocation();
    return this.survey ? this.survey.questionTitleLocation : "top";
  }
  availableQuestionTitleWidth() {
    const questionTitleLocation = this.getQuestionTitleLocation();
    if (questionTitleLocation === "left") return true;
    return this.hasElementWithTitleLocationLeft();
  }
  hasElementWithTitleLocationLeft() {
    const result = this.elements.some((el) => {
      if (el instanceof _PanelModelBase) {
        return el.hasElementWithTitleLocationLeft();
      } else if (el instanceof Question) {
        return el.getTitleLocation() === "left";
      }
    });
    return result;
  }
  getQuestionTitleWidth() {
    return this.questionTitleWidth || this.parent && this.parent.getQuestionTitleWidth();
  }
  get columns() {
    if (!this._columns) {
      this.generateColumns(this.gridLayoutColumns);
      this.gridLayoutColumns = this._columns;
    }
    return this._columns || [];
  }
  generateColumns(gridColumns) {
    var _a;
    const isEnabled = (_a = this.survey) === null || _a === void 0 ? void 0 : _a.gridLayoutEnabled;
    let columns = [].concat(gridColumns);
    if (isEnabled) {
      let maxRowColSpan = this.calcMaxRowColSpan();
      if (maxRowColSpan <= gridColumns.length) {
        columns = gridColumns.slice(0, maxRowColSpan);
      } else {
        for (let index = gridColumns.length; index < maxRowColSpan; index++) {
          const newCol = new PanelLayoutColumnModel();
          columns.push(newCol);
        }
      }
    }
    this._columns = columns;
    try {
      this._columnsReady = false;
      this.updateColumnWidth(columns);
    } finally {
      this._columnsReady = true;
    }
  }
  createGridLayoutColumns() {
    this.generateColumns([]);
    return this._columns;
  }
  updateGridColumns() {
    this.updateColumns();
    this.elements.forEach((el) => {
      el.isPanel && el.updateGridColumns();
    });
  }
  getColumsForElement(el) {
    const row = this.findRowByElement(el);
    if (!row || !this.survey || !this.survey.gridLayoutEnabled) return [];
    let lastExpandableElementIndex = row.elements.length - 1;
    while (lastExpandableElementIndex >= 0) {
      if (!row.elements[lastExpandableElementIndex].getPropertyValueWithoutDefault("colSpan")) {
        break;
      }
      lastExpandableElementIndex--;
    }
    const elementIndex = row.elements.indexOf(el);
    let startIndex = 0;
    for (let index = 0; index < elementIndex; index++) {
      startIndex += row.elements[index].colSpan;
    }
    let currentColSpan = el.getPropertyValueWithoutDefault("colSpan");
    if (!currentColSpan && elementIndex === lastExpandableElementIndex) {
      let usedSpans = 0;
      for (let index = 0; index < row.elements.length; index++) {
        if (index !== lastExpandableElementIndex) {
          usedSpans += row.elements[index].colSpan;
        }
      }
      currentColSpan = this.columns.length - usedSpans;
    }
    const result = this.columns.slice(startIndex, startIndex + (currentColSpan || 1));
    el.setPropertyValueDirectly("effectiveColSpan", result.length);
    return result;
  }
  getStartIndex() {
    if (!!this.parent) return this.parent.getQuestionStartIndex();
    if (!!this.survey) return this.survey.questionStartIndex;
    return "";
  }
  getQuestionStartIndex() {
    return this.getStartIndex();
  }
  getChildrenLayoutType() {
    return "row";
  }
  getProgressInfo() {
    return SurveyElement.getProgressInfoByElements(this.elements, this.isRequired);
  }
  get root() {
    var res = this;
    while (res.parent) res = res.parent;
    return res;
  }
  childVisibilityChanged() {
    var newIsVisibleValue = this.getIsPageVisible(null);
    var oldIsVisibleValue = this.getPropertyValue("isVisible", true);
    if (newIsVisibleValue !== oldIsVisibleValue) {
      this.onVisibleChanged();
    }
  }
  canRenderFirstRows() {
    return this.isPage;
  }
  isLazyRenderInRow(rowIndex) {
    if (!this.survey || !this.survey.isLazyRendering) return false;
    return rowIndex >= this.survey.lazyRenderFirstBatchSize || !this.canRenderFirstRows();
  }
  createRowAndSetLazy(index) {
    const row = this.createRow();
    row.setIsLazyRendering(this.isLazyRenderInRow(index));
    return row;
  }
  createRow() {
    return new QuestionRowModel(this);
  }
  onSurveyLoad() {
    this.blockAnimations();
    super.onSurveyLoad();
    for (var i = 0; i < this.elements.length; i++) {
      this.elements[i].onSurveyLoad();
    }
    this.onElementVisibilityChanged(this);
    this.releaseAnimations();
  }
  onFirstRenderingCore() {
    super.onFirstRenderingCore();
    this.onRowsChanged();
    this.elements.forEach((el) => el.onFirstRendering());
  }
  updateRows() {
    if (this.isLoadingFromJson) return;
    this.getElementsForRows().forEach((el) => {
      if (el.isPanel) {
        el.updateRows();
      }
    });
    this.onRowsChanged();
  }
  get rows() {
    return this.getPropertyValue("rows");
  }
  ensureRowsVisibility() {
    this.rows.forEach((row) => {
      row.ensureVisibility();
    });
  }
  onRowsChanged() {
    if (this.isLoadingFromJson) return;
    this.blockAnimations();
    this.setArrayPropertyDirectly("rows", this.buildRows());
    this.updateColumns();
    this.releaseAnimations();
  }
  blockRowsUpdates() {
    this.locCountRowUpdates++;
  }
  releaseRowsUpdates() {
    this.locCountRowUpdates--;
  }
  updateRowsBeforeElementRemoved(element) {
    const elementRow = this.findRowByElement(element);
    const elementRowIndex = this.rows.indexOf(elementRow);
    const elementIndexInRow = elementRow.elements.indexOf(element);
    elementRow.elements.splice(elementIndexInRow, 1);
    if (elementRow.elements.length == 0) {
      this.rows.splice(elementRowIndex, 1);
    } else if (!elementRow.elements[0].startWithNewLine && this.rows[elementRowIndex - 1]) {
      elementRow.elements.forEach((el) => this.rows[elementRowIndex - 1].addElement(el));
      this.rows.splice(elementRowIndex, 1);
    } else {
      elementRow.updateVisible();
    }
  }
  updateRowsOnElementAdded(element) {
    const index = this.elements.indexOf(element);
    const targetElement = this.elements[index + 1];
    const createRowAtIndex = (index2) => {
      const row = this.createRowAndSetLazy(index2);
      if (this.isDesignMode) {
        row.setIsLazyRendering(false);
      }
      this.rows.splice(index2, 0, row);
      return row;
    };
    const updateRow = (row, start, deleteCount, ...elements) => {
      const removedElements = row.elements.splice(start, deleteCount, ...elements);
      row.updateVisible();
      return removedElements;
    };
    if (!targetElement) {
      if (index == 0 || element.startWithNewLine) {
        updateRow(createRowAtIndex(this.rows.length), 0, 0, element);
      } else {
        this.rows[this.rows.length - 1].addElement(element);
      }
      return;
    }
    const targetRow = this.findRowByElement(targetElement);
    if (!targetRow) return;
    const targetRowIndex = this.rows.indexOf(targetRow);
    const targetElementIndexInRow = targetRow.elements.indexOf(targetElement);
    if (targetElementIndexInRow == 0) {
      if (!targetElement.startWithNewLine) {
        updateRow(targetRow, 0, 0, element);
      } else if (element.startWithNewLine || targetRowIndex < 1) {
        createRowAtIndex(targetRowIndex).addElement(element);
      } else {
        this.rows[targetRowIndex - 1].addElement(element);
      }
    } else {
      if (element.startWithNewLine) {
        updateRow(createRowAtIndex(targetRowIndex + 1), 0, 0, ...[element].concat(updateRow(targetRow, targetElementIndexInRow, targetRow.elements.length)));
      } else {
        updateRow(targetRow, targetElementIndexInRow, 0, element);
      }
    }
  }
  canFireAddRemoveNotifications(element) {
    return !!this.survey && element.prevSurvey !== this.survey;
  }
  onAddElement(element, index) {
    const survey = this.survey;
    const fireNotification = this.canFireAddRemoveNotifications(element);
    if (!!this.surveyImpl) {
      element.setSurveyImpl(this.surveyImpl);
    }
    element.parent = this;
    this.markQuestionListDirty();
    if (this.canBuildRows()) {
      this.updateRowsOnElementAdded(element);
    }
    if (fireNotification) {
      if (element.isPanel) {
        survey.panelAdded(element, index, this, this.root);
      } else {
        survey.questionAdded(element, index, this, this.root);
      }
    }
    if (!!this.addElementCallback) this.addElementCallback(element);
    element.registerPropertyChangedHandlers(["visible", "isVisible"], () => {
      this.onElementVisibilityChanged(element);
    }, this.id);
    element.registerPropertyChangedHandlers(["startWithNewLine"], () => {
      this.onElementStartWithNewLineChanged(element);
    }, this.id);
    this.onElementVisibilityChanged(this);
  }
  onRemoveElement(element) {
    element.parent = null;
    this.unregisterElementPropertiesChanged(element);
    this.markQuestionListDirty();
    this.updateRowsOnElementRemoved(element);
    if (this.isRandomizing) return;
    this.onRemoveElementNotifySurvey(element);
    if (!!this.removeElementCallback) this.removeElementCallback(element);
    this.onElementVisibilityChanged(this);
  }
  unregisterElementPropertiesChanged(element) {
    element.unregisterPropertyChangedHandlers(["visible", "isVisible", "startWithNewLine"], this.id);
  }
  onRemoveElementNotifySurvey(element) {
    if (!this.canFireAddRemoveNotifications(element)) return;
    if (!element.isPanel) {
      this.survey.questionRemoved(element);
    } else {
      this.survey.panelRemoved(element);
    }
  }
  onElementVisibilityChanged(element) {
    if (this.isLoadingFromJson || this.isRandomizing) return;
    this.updateRowsVisibility(element);
    this.childVisibilityChanged();
    if (!!this.parent) {
      this.parent.onElementVisibilityChanged(this);
    }
  }
  onElementStartWithNewLineChanged(element) {
    if (this.locCountRowUpdates > 0) return;
    this.blockAnimations();
    this.updateRowsBeforeElementRemoved(element);
    this.updateRowsOnElementAdded(element);
    this.releaseAnimations();
  }
  updateRowsVisibility(element) {
    var rows = this.rows;
    for (var i = 0; i < rows.length; i++) {
      var row = rows[i];
      if (row.elements.indexOf(element) > -1) {
        row.updateVisible();
        if (row.visible && !row.isNeedRender) {
          row.isNeedRender = true;
        }
        break;
      }
    }
  }
  canBuildRows() {
    return !this.isLoadingFromJson && this.getChildrenLayoutType() == "row";
  }
  buildRows() {
    if (!this.canBuildRows()) return [];
    const res = new Array();
    const els = this.getElementsForRows();
    for (let i = 0; i < els.length; i++) {
      const el = els[i];
      const isNewRow = i == 0 || el.startWithNewLine;
      const row = isNewRow ? this.createRowAndSetLazy(res.length) : res[res.length - 1];
      if (isNewRow) res.push(row);
      row.addElement(el);
    }
    res.forEach((row) => row.updateVisible());
    return res;
  }
  getElementsForRows() {
    return this.elements;
  }
  getDragDropInfo() {
    const page = this.getPage(this.parent);
    return !!page ? page.getDragDropInfo() : void 0;
  }
  updateRowsOnElementRemoved(element) {
    if (!this.canBuildRows()) return;
    this.updateRowsRemoveElementFromRow(element, this.findRowByElement(element));
    this.updateColumns();
  }
  updateRowsRemoveElementFromRow(element, row) {
    if (!row || !row.panel) return;
    var elIndex = row.elements.indexOf(element);
    if (elIndex < 0) return;
    row.elements.splice(elIndex, 1);
    if (row.elements.length > 0) {
      this.blockRowsUpdates();
      row.elements[0].startWithNewLine = true;
      this.releaseRowsUpdates();
      row.updateVisible();
    } else {
      if (row.index >= 0) {
        row.panel.rows.splice(row.index, 1);
      }
    }
  }
  getAllRows() {
    const allRows = [];
    this.rows.forEach((row) => {
      const nestedRows = [];
      row.elements.forEach((element) => {
        if (element.isPanel) {
          nestedRows.push(...element.getAllRows());
        } else if (element.getType() == "paneldynamic") {
          if (this.isDesignMode) {
            nestedRows.push(...element.template.getAllRows());
          } else {
            element.panels.forEach((panel) => nestedRows.push(...panel.getAllRows()));
          }
        }
      });
      allRows.push(row);
      allRows.push(...nestedRows);
    });
    return allRows;
  }
  findRowAndIndexByElement(el, rows) {
    if (!el) {
      return {
        row: void 0,
        index: this.rows.length - 1
      };
    }
    rows = rows || this.rows;
    for (var i = 0; i < rows.length; i++) {
      if (rows[i].elements.indexOf(el) > -1) return {
        row: rows[i],
        index: i
      };
    }
    return {
      row: null,
      index: -1
    };
  }
  forceRenderRow(row) {
    if (!!row && !row.isNeedRender) {
      row.isNeedRender = true;
      row.stopLazyRendering();
    }
  }
  forceRenderElement(el, elementsRendered = () => {
  }, gap = 0) {
    const allRows = this.getAllRows();
    const {
      row,
      index
    } = this.findRowAndIndexByElement(el, allRows);
    if (index >= 0 && index < allRows.length) {
      const rowsToRender = [];
      rowsToRender.push(row);
      for (let i = index - 1; i >= index - gap && i >= 0; i--) {
        rowsToRender.push(allRows[i]);
      }
      this.forceRenderRows(rowsToRender, elementsRendered);
    }
  }
  forceRenderRows(rows, elementsRendered = () => {
  }) {
    const rowRenderedHandler = /* @__PURE__ */ ((rowsCount) => () => {
      rowsCount--;
      if (rowsCount <= 0) {
        elementsRendered();
      }
    })(rows.length);
    rows.forEach((row) => new RenderingCompletedAwaiter(row.visibleElements, rowRenderedHandler));
    rows.forEach((row) => this.forceRenderRow(row));
  }
  findRowByElement(el) {
    return this.findRowAndIndexByElement(el).row;
  }
  elementWidthChanged(el) {
    if (this.isLoadingFromJson) return;
    var row = this.findRowByElement(el);
    if (!!row) {
      row.updateVisible();
    }
  }
  get processedTitle() {
    return this.getRenderedTitle(this.locTitle.textOrHtml);
  }
  getRenderedTitle(str) {
    return this.textProcessor != null ? this.textProcessor.processText(str, true) : str;
  }
  /**
   * Gets or sets panel/page visibility.
   *
   * If you want to display or hide a survey element based on a condition, specify the `visibleIf` property. Refer to the following help topic for information: [Conditional Visibility](https://surveyjs.io/form-library/documentation/design-survey-conditional-logic#conditional-visibility).
   * @see visibleIf
   * @see isVisible
   */
  get visible() {
    return this.getPropertyValue("visible", true);
  }
  set visible(value) {
    if (value === this.visible) return;
    this.setPropertyValue("visible", value);
    this.setPropertyValue("isVisible", this.isVisible);
    if (!this.isLoadingFromJson) this.onVisibleChanged();
  }
  onHidingContent() {
    this.questions.forEach((q) => q.onHidingContent());
  }
  onVisibleChanged() {
    if (this.isRandomizing) return;
    this.setPropertyValue("isVisible", this.isVisible);
    if (!!this.survey && this.survey.getQuestionClearIfInvisible("default") !== "none" && !this.isLoadingFromJson) {
      const questions = this.questions;
      const isVisible = this.isVisible;
      for (var i = 0; i < questions.length; i++) {
        const q = questions[i];
        if (!isVisible) {
          q.clearValueIfInvisible("onHiddenContainer");
          q.onHidingContent();
        } else {
          q.updateValueWithDefaults();
        }
      }
    }
  }
  notifyStateChanged(prevState) {
    super.notifyStateChanged(prevState);
    if (this.isCollapsed) {
      this.questions.forEach((q) => q.onHidingContent());
    }
  }
  /**
   * Returns `true` if the panel/page is visible or the survey is currently in design mode.
   *
   * If you want to display or hide a question based on a condition, specify the `visibleIf` property. Refer to the following help topic for information: [Conditional Visibility](https://surveyjs.io/form-library/documentation/design-survey-conditional-logic#conditional-visibility).
   * @see visibleIf
   * @see visible
   */
  get isVisible() {
    return this.areInvisibleElementsShowing || this.getIsPageVisible(null);
  }
  getIsContentVisible(exceptionQuestion) {
    if (this.areInvisibleElementsShowing) return true;
    for (var i = 0; i < this.elements.length; i++) {
      if (this.elements[i] == exceptionQuestion) continue;
      if (this.elements[i].isVisible) return true;
    }
    return false;
  }
  getIsPageVisible(exceptionQuestion) {
    const isContentVisible = this.getIsContentVisible(exceptionQuestion);
    return this.visible && isContentVisible;
  }
  setVisibleIndex(index) {
    if (!this.isVisible || index < 0) {
      this.resetVisibleIndexes();
      return 0;
    }
    this.lastVisibleIndex = index;
    var startIndex = index;
    index += this.beforeSetVisibleIndex(index);
    var panelStartIndex = this.getPanelStartIndex(index);
    var panelIndex = panelStartIndex;
    const elements = this.elements;
    for (var i = 0; i < elements.length; i++) {
      panelIndex += elements[i].setVisibleIndex(panelIndex);
    }
    if (this.isContinueNumbering()) {
      index += panelIndex - panelStartIndex;
    }
    return index - startIndex;
  }
  updateVisibleIndexes() {
    if (this.lastVisibleIndex === void 0) return;
    this.resetVisibleIndexes();
    this.setVisibleIndex(this.lastVisibleIndex);
  }
  resetVisibleIndexes() {
    const elements = this.elements;
    for (var i = 0; i < elements.length; i++) {
      elements[i].setVisibleIndex(-1);
    }
  }
  beforeSetVisibleIndex(index) {
    return 0;
  }
  getPanelStartIndex(index) {
    return index;
  }
  isContinueNumbering() {
    return true;
  }
  get isReadOnly() {
    var isParentReadOnly = !!this.parent && this.parent.isReadOnly;
    var isSurveyReadOnly = !!this.survey && this.survey.isDisplayMode;
    return this.readOnly || isParentReadOnly || isSurveyReadOnly;
  }
  onReadOnlyChanged() {
    for (var i = 0; i < this.elements.length; i++) {
      var el = this.elements[i];
      el.setPropertyValue("isReadOnly", el.isReadOnly);
    }
    super.onReadOnlyChanged();
  }
  updateElementCss(reNew) {
    super.updateElementCss(reNew);
    for (let i = 0; i < this.elements.length; i++) {
      const el = this.elements[i];
      el.updateElementCss(reNew);
    }
  }
  /**
   * A Boolean expression. If it evaluates to `false`, this panel/page becomes read-only.
   *
   * A survey parses and runs all expressions on startup. If any values used in the expression change, the survey re-evaluates it.
   *
   * Refer to the following help topic for more information: [Conditional Visibility](https://surveyjs.io/form-library/documentation/design-survey-conditional-logic#conditional-visibility).
   * @see readOnly
   * @see isReadOnly
   */
  get enableIf() {
    return this.getPropertyValue("enableIf", "");
  }
  set enableIf(val) {
    this.setPropertyValue("enableIf", val);
  }
  /**
   * Adds a survey element (question or panel) to this panel/page. Returns `true` if the element was added successfully; `false` otherwise.
   * @param element A survey element to add.
   * @param index A desired index of this element in the `elements` array.
   * @see addNewQuestion
   * @see addNewPanel
   */
  addElement(element, index = -1) {
    if (!this.canAddElement(element)) return false;
    if (index < 0 || index >= this.elements.length) {
      this.elements.push(element);
    } else {
      this.elements.splice(index, 0, element);
    }
    if (this.wasRendered) {
      element.onFirstRendering();
    }
    this.updateColumns();
    return true;
  }
  insertElement(element, dest, location = "bottom") {
    if (!dest) {
      this.addElement(element);
      return;
    }
    this.blockRowsUpdates();
    let index = this.elements.indexOf(dest);
    const destRow = this.findRowByElement(dest);
    if (location == "left" || location == "right") {
      if (location == "right") {
        element.startWithNewLine = false;
        index++;
      } else {
        if (destRow.elements.indexOf(dest) == 0) {
          dest.startWithNewLine = false;
          element.startWithNewLine = true;
        } else {
          element.startWithNewLine = false;
        }
      }
    } else {
      element.startWithNewLine = true;
      if (location == "top") {
        index = this.elements.indexOf(destRow.elements[0]);
      } else {
        index = this.elements.indexOf(destRow.elements[destRow.elements.length - 1]) + 1;
      }
    }
    this.releaseRowsUpdates();
    this.addElement(element, index);
  }
  insertElementAfter(element, after) {
    const index = this.elements.indexOf(after);
    if (index >= 0) this.addElement(element, index + 1);
  }
  insertElementBefore(element, before) {
    const index = this.elements.indexOf(before);
    if (index >= 0) this.addElement(element, index);
  }
  canAddElement(element) {
    return !!element && element.isLayoutTypeSupported(this.getChildrenLayoutType());
  }
  addQuestion(question, index = -1) {
    return this.addElement(question, index);
  }
  addPanel(panel, index = -1) {
    return this.addElement(panel, index);
  }
  /**
   * Creates a new question of a given type and adds it to the `elements` array at a specified index.
   *
   * This method returns `null` if the question cannot be created or added to this panel/page; otherwise, the method returns the created question.
   *
   * @param questionType A [question type](https://surveyjs.io/form-library/documentation/question#getType).
   * @param name A question name.
   * @param index A desired index of the new question in the `elements` array.
   * @see elements
   * @see addElement
   */
  addNewQuestion(questionType2, name = null, index = -1) {
    var question = QuestionFactory.Instance.createQuestion(questionType2, name);
    if (!this.addQuestion(question, index)) return null;
    return question;
  }
  /**
   * Creates a new panel and adds it to the end of the `elements` array.
   *
   * This method returns `null` if the panel cannot be created or added to this panel/page; otherwise, the method returns the created panel.
   * @param name A panel name.
   * @see elementsup
   * @see addElement
   */
  addNewPanel(name = null) {
    var panel = this.createNewPanel(name);
    if (!this.addPanel(panel)) return null;
    return panel;
  }
  indexOf(element) {
    return this.elements.indexOf(element);
  }
  createNewPanel(name) {
    var res = Serializer.createClass("panel");
    res.name = name;
    return res;
  }
  /**
   * Deletes a survey element (question or panel) from this panel/page. Returns `true` if the element was deleted successfully; `false` otherwise.
   * @param element A survey element to delete.
   * @see elements
   */
  removeElement(element) {
    var index = this.elements.indexOf(element);
    if (index < 0) {
      for (var i = 0; i < this.elements.length; i++) {
        if (this.elements[i].removeElement(element)) return true;
      }
      return false;
    }
    this.elements.splice(index, 1);
    this.updateColumns();
    return true;
  }
  removeQuestion(question) {
    this.removeElement(question);
  }
  runCondition(values, properties) {
    if (this.isDesignMode || this.isLoadingFromJson) return;
    var elements = this.elements.slice();
    for (var i = 0; i < elements.length; i++) {
      elements[i].runCondition(values, properties);
    }
    this.runConditionCore(values, properties);
  }
  onAnyValueChanged(name, questionName) {
    var els = this.elements;
    for (var i = 0; i < els.length; i++) {
      els[i].onAnyValueChanged(name, questionName);
    }
  }
  checkBindings(valueName, value) {
    var els = this.elements;
    for (var i = 0; i < els.length; i++) {
      els[i].checkBindings(valueName, value);
    }
  }
  // TODO: remove it or not?
  dragDropFindRow(findElement) {
    if (!findElement || findElement.isPage) return null;
    var element = findElement;
    var rows = this.rows;
    for (var i = 0; i < rows.length; i++) {
      if (rows[i].elements.indexOf(element) > -1) return rows[i];
    }
    for (var i = 0; i < this.elements.length; i++) {
      var pnl = this.elements[i].getPanel();
      if (!pnl) continue;
      var row = pnl.dragDropFindRow(element);
      if (!!row) return row;
    }
    return null;
  }
  needResponsiveWidth() {
    let result = false;
    this.elements.forEach((e) => {
      if (e.needResponsiveWidth()) result = true;
    });
    this.rows.forEach((r) => {
      if (r.elements.length > 1) result = true;
    });
    return result;
  }
  get hasDescriptionUnderTitle() {
    return this.hasDescription;
  }
  get cssHeader() {
    return this.cssClasses.panel.header;
  }
  get cssDescription() {
    return this.cssClasses.panel.description;
  }
  /**
   * Specifies the error message position for questions that belong to this page/panel.
   *
   * Use this property to override the [`questionErrorLocation`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#questionErrorLocation) property specified for the survey. You can also set the [`errorLocation`](https://surveyjs.io/form-library/documentation/question#errorLocation) property for individual questions.
   *
   * Possible values:
   *
   * - `"default"` (default) - Inherits the setting from the `questionErrorLocation` property specified for the survey.
   * - `"top"` - Displays error messages above questions.
   * - `"bottom"` - Displays error messages below questions.
   */
  get questionErrorLocation() {
    return this.getPropertyValue("questionErrorLocation");
  }
  set questionErrorLocation(val) {
    this.setPropertyValue("questionErrorLocation", val);
  }
  getQuestionErrorLocation() {
    if (this.questionErrorLocation !== "default") return this.questionErrorLocation;
    if (this.parent) return this.parent.getQuestionErrorLocation();
    return this.survey ? this.survey.questionErrorLocation : "top";
  }
  //ITitleOwner
  getTitleOwner() {
    return this;
  }
  get no() {
    return "";
  }
  get cssTitleNumber() {
    return this.cssClasses.panel.number;
  }
  get cssRequiredMark() {
    return this.cssClasses.panel.requiredMark;
  }
  get cssError() {
    return this.getCssError(this.cssClasses);
  }
  getCssError(cssClasses) {
    return new CssClassBuilder().append(cssClasses.error.root).toString();
  }
  getSerializableColumnsValue() {
    let tailIndex = -1;
    for (let index = this.gridLayoutColumns.length - 1; index >= 0; index--) {
      if (!this.gridLayoutColumns[index].isEmpty()) {
        tailIndex = index;
        break;
      }
    }
    return this.gridLayoutColumns.slice(0, tailIndex + 1);
  }
  afterRender(el) {
    this.afterRenderCore(el);
  }
  dispose() {
    super.dispose();
    if (this.rows) {
      for (let i = 0; i < this.rows.length; i++) {
        this.rows[i].dispose();
      }
      this.rows.splice(0, this.rows.length);
    }
    this.disposeElements();
    this.elements.splice(0, this.elements.length);
  }
  disposeElements() {
    for (let i = 0; i < this.elements.length; i++) {
      this.elements[i].dispose();
    }
  }
};
PanelModelBase.panelCounter = 100;
__decorate([property({
  defaultValue: true
})], PanelModelBase.prototype, "showTitle", void 0);
__decorate([property({
  defaultValue: true
})], PanelModelBase.prototype, "showDescription", void 0);
__decorate([property()], PanelModelBase.prototype, "questionTitleWidth", void 0);
var PanelModel = class _PanelModel extends PanelModelBase {
  constructor(name = "") {
    super(name);
    this.forcusFirstQuestionOnExpand = true;
    this.createNewArray("footerActions");
    this.registerPropertyChangedHandlers(["width"], () => {
      if (!!this.parent) {
        this.parent.elementWidthChanged(this);
      }
    });
    this.registerPropertyChangedHandlers(["indent", "innerIndent", "rightIndent"], () => {
      this.resetIndents();
    });
    this.registerPropertyChangedHandlers(["colSpan"], () => {
      var _a;
      (_a = this.parent) === null || _a === void 0 ? void 0 : _a.updateColumns();
    });
  }
  getType() {
    return "panel";
  }
  get contentId() {
    return this.id + "_content";
  }
  getSurvey(live = false) {
    if (live && this.isPanel) {
      return !!this.parent ? this.parent.getSurvey(live) : null;
    }
    return super.getSurvey(live);
  }
  get isPanel() {
    return true;
  }
  /**
   * Returns a page to which the panel belongs and allows you to move this panel to a different page.
   * @see PanelModelBase.parent
   */
  get page() {
    return this.getPage(this.parent);
  }
  set page(val) {
    this.setPage(this.parent, val);
  }
  removeFromParent() {
    if (!!this.parent) {
      this.removeSelfFromList(this.parent.elements);
    }
  }
  moveTo(container, insertBefore = null) {
    return this.moveToBase(this.parent, container, insertBefore);
  }
  /**
   * Returns the visible index of the panel in the survey. Commonly it is -1 and it doesn't show.
   * You have to set showNumber to true to show index/numbering for the Panel
   * @see showNumber
   */
  get visibleIndex() {
    return this.getPropertyValue("visibleIndex", -1);
  }
  /**
   * Specifies whether to show the panel number in the title.
   *
   * Default value: `false`
   * @see SurveyModel.showQuestionNumbers
   * @see SurveyModel.questionTitlePattern
   */
  get showNumber() {
    return this.getPropertyValue("showNumber");
  }
  set showNumber(val) {
    this.setPropertyValue("showNumber", val);
    this.notifySurveyOnVisibilityChanged();
  }
  /**
   * Gets or sets a value that specifies how the elements numbers inside panel are displayed.
   *
   * The following options are available:
   *
   * - `default` - display questions numbers as defined in parent panel or survey
   * - `onpanel` - display questions numbers, start numbering from beginning of this page
   * - `off` - turn off the numbering for questions titles
   * @see showNumber
   */
  get showQuestionNumbers() {
    return this.getPropertyValue("showQuestionNumbers");
  }
  set showQuestionNumbers(value) {
    this.setPropertyValue("showQuestionNumbers", value);
    this.notifySurveyOnVisibilityChanged();
  }
  /**
   * Specifies a number or letter used to start numbering of elements inside the panel.
   *
   * You can include desired prefixes and postfixes alongside the number or letter:
   *
   * ```js
   * "questionStartIndex": "a.", // a., b., c., ...
   * "questionStartIndex": "#3", // #3, #4, #5, ...
   * "questionStartIndex": "(B)." // (B)., (C)., (D)., ...
   * ```
   * Default value: `"1."` (inherited from `SurveyModel`'s `questionStartIndex` property)
   * @see SurveyModel.questionStartIndex
   * @see showQuestionNumbers
   */
  get questionStartIndex() {
    return this.getPropertyValue("questionStartIndex", "");
  }
  set questionStartIndex(val) {
    this.setPropertyValue("questionStartIndex", val);
  }
  getQuestionStartIndex() {
    if (!!this.questionStartIndex) return this.questionStartIndex;
    return super.getQuestionStartIndex();
  }
  /**
   * A question number or letter (depends on the `questionStartIndex` property).
   *
   * When the question number, title, or the entire question is invisible, this property returns an empty string.
   * @see questionStartIndex
   * @see showNumber
   * @see visibleIf
   */
  get no() {
    return this.getPropertyValue("no", void 0, () => this.calcNo());
  }
  calcNo() {
    let no = Helpers.getNumberByIndex(this.visibleIndex, this.getStartIndex());
    if (this.survey) {
      no = this.survey.getUpdatedPanelNo(this, no);
    }
    return no || "";
  }
  notifyStateChanged(prevState) {
    if (!this.isLoadingFromJson) {
      this.locTitle.strChanged();
    }
    super.notifyStateChanged(prevState);
  }
  createLocTitleProperty() {
    const locTitleValue = super.createLocTitleProperty();
    locTitleValue.onGetTextCallback = (text) => {
      if (!text && this.state !== "default") {
        text = this.name;
      }
      return text;
    };
    return locTitleValue;
  }
  beforeSetVisibleIndex(index) {
    if (this.isPage) return super.beforeSetVisibleIndex(index);
    let visibleIndex = -1;
    if (this.showNumber && (this.isDesignMode || !this.locTitle.isEmpty || this.hasParentInQuestionIndex())) {
      visibleIndex = index;
    }
    this.setPropertyValue("visibleIndex", visibleIndex);
    this.resetPropertyValue("no");
    return visibleIndex < 0 ? 0 : 1;
  }
  getPanelStartIndex(index) {
    if (this.showQuestionNumbers === "off") return -1;
    if (this.showQuestionNumbers === "onpanel") return 0;
    return index;
  }
  hasParentInQuestionIndex() {
    if (this.showQuestionNumbers !== "onpanel") return false;
    const str = this.questionStartIndex;
    const index = str.indexOf(".");
    return index > -1 && index < str.length - 1;
  }
  isContinueNumbering() {
    return this.showQuestionNumbers !== "off" && this.showQuestionNumbers !== "onpanel";
  }
  notifySurveyOnVisibilityChanged() {
    if (this.survey != null && !this.isLoadingFromJson && !!this.page) {
      this.survey.panelVisibilityChanged(this, this.isVisible);
    }
  }
  getRenderedTitle(str) {
    if (this.isPanel && !str) {
      if (this.isCollapsed || this.isExpanded) return this.name;
      if (this.isDesignMode) return "[" + this.name + "]";
    }
    return super.getRenderedTitle(str);
  }
  /**
   * Increases or decreases an indent of panel content from the left edge. Accepts positive integer values and 0.
   */
  get innerIndent() {
    return this.getPropertyValue("innerIndent");
  }
  set innerIndent(val) {
    this.setPropertyValue("innerIndent", val);
  }
  /**
   * Disable this property if you want to render the current panel on the same line or row with the previous question or panel.
   */
  get startWithNewLine() {
    return this.getPropertyValue("startWithNewLine");
  }
  set startWithNewLine(value) {
    this.setPropertyValue("startWithNewLine", value);
  }
  get allowAdaptiveActions() {
    return this.getPropertyValue("allowAdaptiveActions");
  }
  set allowAdaptiveActions(val) {
    this.setPropertyValue("allowAdaptiveActions", val);
  }
  get innerPaddingLeft() {
    const func = () => {
      return this.getIndentSize(this.innerIndent);
    };
    return this.getPropertyValue("innerPaddingLeft", void 0, func);
  }
  set innerPaddingLeft(val) {
    this.setPropertyValue("innerPaddingLeft", val);
  }
  calcPaddingLeft() {
    return this.getIndentSize(this.indent);
  }
  calcPaddingRight() {
    return this.getIndentSize(this.rightIndent);
  }
  resetIndents() {
    this.resetPropertyValue("innerPaddingLeft");
    super.resetIndents();
  }
  getIndentSize(indent) {
    if (!this.survey) return void 0;
    if (indent < 1) return "";
    var css = this.survey["css"];
    if (!css || !css.question || !css.question.indent) return "";
    return indent * css.question.indent + "px";
  }
  clearOnDeletingContainer() {
    this.elements.forEach((element) => {
      if (element instanceof Question || element instanceof _PanelModel) {
        element.clearOnDeletingContainer();
      }
    });
  }
  get footerActions() {
    return this.getPropertyValue("footerActions");
  }
  getFooterToolbar() {
    var _a, _b;
    if (!this.footerToolbarValue) {
      var actions = this.footerActions;
      if (this.hasEditButton) {
        actions.push({
          id: "cancel-preview",
          locTitle: this.survey.locEditText,
          innerCss: this.survey.cssNavigationEdit,
          component: "sv-nav-btn",
          action: () => {
            this.cancelPreview();
          }
        });
      }
      if (!!this.onGetFooterActionsCallback) {
        actions = this.onGetFooterActionsCallback();
      } else {
        actions = (_a = this.survey) === null || _a === void 0 ? void 0 : _a.getUpdatedPanelFooterActions(this, actions);
      }
      this.footerToolbarValue = this.createActionContainer(this.allowAdaptiveActions);
      let footerCss = this.onGetFooterToolbarCssCallback ? this.onGetFooterToolbarCssCallback() : "";
      if (!footerCss) {
        footerCss = (_b = this.cssClasses.panel) === null || _b === void 0 ? void 0 : _b.footer;
      }
      if (footerCss) {
        this.footerToolbarValue.containerCss = footerCss;
      }
      this.footerToolbarValue.setItems(actions);
    }
    return this.footerToolbarValue;
  }
  get hasEditButton() {
    return false;
  }
  cancelPreview() {
    if (!this.hasEditButton) return;
    this.survey.cancelPreviewByPage(this);
  }
  get cssTitle() {
    return this.getCssPanelTitle();
  }
  getCssPanelTitle() {
    return this.getCssTitle(this.cssClasses.panel);
  }
  getCssTitleExpandableSvg() {
    if (this.state === "default") return null;
    return this.cssClasses.panel.titleExpandableSvg;
  }
  get showErrorsAbovePanel() {
    return this.isDefaultV2Theme && !this.showPanelAsPage;
  }
  getCssError(cssClasses) {
    if (this.isPage) return super.getCssError(cssClasses);
    const builder = new CssClassBuilder().append(super.getCssError(cssClasses)).append(cssClasses.panel.errorsContainer);
    return builder.append("panel-error-root", builder.isEmpty()).toString();
  }
  onVisibleChanged() {
    super.onVisibleChanged();
    this.notifySurveyOnVisibilityChanged();
  }
  needResponsiveWidth() {
    if (!this.startWithNewLine) {
      return true;
    } else {
      return super.needResponsiveWidth();
    }
  }
  focusIn() {
    if (!this.survey) return;
    this.survey.whenPanelFocusIn(this);
  }
  getHasFrameV2() {
    return super.getHasFrameV2() && !this.showPanelAsPage;
  }
  getIsNested() {
    return super.getIsNested() && this.parent !== void 0;
  }
  get showPanelAsPage() {
    return false;
  }
  expand(focusFirstQuestion = true) {
    this.forcusFirstQuestionOnExpand = focusFirstQuestion;
    super.expand();
  }
  onElementExpanded(elementIsRendered) {
    if (!this.forcusFirstQuestionOnExpand) {
      return;
    }
    if (this.survey != null && !this.isLoadingFromJson) {
      const q = this.getFirstQuestionToFocus(false);
      if (!!q) {
        setTimeout(() => {
          if (!this.isDisposed && !!this.survey) {
            this.survey.scrollElementToTop(q, q, null, q.inputId, false, {
              behavior: "smooth"
            });
          }
        }, elementIsRendered ? 0 : 15);
      }
    }
  }
  getCssRoot(cssClasses) {
    return new CssClassBuilder().append(super.getCssRoot(cssClasses)).append(cssClasses.container).append(cssClasses.asPage, this.showPanelAsPage).append(cssClasses.invisible, !this.isDesignMode && this.areInvisibleElementsShowing && !this.visible).toString();
  }
  getContainerCss() {
    return this.getCssRoot(this.cssClasses.panel);
  }
  afterRenderCore(element) {
    var _a;
    super.afterRenderCore(element);
    if (this.isPanel) {
      (_a = this.survey) === null || _a === void 0 ? void 0 : _a.afterRenderPanel(this, element);
    }
  }
};
Serializer.addClass("panelbase", ["name", {
  name: "elements",
  alternativeName: "questions",
  baseClassName: "question",
  visible: false,
  isLightSerializable: false
}, {
  name: "visible:switch",
  default: true,
  overridingProperty: "visibleIf"
}, {
  name: "readOnly:boolean",
  overridingProperty: "enableIf"
}, "visibleIf:condition", "enableIf:condition", "requiredIf:condition", {
  name: "questionTitleWidth",
  visibleIf: function(obj) {
    return !!obj && obj["availableQuestionTitleWidth"]();
  }
}, {
  name: "questionTitleLocation",
  default: "default",
  choices: ["default", "top", "bottom", "left", "hidden"]
}, {
  name: "gridLayoutColumns:panellayoutcolumns",
  className: "panellayoutcolumn",
  isArray: true,
  onSerializeValue: (obj) => {
    return obj.getSerializableColumnsValue();
  },
  visibleIf: function(obj) {
    return !!obj && !!obj.survey && obj.survey.gridLayoutEnabled;
  }
}, {
  name: "title:text",
  serializationProperty: "locTitle"
}, {
  name: "description:text",
  serializationProperty: "locDescription"
}, {
  name: "questionOrder",
  alternativeName: "questionsOrder",
  default: "default",
  choices: ["default", "initial", "random"]
}, {
  name: "questionErrorLocation",
  default: "default",
  choices: ["default", "top", "bottom"]
}], function() {
  return new PanelModelBase();
});
Serializer.addClass("panel", [{
  name: "state",
  default: "default",
  choices: ["default", "collapsed", "expanded"]
}, {
  name: "isRequired:switch",
  overridingProperty: "requiredIf"
}, {
  name: "requiredErrorText:text",
  serializationProperty: "locRequiredErrorText"
}, {
  name: "startWithNewLine:boolean",
  default: true
}, {
  name: "width"
}, {
  name: "minWidth",
  defaultFunc: () => "auto"
}, {
  name: "maxWidth",
  defaultFunc: () => settings.maxWidth
}, {
  name: "colSpan:number",
  visible: false,
  onSerializeValue: (obj) => {
    return obj.getPropertyValue("colSpan");
  }
}, {
  name: "effectiveColSpan:number",
  minValue: 1,
  isSerializable: false,
  visibleIf: function(obj) {
    return !!obj.survey && obj.survey.gridLayoutEnabled;
  }
}, {
  name: "innerIndent:number",
  default: 0,
  choices: [0, 1, 2, 3]
}, {
  name: "indent:number",
  default: 0,
  choices: [0, 1, 2, 3],
  visible: false
}, {
  name: "page",
  isSerializable: false,
  visibleIf: function(obj) {
    var survey = obj ? obj.survey : null;
    return !survey || !survey.pages || survey.pages.length > 1;
  },
  choices: function(obj) {
    var survey = obj ? obj.survey : null;
    return survey ? survey.pages.map((p) => {
      return {
        value: p.name,
        text: p.title
      };
    }) : [];
  }
}, {
  name: "showNumber:boolean"
}, {
  name: "showQuestionNumbers",
  default: "default",
  choices: ["default", "onpanel", "off"]
}, {
  name: "questionStartIndex",
  visibleIf: (obj) => obj.isPanel
}, {
  name: "allowAdaptiveActions:boolean",
  default: true,
  visible: false
}], function() {
  return new PanelModel();
}, "panelbase");
ElementFactory.Instance.registerElement("panel", (name) => {
  return new PanelModel(name);
});
var PageModel = class extends PanelModel {
  constructor(name = "") {
    super(name);
    this.hasShownValue = false;
    this.timeSpent = 0;
    this._isReadyForClean = true;
    this.createLocalizableString("navigationDescription", this, true);
  }
  getType() {
    return "page";
  }
  toString() {
    return this.name;
  }
  get isPage() {
    return !this.isPanel;
  }
  get isPanel() {
    return !!this.parent;
  }
  get showPanelAsPage() {
    return true;
  }
  get hasEditButton() {
    return this.isPanel && this.survey && this.survey.state === "preview" && !!this.parent && !this.parent.isPanel;
  }
  getElementsForRows() {
    var _a;
    if (!this.isStartPage) {
      const q = (_a = this.survey) === null || _a === void 0 ? void 0 : _a.currentSingleQuestion;
      if (!!q) {
        if (q.page === this) return [q];
        return [];
      }
    }
    return super.getElementsForRows();
  }
  disposeElements() {
    if (!this.isPageContainer) {
      super.disposeElements();
    }
  }
  onRemoveElement(element) {
    if (this.isPageContainer) {
      element.parent = null;
      this.unregisterElementPropertiesChanged(element);
    } else {
      super.onRemoveElement(element);
    }
  }
  getTemplate() {
    return this.isPanel ? "panel" : super.getTemplate();
  }
  get no() {
    if (!this.canShowPageNumber() || !this.survey) return "";
    let no = this.isStartPage ? "" : this.num + ". ";
    return this.survey.getUpdatedPageNo(this, no);
  }
  get cssTitleNumber() {
    return this.cssClasses.page.number;
  }
  getCssTitleExpandableSvg() {
    return null;
  }
  get cssRequiredMark() {
    return "";
  }
  canShowPageNumber() {
    return this.survey && this.survey.showPageNumbers;
  }
  canShowTitle(survey) {
    return !survey || survey.showPageTitles;
  }
  setTitleValue(val) {
    super.setTitleValue(val);
    this.navigationLocStrChanged();
  }
  /**
   * A caption displayed on a navigation button in the TOC or progress bar. Applies when [`showTOC`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#showTOC) is `true` or when the [progress bar is visible](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#showProgressBar), [`progressBarType`](https://surveyjs.io/form-library/documentation/surveymodel#progressBarType) is set to `"pages"`, and [`progressBarShowPageTitles`](https://surveyjs.io/form-library/documentation/surveymodel#progressBarShowPageTitles) is `true`.
   *
   * If navigation titles are unspecified, the navigation buttons display page [titles](https://surveyjs.io/form-library/documentation/api-reference/page-model#title) or [names](https://surveyjs.io/form-library/documentation/pagemodel#name).
   */
  get navigationTitle() {
    return this.getLocalizableStringText("navigationTitle");
  }
  set navigationTitle(val) {
    this.setLocalizableStringText("navigationTitle", val);
  }
  /**
   * Explanatory text displayed under a navigation button in the progress bar. Applies when the [progress bar is visible](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#showProgressBar), `SurveyModel`'s [`progressBarType`](https://surveyjs.io/form-library/documentation/surveymodel#progressBarType) is set to `"pages"`, and [`progressBarShowPageTitles`](https://surveyjs.io/form-library/documentation/surveymodel#progressBarShowPageTitles) is `true`.
   */
  get navigationDescription() {
    return this.getLocalizableStringText("navigationDescription");
  }
  set navigationDescription(val) {
    this.setLocalizableStringText("navigationDescription", val);
  }
  get locNavigationDescription() {
    return this.getLocalizableString("navigationDescription");
  }
  navigationLocStrChanged() {
    if (this.locNavigationTitle.isEmpty) {
      this.locTitle.strChanged();
    }
    this.locNavigationTitle.strChanged();
    this.locNavigationDescription.strChanged();
  }
  getMarkdownHtml(text, name) {
    const result = super.getMarkdownHtml(text, name);
    if (name === "navigationTitle" && this.canShowPageNumber() && result) {
      return this.num + ". " + result;
    }
    return result;
  }
  get passed() {
    return this.getPropertyValue("passed", false);
  }
  set passed(val) {
    this.setPropertyValue("passed", val);
  }
  removeFromParent() {
    if (!!this.survey) {
      this.removeSelfFromList(this.survey.pages);
    }
  }
  /**
   * The visible index of the page. It has values from 0 to visible page count - 1.
   * @see SurveyModel.visiblePages
   * @see SurveyModel.pages
   */
  get visibleIndex() {
    return this.getPropertyValue("visibleIndex", -1);
  }
  set visibleIndex(val) {
    this.setPropertyValue("visibleIndex", val);
  }
  canRenderFirstRows() {
    return !this.isDesignMode || this.visibleIndex == 0;
  }
  /**
   * Returns `true` if this page is a start page.
   *
   * Refer to the following help topic for more information on how to configure a start page: [Start Page](https://surveyjs.io/form-library/documentation/design-survey-create-a-multi-page-survey#start-page).
   */
  get isStartPage() {
    return this.survey && this.survey.isPageStarted(this);
  }
  get isStarted() {
    return this.isStartPage;
  }
  calcCssClasses(css) {
    if (this.isPanel) return super.calcCssClasses(css);
    const classes = {
      page: {},
      error: {},
      pageTitle: "",
      pageDescription: "",
      row: "",
      rowMultiple: "",
      pageRow: "",
      rowCompact: "",
      rowEnter: "",
      rowLeave: "",
      rowDelayedEnter: "",
      rowReplace: ""
    };
    this.copyCssClasses(classes.page, css.page);
    this.copyCssClasses(classes.error, css.error);
    if (!!css.pageTitle) {
      classes.pageTitle = css.pageTitle;
    }
    if (!!css.pageDescription) {
      classes.pageDescription = css.pageDescription;
    }
    if (!!css.row) {
      classes.row = css.row;
    }
    if (!!css.pageRow) {
      classes.pageRow = css.pageRow;
    }
    if (!!css.rowMultiple) {
      classes.rowMultiple = css.rowMultiple;
    }
    if (!!css.rowCompact) {
      classes.rowCompact = css.rowCompact;
    }
    if (!!css.rowEnter) {
      classes.rowEnter = css.rowEnter;
    }
    if (!!css.rowDelayedEnter) {
      classes.rowDelayedEnter = css.rowDelayedEnter;
    }
    if (!!css.rowLeave) {
      classes.rowLeave = css.rowLeave;
    }
    if (!!css.rowReplace) {
      classes.rowReplace = css.rowReplace;
    }
    if (this.survey) {
      this.survey.updatePageCssClasses(this, classes);
    }
    return classes;
  }
  getCssPanelTitle() {
    if (this.isPanel) return super.getCssPanelTitle();
    if (!this.cssClasses.page) return "";
    return new CssClassBuilder().append(this.cssClasses.page.title).toString();
  }
  get cssRoot() {
    if (this.isPanel || !this.cssClasses.page || !this.survey) return "";
    return new CssClassBuilder().append(this.cssClasses.page.root).append(this.cssClasses.page.emptyHeaderRoot, !this.survey.renderedHasHeader && !(this.survey.isShowProgressBarOnTop && !this.survey.isStaring)).toString();
  }
  getCssError(cssClasses) {
    if (this.isPanel) return super.getCssError(cssClasses);
    return new CssClassBuilder().append(super.getCssError(cssClasses)).append(cssClasses.page.errorsContainer).toString();
  }
  /**
   * @deprecated Use the [`showNavigationButtons`](https://surveyjs.io/form-library/documentation/api-reference/page-model#showNavigationButtons) property instead.
   */
  get navigationButtonsVisibility() {
    const result = this.showNavigationButtons;
    if (result === void 0 || result === null) {
      return "inherit";
    }
    return result ? "show" : "hide";
  }
  set navigationButtonsVisibility(val) {
    if (typeof val == "string") {
      val = val.toLowerCase();
    }
    this.showNavigationButtons = val;
  }
  /**
   * Gets or sets the visibility of the Start, Next, Previous, and Complete navigation buttons on this page. Overrides the [`showNavigationButtons`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#showNavigationButtons) property specified on the survey-level.
   *
   * Default value: `undefined` (the visibility depends on the survey-level setting)
   */
  get showNavigationButtons() {
    return this.getPropertyValue("showNavigationButtons", void 0);
  }
  set showNavigationButtons(val) {
    this.setShowNavigationButtonsProperty(val);
  }
  setShowNavigationButtonsProperty(val) {
    if (val === true || val === false) {
      this.setPropertyValue("showNavigationButtons", val);
    } else if (val === "show") {
      this.setPropertyValue("showNavigationButtons", true);
    } else if (val === "hide") {
      this.setPropertyValue("showNavigationButtons", false);
    } else {
      this.setPropertyValue("showNavigationButtons", void 0);
    }
  }
  /**
   * Returns `true` if this is the current page.
   * @see SurveyModel.currentPage
   */
  get isActive() {
    return !!this.survey && this.survey.currentPage === this;
  }
  /**
   * Returns `true` if the respondent has already seen this page during the current session.
   */
  get wasShown() {
    return this.hasShownValue;
  }
  get hasShown() {
    return this.wasShown;
  }
  setWasShown(val) {
    var _a;
    if (val == this.hasShownValue) return;
    this.hasShownValue = val;
    if (this.isDesignMode || val !== true) return;
    var els = this.elements;
    for (var i = 0; i < els.length; i++) {
      if (els[i].isPanel) {
        els[i].randomizeElements(this.areQuestionsRandomized);
      }
    }
    if (this.randomizeElements(this.areQuestionsRandomized)) {
      const singleQuestion = (_a = this.survey) === null || _a === void 0 ? void 0 : _a.currentSingleQuestion;
      if ((singleQuestion === null || singleQuestion === void 0 ? void 0 : singleQuestion.page) === this) {
        this.survey.currentSingleQuestion = this.getFirstVisibleQuestion();
      }
    }
  }
  /**
   * Scrolls this page to the top.
   */
  scrollToTop() {
    if (!!this.survey) {
      this.survey.scrollElementToTop(this, null, this, this.id);
    }
  }
  /**
   * Returns a list of all panels on this page.
   * @param visibleOnly A Boolean value that specifies whether to include only visible panels.
   * @param includingDesignTime For internal use.
   */
  getAllPanels(visibleOnly = false, includingDesignTime = false) {
    var result = new Array();
    this.addPanelsIntoList(result, visibleOnly, includingDesignTime);
    return result;
  }
  getPanels(visibleOnly = false, includingDesignTime = false) {
    return this.getAllPanels(visibleOnly, includingDesignTime);
  }
  /**
   * A time period that a respondent has to complete this page; measured in seconds. Applies only to [quiz surveys](https://surveyjs.io/form-library/documentation/design-survey-create-a-quiz).
   *
   * Default value: 0 (time is unlimited)
   *
   * Alternatively, you can use the `SurveyModel`'s [`timeLimitPerPage`](https://surveyjs.io/form-library/documentation/surveymodel#timeLimitPerPage) property to specify identical time periods for all survey pages.
   * @see timeSpent
   */
  get timeLimit() {
    return this.getPropertyValue("timeLimit", 0);
  }
  set timeLimit(val) {
    this.setPropertyValue("timeLimit", val);
  }
  /**
   * @deprecated Use the [`timeLimit`](https://surveyjs.io/form-library/documentation/api-reference/page-model#timeLimit) property instead.
   */
  get maxTimeToFinish() {
    return this.timeLimit;
  }
  set maxTimeToFinish(val) {
    this.timeLimit = val;
  }
  getMaxTimeToFinish() {
    if (this.timeLimit !== 0) return this.timeLimit;
    const res = !!this.survey ? this.survey.timeLimitPerPage : 0;
    return res > 0 ? res : 0;
  }
  onNumChanged(value) {
  }
  onVisibleChanged() {
    if (this.isRandomizing) return;
    super.onVisibleChanged();
    if (this.survey != null) {
      this.survey.pageVisibilityChanged(this, this.isVisible);
    }
  }
  ensureRowsVisibility() {
    super.ensureRowsVisibility();
    this.getPanels().forEach((panel) => panel.ensureRowsVisibility());
  }
  get isReadyForClean() {
    return this._isReadyForClean;
  }
  set isReadyForClean(val) {
    const oldValue = this._isReadyForClean;
    this._isReadyForClean = val;
    if (this._isReadyForClean !== oldValue) {
      this.isReadyForCleanChangedCallback && this.isReadyForCleanChangedCallback();
    }
  }
  enableOnElementRerenderedEvent() {
    super.enableOnElementRerenderedEvent();
    this.isReadyForClean = false;
  }
  disableOnElementRerenderedEvent() {
    super.disableOnElementRerenderedEvent();
    this.isReadyForClean = true;
  }
};
__decorate([property({
  defaultValue: -1,
  onSet: (val, target) => target.onNumChanged(val)
})], PageModel.prototype, "num", void 0);
Serializer.addClass("page", [{
  name: "showNavigationButtons:boolean",
  defaultFunc: () => void 0,
  onSetValue: function(obj, value) {
    obj && obj.setShowNavigationButtonsProperty(value);
  },
  alternativeName: "navigationButtonsVisibility"
}, {
  name: "timeLimit:number",
  alternativeName: "maxTimeToFinish",
  default: 0,
  minValue: 0,
  visibleIf: (obj) => {
    return !!obj.survey && obj.survey.showTimer;
  }
}, {
  name: "navigationTitle",
  visibleIf: function(obj) {
    return !!obj.survey && (obj.survey.progressBarType === "buttons" || obj.survey.showTOC);
  },
  serializationProperty: "locNavigationTitle"
}, {
  name: "navigationDescription",
  visibleIf: function(obj) {
    return !!obj.survey && obj.survey.progressBarType === "buttons";
  },
  serializationProperty: "locNavigationDescription"
}, {
  name: "title:text",
  serializationProperty: "locTitle"
}, {
  name: "description:text",
  serializationProperty: "locDescription"
}, {
  name: "state",
  visible: false
}, {
  name: "isRequired",
  visible: false
}, {
  name: "startWithNewLine",
  visible: false
}, {
  name: "width",
  visible: false
}, {
  name: "minWidth",
  visible: false
}, {
  name: "maxWidth",
  visible: false
}, {
  name: "colSpan",
  visible: false,
  isSerializable: false
}, {
  name: "effectiveColSpan:number",
  visible: false,
  isSerializable: false
}, {
  name: "innerIndent",
  visible: false
}, {
  name: "indent",
  visible: false
}, {
  name: "page",
  visible: false,
  isSerializable: false
}, {
  name: "showNumber",
  visible: false
}, {
  name: "showQuestionNumbers",
  visible: false
}, {
  name: "questionStartIndex",
  visible: false
}, {
  name: "allowAdaptiveActions",
  visible: false
}, {
  name: "requiredErrorText:text",
  serializationProperty: "locRequiredErrorText",
  visible: false
}], function() {
  return new PageModel();
}, "panel");
var ProgressButtons = class extends Base {
  constructor(survey) {
    super();
    this.survey = survey;
    this.onResize = this.addEvent();
  }
  isListElementClickable(index) {
    if (!this.survey.onServerValidateQuestions || this.survey.onServerValidateQuestions.isEmpty || this.survey.checkErrorsMode === "onComplete") {
      return true;
    }
    return index <= this.survey.currentPageNo + 1;
  }
  getRootCss(container = "center") {
    let result = this.survey.css.progressButtonsContainerCenter;
    if (this.survey.css.progressButtonsRoot) {
      result += " " + this.survey.css.progressButtonsRoot + " " + this.survey.css.progressButtonsRoot + "--" + (["footer", "contentBottom"].indexOf(container) !== -1 ? "bottom" : "top");
      result += " " + this.survey.css.progressButtonsRoot + "--" + (this.showItemTitles ? "with-titles" : "no-titles");
    }
    if (this.showItemNumbers && this.survey.css.progressButtonsNumbered) {
      result += " " + this.survey.css.progressButtonsNumbered;
    }
    if (this.isFitToSurveyWidth) {
      result += " " + this.survey.css.progressButtonsFitSurveyWidth;
    }
    return result;
  }
  getListElementCss(index) {
    if (index >= this.survey.visiblePages.length) return;
    return new CssClassBuilder().append(this.survey.css.progressButtonsListElementPassed, this.survey.visiblePages[index].passed).append(this.survey.css.progressButtonsListElementCurrent, this.survey.currentPageNo === index).append(this.survey.css.progressButtonsListElementNonClickable, !this.isListElementClickable(index)).toString();
  }
  getScrollButtonCss(hasScroller, isLeftScroll) {
    return new CssClassBuilder().append(this.survey.css.progressButtonsImageButtonLeft, isLeftScroll).append(this.survey.css.progressButtonsImageButtonRight, !isLeftScroll).append(this.survey.css.progressButtonsImageButtonHidden, !hasScroller).toString();
  }
  clickListElement(element) {
    if (!(element instanceof PageModel)) {
      element = this.survey.visiblePages[element];
    }
    this.survey.tryNavigateToPage(element);
  }
  isListContainerHasScroller(element) {
    const listContainerElement = element.querySelector("." + this.survey.css.progressButtonsListContainer);
    if (!!listContainerElement) {
      return listContainerElement.scrollWidth > listContainerElement.offsetWidth;
    }
    return false;
  }
  isCanShowItemTitles(element) {
    const listContainerElement = element.querySelector("ul");
    if (!listContainerElement || listContainerElement.children.length < 2) return true;
    if (listContainerElement.clientWidth > listContainerElement.parentElement.clientWidth) {
      return false;
    }
    const expectedElementWidth = listContainerElement.children[0].clientWidth;
    for (let i = 0; i < listContainerElement.children.length; i++) {
      if (Math.abs(listContainerElement.children[i].clientWidth - expectedElementWidth) > 5) {
        return false;
      }
    }
    return true;
  }
  clearConnectorsWidth(element) {
    const listContainerElements = element.querySelectorAll(".sd-progress-buttons__connector");
    for (let i = 0; i < listContainerElements.length; i++) {
      listContainerElements[i].style.width = "";
    }
  }
  adjustConnectors(element) {
    const listContainerElement = element.querySelector("ul");
    if (!listContainerElement) return;
    const listContainerElements = element.querySelectorAll(".sd-progress-buttons__connector");
    const circleWidth = this.showItemNumbers ? 36 : 20;
    const connectorWidth = (listContainerElement.clientWidth - circleWidth) / (listContainerElement.children.length - 1) - circleWidth;
    for (let i = 0; i < listContainerElements.length; i++) {
      listContainerElements[i].style.width = connectorWidth + "px";
    }
  }
  get isFitToSurveyWidth() {
    if (surveyCss.currentType !== "default") {
      return false;
    }
    return this.survey.progressBarInheritWidthFrom === "survey" && this.survey.widthMode == "static";
  }
  get progressWidth() {
    if (this.isFitToSurveyWidth) {
      return this.survey.renderedWidth;
    }
    return "";
  }
  get showItemNumbers() {
    if (surveyCss.currentType !== "default") {
      return false;
    }
    return this.survey.progressBarShowPageNumbers;
  }
  get showItemTitles() {
    if (surveyCss.currentType !== "default") {
      return true;
    }
    return this.survey.progressBarShowPageTitles;
  }
  getItemNumber(page) {
    let result = "";
    if (this.showItemNumbers) {
      result += this.survey.visiblePages.indexOf(page) + 1;
    }
    return result;
  }
  get headerText() {
    return this.survey.currentPage ? this.survey.currentPage.renderedNavigationTitle : "";
  }
  get footerText() {
    return this.progressText;
  }
  get progressText() {
    return this.getPropertyValue("progressText", void 0, () => this.survey.getProgressText());
  }
  resetProgressText() {
    this.resetPropertyValue("progressText");
  }
  processResponsiveness(width) {
    this.onResize.fire(this, {
      width
    });
  }
};
var ProgressButtonsResponsivityManager = class {
  constructor(model, element, viewModel) {
    this.model = model;
    this.element = element;
    this.viewModel = viewModel;
    this.criticalProperties = ["progressBarType", "progressBarShowPageTitles"];
    this.canShowItemTitles = true;
    this.processResponsiveness = (model2, options) => {
      this.viewModel.onUpdateScroller(model2.isListContainerHasScroller(this.element));
      this.model.clearConnectorsWidth(this.element);
      if (!model2.showItemTitles) {
        this.model.adjustConnectors(this.element);
        return;
      }
      if (model2.survey.isMobile) {
        this.prevWidth = options.width;
        this.canShowItemTitles = false;
        this.model.adjustConnectors(this.element);
        this.viewModel.onResize(this.canShowItemTitles);
        return;
      }
      if (this.timer !== void 0) {
        clearTimeout(this.timer);
      }
      this.timer = setTimeout(() => {
        if (this.prevWidth === void 0 || this.prevWidth < options.width && !this.canShowItemTitles || this.prevWidth > options.width && this.canShowItemTitles) {
          this.prevWidth = options.width;
          this.canShowItemTitles = model2.isCanShowItemTitles(this.element);
          this.viewModel.onResize(this.canShowItemTitles);
          this.timer = void 0;
        }
      }, 10);
    };
    this.model.survey.registerFunctionOnPropertiesValueChanged(this.criticalProperties, () => this.forceUpdate(), "ProgressButtonsResponsivityManager" + this.viewModel.container);
    this.model.onResize.add(this.processResponsiveness);
    this.forceUpdate();
  }
  forceUpdate() {
    this.viewModel.onUpdateSettings();
    this.processResponsiveness(this.model, {});
  }
  dispose() {
    clearTimeout(this.timer);
    this.model.onResize.remove(this.processResponsiveness);
    this.model.survey.unRegisterFunctionOnPropertiesValueChanged(this.criticalProperties, "ProgressButtonsResponsivityManager" + this.viewModel.container);
    this.element = void 0;
    this.model = void 0;
  }
};
function getPage(question) {
  if (!!question.parentQuestion) {
    return getPage(question.parentQuestion);
  }
  let parent = question.parent;
  while (parent && parent.getType() !== "page" && parent.parent) {
    parent = parent.parent;
  }
  if (parent && parent.getType() === "page") {
    return parent;
  }
  return null;
}
function createTOCListModel(survey, onAction) {
  var items = getTOCItems(survey, onAction);
  const listOptions = {
    items,
    searchEnabled: false,
    locOwner: survey
  };
  var listModel = new ListModel(listOptions);
  listModel.allowSelection = false;
  const updateSelectedItem = (currentPage, defaultSelection) => {
    listModel.selectedItem = !!currentPage && listModel.actions.filter((i) => i.id === currentPage.name)[0] || defaultSelection;
  };
  updateSelectedItem(survey.currentPage, items[0]);
  survey.onCurrentPageChanged.add((s, o) => {
    updateSelectedItem(survey.currentPage);
  });
  survey.onFocusInQuestion.add((s, o) => {
    updateSelectedItem(getPage(o.question));
  });
  survey.registerFunctionOnPropertyValueChanged("pages", () => {
    listModel.setItems(getTOCItems(survey, onAction));
  }, "toc");
  return listModel;
}
function getTOCItems(survey, onAction) {
  const pagesSource = survey.pages;
  var items = (pagesSource || []).map((page) => {
    return new Action({
      id: page.name,
      locTitle: page.locNavigationTitle,
      action: () => {
        DomDocumentHelper.activeElementBlur();
        !!onAction && onAction();
        if (page.isPage) {
          return survey.tryNavigateToPage(page);
        }
      },
      visible: new ComputedUpdater(() => {
        return page.isVisible && !page["isStartPage"];
      })
    });
  });
  return items;
}
function getTocRootCss(survey, isMobile = false) {
  let rootCss = TOCModel.RootStyle;
  if (isMobile) {
    return rootCss + " " + TOCModel.RootStyle + "--mobile";
  }
  rootCss += " " + TOCModel.RootStyle + "--" + (survey.tocLocation || "").toLowerCase();
  if (TOCModel.StickyPosition) {
    rootCss += " " + TOCModel.RootStyle + "--sticky";
  }
  return rootCss;
}
var TOCModel = class _TOCModel {
  constructor(survey) {
    this.survey = survey;
    this.icon = "icon-navmenu_24x24";
    this.togglePopup = () => {
      this.popupModel.toggleVisibility();
    };
    this.listModel = createTOCListModel(survey, () => {
      this.popupModel.isVisible = false;
    });
    this.popupModel = new PopupModel("sv-list", {
      model: this.listModel
    });
    this.popupModel.overlayDisplayMode = "plain";
    this.popupModel.displayMode = new ComputedUpdater(() => this.isMobile ? "overlay" : "popup");
    if (_TOCModel.StickyPosition) {
      survey.onAfterRenderSurvey.add((s, o) => this.initStickyTOCSubscriptions(o.htmlElement));
      this.initStickyTOCSubscriptions(survey.rootElement);
    }
  }
  initStickyTOCSubscriptions(rootElement) {
    if (_TOCModel.StickyPosition && !!rootElement) {
      rootElement.addEventListener("scroll", (event) => {
        this.updateStickyTOCSize(rootElement);
      });
      this.updateStickyTOCSize(rootElement);
    }
  }
  updateStickyTOCSize(rootElement) {
    if (!rootElement) {
      return;
    }
    const tocRootElement = rootElement.querySelector("." + _TOCModel.RootStyle);
    if (!!tocRootElement) {
      tocRootElement.style.height = "";
      if (!this.isMobile && _TOCModel.StickyPosition && !!rootElement) {
        const rootHeight = rootElement.getBoundingClientRect().height;
        const titleSelector = this.survey.headerView === "advanced" ? ".sv-header" : ".sv_custom_header+div div." + (this.survey.css.title || "sd-title");
        const titleElement = rootElement.querySelector(titleSelector);
        const titleElementHeight = titleElement ? titleElement.getBoundingClientRect().height : 0;
        const scrollCompensationHeight = rootElement.scrollTop > titleElementHeight ? 0 : titleElementHeight - rootElement.scrollTop;
        tocRootElement.style.height = rootHeight - scrollCompensationHeight - 1 + "px";
      }
    }
  }
  get isMobile() {
    return this.survey.isMobile;
  }
  get containerCss() {
    return getTocRootCss(this.survey, this.isMobile);
  }
  dispose() {
    this.survey.unRegisterFunctionOnPropertyValueChanged("pages", "toc");
    this.popupModel.dispose();
    this.listModel.dispose();
  }
};
TOCModel.RootStyle = "sv_progress-toc";
TOCModel.StickyPosition = true;
var SurveyModel = class _SurveyModel extends SurveyElementCore {
  get platformName() {
    return _SurveyModel.platform;
  }
  /**
   * A suffix added to the name of the property that stores comments.
   *
   * Default value: "-Comment"
   *
   * Many question types allow respondents to leave comments. To enable this functionality, set a question's [`showCommentArea`](https://surveyjs.io/form-library/documentation/api-reference/checkbox-question-model#showCommentArea) property to `true`. Comment values are saved in a separate property. The property name is composed of the question `name` and `commentSuffix`.
   *
   * Respondents can also leave comments when they select "Other" in choice-based questions, such as Dropdown or Checkboxes. The property name for the comment value is composed according to the same rules. However, you can use the question `name` as a key to store the comment value instead. Disable the [`storeOthersAsComment`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#storeOthersAsComment) property in this case.
   *
   * [View Demo](https://surveyjs.io/form-library/examples/create-checkboxes-question-in-javascript/ (linkStyle))
   */
  get commentSuffix() {
    return settings.commentSuffix;
  }
  set commentSuffix(val) {
    settings.commentSuffix = val;
  }
  get commentPrefix() {
    return this.commentSuffix;
  }
  set commentPrefix(val) {
    this.commentSuffix = val;
  }
  //#endregion
  constructor(jsonObj = null, renderedElement = null) {
    super();
    this.valuesHash = {};
    this.variablesHash = {};
    this.onTriggerExecuted = this.addEvent();
    this.onCompleting = this.addEvent();
    this.onComplete = this.addEvent();
    this.onShowingPreview = this.addEvent();
    this.onNavigateToUrl = this.addEvent();
    this.onStarted = this.addEvent();
    this.onPartialSend = this.addEvent();
    this.onCurrentPageChanging = this.addEvent();
    this.onCurrentPageChanged = this.addEvent();
    this.onValueChanging = this.addEvent();
    this.onValueChanged = this.addEvent();
    this.onVariableChanged = this.addEvent();
    this.onQuestionVisibleChanged = this.addEvent();
    this.onVisibleChanged = this.onQuestionVisibleChanged;
    this.onPageVisibleChanged = this.addEvent();
    this.onPanelVisibleChanged = this.addEvent();
    this.onQuestionCreated = this.addEvent();
    this.onQuestionAdded = this.addEvent();
    this.onQuestionRemoved = this.addEvent();
    this.onPanelAdded = this.addEvent();
    this.onPanelRemoved = this.addEvent();
    this.onPageAdded = this.addEvent();
    this.onValidateQuestion = this.addEvent();
    this.onSettingQuestionErrors = this.addEvent();
    this.onServerValidateQuestions = this.addEvent();
    this.onValidatePanel = this.addEvent();
    this.onErrorCustomText = this.addEvent();
    this.onValidatePage = this.addEvent();
    this.onValidatedErrorsOnCurrentPage = this.onValidatePage;
    this.onProcessHtml = this.addEvent();
    this.onGetQuestionDisplayValue = this.addEvent();
    this.onGetQuestionTitle = this.addEvent();
    this.onGetTitleTagName = this.addEvent();
    this.onGetQuestionNumber = this.addEvent();
    this.onGetQuestionNo = this.onGetQuestionNumber;
    this.onGetPanelNumber = this.addEvent();
    this.onGetPageNumber = this.addEvent();
    this.onGetProgressText = this.addEvent();
    this.onProgressText = this.onGetProgressText;
    this.onTextMarkdown = this.addEvent();
    this.onTextRenderAs = this.addEvent();
    this.onSendResult = this.addEvent();
    this.onGetResult = this.addEvent();
    this.onOpenFileChooser = this.addEvent();
    this.onUploadFiles = this.addEvent();
    this.onDownloadFile = this.addEvent();
    this.onClearFiles = this.addEvent();
    this.onChoicesLoaded = this.addEvent();
    this.onLoadChoicesFromServer = this.onChoicesLoaded;
    this.onLoadedSurveyFromService = this.addEvent();
    this.onProcessDynamicText = this.addEvent();
    this.onProcessTextValue = this.onProcessDynamicText;
    this.onUpdateQuestionCssClasses = this.addEvent();
    this.onUpdatePanelCssClasses = this.addEvent();
    this.onUpdatePageCssClasses = this.addEvent();
    this.onUpdateChoiceItemCss = this.addEvent();
    this.onAfterRenderSurvey = this.addEvent();
    this.onAfterRenderHeader = this.addEvent();
    this.onAfterRenderPage = this.addEvent();
    this.onAfterRenderQuestion = this.addEvent();
    this.onAfterRenderQuestionInput = this.addEvent();
    this.onAfterRenderPanel = this.addEvent();
    this.onFocusInQuestion = this.addEvent();
    this.onFocusInPanel = this.addEvent();
    this.onShowingChoiceItem = this.addEvent();
    this.onChoicesLazyLoad = this.addEvent();
    this.onChoicesSearch = this.addEvent();
    this.onGetChoiceDisplayValue = this.addEvent();
    this.onMatrixRowAdded = this.addEvent();
    this.onMatrixRowAdding = this.addEvent();
    this.onMatrixBeforeRowAdded = this.onMatrixRowAdding;
    this.onMatrixRowRemoving = this.addEvent();
    this.onMatrixRowRemoved = this.addEvent();
    this.onMatrixRenderRemoveButton = this.addEvent();
    this.onMatrixAllowRemoveRow = this.onMatrixRenderRemoveButton;
    this.onMatrixDetailPanelVisibleChanged = this.addEvent();
    this.onMatrixCellCreating = this.addEvent();
    this.onMatrixCellCreated = this.addEvent();
    this.onAfterRenderMatrixCell = this.addEvent();
    this.onMatrixAfterCellRender = this.onAfterRenderMatrixCell;
    this.onMatrixCellValueChanged = this.addEvent();
    this.onMatrixCellValueChanging = this.addEvent();
    this.onMatrixCellValidate = this.addEvent();
    this.onMatrixColumnAdded = this.addEvent();
    this.onMultipleTextItemAdded = this.addEvent();
    this.onDynamicPanelAdded = this.addEvent();
    this.onDynamicPanelRemoved = this.addEvent();
    this.onDynamicPanelRemoving = this.addEvent();
    this.onTimerTick = this.addEvent();
    this.onTimer = this.onTimerTick;
    this.onTimerPanelInfoText = this.addEvent();
    this.onDynamicPanelValueChanged = this.addEvent();
    this.onDynamicPanelItemValueChanged = this.onDynamicPanelValueChanged;
    this.onDynamicPanelValueChanging = this.addEvent();
    this.onGetDynamicPanelTabTitle = this.addEvent();
    this.onDynamicPanelCurrentIndexChanged = this.addEvent();
    this.onCheckAnswerCorrect = this.addEvent();
    this.onIsAnswerCorrect = this.onCheckAnswerCorrect;
    this.onDragDropAllow = this.addEvent();
    this.onScrollToTop = this.addEvent();
    this.onScrollingElementToTop = this.onScrollToTop;
    this.onLocaleChangedEvent = this.addEvent();
    this.onGetQuestionTitleActions = this.addEvent();
    this.onGetPanelTitleActions = this.addEvent();
    this.onGetPageTitleActions = this.addEvent();
    this.onGetPanelFooterActions = this.addEvent();
    this.onGetMatrixRowActions = this.addEvent();
    this.onElementContentVisibilityChanged = this.addEvent();
    this.onGetExpressionDisplayValue = this.addEvent();
    this.onPopupVisibleChanged = this.addEvent();
    this.onOpenDropdownMenu = this.addEvent();
    this.onElementWrapperComponentName = this.addEvent();
    this.onElementWrapperComponentData = this.addEvent();
    this.jsonErrors = null;
    this.cssValue = null;
    this.showHeaderOnCompletePage = "auto";
    this._isLazyRenderingSuspended = false;
    this.hideRequiredErrors = false;
    this.cssVariables = {};
    this._isMobile = false;
    this._isCompact = false;
    this.setValueOnExpressionCounter = 0;
    this._isDesignMode = false;
    this.validationAllowSwitchPages = false;
    this.validationAllowComplete = false;
    this.isNavigationButtonPressed = false;
    this.mouseDownPage = null;
    this.isSmoothScrollEnabled = false;
    this.onResize = new EventBase();
    this.isCurrentPageRendering = true;
    this.isCurrentPageRendered = void 0;
    this.skeletonHeight = void 0;
    this.isTriggerIsRunning = false;
    this.triggerValues = null;
    this.triggerKeys = null;
    this.conditionValues = null;
    this.isValueChangedOnRunningCondition = false;
    this.conditionRunnerCounter = 0;
    this.conditionUpdateVisibleIndexes = false;
    this.conditionNotifyElementsOnAnyValueOrVariableChanged = false;
    this.isEndLoadingFromJson = null;
    this.questionHashes = {
      names: {},
      namesInsensitive: {},
      valueNames: {},
      valueNamesInsensitive: {}
    };
    this.setValueFromTriggerCounter = 0;
    this.isMovingPage = false;
    this.needRenderIcons = true;
    this.skippedPages = [];
    this.skeletonComponentName = "sv-skeleton";
    this.taskManager = new SurveyTaskManagerModel();
    this.questionErrorComponent = "sv-question-error";
    this.onBeforeRunConstructor();
    const htmlCallBack = (str) => {
      return "<h3>" + str + "</h3>";
    };
    this.createHtmlLocString("completedHtml", "completingSurvey", htmlCallBack);
    this.createHtmlLocString("completedBeforeHtml", "completingSurveyBefore", htmlCallBack, "completed-before");
    this.createHtmlLocString("loadingHtml", "loadingSurvey", htmlCallBack, "loading");
    this.createLocalizableString("emptySurveyText", this, true, "emptySurvey");
    this.createLocalizableString("logo", this, false);
    this.createLocalizableString("startSurveyText", this, false, true);
    this.createLocalizableString("pagePrevText", this, false, true);
    this.createLocalizableString("pageNextText", this, false, true);
    this.createLocalizableString("completeText", this, false, true);
    this.createLocalizableString("previewText", this, false, true);
    this.createLocalizableString("editText", this, false, true);
    this.createLocalizableString("questionTitleTemplate", this, true);
    this.timerModelValue = new SurveyTimerModel(this);
    this.timerModelValue.onTimerTick = (page) => {
      this.doTimer(page);
    };
    this.createNewArray("pages", (value) => {
      if (value.isReadyForCleanChangedCallback) {
        value.isReadyForCleanChangedCallback();
      }
      this.doOnPageAdded(value);
    }, (value) => {
      if (!value.isReadyForClean) {
        value.isReadyForCleanChangedCallback = () => {
          this.doOnPageRemoved(value);
          value.isReadyForCleanChangedCallback = void 0;
        };
      } else {
        this.doOnPageRemoved(value);
      }
    });
    this.createNewArray("triggers", (value) => {
      value.setOwner(this);
    });
    this.createNewArray("calculatedValues", (value) => {
      value.setOwner(this);
    });
    this.createNewArray("completedHtmlOnCondition", (value) => {
      value.locOwner = this;
    });
    this.createNewArray("navigateToUrlOnCondition", (value) => {
      value.locOwner = this;
    });
    this.registerPropertyChangedHandlers(["locale"], () => {
      this.onSurveyLocaleChanged();
    });
    this.registerPropertyChangedHandlers(["firstPageIsStartPage"], () => {
      this.onFirstPageIsStartedChanged();
    });
    this.registerPropertyChangedHandlers(["readOnly"], () => {
      this.onReadOnlyChanged();
    });
    this.registerPropertyChangedHandlers(["progressBarType"], () => {
      this.updateProgressText();
    });
    this.registerPropertyChangedHandlers(["questionStartIndex", "requiredMark", "questionTitlePattern"], () => {
      this.resetVisibleIndexes();
    });
    this.registerPropertyChangedHandlers(["isLoading", "isCompleted", "isCompletedBefore", "readOnly", "isStartedState", "currentPage", "isShowingPreview"], () => {
      this.updateState();
    });
    this.registerPropertyChangedHandlers(["state", "currentPage", "showPreviewBeforeComplete"], () => {
      this.onStateAndCurrentPageChanged();
    });
    this.registerPropertyChangedHandlers(["logo", "logoPosition"], () => {
      this.resetHasLogo();
    });
    this.registerPropertyChangedHandlers(["backgroundImage"], () => {
      this.resetPropertyValue("renderBackgroundImage");
    });
    this.registerPropertyChangedHandlers(["backgroundImage", "backgroundOpacity", "backgroundImageFit", "fitToContainer", "backgroundImageAttachment"], () => {
      this.resetPropertyValue("backgroundImageStyle");
    });
    this.registerPropertyChangedHandlers(["showPrevButton", "showCompleteButton"], () => {
      this.updateButtonsVisibility();
    });
    this.onGetQuestionNumber.onCallbacksChanged = () => {
      this.resetVisibleIndexes();
    };
    this.onGetPanelNumber.onCallbacksChanged = () => {
      this.resetVisibleIndexes();
    };
    this.onGetProgressText.onCallbacksChanged = () => {
      this.updateProgressText();
    };
    this.onTextMarkdown.onCallbacksChanged = () => {
      this.locStrsChanged();
    };
    this.onProcessHtml.onCallbacksChanged = () => {
      this.locStrsChanged();
    };
    this.onGetQuestionTitle.onCallbacksChanged = () => {
      this.locStrsChanged();
    };
    this.onUpdatePageCssClasses.onCallbacksChanged = () => {
      this.currentPage && this.currentPage.updateElementCss();
    };
    this.onUpdatePanelCssClasses.onCallbacksChanged = () => {
      this.currentPage && this.currentPage.updateElementCss();
    };
    this.onUpdateQuestionCssClasses.onCallbacksChanged = () => {
      this.currentPage && this.currentPage.updateElementCss();
    };
    this.onShowingChoiceItem.onCallbacksChanged = () => {
      this.rebuildQuestionChoices();
    };
    this.locTitle.onStringChanged.add(() => this.resetPropertyValue("titleIsEmpty"));
    this.onBeforeCreating();
    if (jsonObj) {
      if (typeof jsonObj === "string" || jsonObj instanceof String) {
        jsonObj = JSON.parse(jsonObj);
      }
      if (jsonObj && jsonObj.clientId) {
        this.clientId = jsonObj.clientId;
      }
      this.fromJSON(jsonObj);
      if (this.surveyId) {
        this.loadSurveyFromService(this.surveyId, this.clientId);
      }
    }
    this.onCreating();
    if (!!renderedElement) {
      this.render(renderedElement);
    }
    this.updateCss();
    this.setCalculatedWidthModeUpdater();
    this.notifier = new Notifier(this.css.saveData);
    this.notifier.addAction(this.createTryAgainAction(), "error");
    this.onPopupVisibleChanged.add((_, opt) => {
      if (opt.visible) {
        this.onScrollCallback = () => {
          opt.popup.hide();
        };
      } else {
        this.onScrollCallback = void 0;
      }
    });
    this.layoutElements.push({
      id: "timerpanel",
      template: "survey-timerpanel",
      component: "sv-timerpanel",
      data: this.timerModel
    });
    this.layoutElements.push({
      id: "progress-buttons",
      component: "sv-progress-buttons",
      getData: () => this.progressBar,
      processResponsiveness: (width) => this.progressBar.processResponsiveness && this.progressBar.processResponsiveness(width)
    });
    this.layoutElements.push({
      id: "progress-questions",
      component: "sv-progress-questions",
      data: this
    });
    this.layoutElements.push({
      id: "progress-pages",
      component: "sv-progress-pages",
      data: this
    });
    this.layoutElements.push({
      id: "progress-correctquestions",
      component: "sv-progress-correctquestions",
      data: this
    });
    this.layoutElements.push({
      id: "progress-requiredquestions",
      component: "sv-progress-requiredquestions",
      data: this
    });
    this.addLayoutElement({
      id: "toc-navigation",
      component: "sv-navigation-toc",
      getData: () => this.tocModel,
      processResponsiveness: (width) => this.tocModel.updateStickyTOCSize(this.rootElement)
    });
    this.layoutElements.push({
      id: "buttons-navigation",
      component: "sv-action-bar",
      getData: () => this.navigationBar
    });
  }
  get tocModel() {
    if (!this.tocModelValue) {
      this.tocModelValue = new TOCModel(this);
    }
    return this.tocModelValue;
  }
  get sjsVersion() {
    return this.getPropertyValue("sjsVersion");
  }
  set sjsVersion(val) {
    this.setPropertyValue("sjsVersion", val);
  }
  processClosedPopup(question, popupModel) {
    throw new Error("Method not implemented.");
  }
  createTryAgainAction() {
    return {
      id: "save-again",
      title: this.getLocalizationString("saveAgainButton"),
      action: () => {
        if (this.isCompleted) {
          this.saveDataOnComplete();
        } else {
          this.doComplete();
        }
      }
    };
  }
  createHtmlLocString(name, locName, func, reason) {
    const res = this.createLocalizableString(name, this, false, locName);
    res.onGetLocalizationTextCallback = func;
    if (reason) {
      res.onGetTextCallback = (str) => {
        return this.processHtml(str, reason);
      };
    }
  }
  getType() {
    return "survey";
  }
  onPropertyValueChanged(name, oldValue, newValue) {
    if (name === "questionsOnPageMode") {
      this.onQuestionsOnPageModeChanged(oldValue);
    }
  }
  /**
   * Returns an array of all pages in the survey.
   *
   * To get an array of only visible pages, use the [`visiblePages`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#visiblePages) array.
   * @see PageModel
   */
  get pages() {
    return this.getPropertyValue("pages");
  }
  render(element = null) {
    if (this.renderCallback) {
      this.renderCallback();
    }
  }
  updateSurvey(newProps, oldProps) {
    for (var key in newProps) {
      if (key == "model" || key == "children") continue;
      if (key.indexOf("on") == 0 && this[key] && this[key].add) {
        let funcBody = newProps[key];
        let func = function(sender, options) {
          funcBody(sender, options);
        };
        this[key].add(func);
      } else {
        this[key] = newProps[key];
      }
    }
    if (newProps && newProps.data) this.onValueChanged.add((sender, options) => {
      newProps.data[options.name] = options.value;
    });
  }
  getCss() {
    return this.css;
  }
  updateCompletedPageCss() {
    this.containerCss = this.css.container;
    this.completedCss = new CssClassBuilder().append(this.css.body).append(this.css.completedPage).toString();
    this.completedBeforeCss = new CssClassBuilder().append(this.css.body).append(this.css.completedBeforePage).toString();
    this.loadingBodyCss = new CssClassBuilder().append(this.css.body).append(this.css.bodyLoading).toString();
  }
  updateCss() {
    this.rootCss = this.getRootCss();
    this.updateNavigationCss();
    this.updateCompletedPageCss();
    this.updateWrapperFormCss();
  }
  /**
   * Gets or sets an object in which keys are UI elements and values are CSS classes applied to them.
   *
   * [View Demo](https://surveyjs.io/form-library/examples/customize-survey-with-css/ (linkStyle))
   */
  get css() {
    if (!this.cssValue) {
      this.cssValue = {};
      this.copyCssClasses(this.cssValue, surveyCss.getCss());
    }
    return this.cssValue;
  }
  set css(value) {
    this.setCss(value);
  }
  setCss(value, needMerge = true) {
    if (needMerge) {
      this.mergeValues(value, this.css);
    } else {
      this.cssValue = value;
    }
    this.updateElementCss(false);
  }
  get cssTitle() {
    return this.css.title;
  }
  get cssNavigationComplete() {
    return this.getNavigationCss(this.cssSurveyNavigationButton, this.css.navigation.complete);
  }
  get cssNavigationPreview() {
    return this.getNavigationCss(this.cssSurveyNavigationButton, this.css.navigation.preview);
  }
  get cssNavigationEdit() {
    return this.getNavigationCss(this.css.navigationButton, this.css.navigation.edit);
  }
  get cssNavigationPrev() {
    return this.getNavigationCss(this.cssSurveyNavigationButton, this.css.navigation.prev);
  }
  get cssNavigationStart() {
    return this.getNavigationCss(this.cssSurveyNavigationButton, this.css.navigation.start);
  }
  get cssNavigationNext() {
    return this.getNavigationCss(this.cssSurveyNavigationButton, this.css.navigation.next);
  }
  get cssSurveyNavigationButton() {
    return new CssClassBuilder().append(this.css.navigationButton).append(this.css.bodyNavigationButton).toString();
  }
  get bodyCss() {
    return new CssClassBuilder().append(this.css.body).append(this.css.bodyWithTimer, this.showTimer && this.state === "running").append(this.css.body + "--" + this.calculatedWidthMode).toString();
  }
  get bodyContainerCss() {
    return this.css.bodyContainer;
  }
  insertAdvancedHeader(advHeader) {
    advHeader.survey = this;
    this.layoutElements.push({
      id: "advanced-header",
      container: "header",
      component: "sv-header",
      index: -100,
      data: advHeader,
      processResponsiveness: (width) => advHeader.processResponsiveness()
    });
  }
  getNavigationCss(main, btn) {
    return new CssClassBuilder().append(main).append(btn).toString();
  }
  /**
   * Specifies whether to enable lazy rendering.
   *
   * In default mode, a survey renders the entire current page. With lazy rendering, the survey renders the page gradually as a user scrolls it. This helps reduce survey startup time and optimizes large surveys for low-end devices.
   *
   * Default value: `false`
   *
   * [View Demo](https://surveyjs.io/form-library/examples/survey-lazy/ (linkStyle))
   * @see [settings.lazyRender](https://surveyjs.io/form-library/documentation/api-reference/settings#lazyRender)
   */
  get lazyRenderEnabled() {
    return this.lazyRenderEnabledValue === true;
  }
  set lazyRenderEnabled(val) {
    if (this.lazyRenderEnabled === val) return;
    this.lazyRenderEnabledValue = val;
    const page = this.currentPage;
    if (!!page) {
      page.updateRows();
    }
  }
  /**
   * @deprecated Use the [`lazyRenderEnabled`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#lazyRenderEnabled) property instead.
   */
  get lazyRendering() {
    return this.lazyRenderEnabled;
  }
  set lazyRendering(val) {
    this.lazyRenderEnabled = val;
  }
  get isLazyRendering() {
    return this.lazyRenderEnabled || settings.lazyRender.enabled;
  }
  get lazyRenderFirstBatchSize() {
    return this.lazyRenderFirstBatchSizeValue || settings.lazyRender.firstBatchSize;
  }
  set lazyRenderFirstBatchSize(val) {
    this.lazyRenderFirstBatchSizeValue = val;
  }
  get isLazyRenderingSuspended() {
    return this._isLazyRenderingSuspended;
  }
  suspendLazyRendering() {
    if (!this.isLazyRendering) return;
    this._isLazyRenderingSuspended = true;
  }
  releaseLazyRendering() {
    if (!this.isLazyRendering) return;
    this._isLazyRenderingSuspended = false;
  }
  updateLazyRenderingRowsOnRemovingElements() {
    if (!this.isLazyRendering) return;
    var page = this.currentPage;
    if (!!page) {
      activateLazyRenderingChecks(page.id);
    }
  }
  /**
   * A list of triggers in the survey.
   *
   * [Conditional Survey Logic (Triggers)](https://surveyjs.io/form-library/documentation/design-survey/conditional-logic#conditional-survey-logic-triggers (linkStyle))
   * @see runTriggers
   * @see onTriggerExecuted
   */
  get triggers() {
    return this.getPropertyValue("triggers");
  }
  set triggers(val) {
    this.setPropertyValue("triggers", val);
  }
  /**
   * An array of [calculated values](https://surveyjs.io/form-library/documentation/design-survey-conditional-logic#calculated-values).
   */
  get calculatedValues() {
    return this.getPropertyValue("calculatedValues");
  }
  set calculatedValues(val) {
    this.setPropertyValue("calculatedValues", val);
  }
  /**
   * @deprecated Self-hosted Form Library [no longer supports integration with SurveyJS Demo Service](https://surveyjs.io/stay-updated/release-notes/v2.0.0#form-library-removes-apis-for-integration-with-surveyjs-demo-service).
   */
  get surveyId() {
    return this.getPropertyValue("surveyId", "");
  }
  set surveyId(val) {
    this.setPropertyValue("surveyId", val);
  }
  /**
   * @deprecated Self-hosted Form Library [no longer supports integration with SurveyJS Demo Service](https://surveyjs.io/stay-updated/release-notes/v2.0.0#form-library-removes-apis-for-integration-with-surveyjs-demo-service).
   */
  get surveyPostId() {
    return this.getPropertyValue("surveyPostId", "");
  }
  set surveyPostId(val) {
    this.setPropertyValue("surveyPostId", val);
  }
  /**
   * @deprecated Self-hosted Form Library [no longer supports integration with SurveyJS Demo Service](https://surveyjs.io/stay-updated/release-notes/v2.0.0#form-library-removes-apis-for-integration-with-surveyjs-demo-service).
   */
  get clientId() {
    return this.getPropertyValue("clientId", "");
  }
  set clientId(val) {
    this.setPropertyValue("clientId", val);
  }
  /**
   * A cookie name used to save information about survey completion.
   *
   * When this property has a value, the survey creates a cookie with the specified name on completion. This cookie helps ensure that users do not pass the same survey twice. On the second run, they will see the [Completed Before page](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#completedBeforeHtml).
   * @see clientId
   */
  get cookieName() {
    return this.getPropertyValue("cookieName", "");
  }
  set cookieName(val) {
    this.setPropertyValue("cookieName", val);
  }
  /**
   * Specifies whether to save survey results when respondents switch between pages. Handle the [`onPartialSend`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#onPartialSend) event to implement the save operation.
   *
   * Alternatively, you can handle the [`onCurrentPageChanged`](#onCurrentPageChanged) and [`onValueChanged`](#onValueChanged) events, as shown in the following demo: [Continue an Incomplete Survey](https://surveyjs.io/form-library/examples/survey-editprevious/).
   */
  get partialSendEnabled() {
    return this.getPropertyValue("partialSendEnabled");
  }
  set partialSendEnabled(val) {
    this.setPropertyValue("partialSendEnabled", val);
  }
  /**
   * @deprecated Use the [`partialSend`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#partialSend) property instead.
   */
  get sendResultOnPageNext() {
    return this.partialSendEnabled;
  }
  set sendResultOnPageNext(val) {
    this.partialSendEnabled = val;
  }
  /**
   * @deprecated Self-hosted Form Library [no longer supports integration with SurveyJS Demo Service](https://surveyjs.io/stay-updated/release-notes/v2.0.0#form-library-removes-apis-for-integration-with-surveyjs-demo-service).
   */
  get surveyShowDataSaving() {
    return this.getPropertyValue("surveyShowDataSaving");
  }
  set surveyShowDataSaving(val) {
    this.setPropertyValue("surveyShowDataSaving", val);
  }
  /**
   * Specifies whether to focus the first question on the page on survey startup or when users switch between pages.
   *
   * Default value: `false` in v1.9.114 and later, `true` in earlier versions
   * @see autoFocusFirstError
   * @see focusFirstQuestion
   * @see focusQuestion
   */
  get autoFocusFirstQuestion() {
    return this.getPropertyValue("autoFocusFirstQuestion");
  }
  set autoFocusFirstQuestion(val) {
    this.setPropertyValue("autoFocusFirstQuestion", val);
  }
  /**
   * @deprecated Use the [`autoFocusFirstQuestion`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#autoFocusFirstQuestion) property instead.
   */
  get focusFirstQuestionAutomatic() {
    return this.autoFocusFirstQuestion;
  }
  set focusFirstQuestionAutomatic(val) {
    this.autoFocusFirstQuestion = val;
  }
  /**
   * Specifies whether to focus the first question with a validation error on the current page.
   *
   * Default value: `true`
   * @see validate
   * @see autoFocusFirstQuestion
   */
  get autoFocusFirstError() {
    return this.getPropertyValue("autoFocusFirstError");
  }
  set autoFocusFirstError(val) {
    this.setPropertyValue("autoFocusFirstError", val);
  }
  /**
   * @deprecated Use the [`autoFocusFirstError`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#autoFocusFirstError) property instead.
   */
  get focusOnFirstError() {
    return this.autoFocusFirstError;
  }
  set focusOnFirstError(val) {
    this.autoFocusFirstError = val;
  }
  /**
   * Gets or sets the visibility of the Start, Next, Previous, and Complete navigation buttons.
   *
   * Possible values:
   *
   * - `true` (default) - Displays the navigation buttons.
   * - `false` - Hides the navigation buttons. This setting may be useful if you [implement custom external navigation](https://surveyjs.io/form-library/examples/external-form-navigation-system/).
   * @see navigationButtonsLocation
   * @see autoAdvanceEnabled
   * @see showPrevButton
   * @see showCompleteButton
   */
  get showNavigationButtons() {
    return this.getPropertyValue("showNavigationButtons");
  }
  set showNavigationButtons(val) {
    if (val === true || val === false) {
      this.setPropertyValue("showNavigationButtons", val);
    } else if (val === "none") {
      this.setPropertyValue("showNavigationButtons", false);
    } else if (["top", "bottom", "both", "topBottom"].indexOf(val) > -1) {
      this.setPropertyValue("showNavigationButtons", true);
      this.navigationButtonsLocation = val;
    }
  }
  /**
   * Gets or sets the position of the Start, Next, Previous, and Complete navigation buttons. Applies only if the [`showNavigationButtons`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#showNavigationButtons) property is `true`.
   *
   * Possible values:
   *
   * - `"bottom"` (default) - Displays the navigation buttons below survey content.
   * - `"top"` - Displays the navigation buttons above survey content.
   * - `"topBottom"` - Displays the navigation buttons above and below survey content.
   * @see autoAdvanceEnabled
   * @see showPrevButton
   * @see showCompleteButton
   */
  get navigationButtonsLocation() {
    return this.getPropertyValue("navigationButtonsLocation");
  }
  set navigationButtonsLocation(val) {
    this.setPropertyValue("navigationButtonsLocation", val);
  }
  /**
   * Specifies whether to display the Previous button. Set this property to `false` if respondents should not move backward along the survey.
   * @see showNavigationButtons
   * @see showCompleteButton
   */
  get showPrevButton() {
    return this.getPropertyValue("showPrevButton");
  }
  set showPrevButton(val) {
    this.setPropertyValue("showPrevButton", val);
  }
  /**
   * Specifies whether to display the Complete button. Set this property to `false` if respondents should not complete the survey.
   * @see showNavigationButtons
   * @see showPrevButton
   */
  get showCompleteButton() {
    return this.getPropertyValue("showCompleteButton", true);
  }
  set showCompleteButton(val) {
    this.setPropertyValue("showCompleteButton", val);
  }
  /**
   * Gets or sets the visibility of the table of contents.
   *
   * Default value: `false`
   *
   * [View Demo](https://surveyjs.io/form-library/examples/toc-feature/ (linkStyle))
   * @see tocLocation
   */
  get showTOC() {
    return this.getPropertyValue("showTOC");
  }
  set showTOC(val) {
    this.setPropertyValue("showTOC", val);
  }
  /**
   * Gets or sets the position of the table of contents. Applies only when the table of contents is visible.
   *
   * Possible values:
   *
   * - `"left"` (default)
   * - `"right"`
   *
   * [View Demo](https://surveyjs.io/form-library/examples/toc-feature/ (linkStyle))
   * @see showTOC
   */
  get tocLocation() {
    return this.getPropertyValue("tocLocation");
  }
  set tocLocation(val) {
    this.setPropertyValue("tocLocation", val);
  }
  /**
   * Specifies whether to display the [survey title](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#title).
   *
   * [View Demo](https://surveyjs.io/form-library/examples/brand-your-survey-header/ (linkStyle))
   * @see title
   */
  get showTitle() {
    return this.getPropertyValue("showTitle");
  }
  set showTitle(val) {
    this.setPropertyValue("showTitle", val);
  }
  /**
   * Specifies whether to display [page titles](https://surveyjs.io/form-library/documentation/api-reference/page-model#title).
   */
  get showPageTitles() {
    return this.getPropertyValue("showPageTitles");
  }
  set showPageTitles(val) {
    this.setPropertyValue("showPageTitles", val);
  }
  /**
   * Specifies whether to show the [complete page](https://surveyjs.io/form-library/documentation/design-survey/create-a-multi-page-survey#complete-page).
   * @see onComplete
   * @see navigateToUrl
   */
  get showCompletePage() {
    return this.getPropertyValue("showCompletePage");
  }
  set showCompletePage(val) {
    this.setPropertyValue("showCompletePage", val);
  }
  /**
   * @deprecated Use the [`showCompletePage`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#showCompletePage) property instead.
   */
  get showCompletedPage() {
    return this.showCompletePage;
  }
  set showCompletedPage(val) {
    this.showCompletePage = val;
  }
  /**
   * A URL to which respondents should be navigated after survey completion.
   * @see onNavigateToUrl
   * @see navigateToUrlOnCondition
   */
  get navigateToUrl() {
    return this.getPropertyValue("navigateToUrl");
  }
  set navigateToUrl(val) {
    this.setPropertyValue("navigateToUrl", val);
  }
  /**
   * An array of objects that allows you to navigate respondents to different URLs after survey completion.
   *
   * Each object should include the [`expression`](https://surveyjs.io/form-library/documentation/api-reference/urlconditionitem#url) and [`url`](https://surveyjs.io/form-library/documentation/api-reference/urlconditionitem#expression) properties. When `expression` evaluates to `true`, the survey navigates to the corresponding `url`. Refer to the following help topic for more information about expressions: [Expressions](https://surveyjs.io/form-library/documentation/design-survey/conditional-logic#expressions).
   * @see onNavigateToUrl
   * @see navigateToUrl
   */
  get navigateToUrlOnCondition() {
    return this.getPropertyValue("navigateToUrlOnCondition");
  }
  set navigateToUrlOnCondition(val) {
    this.setPropertyValue("navigateToUrlOnCondition", val);
  }
  getNavigateToUrl() {
    var item = this.getExpressionItemOnRunCondition(this.navigateToUrlOnCondition);
    var url = !!item ? item.url : this.navigateToUrl;
    if (!!url) {
      url = this.processText(url, false);
    }
    return url;
  }
  navigateTo() {
    var url = this.getNavigateToUrl();
    var options = {
      url,
      allow: true
    };
    this.onNavigateToUrl.fire(this, options);
    if (!options.url || !options.allow) return;
    navigateToUrl(options.url);
  }
  /**
   * Specifies one or multiple characters that designate required questions.
   *
   * Default value: `*`
   *
   * [View Demo](https://surveyjs.io/form-library/examples/modify-question-title/ (linkStyle))
   */
  get requiredMark() {
    return this.getPropertyValue("requiredMark");
  }
  set requiredMark(val) {
    this.setPropertyValue("requiredMark", val);
  }
  /**
   * @deprecated Use the [`requiredMark`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#requiredMark) property instead.
   */
  get requiredText() {
    return this.requiredMark;
  }
  set requiredText(val) {
    this.requiredMark = val;
  }
  beforeSettingQuestionErrors(question, errors) {
    this.makeRequiredErrorsInvisible(errors);
    this.onSettingQuestionErrors.fire(this, {
      question,
      errors
    });
  }
  makeRequiredErrorsInvisible(errors) {
    if (!this.hideRequiredErrors) return;
    for (var i = 0; i < errors.length; i++) {
      var erType = errors[i].getErrorType();
      if (erType == "required" || erType == "requireoneanswer") {
        errors[i].visible = false;
      }
    }
  }
  /**
   * Specifies the initial number or letter from which to start question numbering.
   *
   * [Question Numbers](https://surveyjs.io/form-library/documentation/design-survey/configure-question-titles#question-numbers (linkStyle))
   */
  get questionStartIndex() {
    return this.getPropertyValue("questionStartIndex", "");
  }
  set questionStartIndex(val) {
    this.setPropertyValue("questionStartIndex", val);
  }
  /**
   * Specifies whether to store the "Other" option response in a separate property.
   *
   * Default value: `true`
   *
   * Respondents can leave comments when they select "Other" in choice-based questions, such as Dropdown or Checkboxes. Comment values are saved in a separate property. The property name is composed of the question `name` and [`commentSuffix`](#commentSuffix). However, you can use the question `name` as a key to store the comment value instead. Disable the `storeOthersAsComment` property in this case.
   * @see maxCommentLength
   */
  get storeOthersAsComment() {
    return this.getPropertyValue("storeOthersAsComment");
  }
  set storeOthersAsComment(val) {
    this.setPropertyValue("storeOthersAsComment", val);
  }
  /**
   * Specifies the maximum text length in textual questions ([Single-Line Input](https://surveyjs.io/form-library/examples/text-entry-question/), [Long Text](https://surveyjs.io/form-library/examples/add-open-ended-question-to-a-form/), [Multiple Textboxes](https://surveyjs.io/form-library/examples/multiple-text-box-question/)), measured in characters.
   *
   * Default value: 0 (unlimited)
   *
   * You can override this setting for individual questions if you specify their [`maxLength`](https://surveyjs.io/form-library/documentation/api-reference/text-entry-question-model#maxLength) property.
   * @see maxCommentLength
   */
  get maxTextLength() {
    return this.getPropertyValue("maxTextLength");
  }
  set maxTextLength(val) {
    this.setPropertyValue("maxTextLength", val);
  }
  /**
   * Specifies the maximum text length for question comments. Applies to questions with the [`showCommentArea`](https://surveyjs.io/form-library/documentation/api-reference/question#showCommentArea) or [`showOtherItem`](https://surveyjs.io/form-library/documentation/api-reference/question#showOtherItem) property set to `true`.
   *
   * Default value: 0 (unlimited)
   * @see maxTextLength
   */
  get maxCommentLength() {
    return this.getPropertyValue("maxCommentLength");
  }
  set maxCommentLength(val) {
    this.setPropertyValue("maxCommentLength", val);
  }
  /**
   * @deprecated Use the [`maxCommentLength`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#maxCommentLength) property instead.
   */
  get maxOthersLength() {
    return this.maxCommentLength;
  }
  set maxOthersLength(val) {
    this.maxCommentLength = val;
  }
  /**
   * Specifies whether the survey switches to the next page automatically after a user answers all questions on the current page.
   *
   * Default value: `false`
   *
   * If you enable this property, the survey is also completed automatically. Set the [`autoAdvanceAllowComplete`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#autoAdvanceAllowComplete) property to `false` if you want to disable this behavior.
   *
   * > If any of the following questions is answered last, the survey does not switch to the next page: Checkboxes, Yes/No (Boolean) (rendered as Checkbox), Long Text, Signature, Image Picker (with Multi Select), File Upload, Single-Select Matrix (not all rows are answered), Dynamic Matrix, Dynamic Panel.
   *
   * [View Demo](https://surveyjs.io/form-library/examples/automatically-move-to-next-page-if-answer-selected/ (linkStyle))
   * @see [`settings.autoAdvanceDelay`](https://surveyjs.io/form-library/documentation/api-reference/settings#autoAdvanceDelay)
   */
  get autoAdvanceEnabled() {
    return this.getPropertyValue("autoAdvanceEnabled");
  }
  set autoAdvanceEnabled(val) {
    this.setPropertyValue("autoAdvanceEnabled", val);
  }
  /**
   * @deprecated Use the [`autoAdvanceEnabled`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#autoAdvanceEnabled) property instead.
   */
  get goNextPageAutomatic() {
    return this.autoAdvanceEnabled;
  }
  set goNextPageAutomatic(val) {
    this.autoAdvanceEnabled = val;
  }
  /**
   * Specifies whether to complete the survey automatically after a user answers all questions on the last page. Applies only if the [`autoAdvanceEnabled`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#autoAdvanceEnabled) property is `true`.
   *
   * Default value: `true`
   * @see [`settings.autoAdvanceDelay`](https://surveyjs.io/form-library/documentation/api-reference/settings#autoAdvanceDelay)
   */
  get autoAdvanceAllowComplete() {
    return this.getPropertyValue("autoAdvanceAllowComplete");
  }
  set autoAdvanceAllowComplete(val) {
    this.setPropertyValue("autoAdvanceAllowComplete", val);
  }
  /**
   * @deprecated Use the [`autoAdvanceAllowComplete`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#autoAdvanceAllowComplete) property instead.
   */
  get allowCompleteSurveyAutomatic() {
    return this.autoAdvanceAllowComplete;
  }
  set allowCompleteSurveyAutomatic(val) {
    this.autoAdvanceAllowComplete = val;
  }
  /**
   * Specifies when the survey validates answers.
   *
   * Possible values:
   *
   * - `"onNextPage"` (default) - Triggers validation before the survey is switched to the next page or completed.
   * - `"onValueChanged"` - Triggers validation each time a question value is changed.
   * - `"onComplete"` - Triggers validation when a user clicks the Complete button. If previous pages contain errors, the survey switches to the page with the first error.
   *
   * > In SurveyJS Form Library v1.12.5 and earlier, the `"onValueChanged"` mode doesn't work with date input fields because of the way browsers process date values. In most browsers, the value is considered changed as soon as a user starts entering the date in a text input field. This means that a user may only enter the day without having the chance to enter the month and year before validation is triggered. For this reason, date input fields are validated before the survey is switched to the next page or completed. Starting with v1.12.6, `"onValueChanged"` works for date input fields as well as for input fields of other types.
   *
   * Refer to the following help topic for more information: [Data Validation](https://surveyjs.io/form-library/documentation/data-validation).
   * @see validationEnabled
   * @see validationAllowSwitchPages
   * @see validationAllowComplete
   * @see validate
   */
  get checkErrorsMode() {
    return this.getPropertyValue("checkErrorsMode");
  }
  set checkErrorsMode(val) {
    this.setPropertyValue("checkErrorsMode", val);
  }
  /**
   * Specifies whether to trigger validation when a user focuses on an empty input field and then leaves it without making any changes. Applies only if [`checkErrorsMode`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#checkErrorsMode) is set to `"onValueChanged"`.
   *
   * Default value: `false`
   *
   * This property changes validation behavior for the following question types:
   *
   * - [Single-Line Input](https://surveyjs.io/form-library/documentation/api-reference/text-entry-question-model)
   * - [Long Text](https://surveyjs.io/form-library/documentation/api-reference/comment-field-model)
   * - [Dropdown](https://surveyjs.io/form-library/documentation/api-reference/dropdown-menu-model)
   * @see validationEnabled
   * @see validationAllowSwitchPages
   * @see validationAllowComplete
   * @see validate
   */
  get validateVisitedEmptyFields() {
    return this.getPropertyValue("validateVisitedEmptyFields");
  }
  set validateVisitedEmptyFields(val) {
    this.setPropertyValue("validateVisitedEmptyFields", val);
  }
  getValidateVisitedEmptyFields() {
    return this.validateVisitedEmptyFields && this.isValidateOnValueChange;
  }
  /**
   * Specifies whether to increase the height of [Long Text](https://surveyjs.io/form-library/examples/add-open-ended-question-to-a-form/) questions and other text areas to accommodate multi-line text content.
   *
   * Default value: `false`
   *
   * You can override this property for individual Long Text questions: [`autoGrow`](https://surveyjs.io/form-library/documentation/api-reference/comment-field-model#autoGrow).
   * @see allowResizeComment
   * @see commentAreaRows
   */
  get autoGrowComment() {
    return this.getPropertyValue("autoGrowComment");
  }
  set autoGrowComment(val) {
    this.setPropertyValue("autoGrowComment", val);
  }
  /**
   * Specifies whether to display a resize handle for [Long Text](https://surveyjs.io/form-library/examples/add-open-ended-question-to-a-form/) questions and other text areas intended for multi-line text content.
   *
   * Default value: `true`
   *
   * You can override this property for individual Long Text questions: [`allowResize`](https://surveyjs.io/form-library/documentation/api-reference/comment-field-model#allowResize).
   * @see autoGrowComment
   * @see commentAreaRows
   */
  get allowResizeComment() {
    return this.getPropertyValue("allowResizeComment");
  }
  set allowResizeComment(val) {
    this.setPropertyValue("allowResizeComment", val);
  }
  /**
   * Specifies the visible height of comment areas, measured in lines. Applies to the questions with the [`showCommentArea`](https://surveyjs.io/form-library/documentation/api-reference/question#showCommentArea) or [`showOtherItem`](https://surveyjs.io/form-library/documentation/api-reference/question#showOtherItem) property enabled.
   *
   * Default value: 2
   *
   * The value of this property is passed on to the `rows` attribute of the underlying `<textarea>` element.
   * @see autoGrowComment
   * @see allowResizeComment
   */
  get commentAreaRows() {
    return this.getPropertyValue("commentAreaRows");
  }
  set commentAreaRows(val) {
    this.setPropertyValue("commentAreaRows", val);
  }
  /**
   * Specifies when to update the question value in questions with a text input field.
   *
   * Possible values:
   *
   * - `"onBlur"` (default) - Updates the value after the input field loses focus.
   * - `"onTyping"` - Updates the value on every key press.
   *
   * > Do not use the `"onTyping"` mode if your survey contains many expressions. Expressions are reevaluated each time a question value is changed. In `"onTyping"` mode, the question value changes frequently. This may cause performance degradation.
   *
   * You can override this setting for individual questions: [`textUpdateMode`](https://surveyjs.io/form-library/documentation/api-reference/text-entry-question-model#textUpdateMode).
   */
  get textUpdateMode() {
    return this.getPropertyValue("textUpdateMode");
  }
  set textUpdateMode(val) {
    this.setPropertyValue("textUpdateMode", val);
  }
  /**
   * Specifies when to remove values of invisible questions from [survey results](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#data).
   *
   * Possible values:
   *
   * - `"onComplete"` (default) - Clears invisible question values when the survey is complete.
   * - `"onHidden"` - Clears a question value when the question becomes invisible. If the question is invisible initially, its value is removed on survey completion.
   * - `"onHiddenContainer"` - Clears a question value when the question or its containter (page or panel) becomes invisible. If the question is invisible initially, its value is removed on survey completion.
   * - `"none"` - Keeps invisible values in survey results.
   * - `true` - Equivalent to `"onComplete"`.
   * - `false` - Equivalent to `"none"`.
   * @see [Conditional Visibility](https://surveyjs.io/form-library/documentation/design-survey/conditional-logic#conditional-visibility)
   * @see onComplete
   */
  get clearInvisibleValues() {
    return this.getPropertyValue("clearInvisibleValues");
  }
  set clearInvisibleValues(val) {
    if (val === true) val = "onComplete";
    if (val === false) val = "none";
    this.setPropertyValue("clearInvisibleValues", val);
  }
  /**
   * Removes values that cannot be assigned to a question, for example, choices unlisted in the `choices` array.
   *
   * Call this method after you assign new question values in code to ensure that they are acceptable.
   *
   * > This method does not remove values that fail validation. Call the [`validate()`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#validate) method to validate newly assigned values.
   * @param removeNonExistingRootKeys Pass `true` to remove values that do not correspond to any question or [calculated value](https://surveyjs.io/form-library/documentation/design-survey/conditional-logic#calculated-values).
   */
  clearIncorrectValues(removeNonExistingRootKeys = false) {
    for (var i = 0; i < this.pages.length; i++) {
      this.pages[i].clearIncorrectValues();
    }
    if (!removeNonExistingRootKeys) return;
    var data = this.data;
    var hasChanges = false;
    for (var key in data) {
      if (!!this.getQuestionByValueName(key)) continue;
      if (this.iscorrectValueWithPostPrefix(key, settings.commentSuffix) || this.iscorrectValueWithPostPrefix(key, settings.matrix.totalsSuffix)) continue;
      var calcValue = this.getCalculatedValueByName(key);
      if (!!calcValue && calcValue.includeIntoResult) continue;
      hasChanges = true;
      delete data[key];
    }
    if (hasChanges) {
      this.data = data;
    }
  }
  iscorrectValueWithPostPrefix(key, postPrefix) {
    if (key.indexOf(postPrefix) !== key.length - postPrefix.length) return false;
    return !!this.getQuestionByValueName(key.substring(0, key.indexOf(postPrefix)));
  }
  /**
   * Specifies whether to keep values that cannot be assigned to questions, for example, choices unlisted in the `choices` array.
   *
   * > This property cannot be specified in the survey JSON schema. Use dot notation to specify it.
   * @see clearIncorrectValues
   */
  get keepIncorrectValues() {
    return this.getPropertyValue("keepIncorrectValues");
  }
  set keepIncorrectValues(val) {
    this.setPropertyValue("keepIncorrectValues", val);
  }
  /**
   * Specifies the survey's locale.
   *
   * Default value: `""` (a default locale is used)
   *
   * [Localization & Globalization help topic](https://surveyjs.io/form-library/documentation/survey-localization (linkStyle))
   *
   * [Survey Localization demo](https://surveyjs.io/form-library/examples/survey-localization/ (linkStyle))
   */
  get locale() {
    return this.getPropertyValueWithoutDefault("locale") || surveyLocalization.currentLocale;
  }
  set locale(value) {
    if (value === surveyLocalization.defaultLocale && !surveyLocalization.currentLocale) {
      value = "";
    }
    this.setPropertyValue("locale", value);
  }
  onSurveyLocaleChanged() {
    this.notifyElementsOnAnyValueOrVariableChanged("locale");
    this.localeChanged();
    this.onLocaleChangedEvent.fire(this, this.locale);
  }
  get localeDir() {
    return surveyLocalization.localeDirections[this.locale];
  }
  /**
   * Returns an array of locales whose translations are used in the survey.
   *
   * [Localization & Globalization help topic](https://surveyjs.io/form-library/documentation/survey-localization (linkStyle))
   *
   * [Survey Localization demo](https://surveyjs.io/form-library/examples/survey-localization/ (linkStyle))
   */
  getUsedLocales() {
    var locs = new Array();
    this.addUsedLocales(locs);
    var index = locs.indexOf("default");
    if (index > -1) {
      var defaultLoc = surveyLocalization.defaultLocale;
      var defIndex = locs.indexOf(defaultLoc);
      if (defIndex > -1) {
        locs.splice(defIndex, 1);
      }
      index = locs.indexOf("default");
      locs[index] = defaultLoc;
    }
    return locs;
  }
  localeChanged() {
    for (var i = 0; i < this.pages.length; i++) {
      this.pages[i].localeChanged();
    }
  }
  //ILocalizableOwner
  getLocale() {
    return this.locale;
  }
  locStrsChanged() {
    if (this.isClearingUnsedValues) return;
    super.locStrsChanged();
    if (!this.currentPage) return;
    if (this.isDesignMode) {
      this.pages.forEach((page2) => page2.locStrsChanged());
    } else {
      var page = this.activePage;
      if (!!page) {
        page.locStrsChanged();
      }
      const visPages = this.visiblePages;
      for (var i = 0; i < visPages.length; i++) {
        visPages[i].navigationLocStrChanged();
      }
    }
    if (!this.isStartPageActive) {
      this.updateProgressText();
    }
    if (!!this.navigationBarValue) {
      this.navigationBar.locStrsChanged();
    }
  }
  getMarkdownHtml(text, name) {
    return this.getSurveyMarkdownHtml(this, text, name);
  }
  getRenderer(name) {
    return this.getRendererForString(this, name);
  }
  getRendererContext(locStr) {
    return this.getRendererContextForString(this, locStr);
  }
  getRendererForString(element, name) {
    let renderAs = this.getBuiltInRendererForString(element, name);
    renderAs = this.elementWrapperComponentNameCore(renderAs, element, "string", name);
    const options = {
      element,
      name,
      renderAs
    };
    this.onTextRenderAs.fire(this, options);
    return options.renderAs;
  }
  getRendererContextForString(element, locStr) {
    return this.elementWrapperDataCore(locStr, element, "string");
  }
  getExpressionDisplayValue(question, value, displayValue2) {
    const options = {
      question,
      value,
      displayValue: displayValue2
    };
    this.onGetExpressionDisplayValue.fire(this, options);
    return options.displayValue;
  }
  getBuiltInRendererForString(element, name) {
    if (this.isDesignMode) return LocalizableString.editableRenderer;
    return void 0;
  }
  getProcessedText(text) {
    return this.processText(text, true);
  }
  getLocString(str) {
    return this.getLocalizationString(str);
  }
  //ISurveyErrorOwner
  getErrorCustomText(text, error) {
    return this.getSurveyErrorCustomText(this, text, error);
  }
  getSurveyErrorCustomText(obj, text, error) {
    const options = {
      text,
      name: error.getErrorType(),
      obj,
      error
    };
    this.onErrorCustomText.fire(this, options);
    return options.text;
  }
  getQuestionDisplayValue(question, displayValue2) {
    const options = {
      question,
      displayValue: displayValue2
    };
    this.onGetQuestionDisplayValue.fire(this, options);
    return options.displayValue;
  }
  /**
   * A message that is displayed when a survey does not contain visible pages or questions.
   * @see [Localization & Globalization](https://surveyjs.io/form-library/documentation/survey-localization)
   */
  get emptySurveyText() {
    return this.getLocalizableStringText("emptySurveyText");
  }
  set emptySurveyText(val) {
    this.setLocalizableStringText("emptySurveyText", val);
  }
  //#region Title/Header options
  /**
   * An image URL or a Base64-encoded image to use as a survey logo.
   *
   * [View Demo](https://surveyjs.io/form-library/examples/survey-logo/ (linkStyle))
   * @see logoPosition
   * @see logoFit
   */
  get logo() {
    return this.getLocalizableStringText("logo");
  }
  set logo(value) {
    this.setLocalizableStringText("logo", value);
  }
  get locLogo() {
    return this.getLocalizableString("logo");
  }
  /**
   * A logo width in CSS-accepted values.
   *
   * Default value: `auto` (the width is calculated automatically based on the [`logoHeight`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#logoHeight) value to keep the original aspect ratio)
   *
   * [View Demo](https://surveyjs.io/form-library/examples/survey-logo/ (linkStyle))
   * @see logo
   * @see logoPosition
   * @see logoFit
   */
  get logoWidth() {
    return this.getPropertyValue("logoWidth");
  }
  set logoWidth(value) {
    this.setPropertyValue("logoWidth", value);
  }
  get renderedLogoWidth() {
    return this.logoWidth ? getRenderedSize(this.logoWidth) : void 0;
  }
  get renderedStyleLogoWidth() {
    return this.logoWidth ? getRenderedStyleSize(this.logoWidth) : void 0;
  }
  /**
   * A logo height in CSS-accepted values.
   *
   * Default value: `40px`
   *
   * [View Demo](https://surveyjs.io/form-library/examples/survey-logo/ (linkStyle))
   * @see logoWidth
   * @see logo
   * @see logoPosition
   * @see logoFit
   */
  get logoHeight() {
    return this.getPropertyValue("logoHeight");
  }
  set logoHeight(value) {
    this.setPropertyValue("logoHeight", value);
  }
  get renderedLogoHeight() {
    return this.logoHeight ? getRenderedSize(this.logoHeight) : void 0;
  }
  get renderedStyleLogoHeight() {
    return this.logoHeight ? getRenderedStyleSize(this.logoHeight) : void 0;
  }
  /**
   * A logo position relative to the [survey title](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#title).
   *
   * Possible values:
   *
   * - `"left"` (default) - Places the logo to the left of the survey title.
   * - `"right"` - Places the logo to the right of the survey title.
   * - `"none"` - Hides the logo.
   *
   * [View Demo](https://surveyjs.io/form-library/examples/survey-logo/ (linkStyle))
   * @see logo
   * @see logoFit
   */
  get logoPosition() {
    return this.getPropertyValue("logoPosition");
  }
  set logoPosition(value) {
    this.setPropertyValue("logoPosition", value);
  }
  get hasLogo() {
    return this.getPropertyValue("hasLogo", void 0, () => !!this.logo && this.logoPosition !== "none");
  }
  resetHasLogo() {
    this.resetPropertyValue("hasLogo");
  }
  get isLogoBefore() {
    if (this.isDesignMode) return false;
    return this.renderedHasLogo && (this.logoPosition === "left" || this.logoPosition === "top");
  }
  get isLogoAfter() {
    if (this.isDesignMode) return this.renderedHasLogo;
    return this.renderedHasLogo && (this.logoPosition === "right" || this.logoPosition === "bottom");
  }
  get logoClassNames() {
    const logoClasses = {
      left: "sv-logo--left",
      right: "sv-logo--right",
      top: "sv-logo--top",
      bottom: "sv-logo--bottom"
    };
    return new CssClassBuilder().append(this.css.logo).append(logoClasses[this.logoPosition]).toString();
  }
  get titleIsEmpty() {
    return this.getPropertyValue("titleIsEmpty", void 0, () => this.locTitle.isEmpty);
  }
  get renderedHasTitle() {
    if (this.isDesignMode) return this.isPropertyVisible("title");
    return !this.titleIsEmpty && this.showTitle;
  }
  get renderedHasDescription() {
    if (this.isDesignMode) return this.isPropertyVisible("description");
    return !!this.hasDescription;
  }
  get hasTitle() {
    return this.renderedHasTitle;
  }
  get renderedHasLogo() {
    if (this.isDesignMode) return this.isPropertyVisible("logo");
    return this.hasLogo;
  }
  get renderedHasHeader() {
    return this.renderedHasTitle || this.renderedHasLogo;
  }
  /**
   * Specifies how to resize a logo to fit it into its container.
   *
   * Possible values:
   *
   * - `"contain"` (default)
   * - `"cover"`
   * - `"fill"`
   * - `"none"`
   *
   * Refer to the [`object-fit`](https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit) CSS property description for information on the possible values.
   *
   * [View Demo](https://surveyjs.io/form-library/examples/survey-logo/ (linkStyle))
   * @see logo
   * @see logoPosition
   */
  get logoFit() {
    return this.getPropertyValue("logoFit");
  }
  set logoFit(val) {
    this.setPropertyValue("logoFit", val);
  }
  get themeVariables() {
    return Object.assign({}, this.cssVariables);
  }
  setIsMobile(newVal = true) {
    if (this._isMobile !== newVal) {
      this._isMobile = newVal;
      this.updateCss();
      this.getAllQuestions().forEach((q) => q.setIsMobile(newVal));
    }
  }
  get isMobile() {
    return this._isMobile && !this.isDesignMode;
  }
  set isCompact(newVal) {
    if (newVal !== this._isCompact) {
      this._isCompact = newVal;
      this.updateElementCss();
      this.triggerResponsiveness(true);
    }
  }
  get isCompact() {
    return this._isCompact;
  }
  isLogoImageChoosen() {
    return this.locLogo.renderedHtml;
  }
  get titleMaxWidth() {
    return "";
  }
  get renderBackgroundImage() {
    return this.getPropertyValue("renderBackgroundImage", void 0, () => wrapUrlForBackgroundImage(this.backgroundImage));
  }
  /**
   * A value from 0 to 1 that specifies how transparent the [background image](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#backgroundImage) should be: 0 makes the image completely transparent, and 1 makes it opaque.
   */
  get backgroundOpacity() {
    return this.getPropertyValue("backgroundOpacity");
  }
  set backgroundOpacity(val) {
    this.setPropertyValue("backgroundOpacity", val);
  }
  get backgroundImageStyle() {
    return this.getPropertyValue("backgroundImageStyle", void 0, () => this.calcBackgroundImageStyle());
  }
  calcBackgroundImageStyle() {
    return {
      opacity: this.backgroundOpacity,
      backgroundImage: this.renderBackgroundImage,
      backgroundSize: this.backgroundImageFit,
      backgroundAttachment: !this.fitToContainer ? this.backgroundImageAttachment : void 0
    };
  }
  updateWrapperFormCss() {
    this.wrapperFormCss = new CssClassBuilder().append(this.css.rootWrapper).append(this.css.rootWrapperHasImage, !!this.backgroundImage).append(this.css.rootWrapperFixed, !!this.backgroundImage && this.backgroundImageAttachment === "fixed").toString();
  }
  /**
   * HTML content displayed on the [complete page](https://surveyjs.io/form-library/documentation/design-survey/create-a-multi-page-survey#complete-page).
   *
   * [View Demo](https://surveyjs.io/form-library/examples/modify-survey-navigation-settings/ (linkStyle))
   * @see showCompletePage
   * @see completedHtmlOnCondition
   */
  get completedHtml() {
    return this.getLocalizableStringText("completedHtml");
  }
  set completedHtml(value) {
    this.setLocalizableStringText("completedHtml", value);
  }
  get locCompletedHtml() {
    return this.getLocalizableString("completedHtml");
  }
  /**
   * An array of objects that allows you to specify different HTML content for the [complete page](https://surveyjs.io/form-library/documentation/design-survey/create-a-multi-page-survey#complete-page).
   *
   * Each object should include the [`expression`](https://surveyjs.io/form-library/documentation/api-reference/htmlconditionitem#expression) and [`html`](https://surveyjs.io/form-library/documentation/api-reference/htmlconditionitem#html) properties. When `expression` evaluates to `true`, the survey uses the corresponding HTML markup instead of [`completedHtml`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#completedHtml). Refer to the following help topic for more information about expressions: [Expressions](https://surveyjs.io/form-library/documentation/design-survey/conditional-logic#expressions).
   *
   * [View Demo](https://surveyjs.io/form-library/examples/nps-question/ (linkStyle))
   */
  get completedHtmlOnCondition() {
    return this.getPropertyValue("completedHtmlOnCondition");
  }
  set completedHtmlOnCondition(val) {
    this.setPropertyValue("completedHtmlOnCondition", val);
  }
  /**
   * Calculates a given [expression](https://surveyjs.io/form-library/documentation/design-survey/conditional-logic#expressions) and returns a result value.
   * @param expression An expression to calculate.
   * @param callback A callback function that you can use to access the calculation result if the expression uses asynchronous functions.
   */
  runExpression(expression, callback) {
    if (!expression) return null;
    var values = this.getFilteredValues();
    var properties = this.getFilteredProperties();
    const exp = new ExpressionRunner(expression);
    let onCompleteRes = void 0;
    exp.onRunComplete = (res) => {
      onCompleteRes = res;
      callback && callback(res);
    };
    return exp.run(values, properties) || onCompleteRes;
  }
  get isSettingValueOnExpression() {
    return this.setValueOnExpressionCounter > 0;
  }
  startSetValueOnExpression() {
    this.setValueOnExpressionCounter++;
  }
  finishSetValueOnExpression() {
    this.setValueOnExpressionCounter--;
  }
  /**
   * Calculates a given [expression](https://surveyjs.io/form-library/documentation/design-survey/conditional-logic#expressions) and returns `true` or `false`.
   * @param expression An expression to calculate.
   */
  runCondition(expression) {
    if (!expression) return false;
    var values = this.getFilteredValues();
    var properties = this.getFilteredProperties();
    return new ConditionRunner(expression).run(values, properties);
  }
  /**
   * Executes [all triggers](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#triggers), except ["complete"](https://surveyjs.io/form-library/documentation/design-survey/conditional-logic#complete).
   *
   * [Conditional Survey Logic (Triggers)](https://surveyjs.io/form-library/documentation/design-survey/conditional-logic#conditional-survey-logic-triggers (linkStyle))
   * @see onTriggerExecuted
   */
  runTriggers() {
    this.checkTriggers(this.getFilteredValues(), false);
  }
  get renderedCompletedHtml() {
    var item = this.getExpressionItemOnRunCondition(this.completedHtmlOnCondition);
    return !!item ? item.html : this.completedHtml;
  }
  getExpressionItemOnRunCondition(items) {
    if (items.length == 0) return null;
    var values = this.getFilteredValues();
    var properties = this.getFilteredProperties();
    for (var i = 0; i < items.length; i++) {
      if (items[i].runCondition(values, properties)) {
        return items[i];
      }
    }
    return null;
  }
  /**
   * HTML content displayed to a user who has completed the survey before. To identify such users, the survey uses a [cookie name](#cookieName) or [client ID](#clientId).
   * @see processedCompletedBeforeHtml
   */
  get completedBeforeHtml() {
    return this.getLocalizableStringText("completedBeforeHtml");
  }
  set completedBeforeHtml(value) {
    this.setLocalizableStringText("completedBeforeHtml", value);
  }
  get locCompletedBeforeHtml() {
    return this.getLocalizableString("completedBeforeHtml");
  }
  /**
   * HTML content displayed while a survey JSON schema is [being loaded](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#beginLoading).
   * @see processedLoadingHtml
   */
  get loadingHtml() {
    return this.getLocalizableStringText("loadingHtml");
  }
  set loadingHtml(value) {
    this.setLocalizableStringText("loadingHtml", value);
  }
  get locLoadingHtml() {
    return this.getLocalizableString("loadingHtml");
  }
  get defaultLoadingHtml() {
    return "<h3>" + this.getLocalizationString("loadingSurvey") + "</h3>";
  }
  get navigationBar() {
    if (!this.navigationBarValue) {
      this.navigationBarValue = this.createNavigationBar();
      this.updateNavigationCss();
    }
    return this.navigationBarValue;
  }
  /**
   * Adds a custom navigation item similar to the Previous Page, Next Page, and Complete buttons.
   * Accepts an object described in the [IAction](https://surveyjs.io/Documentation/Library?id=IAction) help section.
   *
   * [View Demo](https://surveyjs.io/form-library/examples/survey-changenavigation/ (linkStyle))
  */
  addNavigationItem(val) {
    if (!val.component) {
      val.component = "sv-nav-btn";
    }
    if (!val.innerCss) {
      val.innerCss = this.cssSurveyNavigationButton;
    }
    return this.navigationBar.addAction(val);
  }
  /**
   * Gets or sets a caption for the Start button.
   * @see firstPageIsStartPage
   * @see [Localization & Globalization](https://surveyjs.io/form-library/documentation/survey-localization)
   */
  get startSurveyText() {
    return this.getLocalizableStringText("startSurveyText");
  }
  set startSurveyText(newValue) {
    this.setLocalizableStringText("startSurveyText", newValue);
  }
  get locStartSurveyText() {
    return this.getLocalizableString("startSurveyText");
  }
  /**
   * Gets or sets a caption for the Previous button.
   * @see [Localization & Globalization](https://surveyjs.io/form-library/documentation/survey-localization)
   */
  get pagePrevText() {
    return this.getLocalizableStringText("pagePrevText");
  }
  set pagePrevText(newValue) {
    this.setLocalizableStringText("pagePrevText", newValue);
  }
  get locPagePrevText() {
    return this.getLocalizableString("pagePrevText");
  }
  /**
   * Gets or sets a caption for the Next button.
   * @see [Localization & Globalization](https://surveyjs.io/form-library/documentation/survey-localization)
   */
  get pageNextText() {
    return this.getLocalizableStringText("pageNextText");
  }
  set pageNextText(newValue) {
    this.setLocalizableStringText("pageNextText", newValue);
  }
  get locPageNextText() {
    return this.getLocalizableString("pageNextText");
  }
  /**
   * Gets or sets a caption for the Complete button.
   * @see [Localization & Globalization](https://surveyjs.io/form-library/documentation/survey-localization)
   */
  get completeText() {
    return this.getLocalizableStringText("completeText");
  }
  set completeText(newValue) {
    this.setLocalizableStringText("completeText", newValue);
  }
  get locCompleteText() {
    return this.getLocalizableString("completeText");
  }
  /**
   * Gets or sets a caption for the Preview button.
   * @see showPreviewBeforeComplete
   * @see showPreview
   * @see editText
   */
  get previewText() {
    return this.getLocalizableStringText("previewText");
  }
  set previewText(newValue) {
    this.setLocalizableStringText("previewText", newValue);
  }
  get locPreviewText() {
    return this.getLocalizableString("previewText");
  }
  /**
   * Gets or sets a caption for the Edit button displayed when the survey shows a [preview of given answers](https://surveyjs.io/form-library/documentation/design-survey/create-a-multi-page-survey#preview-page).
   * @see showPreviewBeforeComplete
   * @see cancelPreview
   * @see previewText
   */
  get editText() {
    return this.getLocalizableStringText("editText");
  }
  set editText(newValue) {
    this.setLocalizableStringText("editText", newValue);
  }
  get locEditText() {
    return this.getLocalizableString("editText");
  }
  getElementTitleTagName(element, tagName) {
    if (this.onGetTitleTagName.isEmpty) return tagName;
    const options = {
      element,
      tagName
    };
    this.onGetTitleTagName.fire(this, options);
    return options.tagName;
  }
  /**
   * Specifies a pattern for question titles.
   *
   * Refer to the following help topic for more information: [Title Pattern](https://surveyjs.io/form-library/documentation/design-survey/configure-question-titles#title-pattern).
   */
  get questionTitlePattern() {
    return this.getPropertyValue("questionTitlePattern", "numTitleRequire");
  }
  set questionTitlePattern(val) {
    if (val !== "numRequireTitle" && val !== "requireNumTitle" && val != "numTitle") {
      val = "numTitleRequire";
    }
    this.setPropertyValue("questionTitlePattern", val);
  }
  getQuestionTitlePatternOptions() {
    const res = new Array();
    const title = this.getLocalizationString("questionTitlePatternText");
    const num = !!this.questionStartIndex ? this.questionStartIndex : "1.";
    res.push({
      value: "numTitleRequire",
      text: num + " " + title + " " + this.requiredMark
    });
    res.push({
      value: "numRequireTitle",
      text: num + " " + this.requiredMark + " " + title
    });
    res.push({
      value: "numTitle",
      text: num + " " + title
    });
    return res;
  }
  get questionTitleTemplate() {
    return this.getLocalizableStringText("questionTitleTemplate");
  }
  set questionTitleTemplate(value) {
    this.setLocalizableStringText("questionTitleTemplate", value);
    this.questionTitlePattern = this.getNewTitlePattern(value);
    this.questionStartIndex = this.getNewQuestionTitleElement(value, "no", this.questionStartIndex, "1");
    this.requiredMark = this.getNewQuestionTitleElement(value, "require", this.requiredMark, "*");
  }
  getNewTitlePattern(template) {
    if (!!template) {
      var strs = [];
      while (template.indexOf("{") > -1) {
        template = template.substring(template.indexOf("{") + 1);
        var ind = template.indexOf("}");
        if (ind < 0) break;
        strs.push(template.substring(0, ind));
        template = template.substring(ind + 1);
      }
      if (strs.length > 1) {
        if (strs[0] == "require") return "requireNumTitle";
        if (strs[1] == "require" && strs.length == 3) return "numRequireTitle";
        if (strs.indexOf("require") < 0) return "numTitle";
      }
      if (strs.length == 1 && strs[0] == "title") {
        return "numTitle";
      }
    }
    return "numTitleRequire";
  }
  getNewQuestionTitleElement(template, name, currentValue, defaultValue) {
    name = "{" + name + "}";
    if (!template || template.indexOf(name) < 0) return currentValue;
    var ind = template.indexOf(name);
    var prefix = "";
    var postfix = "";
    var i = ind - 1;
    for (; i >= 0; i--) {
      if (template[i] == "}") break;
    }
    if (i < ind - 1) {
      prefix = template.substring(i + 1, ind);
    }
    ind += name.length;
    i = ind;
    for (; i < template.length; i++) {
      if (template[i] == "{") break;
    }
    if (i > ind) {
      postfix = template.substring(ind, i);
    }
    i = 0;
    while (i < prefix.length && prefix.charCodeAt(i) < 33) i++;
    prefix = prefix.substring(i);
    i = postfix.length - 1;
    while (i >= 0 && postfix.charCodeAt(i) < 33) i--;
    postfix = postfix.substring(0, i + 1);
    if (!prefix && !postfix) return currentValue;
    var value = !!currentValue ? currentValue : defaultValue;
    return prefix + value + postfix;
  }
  get locQuestionTitleTemplate() {
    return this.getLocalizableString("questionTitleTemplate");
  }
  getUpdatedQuestionTitle(question, title) {
    if (this.onGetQuestionTitle.isEmpty) return title;
    const options = {
      question,
      title
    };
    this.onGetQuestionTitle.fire(this, options);
    return options.title;
  }
  getUpdatedQuestionNo(question, no) {
    if (this.onGetQuestionNumber.isEmpty) return no;
    const options = {
      question,
      number: no,
      no
    };
    this.onGetQuestionNumber.fire(this, options);
    return options.no === no ? options.number : options.no;
  }
  getUpdatedPanelNo(panel, no) {
    if (this.onGetPanelNumber.isEmpty) return no;
    const options = {
      panel,
      number: no
    };
    this.onGetPanelNumber.fire(this, options);
    return options.number;
  }
  getUpdatedPageNo(page, no) {
    if (this.onGetPageNumber.isEmpty) return no;
    const options = {
      page,
      number: no
    };
    this.onGetPageNumber.fire(this, options);
    return options.number;
  }
  /**
   * Specifies whether page titles contain page numbers.
   *
   * [View Demo](https://surveyjs.io/form-library/examples/how-to-number-pages-and-questions/ (linkStyle))
   * @see onGetPageNumber
   */
  get showPageNumbers() {
    return this.getPropertyValue("showPageNumbers");
  }
  set showPageNumbers(value) {
    if (value === this.showPageNumbers) return;
    this.setPropertyValue("showPageNumbers", value);
    this.updateVisibleIndexes();
  }
  /**
   * Specifies whether to display question numbers and how to calculate them.
   *
   * Possible values:
   *
   * - `true` or `"on"` - Displays question numbers.
   * - `"onpage"` - Displays question numbers and starts numbering on each page from scratch.
   * - `false` or `"off"` - Hides question numbers.
   *
   * [View Demo](https://surveyjs.io/form-library/examples/how-to-number-pages-and-questions/ (linkStyle))
   *
   * If you want to hide the number of an individual question, disable its [`showNumber`](https://surveyjs.io/form-library/documentation/api-reference/question#showNumber) property.
   * @see onGetQuestionNumber
   */
  get showQuestionNumbers() {
    return this.getPropertyValue("showQuestionNumbers");
  }
  set showQuestionNumbers(value) {
    if (value === true) {
      value = "on";
    }
    if (value === false) {
      value = "off";
    }
    value = value.toLowerCase();
    value = value === "onpage" ? "onPage" : value;
    if (value === this.showQuestionNumbers) return;
    this.setPropertyValue("showQuestionNumbers", value);
    this.updateVisibleIndexes();
  }
  get progressBar() {
    if (!this.progressBarValue) {
      this.progressBarValue = new ProgressButtons(this);
    }
    return this.progressBarValue;
  }
  /**
   * Specifies the visibility of the progress bar.
   *
   * Default value: `false`
   *
   * [View Demo](https://surveyjs.io/form-library/examples/navigation-default/ (linkStyle))
   * @see progressBarLocation
   * @see progressBarType
   * @see progressValue
   */
  get showProgressBar() {
    return this.getPropertyValue("showProgressBar");
  }
  set showProgressBar(newValue) {
    this.setShowProgressBar(newValue);
  }
  setShowProgressBar(newValue) {
    if (newValue === "off") {
      newValue = false;
    }
    if (newValue === true || newValue === false) {
      this.setPropertyValue("showProgressBar", newValue);
    } else {
      this.setPropertyValue("showProgressBar", true);
      this.progressBarLocation = newValue;
    }
  }
  /**
   * Specifies the alignment of the progress bar. Applies only if the [`showProgressBar`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#showProgressBar) property is `true`.
   *
   * Possible values:
   *
   * - `"aboveHeader"` - Displays the progress bar above the survey header.
   * - `"belowHeader"` - Displays the progress bar below the survey header.
   * - `"bottom"` - Displays the progress bar below survey content.
   * - `"topBottom"` - Displays the progress bar above and below survey content.
   * - `"auto"` (default) - Displays the progress bar below the survey header if the header has a [background image](https://surveyjs.io/form-library/documentation/api-reference/iheader#backgroundImage) or color. Otherwise, the progress bar is displayed above the header.
   *
   * [View Demo](https://surveyjs.io/form-library/examples/navigation-default/ (linkStyle))
   * @see showProgressBar
   * @see progressBarType
   * @see progressValue
   */
  get progressBarLocation() {
    return this.getPropertyValue("progressBarLocation");
  }
  set progressBarLocation(newValue) {
    this.setPropertyValue("progressBarLocation", newValue.toLowerCase());
  }
  /**
   * Specifies the type of information displayed by the progress bar. Applies only when [`showProgressBar`](#showProgressBar) is `true`.
   *
   * Possible values:
   *
   * - `"pages"` (default) - The number of completed pages.
   * - `"questions"` - The number of answered questions.
   * - `"requiredQuestions"` - The number of answered [required questions](https://surveyjs.io/form-library/documentation/api-reference/question#isRequired).
   * - `"correctQuestions"` - The number of correct questions in a [quiz](https://surveyjs.io/form-library/documentation/design-survey/create-a-quiz).
   * - `"buttons"` - *(Obsolete)* Use the `"pages"` property value with the [`progressBarShowPageTitles`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#progressBarShowPageTitles) property set to `true` instead.
   *
   * > When `progressBarType` is set to `"pages"`, you can also enable the [`progressBarShowPageNumbers`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#progressBarShowPageNumbers) and [`progressBarShowPageTitles`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#progressBarShowPageTitles) properties if you want to display page numbers and titles in the progress bar.
   *
   * [View Demo](https://surveyjs.io/form-library/examples/navigation-buttons/ (linkStyle))
   * @see progressValue
   */
  get progressBarType() {
    return this.getPropertyValue("progressBarType");
  }
  set progressBarType(newValue) {
    if (newValue === "correctquestion") newValue = "correctQuestion";
    if (newValue === "requiredquestion") newValue = "requiredQuestion";
    this.setPropertyValue("progressBarType", newValue);
  }
  get progressBarComponentName() {
    let actualProgressBarType = this.progressBarType;
    if (!settings.legacyProgressBarView && surveyCss.currentType === "default") {
      if (isStrCiEqual(actualProgressBarType, "pages")) {
        actualProgressBarType = "buttons";
      }
    }
    return "progress-" + actualProgressBarType;
  }
  get isShowProgressBarOnTop() {
    if (!this.canShowProgressBar()) return false;
    if (!this.showProgressBar) return false;
    return ["auto", "aboveheader", "belowheader", "topbottom", "top", "both"].indexOf(this.progressBarLocation) !== -1;
  }
  get isShowProgressBarOnBottom() {
    if (!this.canShowProgressBar()) return false;
    if (!this.showProgressBar) return false;
    return this.progressBarLocation === "bottom" || this.progressBarLocation === "both" || this.progressBarLocation === "topbottom";
  }
  getProgressTypeComponent() {
    return "sv-progress-" + this.progressBarType.toLowerCase();
  }
  getProgressCssClasses(container = "") {
    return new CssClassBuilder().append(this.css.progress).append(this.css.progressTop, this.isShowProgressBarOnTop && (!container || container == "header")).append(this.css.progressBottom, this.isShowProgressBarOnBottom && (!container || container == "footer")).toString();
  }
  canShowProgressBar() {
    return !this.isShowingPreview || !this.showPreviewBeforeComplete || this.previewMode != "allQuestions";
  }
  get processedTitle() {
    return this.locTitle.renderedHtml;
  }
  /**
   * Gets or sets question title location relative to the input field: `"top"`, `"bottom"`, or `"left"`.
   *
   * > Certain question types (Matrix, Multiple Text) do not support the `"left"` value. For them, the `"top"` value is used.
   *
   * You can override this setting if you specify the `questionTitleLocation` property for an [individual page](https://surveyjs.io/form-library/documentation/pagemodel#questionTitleLocation) or [panel](https://surveyjs.io/form-library/documentation/panelmodel#questionTitleLocation) or set the `titleLocation` property for a [specific question](https://surveyjs.io/form-library/documentation/question#titleLocation).
   */
  get questionTitleLocation() {
    return this.getPropertyValue("questionTitleLocation");
  }
  set questionTitleLocation(value) {
    this.setPropertyValue("questionTitleLocation", value.toLowerCase());
    if (!this.isLoadingFromJson) {
      this.updateElementCss(true);
    }
  }
  updateElementCss(reNew) {
    if (!!this.startPage) {
      this.startPage.updateElementCss(reNew);
    }
    var pages = this.visiblePages;
    for (var i = 0; i < pages.length; i++) {
      pages[i].updateElementCss(reNew);
    }
    this.updateCss();
  }
  /**
   * Specifies the error message position.
   *
   * Possible values:
   *
   * - `"top"` (default) - Displays error messages above questions.
   * - `"bottom"` - Displays error messages below questions.
   *
   * You can override this setting if you specify the `questionErrorLocation` property for an [individual page](https://surveyjs.io/form-library/documentation/pagemodel#questionErrorLocation) or [panel](https://surveyjs.io/form-library/documentation/panelmodel#questionErrorLocation) or set the `errorLocation` property for a [specific question](https://surveyjs.io/form-library/documentation/question#errorLocation).
   */
  get questionErrorLocation() {
    return this.getPropertyValue("questionErrorLocation");
  }
  set questionErrorLocation(value) {
    this.setPropertyValue("questionErrorLocation", value.toLowerCase());
  }
  /**
   * Specifies where to display question descriptions.
   *
   * Possible values:
   *
   * - `"underTitle"` (default) - Displays descriptions under question titles.
   * - `"underInput"` - Displays descriptions under the interactive area.
   *
   * You can override this setting for individual questions if you specify their [`descriptionLocation`](https://surveyjs.io/form-library/documentation/api-reference/question#descriptionLocation) property.
   *
   */
  get questionDescriptionLocation() {
    return this.getPropertyValue("questionDescriptionLocation");
  }
  set questionDescriptionLocation(value) {
    this.setPropertyValue("questionDescriptionLocation", value);
  }
  /**
   * @deprecated Use the [`readOnly`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#readOnly) property.
   */
  get mode() {
    return this.readOnly ? "display" : "edit";
  }
  set mode(value) {
    value = value.toLowerCase();
    if (value == this.mode) return;
    if (value != "edit" && value != "display") return;
    this.readOnly = value == "display";
  }
  /**
   * Enables the read-only mode. If you set this property to `true`, users cannot take the survey.
   *
   * Default value: `false`
   *
   * [View Demo](https://surveyjs.io/form-library/examples/prevent-form-editing-with-read-only-mode/ (linkStyle))
   */
  get readOnly() {
    return this.getPropertyValue("readOnly");
  }
  set readOnly(val) {
    this.setPropertyValue("readOnly", val);
  }
  onReadOnlyChanged() {
    for (var i = 0; i < this.pages.length; i++) {
      var page = this.pages[i];
      page.setPropertyValue("isReadOnly", page.isReadOnly);
    }
    this.updateButtonsVisibility();
    this.updateCss();
  }
  /**
   * Gets or sets an object with survey results. You can set this property with an object of the following structure:
   *
   * ```js
   * {
   *   question1Name: question1Value,
   *   question2Name: question2Value,
   *   // ...
   * }
   * ```
   *
   * When you set this property in code, the new object overrides the old object that may contain default question values and entered data. If you want to *merge* the new and old objects, call the [`mergeData(newDataObj)`](https://surveyjs.io/form-library/documentation/surveymodel#mergeData) method.
   *
   * If you assign a new object while a respondent takes the survey, set the [`currentPageNo`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#currentPageNo) property to 0 to start the survey from the beginning. This will also cause the survey to re-evaluate the [`visibleIf`](https://surveyjs.io/form-library/documentation/api-reference/question#visibleIf), [`enableIf`](https://surveyjs.io/form-library/documentation/api-reference/question#enableIf), and other [expressions](https://surveyjs.io/form-library/documentation/design-survey/conditional-logic#expressions).
   * @see setValue
   * @see getValue
   */
  get data() {
    var result = {};
    var keys = this.getValuesKeys();
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var dataValue = this.getDataValueCore(this.valuesHash, key);
      if (dataValue !== void 0) {
        result[key] = dataValue;
      }
    }
    this.setCalculatedValuesIntoResult(result);
    return result;
  }
  set data(data) {
    this.valuesHash = {};
    this.setDataCore(data, !data);
  }
  /**
   * Merges a specified data object with the object from the [`data`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#data) property.
   *
   * Refer to the following help topic for more information: [Populate Form Fields | Multiple Question Values](https://surveyjs.io/form-library/documentation/design-survey/pre-populate-form-fields#multiple-question-values).
   *
   * @param data A data object to merge. It should have the following structure: `{ questionName: questionValue, ... }`
   * @see setValue
   */
  mergeData(data) {
    if (!data) return;
    const newData = this.data;
    this.mergeValues(data, newData);
    this.setDataCore(newData);
  }
  setDataCore(data, clearData = false) {
    if (clearData) {
      this.valuesHash = {};
    }
    if (data) {
      for (var key in data) {
        const dataKey = typeof key === "string" ? key.trim() : key;
        this.setDataValueCore(this.valuesHash, dataKey, data[key]);
      }
    }
    this.updateAllQuestionsValue(clearData);
    this.notifyAllQuestionsOnValueChanged();
    this.notifyElementsOnAnyValueOrVariableChanged("");
    this.runConditions();
    this.updateAllQuestionsValue(clearData);
  }
  get isSurvey() {
    return true;
  }
  /**
   * Returns an object with survey results.
   *
   * If you want to get a survey results object that mirrors the survey structure, call the `getData()` method with an object that has the `includePages` and `includePanels` properties enabled. Without this object, the `getData()` method returns the [`data`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#data) property value.
   *
   * ```js
   * import { Model } from "survey-core";
   *
   * const surveyJson = { ... };
   * const survey = new Model(surveyJson);
   * survey.getData({ includePages: true, includePanels: true });
   * ```
   */
  getData(options) {
    const opt = options || {
      includePages: false,
      includePanels: false
    };
    if (!opt.includePages && !opt.includePanels) return this.data;
    return this.getStructuredData(!!opt.includePages, !opt.includePanels ? opt.includePages ? 1 : 0 : -1);
  }
  getStructuredData(includePages = true, level = -1) {
    if (level === 0) return this.data;
    const data = {};
    this.pages.forEach((p) => {
      if (includePages) {
        const pageValues = {};
        if (p.collectValues(pageValues, level - 1)) {
          data[p.name] = pageValues;
        }
      } else {
        p.collectValues(data, level);
      }
    });
    return data;
  }
  setStructuredData(data, doMerge = false) {
    if (!data) return;
    const res = {};
    for (let key in data) {
      const q = this.getQuestionByValueName(key);
      if (q) {
        res[key] = data[key];
      } else {
        let panel = this.getPageByName(key);
        if (!panel) {
          panel = this.getPanelByName(key);
        }
        if (panel) {
          this.collectDataFromPanel(panel, res, data[key]);
        }
      }
    }
    if (doMerge) {
      this.mergeData(res);
    } else {
      this.data = res;
    }
  }
  collectDataFromPanel(panel, output, data) {
    for (let key in data) {
      let el = panel.getElementByName(key);
      if (!el) continue;
      if (el.isPanel) {
        this.collectDataFromPanel(el, output, data[key]);
      } else {
        output[key] = data[key];
      }
    }
  }
  get editingObj() {
    return this.editingObjValue;
  }
  set editingObj(val) {
    if (this.editingObj == val) return;
    this.unConnectEditingObj();
    this.editingObjValue = val;
    if (this.isDisposed) return;
    if (!val) {
      var questions = this.getAllQuestions();
      for (var i = 0; i < questions.length; i++) {
        questions[i].unbindValue();
      }
    }
    if (!!this.editingObj) {
      this.setDataCore({});
      this.onEditingObjPropertyChanged = (sender, options) => {
        if (!Serializer.hasOriginalProperty(this.editingObj, options.name)) return;
        if (options.name === "locale") {
          this.setDataCore({});
        }
        this.updateOnSetValue(options.name, this.editingObj[options.name], options.oldValue);
      };
      this.editingObj.onPropertyChanged.add(this.onEditingObjPropertyChanged);
    }
  }
  unConnectEditingObj() {
    if (!!this.editingObj && !this.editingObj.isDisposed) {
      this.editingObj.onPropertyChanged.remove(this.onEditingObjPropertyChanged);
    }
  }
  get isEditingSurveyElement() {
    return !!this.editingObj;
  }
  setCalculatedValuesIntoResult(result) {
    for (var i = 0; i < this.calculatedValues.length; i++) {
      var calValue = this.calculatedValues[i];
      if (calValue.includeIntoResult && !!calValue.name && this.getVariable(calValue.name) !== void 0) {
        result[calValue.name] = this.getVariable(calValue.name);
      }
    }
  }
  getAllValues() {
    return this.data;
  }
  /**
   * Returns survey results as an array of objects in which the question name, title, value, and other parameters are stored as individual properties.
   *
   * If a question can have more than one value (Matrix, Multiple Text), its object enables the `isNode` flag and stores information about these values in the `data` property. Refer to the following help topic for more information: [Access Full Survey Results](https://surveyjs.io/form-library/documentation/handle-survey-results-access#access-full-survey-results).
   *
   * If you want to skip empty answers, pass an object with the `includeEmpty` property set to `false`.
   */
  getPlainData(options) {
    if (!options) {
      options = {
        includeEmpty: true,
        includeQuestionTypes: false,
        includeValues: false
      };
    }
    const result = [];
    const questionValueNames = [];
    this.getAllQuestions().forEach((question) => {
      var resultItem = question.getPlainData(options);
      if (!!resultItem) {
        result.push(resultItem);
        questionValueNames.push(question.valueName || question.name);
      }
    });
    if (!!options.includeValues) {
      const keys = this.getValuesKeys();
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (questionValueNames.indexOf(key) == -1) {
          var dataValue = this.getDataValueCore(this.valuesHash, key);
          if (!!dataValue) {
            result.push({
              name: key,
              title: key,
              value: dataValue,
              displayValue: dataValue,
              isNode: false,
              getString: (val) => typeof val === "object" ? JSON.stringify(val) : val
            });
          }
        }
      }
    }
    return result;
  }
  getFilteredValues() {
    const values = {};
    for (var key in this.variablesHash) values[key] = this.variablesHash[key];
    this.addCalculatedValuesIntoFilteredValues(values);
    if (!this.isDesignMode) {
      const keys = this.getValuesKeys();
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        values[key] = this.getDataValueCore(this.valuesHash, key);
      }
      this.getAllQuestions().forEach((q) => {
        if (q.hasFilteredValue) {
          values[q.getFilteredName()] = q.getFilteredValue();
        }
      });
    }
    return values;
  }
  addCalculatedValuesIntoFilteredValues(values) {
    var caclValues = this.calculatedValues;
    for (var i = 0; i < caclValues.length; i++) values[caclValues[i].name] = caclValues[i].value;
  }
  getFilteredProperties() {
    return {
      survey: this
    };
  }
  getValuesKeys() {
    if (!this.editingObj) return Object.keys(this.valuesHash);
    var props = Serializer.getPropertiesByObj(this.editingObj);
    var res = [];
    for (var i = 0; i < props.length; i++) {
      res.push(props[i].name);
    }
    return res;
  }
  getDataValueCore(valuesHash, key) {
    if (!!this.editingObj) return Serializer.getObjPropertyValue(this.editingObj, key);
    return this.getDataFromValueHash(valuesHash, key);
  }
  setDataValueCore(valuesHash, key, value) {
    if (!!this.editingObj) {
      Serializer.setObjPropertyValue(this.editingObj, key, value);
    } else {
      this.setDataToValueHash(valuesHash, key, value);
    }
  }
  deleteDataValueCore(valuesHash, key) {
    if (!!this.editingObj) {
      this.editingObj[key] = null;
    } else {
      this.deleteDataFromValueHash(valuesHash, key);
    }
  }
  getDataFromValueHash(valuesHash, key) {
    if (!!this.valueHashGetDataCallback) return this.valueHashGetDataCallback(valuesHash, key);
    return valuesHash[key];
  }
  setDataToValueHash(valuesHash, key, value) {
    if (!!this.valueHashSetDataCallback) {
      this.valueHashSetDataCallback(valuesHash, key, value);
    } else {
      valuesHash[key] = value;
    }
  }
  deleteDataFromValueHash(valuesHash, key) {
    if (!!this.valueHashDeleteDataCallback) {
      this.valueHashDeleteDataCallback(valuesHash, key);
    } else {
      delete valuesHash[key];
    }
  }
  /**
   * An object with all comment values.
   * @see Question.showCommentArea
   * @see storeOthersAsComment
   */
  get comments() {
    var result = {};
    var keys = this.getValuesKeys();
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      if (key.indexOf(this.commentSuffix) > 0) {
        result[key] = this.getDataValueCore(this.valuesHash, key);
      }
    }
    return result;
  }
  /**
   * Returns an array of visible pages without the start page.
   *
   * To get an array of all pages, use the [`pages`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#pages) property. If all pages are visible, the `pages` and `visiblePages` arrays are identical.
   * @see [Conditional Visibility](https://surveyjs.io/form-library/documentation/design-survey/conditional-logic#conditional-visibility)
   */
  get visiblePages() {
    if (this.isDesignMode) return this.pages;
    if (!!this.pageContainerValue && (this.isShowingPreview || this.isSinglePage)) return [this.pageContainerValue];
    var result = new Array();
    for (var i = 0; i < this.pages.length; i++) {
      if (this.isPageInVisibleList(this.pages[i])) {
        result.push(this.pages[i]);
      }
    }
    return result;
  }
  isPageInVisibleList(page) {
    return this.isDesignMode || page.isVisible && !page.isStartPage;
  }
  /**
   * Returns `true` if the survey contains zero pages.
   * @see emptySurveyText
   */
  get isEmpty() {
    return this.pages.length == 0;
  }
  get PageCount() {
    return this.pageCount;
  }
  /**
   * Returns a total number of survey pages.
   *
   * To get the number of visible pages, use the [`visiblePageCount`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#visiblePageCount) property.
   * @see pages
   */
  get pageCount() {
    return this.pages.length;
  }
  /**
   * Returns the number of visible survey pages.
   *
   * To get a total number of survey pages, use the [`pageCount`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#pageCount) property.
   * @see visiblePages
   * @see [Conditional Visibility](https://surveyjs.io/form-library/documentation/design-survey/conditional-logic#conditional-visibility)
   */
  get visiblePageCount() {
    return this.visiblePages.length;
  }
  /**
   * Returns the start page. Applies only if the [`firstPageIsStartPage`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#firstPageIsStartPage) property is set to `true`.
   *
   * Refer to the following help topic for more information: [Start Page](https://surveyjs.io/form-library/documentation/design-survey/create-a-multi-page-survey#start-page).
   * @see firstPageIsStartPage
   * @see activePage
   */
  get startPage() {
    var page = this.firstPageIsStartPage && this.pages.length > 1 ? this.pages[0] : null;
    if (!!page) {
      page.onFirstRendering();
      page.setWasShown(true);
    }
    return page;
  }
  /**
   * @deprecated Use the [`startPage`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#startPage) property instead.
   */
  get startedPage() {
    return this.startPage;
  }
  /**
   * Gets or sets the current page.
   *
   * If you want to change the current page, set this property to a `PageModel` object. You can get this object in different ways. For example, you can call the [`getPageByName()`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#getPageByName) method to obtain a `PageModel` object with a specific name:
   *
   * ```js
   * survey.currentPage = survey.getPageByName("my-page-name");
   * ```
   *
   * Alternatively, you can change the current page if you set the [`currentPageNo`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#currentPageNo) property to the index of the required page.
   *
   * The `currentPage` property does not return the start page even if it is current. Use the [`activePage`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#activePage) property instead if your survey contains a start page.
   */
  get currentPage() {
    return this.getPropertyValue("currentPage", null);
  }
  set currentPage(value) {
    if (this.isLoadingFromJson) return;
    var newPage = this.getPageByObject(value);
    if (!!value && !newPage) return;
    if (!newPage && this.isCurrentPageAvailable) return;
    var vPages = this.visiblePages;
    if (newPage != null && vPages.indexOf(newPage) < 0) return;
    if (newPage == this.currentPage) return;
    var oldValue = this.currentPage;
    if (!this.isShowingPreview && !this.currentSingleQuestion && !this.currentPageChanging(newPage, oldValue)) return;
    this.setPropertyValue("currentPage", newPage);
    if (!!newPage) {
      newPage.onFirstRendering();
      newPage.updateCustomWidgets();
      newPage.setWasShown(true);
    }
    this.locStrsChanged();
    if (!this.isShowingPreview) {
      this.currentPageChanged(newPage, oldValue);
    }
  }
  tryNavigateToPage(page) {
    if (!this.performValidationOnPageChanging(page)) return false;
    const index = this.visiblePages.indexOf(page);
    const res = index < this.currentPageNo || !this.doServerValidation(false, false, page);
    if (res) {
      this.currentPage = page;
    }
    return res;
  }
  performValidationOnPageChanging(page) {
    if (this.isDesignMode) return false;
    if (this.canGoTroughValidation()) return true;
    const index = this.visiblePages.indexOf(page);
    if (index < 0 || index >= this.visiblePageCount) return false;
    if (index === this.currentPageNo) return false;
    if (index < this.currentPageNo || this.checkErrorsMode === "onComplete" || this.validationAllowSwitchPages) return true;
    if (!this.validateCurrentPage()) return false;
    for (let i = this.currentPageNo + 1; i < index; i++) {
      const page2 = this.visiblePages[i];
      if (!page2.validate(true, true)) return false;
      page2.passed = true;
    }
    return true;
  }
  updateCurrentPage() {
    if (this.isCurrentPageAvailable) return;
    this.currentPage = this.firstVisiblePage;
  }
  get isCurrentPageAvailable() {
    const page = this.currentPage;
    return !!page && this.isPageInVisibleList(page) && this.isPageExistsInSurvey(page);
  }
  isPageExistsInSurvey(page) {
    if (this.pages.indexOf(page) > -1) return true;
    return !!this.onContainsPageCallback && this.onContainsPageCallback(page);
  }
  /**
   * Returns [`startPage`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#startPage) if the survey currently displays a start page; otherwise, returns [`currentPage`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#currentPage).
   * @see startPage
   * @see currentPage
   * @see firstPageIsStartPage
   */
  get activePage() {
    return this.getPropertyValue("activePage");
  }
  /**
   * A Boolean value that indicates whether the [start page](https://surveyjs.io/form-library/documentation/design-survey/create-a-multi-page-survey#start-page) is currently displayed.
   */
  get isStartPageActive() {
    return this.state === "starting";
  }
  /**
   * @deprecated Use the [`isStartPageActive`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#isStartPageActive) property instead.
   */
  get isShowStartingPage() {
    return this.isStartPageActive;
  }
  /**
   * Specifies which part of a matrix row responds to a drag gesture in [Dynamic Matrix](https://surveyjs.io/form-library/examples/questiontype-matrixdynamic/) questions.
   *
   * Possible values:
   *
   * - `"entireItem"` (default) - Users can use the entire matrix row as a drag handle.
   * - `"icon"` - Users can only use a drag icon as a drag handle.
   */
  get matrixDragHandleArea() {
    return this.getPropertyValue("matrixDragHandleArea", "entireItem");
  }
  set matrixDragHandleArea(val) {
    this.setPropertyValue("matrixDragHandleArea", val);
  }
  get isShowingPage() {
    return this.state == "running" || this.state == "preview" || this.isStartPageActive;
  }
  updateActivePage() {
    const newPage = this.isStartPageActive ? this.startPage : this.currentPage;
    if (newPage !== this.activePage) {
      this.setPropertyValue("activePage", newPage);
    }
  }
  onStateAndCurrentPageChanged() {
    this.updateActivePage();
    this.updateButtonsVisibility();
  }
  getPageByObject(value) {
    if (!value) return null;
    if (value.getType && value.getType() == "page") return value;
    if (typeof value === "string" || value instanceof String) return this.getPageByName(String(value));
    if (!isNaN(value)) {
      var index = Number(value);
      var vPages = this.visiblePages;
      if (value < 0 || value >= vPages.length) return null;
      return vPages[index];
    }
    return value;
  }
  /**
   * A zero-based index of the current page in the [`visiblePages`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#visiblePages) array.
   *
   * [View Demo](https://surveyjs.io/form-library/examples/survey-editprevious/ (linkStyle))
   * @see visiblePages
   */
  get currentPageNo() {
    return this.visiblePages.indexOf(this.currentPage);
  }
  set currentPageNo(value) {
    var vPages = this.visiblePages;
    if (value < 0 || value >= vPages.length) return;
    this.currentPage = vPages[value];
  }
  /**
   * Specifies the sort order of questions in the survey.
   *
   * Possible values:
   *
   * - `"initial"` (default) - Preserves the original order of questions.
   * - `"random"` - Displays questions in random order.
   *
   * You can override this property for individual pages and panels.
   * @see PageModel.questionOrder
   * @see PanelModel.questionOrder
   */
  get questionOrder() {
    return this.getPropertyValue("questionOrder");
  }
  set questionOrder(val) {
    this.setPropertyValue("questionOrder", val);
  }
  /**
   * @deprecated Use the [`questionOrder`](#questionOrder) property instead.
   */
  get questionsOrder() {
    return this.questionOrder;
  }
  set questionsOrder(val) {
    this.questionOrder = val;
  }
  /**
   * Focuses the first question on the current page.
   * @see focusQuestion
   * @see autoFocusFirstQuestion
   */
  focusFirstQuestion() {
    if (this.focusingQuestionInfo) return;
    var page = this.activePage;
    if (page) {
      page.scrollToTop();
      page.focusFirstQuestion();
    }
  }
  scrollToTopOnPageChange(doScroll = true) {
    var page = this.activePage;
    if (!page) return;
    if (doScroll) {
      page.scrollToTop();
    }
    if (this.isCurrentPageRendering && this.autoFocusFirstQuestion && !this.focusingQuestionInfo) {
      page.focusFirstQuestion();
      this.isCurrentPageRendering = false;
    }
  }
  /**
   * Returns the current survey state.
   *
   * Possible values:
   *
   * - `"loading"` - The survey is being loaded from a JSON schema.
   * - `"empty"` - The survey has no elements to display.
   * - `"starting"` - The survey displays a [start page](https://surveyjs.io/form-library/documentation/design-survey/create-a-multi-page-survey#start-page).
   * - `"running"` - A respondent is taking the survey.
   * - `"preview"` - A respondent is [previewing](https://surveyjs.io/form-library/examples/survey-showpreview/) answers before submitting them.
   * - `"completed"` - A respondent has completed the survey and submitted the results.
   */
  get state() {
    return this.getPropertyValue("state", "empty");
  }
  updateState() {
    this.setPropertyValue("state", this.calcState());
  }
  calcState() {
    if (this.isLoading) return "loading";
    if (this.isCompleted) return "completed";
    if (this.isCompletedBefore) return "completedbefore";
    if (!this.isDesignMode && this.isEditMode && this.isStartedState && this.startPage) return "starting";
    if (this.isShowingPreview) return this.currentPage ? "preview" : "empty";
    return this.currentPage ? "running" : "empty";
  }
  get isCompleted() {
    return this.getPropertyValue("isCompleted", false);
  }
  set isCompleted(val) {
    this.setPropertyValue("isCompleted", val);
  }
  get isShowingPreview() {
    return this.getPropertyValue("isShowingPreview", false);
  }
  set isShowingPreview(val) {
    if (this.isShowingPreview == val) return;
    this.setPropertyValue("isShowingPreview", val);
    this.onShowingPreviewChanged();
  }
  get isStartedState() {
    return this.getPropertyValue("isStartedState", false);
  }
  set isStartedState(val) {
    this.setPropertyValue("isStartedState", val);
  }
  get isCompletedBefore() {
    return this.getPropertyValue("isCompletedBefore", false);
  }
  set isCompletedBefore(val) {
    this.setPropertyValue("isCompletedBefore", val);
  }
  get isLoading() {
    return this.getPropertyValue("isLoading", false);
  }
  set isLoading(val) {
    this.setPropertyValue("isLoading", val);
  }
  /**
   * Displays the [Loading page](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#loadingHtml).
   * @see endLoading
   */
  beginLoading() {
    this.isLoading = true;
  }
  /**
   * Stops displaying the [Loading page](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#loadingHtml).
   * @see beginLoading
   */
  endLoading() {
    this.isLoading = false;
  }
  get completedState() {
    return this.getPropertyValue("completedState", "");
  }
  get completedStateText() {
    return this.getPropertyValue("completedStateText", "");
  }
  setCompletedState(value, text) {
    this.setPropertyValue("completedState", value);
    if (!text) {
      if (value == "saving") text = this.getLocalizationString("savingData");
      if (value == "error") text = this.getLocalizationString("savingDataError");
      if (value == "success") text = this.getLocalizationString("savingDataSuccess");
    }
    this.setPropertyValue("completedStateText", text);
    if (this.state === "completed" && this.showCompletePage && !!this.completedState) {
      this.notify(this.completedStateText, this.completedState, value === "error");
    }
  }
  /**
   * Displays a toast notification with a specified message.
   *
   * Depending on the `type` argument, a survey can display the following notification types:
   *
   * ![Toast notification types in SurveyJS Form Library](https://surveyjs.io//Content/Images/docs/notification-types.png)
   * @param message A message to display.
   * @param type A notification type: `"info"` (default), `"success"`, or `"error"`.
   * @param showActions For internal use.
   */
  notify(message, type, showActions = false) {
    this.notifier.showActions = showActions;
    this.notifier.notify(message, type, showActions);
  }
  /**
   * Resets the survey [`state`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#state) and, optionally, [`data`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#data). If `state` is `"completed"`, it becomes `"running"`.
   * @param clearData *(Optional)* Specifies whether to clear survey data. Default value: `true`.
   * @param goToFirstPage *(Optional)* Specifies whether to switch the survey to the first page. Default value: `true`.
   */
  clear(clearData = true, goToFirstPage = true) {
    this.isCompleted = false;
    this.isCompletedBefore = false;
    this.isLoading = false;
    this.completedByTriggers = void 0;
    if (clearData) {
      this.setDataCore(null, true);
    }
    this.timerModel.spent = 0;
    for (var i = 0; i < this.pages.length; i++) {
      this.pages[i].timeSpent = 0;
      this.pages[i].setWasShown(false);
      this.pages[i].passed = false;
    }
    this.onFirstPageIsStartedChanged();
    if (goToFirstPage) {
      this.currentPage = this.firstVisiblePage;
      if (this.currentSingleQuestion) {
        const questions = this.getSingleQuestions();
        this.currentSingleQuestion = questions.length > 0 ? questions[0] : void 0;
      }
    }
    if (clearData) {
      this.updateValuesWithDefaults();
    }
  }
  mergeValues(src, dest) {
    mergeValues(src, dest);
  }
  updateValuesWithDefaults() {
    if (this.isDesignMode || this.isLoading) return;
    for (var i = 0; i < this.pages.length; i++) {
      var questions = this.pages[i].questions;
      for (var j = 0; j < questions.length; j++) {
        questions[j].updateValueWithDefaults();
      }
    }
  }
  updateCustomWidgets(page) {
    if (!page) return;
    page.updateCustomWidgets();
  }
  currentPageChanging(newValue, oldValue, newQuestion, oldQuestion) {
    const options = this.createPageChangeEventOptions(newValue, oldValue, newQuestion, oldQuestion);
    return this.currentPageChangingFromOptions(options);
  }
  currentPageChangingFromOptions(options) {
    options.allow = true;
    options.allowChanging = true;
    this.onCurrentPageChanging.fire(this, options);
    const allow = options.allowChanging && options.allow;
    if (allow && options.newCurrentPage !== options.oldCurrentPage) {
      this.isCurrentPageRendering = true;
    }
    return allow;
  }
  currentPageChanged(newValue, oldValue) {
    this.notifyQuestionsOnHidingContent(oldValue);
    if (oldValue && !oldValue.isDisposed && !oldValue.passed) {
      if (oldValue.validate(false)) {
        oldValue.passed = true;
      }
    }
    if (this.isCurrentPageRendered === true) {
      this.isCurrentPageRendered = false;
    }
    if (!this.currentSingleQuestion) {
      const options = this.createPageChangeEventOptions(newValue, oldValue);
      this.onCurrentPageChanged.fire(this, options);
    }
  }
  notifyQuestionsOnHidingContent(page) {
    if (page && !page.isDisposed) {
      page.questions.forEach((q) => q.onHidingContent());
    }
  }
  createPageChangeEventOptions(newValue, oldValue, newQuestion, oldQuestion) {
    const diff = !!newValue && !!oldValue ? newValue.visibleIndex - oldValue.visibleIndex : 0;
    let qDiff = diff;
    if (qDiff === 0 && !!oldQuestion && !!newQuestion) {
      qDiff = newValue.elements.indexOf(newQuestion) - newValue.elements.indexOf(oldQuestion);
    }
    return {
      oldCurrentQuestion: oldQuestion,
      newCurrentQuestion: newQuestion,
      oldCurrentPage: oldValue,
      newCurrentPage: newValue,
      isNextPage: diff === 1,
      isPrevPage: diff === -1,
      isGoingForward: qDiff > 0,
      isGoingBackward: qDiff < 0,
      isAfterPreview: this.changeCurrentPageFromPreview === true
    };
  }
  getProgress() {
    if (this.currentPage == null) return 0;
    if (this.progressBarType !== "pages") {
      var info = this.getProgressInfo();
      if (this.progressBarType === "requiredQuestions") {
        return info.requiredQuestionCount >= 1 ? Math.ceil(info.requiredAnsweredQuestionCount * 100 / info.requiredQuestionCount) : 100;
      }
      return info.questionCount >= 1 ? Math.ceil(info.answeredQuestionCount * 100 / info.questionCount) : 100;
    }
    const visPages = this.visiblePages;
    var index = visPages.indexOf(this.currentPage);
    return Math.ceil(index * 100 / visPages.length);
  }
  get isNavigationButtonsShowing() {
    if (this.isDesignMode) return "none";
    var page = this.activePage;
    if (!page) return "none";
    if (page.navigationButtonsVisibility === "hide") {
      return "none";
    }
    if (page.navigationButtonsVisibility === "show") {
      return !this.showNavigationButtons ? "bottom" : this.navigationButtonsLocation;
    }
    return !this.showNavigationButtons ? "none" : this.navigationButtonsLocation;
  }
  get isNavigationButtonsShowingOnTop() {
    return this.getIsNavigationButtonsShowingOn("top");
  }
  get isNavigationButtonsShowingOnBottom() {
    return this.getIsNavigationButtonsShowingOn("bottom");
  }
  getIsNavigationButtonsShowingOn(buttonPosition) {
    var res = this.isNavigationButtonsShowing;
    return res == "both" || res == "topBottom" || res == buttonPosition;
  }
  get isEditMode() {
    return !this.readOnly;
  }
  get isDisplayMode() {
    return this.readOnly && !this.isDesignMode || this.state == "preview";
  }
  get isUpdateValueTextOnTyping() {
    return this.textUpdateMode == "onTyping";
  }
  /**
   * Indicates whether the survey is being designed in [Survey Creator](https://surveyjs.io/survey-creator/documentation/overview).
   */
  get isDesignMode() {
    return this._isDesignMode;
  }
  setDesignMode(value) {
    if (!!this._isDesignMode != !!value) {
      this._isDesignMode = !!value;
      this.onQuestionsOnPageModeChanged("standard");
    }
  }
  /**
   * Specifies whether to show all survey elements, regardless of their visibility.
   *
   * Default value: `false`
   */
  get showInvisibleElements() {
    return this.getPropertyValue("showInvisibleElements", false);
  }
  set showInvisibleElements(val) {
    var visPages = this.visiblePages;
    this.setPropertyValue("showInvisibleElements", val);
    if (this.isLoadingFromJson) return;
    this.runConditions();
    this.updateAllElementsVisibility(visPages);
  }
  updateAllElementsVisibility(visPages) {
    for (var i = 0; i < this.pages.length; i++) {
      var page = this.pages[i];
      page.updateElementVisibility();
      if (visPages.indexOf(page) > -1 != page.isVisible) {
        this.onPageVisibleChanged.fire(this, {
          page,
          visible: page.isVisible
        });
      }
    }
  }
  get areInvisibleElementsShowing() {
    return this.isDesignMode || this.showInvisibleElements;
  }
  get areEmptyElementsHidden() {
    return this.isShowingPreview && this.showPreviewBeforeComplete && this.previewMode == "answeredQuestions" && this.isAnyQuestionAnswered;
  }
  get isAnyQuestionAnswered() {
    const questions = this.getAllQuestions(true);
    for (let i = 0; i < questions.length; i++) {
      if (!questions[i].isEmpty()) return true;
    }
    return false;
  }
  /**
   * Indicates whether the browser has a cookie with a specified [`cookieName`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#cookieName). If this property's value is `true`, the respondent has passed the survey previously.
   * @see setCookie
   * @see deleteCookie
   */
  get hasCookie() {
    if (!this.cookieName) return false;
    var cookies = DomDocumentHelper.getCookie();
    return cookies && cookies.indexOf(this.cookieName + "=true") > -1;
  }
  /**
   * Sets a cookie with a specified [`cookieName`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#cookieName) in the browser. If the `cookieName` property value is defined, this method is automatically called on survey completion.
   * @see hasCookie
   * @see deleteCookie
   */
  setCookie() {
    if (!this.cookieName) return;
    DomDocumentHelper.setCookie(this.cookieName + "=true; expires=Fri, 31 Dec 9999 0:0:0 GMT");
  }
  /**
   * Deletes a cookie with a specified [`cookieName`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#cookieName) from the browser.
   * @see hasCookie
   * @see setCookie
   */
  deleteCookie() {
    if (!this.cookieName) return;
    DomDocumentHelper.setCookie(this.cookieName + "=;");
  }
  /**
   * @deprecated Use the [`validationEnabled`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#validationEnabled) property instead.
   */
  get ignoreValidation() {
    return !this.validationEnabled;
  }
  set ignoreValidation(val) {
    this.validationEnabled = !val;
  }
  /**
   * Switches the survey to the next page.
   *
   * This method returns a Boolean value that indicates whether the page was successfully switched. `false` is returned if the current page is the last page or if it contains validation errors.
   * @returns `true` if the page was successfully switched; `false` otherwise.
   * @see isLastPage
   * @see prevPage
   * @see completeLastPage
   */
  nextPage() {
    if (this.currentSingleQuestion) return this.performNext();
    if (this.isLastPage) return false;
    return this.doCurrentPageComplete(false);
  }
  performNext() {
    const q = this.currentSingleQuestion;
    if (!q) return this.nextPage();
    if (!q.validate(true)) return false;
    const questions = this.getSingleQuestions();
    const index = questions.indexOf(q);
    if (index < 0 || index === questions.length - 1) return false;
    const key = {};
    key[q.name] = q.value;
    this.checkTriggers(key, false, false, true, q.name);
    this.currentSingleQuestion = questions[index + 1];
    return true;
  }
  performPrevious() {
    const q = this.currentSingleQuestion;
    if (!q) return this.prevPage();
    const questions = this.getSingleQuestions();
    const index = questions.indexOf(q);
    if (index === 0) return false;
    this.currentSingleQuestion = questions[index - 1];
    return true;
  }
  hasErrorsOnNavigate(doComplete) {
    if (this.canGoTroughValidation()) return false;
    const skipValidation = doComplete && this.validationAllowComplete || !doComplete && this.validationAllowSwitchPages;
    const func = (hasErrors) => {
      if (!hasErrors || skipValidation) {
        this.doCurrentPageCompleteCore(doComplete);
      }
    };
    if (this.isValidateOnComplete) {
      if (!this.isLastPage) return false;
      return this.validate(true, this.autoFocusFirstError, func, true) !== true && !skipValidation;
    }
    return this.validateCurrentPage(func) !== true && !skipValidation;
  }
  canGoTroughValidation() {
    return !this.isEditMode || !this.validationEnabled;
  }
  checkForAsyncQuestionValidation(questions, func) {
    this.clearAsyncValidationQuesitons();
    for (var i = 0; i < questions.length; i++) {
      if (questions[i].isRunningValidators) {
        let q = questions[i];
        q.onCompletedAsyncValidators = (hasErrors) => {
          this.onCompletedAsyncQuestionValidators(q, func, hasErrors);
        };
        this.asyncValidationQuesitons.push(questions[i]);
      }
    }
    return this.asyncValidationQuesitons.length > 0;
  }
  clearAsyncValidationQuesitons() {
    if (!!this.asyncValidationQuesitons) {
      var asynQuestions = this.asyncValidationQuesitons;
      for (var i = 0; i < asynQuestions.length; i++) {
        asynQuestions[i].onCompletedAsyncValidators = null;
      }
    }
    this.asyncValidationQuesitons = [];
  }
  onCompletedAsyncQuestionValidators(question, func, hasErrors) {
    if (hasErrors) {
      this.clearAsyncValidationQuesitons();
      func(true);
      if (this.autoFocusFirstError && !!question && !!question.page && question.page === this.currentPage) {
        const questions = this.currentPage.questions;
        for (let i2 = 0; i2 < questions.length; i2++) {
          if (questions[i2] !== question && questions[i2].errors.length > 0) return;
        }
        question.focus(true);
      }
      return;
    }
    var asynQuestions = this.asyncValidationQuesitons;
    for (var i = 0; i < asynQuestions.length; i++) {
      if (asynQuestions[i].isRunningValidators) return;
    }
    func(false);
  }
  get isCurrentPageHasErrors() {
    return this.checkIsCurrentPageHasErrors();
  }
  /**
   * Returns `true` if the current page does not contain errors.
   * @see currentPage
   */
  get isCurrentPageValid() {
    return !this.checkIsCurrentPageHasErrors();
  }
  hasCurrentPageErrors(onAsyncValidation) {
    return this.hasPageErrors(void 0, onAsyncValidation);
  }
  /**
   * Validates all questions on the current page and returns `false` if the validation fails.
   *
   * If you use validation expressions and at least one of them calls an async function, the `validateCurrentPage` method returns `undefined`. In this case, you should pass a callback function as the `onAsyncValidation` parameter. The function's `hasErrors` Boolean parameter will contain the validation result.
   * @param onAsyncValidation *(Optional)* Pass a callback function. It accepts a Boolean `hasErrors` parameter that equals `true` if the validation fails or `false` otherwise.
   * @see currentPage
   * @see validate
   * @see validateCurrentPage
   */
  validateCurrentPage(onAsyncValidation) {
    return this.validatePage(void 0, onAsyncValidation);
  }
  hasPageErrors(page, onAsyncValidation) {
    const res = this.validatePage(page, onAsyncValidation);
    if (res === void 0) return res;
    return !res;
  }
  /**
   * Validates all questions on a specified page and returns `false` if the validation fails.
   *
   * If you use validation expressions and at least one of them calls an async function, the `validatePage` method returns `undefined`. In this case, you should pass a callback function as the `onAsyncValidation` parameter. The function's `hasErrors` Boolean parameter will contain the validation result.
   * @param page Pass the `PageModel` that you want to validate. You can pass `undefined` to validate the [`activePage`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#activePage).
   * @param onAsyncValidation *(Optional)* Pass a callback function. It accepts a Boolean `hasErrors` parameter that equals `true` if the validation fails or `false` otherwise.
   * @see validate
   * @see validateCurrentPage
   */
  validatePage(page, onAsyncValidation) {
    if (!page) {
      page = this.activePage;
    }
    if (!page) return true;
    if (this.checkIsPageHasErrors(page)) return false;
    if (!onAsyncValidation) return true;
    return this.checkForAsyncQuestionValidation(page.questions, (hasErrors) => onAsyncValidation(hasErrors)) ? void 0 : true;
  }
  hasErrors(fireCallback = true, focusOnFirstError = false, onAsyncValidation) {
    const res = this.validate(fireCallback, focusOnFirstError, onAsyncValidation);
    if (res === void 0) return res;
    return !res;
  }
  /**
   * Validates all questions and returns `false` if the validation fails.
   *
   * If you use validation expressions and at least one of them calls an async function, the `validate` method returns `undefined`. In this case, you should pass a callback function as the `onAsyncValidation` parameter. The function's `hasErrors` Boolean parameter will contain the validation result.
   * @param fireCallback *(Optional)* Pass `false` if you do not want to show validation errors in the UI.
   * @param focusFirstError *(Optional)* Pass `true` if you want to focus the first question with a validation error. The survey will be switched to the page that contains this question if required.
   * @param onAsyncValidation *(Optional)* Pass a callback function. It accepts a Boolean `hasErrors` parameter that equals `true` if the validation fails or `false` otherwise.
   * @see validateCurrentPage
   * @see validatePage
   */
  validate(fireCallback = true, focusFirstError = false, onAsyncValidation, changeCurrentPage) {
    if (!!onAsyncValidation) {
      fireCallback = true;
    }
    var visPages = this.visiblePages;
    var res = true;
    const rec = {
      fireCallback,
      focusOnFirstError: focusFirstError,
      firstErrorQuestion: null,
      result: false
    };
    for (var i = 0; i < visPages.length; i++) {
      if (!visPages[i].validate(fireCallback, focusFirstError, rec)) {
        res = false;
      }
    }
    if (!!rec.firstErrorQuestion && (focusFirstError || changeCurrentPage)) {
      if (focusFirstError) {
        rec.firstErrorQuestion.focus(true);
      } else {
        this.currentPage = rec.firstErrorQuestion.page;
      }
    }
    if (!res || !onAsyncValidation) return res;
    return this.checkForAsyncQuestionValidation(this.getAllQuestions(), (hasErrors) => onAsyncValidation(hasErrors)) ? void 0 : true;
  }
  ensureUniqueNames(element = null) {
    if (element == null) {
      for (var i = 0; i < this.pages.length; i++) {
        this.ensureUniqueName(this.pages[i]);
      }
    } else {
      this.ensureUniqueName(element);
    }
  }
  ensureUniqueName(element) {
    if (element.isPage) {
      this.ensureUniquePageName(element);
    }
    if (element.isPanel) {
      this.ensureUniquePanelName(element);
    }
    if (element.isPage || element.isPanel) {
      var elements = element.elements;
      for (var i = 0; i < elements.length; i++) {
        this.ensureUniqueNames(elements[i]);
      }
    } else {
      this.ensureUniqueQuestionName(element);
    }
  }
  ensureUniquePageName(element) {
    return this.ensureUniqueElementName(element, (name) => {
      return this.getPageByName(name);
    });
  }
  ensureUniquePanelName(element) {
    return this.ensureUniqueElementName(element, (name) => {
      return this.getPanelByName(name);
    });
  }
  ensureUniqueQuestionName(element) {
    return this.ensureUniqueElementName(element, (name) => {
      return this.getQuestionByName(name);
    });
  }
  ensureUniqueElementName(element, getElementByName) {
    var existingElement = getElementByName(element.name);
    if (!existingElement || existingElement == element) return;
    var newName = this.getNewName(element.name);
    while (!!getElementByName(newName)) {
      var newName = this.getNewName(element.name);
    }
    element.name = newName;
  }
  getNewName(name) {
    var pos = name.length;
    while (pos > 0 && name[pos - 1] >= "0" && name[pos - 1] <= "9") {
      pos--;
    }
    var base = name.substring(0, pos);
    var num = 0;
    if (pos < name.length) {
      num = parseInt(name.substring(pos));
    }
    num++;
    return base + num;
  }
  checkIsCurrentPageHasErrors(isFocuseOnFirstError = void 0) {
    return this.checkIsPageHasErrors(this.activePage, isFocuseOnFirstError);
  }
  checkIsPageHasErrors(page, isFocuseOnFirstError = void 0) {
    if (isFocuseOnFirstError === void 0) {
      isFocuseOnFirstError = this.focusOnFirstError;
    }
    if (!page) return true;
    let res = false;
    if (this.currentSingleQuestion) {
      res = !this.currentSingleQuestion.validate(true);
    } else {
      res = !page.validate(true, isFocuseOnFirstError);
    }
    this.fireValidatedErrorsOnPage(page);
    return res;
  }
  fireValidatedErrorsOnPage(page) {
    if (this.onValidatePage.isEmpty || !page) return;
    var questionsOnPage = page.questions;
    var questions = new Array();
    var errors = new Array();
    for (var i = 0; i < questionsOnPage.length; i++) {
      var q = questionsOnPage[i];
      if (q.errors.length > 0) {
        questions.push(q);
        for (var j = 0; j < q.errors.length; j++) {
          errors.push(q.errors[j]);
        }
      }
    }
    this.onValidatePage.fire(this, {
      questions,
      errors,
      page
    });
  }
  /**
   * Switches the survey to the previous page.
   *
   * This method returns a Boolean value that indicates whether the page was successfully switched. `false` is returned if the current page is the first page.
   * @returns `true` if the page was successfully switched; `false` otherwise.
   * @see isFirstPage
   * @see nextPage
   */
  prevPage() {
    if (this.currentSingleQuestion) return this.performPrevious();
    if (this.isFirstPage || this.state === "starting") return false;
    this.resetNavigationButton();
    const skipped = this.skippedPages.find((sp) => sp.to == this.currentPage);
    if (skipped) {
      this.currentPage = skipped.from;
      this.skippedPages.splice(this.skippedPages.indexOf(skipped), 1);
    } else {
      const vPages = this.visiblePages;
      const index = vPages.indexOf(this.currentPage);
      this.currentPage = vPages[index - 1];
    }
    return true;
  }
  /**
   * Completes the survey if it currently displays the last page and the page contains no validation errors. If both these conditions are met, this method returns `true`; otherwise, `false`.
   *
   * If you want to complete the survey regardless of the current page and validation errors, use the [`doComplete()`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#completeLastPage) event.
   * @see isCurrentPageValid
   * @see nextPage
   */
  tryComplete() {
    if (this.isValidateOnComplete) {
      this.cancelPreview();
    }
    let res = this.doCurrentPageComplete(true);
    if (res) {
      this.cancelPreview();
    }
    return res;
  }
  /**
   * @deprecated Use the [`tryComplete`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#tryComplete) method instead.
   */
  completeLastPage() {
    return this.tryComplete();
  }
  navigationMouseDown() {
    this.isNavigationButtonPressed = true;
    return true;
  }
  resetNavigationButton() {
    this.isNavigationButtonPressed = false;
  }
  nextPageUIClick() {
    if (!!this.mouseDownPage && this.mouseDownPage !== this.activePage) return false;
    this.mouseDownPage = null;
    return this.performNext();
  }
  nextPageMouseDown() {
    this.mouseDownPage = this.activePage;
    return this.navigationMouseDown();
  }
  /**
   * Displays a [preview of given answers](https://surveyjs.io/form-library/documentation/design-survey/create-a-multi-page-survey#preview-page). Returns `false` if the preview cannot be displayed because of validation errors.
   * @see cancelPreview
   * @see showPreviewBeforeComplete
   * @see onShowingPreview
   * @see state
   */
  showPreview() {
    this.resetNavigationButton();
    if (!this.isValidateOnComplete) {
      if (this.hasErrorsOnNavigate(true)) return false;
      if (this.doServerValidation(true, true)) return false;
    }
    this.showPreviewCore();
    return this.isShowingPreview;
  }
  showPreviewCore() {
    var options = {
      allowShowPreview: true,
      allow: true
    };
    this.onShowingPreview.fire(this, options);
    this.isShowingPreview = options.allowShowPreview && options.allow;
  }
  /**
   * Cancels a [preview of given answers](https://surveyjs.io/form-library/documentation/design-survey/create-a-multi-page-survey#preview-page) and switches the survey to the page specified by the `currentPage` parameter.
   * @param currentPage A new current page. If you do not specify this parameter, the survey displays the last page.
   * @see showPreview
   * @see showPreviewBeforeComplete
   * @see state
   */
  cancelPreview(currentPage = null) {
    if (!this.isShowingPreview) return;
    this.gotoPageFromPreview = currentPage;
    this.isShowingPreview = false;
    const q = this.currentSingleQuestion;
    if (!!(q === null || q === void 0 ? void 0 : q.page)) {
      q.page.updateRows();
      this.currentPage = q.page;
    }
  }
  cancelPreviewByPage(panel) {
    this.cancelPreview(panel);
  }
  doCurrentPageComplete(doComplete) {
    if (this.isValidatingOnServer) return false;
    this.resetNavigationButton();
    if (this.hasErrorsOnNavigate(doComplete)) return false;
    return this.doCurrentPageCompleteCore(doComplete);
  }
  doCurrentPageCompleteCore(doComplete) {
    if (this.doServerValidation(doComplete)) return false;
    if (doComplete) {
      this.currentPage.passed = true;
      return this.doComplete(this.canBeCompletedByTrigger, this.completedTrigger);
    }
    this.doNextPage();
    return true;
  }
  get isSinglePage() {
    return this.questionsOnPageMode == "singlePage";
  }
  set isSinglePage(val) {
    this.questionsOnPageMode = val ? "singlePage" : "standard";
  }
  get isSingleVisibleQuestion() {
    return this.isSingleVisibleQuestionVal(this.questionsOnPageMode);
  }
  isSingleVisibleQuestionVal(val) {
    return val === "questionPerPage" || val === "questionOnPage";
  }
  /**
   * Specifies how to distribute survey elements between pages.
   *
   * Possible values:
   *
   * - `"singlePage"` - Combines all survey pages into a single page.
   * - `"questionPerPage"` - Displays each question on a separate page.
   * - `"standard"` (default) - Retains the original structure specified in the JSON schema.
   */
  get questionsOnPageMode() {
    return this.getPropertyValue("questionsOnPageMode");
  }
  set questionsOnPageMode(val) {
    this.setPropertyValue("questionsOnPageMode", val);
  }
  /**
   * Gets or sets a Boolean value that specifies whether the first page is a start page.
   *
   * Refer to the following help topic for more information: [Start Page](https://surveyjs.io/form-library/documentation/design-survey/create-a-multi-page-survey#start-page).
   * @see startPage
   * @see activePage
   */
  get firstPageIsStartPage() {
    return this.getPropertyValue("firstPageIsStartPage");
  }
  set firstPageIsStartPage(val) {
    this.setPropertyValue("firstPageIsStartPage", val);
  }
  /**
   * @deprecated Use the [`firstPageIsStartPage`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#firstPageIsStartPage) property instead.
   */
  get firstPageIsStarted() {
    return this.firstPageIsStartPage;
  }
  set firstPageIsStarted(val) {
    this.firstPageIsStartPage = val;
  }
  isPageStarted(page) {
    return this.firstPageIsStartPage && this.pages.length > 1 && this.pages[0] === page;
  }
  /**
   * Specifies whether to show a preview of given answers before they are submitted.
   *
   * Default value: `false`
   *
   * [View Demo](https://surveyjs.io/form-library/examples/survey-preview/ (linkStyle))
   * @see previewMode
   * @see showPreview
   * @see cancelPreview
   */
  get showPreviewBeforeComplete() {
    return this.getPropertyValue("showPreviewBeforeComplete");
  }
  set showPreviewBeforeComplete(val) {
    this.setShowPreviewBeforeComplete(val);
  }
  setShowPreviewBeforeComplete(val) {
    if (val === void 0 || val === "noPreview" || val === false) {
      this.setPropertyValue("showPreviewBeforeComplete", false);
    } else {
      this.setPropertyValue("showPreviewBeforeComplete", true);
      if (val === "showAllQuestions") this.previewMode = "allQuestions";
      if (val === "showAnsweredQuestions") this.previewMode = "answeredQuestions";
    }
  }
  /**
   * Specifies whether the [preview of given answers](https://surveyjs.io/form-library/documentation/design-survey/create-a-multi-page-survey#preview-page) includes all or only answered questions.
   *
   * Possible values:
   *
   * - `"allQuestions"` (default)
   * - `"answeredQuestions"`
   *
   * [View Demo](https://surveyjs.io/form-library/examples/survey-preview/ (linkStyle))
   */
  get previewMode() {
    return this.getPropertyValue("previewMode");
  }
  set previewMode(val) {
    this.setPropertyValue("previewMode", val);
  }
  onFirstPageIsStartedChanged() {
    this.isStartedState = this.firstPageIsStartPage && this.pages.length > 1;
    this.pageVisibilityChanged(this.pages[0], !this.isStartedState);
  }
  onShowingPreviewChanged() {
    this.updatePagesContainer();
  }
  createRootPage(name, pages) {
    const container = Serializer.createClass("page");
    container.name = name;
    container.isPageContainer = true;
    pages.forEach((page) => {
      if (!page.isStartPage) {
        container.addElement(page);
      }
    });
    return container;
  }
  disposeContainerPage() {
    let cPage = this.pageContainerValue;
    const elements = [].concat(cPage.elements);
    elements.forEach((el) => cPage.removeElement(el));
    cPage.dispose();
    this.pageContainerValue = void 0;
  }
  updatePagesContainer() {
    if (this.isDesignMode) return;
    this.getAllQuestions().forEach((q) => q.updateElementVisibility());
    this.setPropertyValue("currentPage", void 0);
    const singleName = "single-page";
    const previewName = "preview-page";
    let rootPage = void 0;
    if (this.isSinglePage) {
      const cPage = this.pageContainerValue;
      if (cPage && cPage.name === previewName) {
        rootPage = cPage.elements[0];
        this.disposeContainerPage();
      } else {
        rootPage = this.createRootPage(singleName, this.pages);
      }
    }
    if (this.isShowingPreview) {
      rootPage = this.createRootPage(previewName, rootPage ? [rootPage] : this.pages);
    }
    if (rootPage) {
      rootPage.setSurveyImpl(this);
      this.pageContainerValue = rootPage;
      this.currentPage = rootPage;
      if (!!this.currentSingleQuestionValue) {
        this.visiblePages.forEach((page) => page.updateRows());
      }
    }
    if (!this.isSinglePage && !this.isShowingPreview) {
      this.disposeContainerPage();
      let curPage = this.gotoPageFromPreview;
      this.gotoPageFromPreview = null;
      if (Helpers.isValueEmpty(curPage) && this.visiblePageCount > 0) {
        curPage = this.visiblePages[this.visiblePageCount - 1];
      }
      if (!!curPage) {
        this.changeCurrentPageFromPreview = true;
        this.currentPage = curPage;
        this.changeCurrentPageFromPreview = false;
      }
    }
    if (!this.currentPage && this.visiblePageCount > 0) {
      this.currentPage = this.visiblePages[0];
    }
    this.pages.forEach((page) => {
      if (page.hasShown) {
        page.updateElementCss(true);
      }
    });
    this.updateButtonsVisibility();
  }
  getSingleQuestions() {
    const res = new Array();
    const pages = this.pages;
    for (var i = 0; i < pages.length; i++) {
      const p = pages[i];
      if (!p.isStartPage && p.isVisible) {
        p.addQuestionsToList(res, true);
      }
    }
    return res;
  }
  get currentSingleQuestion() {
    return !this.isShowingPreview ? this.currentSingleQuestionValue : void 0;
  }
  set currentSingleQuestion(val) {
    const oldVal = this.currentSingleQuestion;
    if (val !== oldVal && !this.isCompleted) {
      const options = !!val && !!oldVal ? this.createPageChangeEventOptions(val.page, oldVal.page, val, oldVal) : void 0;
      if (!!options && !this.currentPageChangingFromOptions(options)) return;
      this.currentSingleQuestionValue = val;
      if (!!val) {
        const page = val.page;
        page.updateRows();
        if (page !== this.currentPage) {
          this.currentPage = page;
        } else {
          if (this.autoFocusFirstQuestion) {
            val.focus();
          }
        }
        this.updateButtonsVisibility();
        if (!!options) {
          this.onCurrentPageChanged.fire(this, options);
        }
      } else {
        this.visiblePages.forEach((page) => page.updateRows());
      }
    }
  }
  onQuestionsOnPageModeChanged(oldValue) {
    if (this.isShowingPreview || this.isDesignMode) return;
    this.currentSingleQuestion = void 0;
    if (oldValue === "singlePage") {
      this.updatePagesContainer();
    }
    if (this.isSinglePage) {
      this.updatePagesContainer();
    }
    if (this.isSingleVisibleQuestion) {
      const questions = this.getSingleQuestions();
      if (questions.length > 0) {
        this.currentSingleQuestion = questions[0];
      }
    }
  }
  getPageStartIndex() {
    return this.firstPageIsStartPage && this.pages.length > 0 ? 1 : 0;
  }
  /**
   * Indicates whether the [current page](#currentPage) is the first page.
   *
   * > If the survey displays the [start page](https://surveyjs.io/form-library/documentation/design-survey/create-a-multi-page-survey#start-page), this property contains `false`. Use the [`isStartPageActive`](#isStartPageActive) property to find out whether the start page is currently displayed.
   */
  get isFirstPage() {
    return this.getPropertyValue("isFirstPage");
  }
  /**
   * Indicates whether the [current page](#currentPage) is the last page.
   */
  get isLastPage() {
    return this.getPropertyValue("isLastPage");
  }
  updateButtonsVisibility() {
    this.updateIsFirstLastPageState();
    this.setPropertyValue("isShowPrevButton", this.calcIsShowPrevButton());
    this.setPropertyValue("isShowNextButton", this.calcIsShowNextButton());
    this.setPropertyValue("isCompleteButtonVisible", this.calcIsCompleteButtonVisible());
    this.setPropertyValue("isPreviewButtonVisible", this.calcIsPreviewButtonVisible());
    this.setPropertyValue("isCancelPreviewButtonVisible", this.calcIsCancelPreviewButtonVisible());
  }
  get isShowPrevButton() {
    return this.getPropertyValue("isShowPrevButton");
  }
  get isShowNextButton() {
    return this.getPropertyValue("isShowNextButton");
  }
  get isCompleteButtonVisible() {
    return this.getPropertyValue("isCompleteButtonVisible");
  }
  get isPreviewButtonVisible() {
    return this.getPropertyValue("isPreviewButtonVisible");
  }
  get isCancelPreviewButtonVisible() {
    return this.getPropertyValue("isCancelPreviewButtonVisible");
  }
  get isFirstElement() {
    return this.getPropertyValue("isFirstElement");
  }
  get isLastElement() {
    return this.getPropertyValue("isLastElement");
  }
  updateIsFirstLastPageState() {
    const curPage = this.currentPage;
    this.setPropertyValue("isFirstPage", !!curPage && curPage === this.firstVisiblePage);
    this.setPropertyValue("isLastPage", !!curPage && curPage === this.lastVisiblePage);
    let fVal = void 0;
    let lVal = void 0;
    const q = this.currentSingleQuestion;
    if (!!q) {
      const questions = this.getSingleQuestions();
      const index = questions.indexOf(q);
      if (index >= 0) {
        fVal = index === 0;
        lVal = index === questions.length - 1;
      }
    }
    this.setPropertyValue("isFirstElement", fVal);
    this.setPropertyValue("isLastElement", lVal);
  }
  get isLastPageOrElement() {
    return this.isLastElement !== void 0 ? this.isLastElement : this.isLastPage;
  }
  get isFirstPageOrElement() {
    return this.isFirstElement !== void 0 ? this.isFirstElement : this.isFirstPage;
  }
  calcIsShowPrevButton() {
    if (this.isFirstPageOrElement || !this.showPrevButton || this.state !== "running") return false;
    if (this.isFirstElement !== void 0) return true;
    const page = this.visiblePages[this.currentPageNo - 1];
    return page && page.getMaxTimeToFinish() <= 0;
  }
  calcIsShowNextButton() {
    return this.state === "running" && !this.isLastPageOrElement && !this.canBeCompletedByTrigger;
  }
  calcIsCompleteButtonVisible() {
    const state = this.state;
    return this.isEditMode && (this.state === "running" && (this.isLastPageOrElement && !this.showPreviewBeforeComplete || this.canBeCompletedByTrigger) || state === "preview") && this.showCompleteButton;
  }
  calcIsPreviewButtonVisible() {
    return this.isEditMode && this.showPreviewBeforeComplete && this.state == "running" && this.isLastPageOrElement;
  }
  calcIsCancelPreviewButtonVisible() {
    return this.isEditMode && this.showPreviewBeforeComplete && this.state == "preview";
  }
  get firstVisiblePage() {
    if (this.visiblePageCount === 1) return this.visiblePages[0];
    const pages = this.pages;
    for (let i = 0; i < pages.length; i++) {
      if (this.isPageInVisibleList(pages[i])) return pages[i];
    }
    return null;
  }
  get lastVisiblePage() {
    if (this.visiblePageCount === 1) return this.visiblePages[0];
    const pages = this.pages;
    for (let i = pages.length - 1; i >= 0; i--) {
      if (this.isPageInVisibleList(pages[i])) return pages[i];
    }
    return null;
  }
  /**
   * Completes the survey.
   *
   * When you call this method, Form Library performs the following actions:
   *
   * 1. Saves a cookie if the [`cookieName`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#cookieName) property is set.
   * 1. Switches the survey [`state`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#state) to `"completed"`.
   * 1. Raises the [`onComplete`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#onComplete) event.
   * 1. Navigates the user to a URL specified by the [`navigateToUrl`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#navigateToUrl) or [`navigateToUrlOnCondition`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#navigateToUrlOnCondition) property.
   *
   * The `doComplete()` method completes the survey regardless of validation errors and the current page. If you need to ensure that survey results are valid and full, call the [`completeLastPage()`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#completeLastPage) method instead.
   *
   * @param isCompleteOnTrigger For internal use.
   * @param completeTrigger For internal use.
   * @returns `false` if survey completion is cancelled within the [`onCompleting`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#onCompleting) event handler; otherwise, `true`.
   */
  doComplete(isCompleteOnTrigger = false, completeTrigger) {
    if (this.isCompleted) return;
    if (!this.checkOnCompletingEvent(isCompleteOnTrigger, completeTrigger)) {
      this.isCompleted = false;
      return false;
    }
    this.checkOnPageTriggers(true);
    this.stopTimer();
    this.notifyQuestionsOnHidingContent(this.currentPage);
    this.isCompleted = true;
    this.clearUnusedValues();
    this.saveDataOnComplete(isCompleteOnTrigger, completeTrigger);
    this.setCookie();
    return true;
  }
  saveDataOnComplete(isCompleteOnTrigger = false, completeTrigger) {
    let previousCookie = this.hasCookie;
    const showSaveInProgress = (text) => {
      savingDataStarted = true;
      this.setCompletedState("saving", text);
    };
    const showSaveError = (text) => {
      this.setCompletedState("error", text);
    };
    const showSaveSuccess = (text) => {
      this.setCompletedState("success", text);
      this.navigateTo();
    };
    const clearSaveMessages = (text) => {
      this.setCompletedState("", "");
    };
    var savingDataStarted = false;
    var onCompleteOptions = {
      isCompleteOnTrigger,
      completeTrigger,
      showSaveInProgress,
      showSaveError,
      showSaveSuccess,
      clearSaveMessages,
      //Obsolete functions
      showDataSaving: showSaveInProgress,
      showDataSavingError: showSaveError,
      showDataSavingSuccess: showSaveSuccess,
      showDataSavingClear: clearSaveMessages
    };
    this.onComplete.fire(this, onCompleteOptions);
    if (!previousCookie && this.surveyPostId) {
      this.sendResult();
    }
    if (!savingDataStarted) {
      this.navigateTo();
    }
  }
  checkOnCompletingEvent(isCompleteOnTrigger, completeTrigger) {
    var options = {
      allowComplete: true,
      allow: true,
      isCompleteOnTrigger,
      completeTrigger
    };
    this.onCompleting.fire(this, options);
    return options.allowComplete && options.allow;
  }
  /**
   * Starts the survey. Applies only if the survey has a [start page](https://surveyjs.io/form-library/documentation/design-survey/create-a-multi-page-survey#start-page).
   * @see firstPageIsStartPage
   * @see completeLastPage
   */
  start() {
    if (!this.firstPageIsStartPage) return false;
    this.isCurrentPageRendering = true;
    if (this.checkIsPageHasErrors(this.startPage, true)) return false;
    this.isStartedState = false;
    this.notifyQuestionsOnHidingContent(this.pages[0]);
    this.startTimerFromUI();
    this.onStarted.fire(this, {});
    this.updateVisibleIndexes();
    this.currentPageNo = 0;
    if (!!this.currentPage) {
      this.currentPage.locStrsChanged();
    }
    return true;
  }
  /**
   * Indicates whether the current page is being [validated on a server](#onServerValidateQuestions).
   */
  get isValidatingOnServer() {
    return this.getPropertyValue("isValidatingOnServer", false);
  }
  setIsValidatingOnServer(val) {
    if (val == this.isValidatingOnServer) return;
    this.setPropertyValue("isValidatingOnServer", val);
    this.onIsValidatingOnServerChanged();
  }
  createServerValidationOptions(doComplete, isPreview, page) {
    var self2 = this;
    const options = {
      data: {},
      errors: {},
      survey: this,
      complete: function() {
        self2.completeServerValidation(options, isPreview, page);
      }
    };
    if (doComplete && this.isValidateOnComplete) {
      options.data = this.data;
    } else {
      var questions = this.activePage.questions;
      for (var i = 0; i < questions.length; i++) {
        var question = questions[i];
        if (!question.visible) continue;
        var value = this.getValue(question.getValueName());
        if (!this.isValueEmpty(value)) options.data[question.getValueName()] = value;
      }
    }
    return options;
  }
  onIsValidatingOnServerChanged() {
  }
  doServerValidation(doComplete, isPreview = false, page) {
    if (!this.onServerValidateQuestions || this.onServerValidateQuestions.isEmpty) return false;
    if (!doComplete && this.isValidateOnComplete) return false;
    this.setIsValidatingOnServer(true);
    const isFunc = typeof this.onServerValidateQuestions === "function";
    this.serverValidationEventCount = !isFunc ? this.onServerValidateQuestions.length : 1;
    if (isFunc) {
      this.onServerValidateQuestions(this, this.createServerValidationOptions(doComplete, isPreview, page));
    } else {
      this.onServerValidateQuestions.fireByCreatingOptions(this, () => {
        return this.createServerValidationOptions(doComplete, isPreview, page);
      });
    }
    return true;
  }
  completeServerValidation(options, isPreview, page) {
    if (this.serverValidationEventCount > 1) {
      this.serverValidationEventCount--;
      if (!!options && !!options.errors && Object.keys(options.errors).length === 0) return;
    }
    this.serverValidationEventCount = 0;
    this.setIsValidatingOnServer(false);
    if (!options && !options.survey) return;
    var self2 = options.survey;
    var hasErrors = false;
    if (options.errors) {
      var hasToFocus = this.autoFocusFirstError;
      for (var name in options.errors) {
        var question = self2.getQuestionByName(name);
        if (question && question["errors"]) {
          hasErrors = true;
          question.addError(new CustomError(options.errors[name], this));
          if (hasToFocus) {
            hasToFocus = false;
            if (!!question.page) {
              this.currentPage = question.page;
            }
            question.focus(true);
          }
        }
      }
      this.fireValidatedErrorsOnPage(this.currentPage);
    }
    if (!hasErrors) {
      if (isPreview) {
        this.showPreviewCore();
      } else {
        if (page) {
          this.currentPage = page;
        } else {
          if (self2.isLastPage) self2.doComplete();
          else self2.doNextPage();
        }
      }
    }
  }
  doNextPage() {
    var curPage = this.currentPage;
    this.checkOnPageTriggers(false);
    if (!this.isCompleted) {
      if (this.partialSendEnabled) {
        this.sendResult(this.surveyPostId, this.clientId, true);
      }
      if (curPage === this.currentPage) {
        var vPages = this.visiblePages;
        var index = vPages.indexOf(this.currentPage);
        this.currentPage = vPages[index + 1];
      }
    } else {
      this.doComplete(true);
    }
  }
  setCompleted(trigger) {
    this.doComplete(true, trigger);
  }
  canBeCompleted(trigger, isCompleted) {
    var _a;
    if (!settings.triggers.changeNavigationButtonsOnComplete) return;
    const prevCanBeCompleted = this.canBeCompletedByTrigger;
    if (!this.completedByTriggers) this.completedByTriggers = {};
    if (isCompleted) {
      this.completedByTriggers[trigger.id] = {
        trigger,
        pageId: (_a = this.currentPage) === null || _a === void 0 ? void 0 : _a.id
      };
    } else {
      delete this.completedByTriggers[trigger.id];
    }
    if (prevCanBeCompleted !== this.canBeCompletedByTrigger) {
      this.updateButtonsVisibility();
    }
  }
  get canBeCompletedByTrigger() {
    var _a;
    if (!this.completedByTriggers) return false;
    const keys = Object.keys(this.completedByTriggers);
    if (keys.length === 0) return false;
    const id = (_a = this.currentPage) === null || _a === void 0 ? void 0 : _a.id;
    if (!id) return true;
    for (let i = 0; i < keys.length; i++) {
      if (id === this.completedByTriggers[keys[i]].pageId) return true;
    }
    return false;
  }
  get completedTrigger() {
    if (!this.canBeCompletedByTrigger) return void 0;
    const key = Object.keys(this.completedByTriggers)[0];
    return this.completedByTriggers[key].trigger;
  }
  /**
   * Returns HTML content displayed on the [complete page](https://surveyjs.io/form-library/documentation/design-survey/create-a-multi-page-survey#complete-page).
   *
   * To specify HTML content, use the [`completedHtml`](#completedHtml) property.
   */
  get processedCompletedHtml() {
    var html = this.renderedCompletedHtml;
    return !!html ? this.processHtml(html, "completed") : "";
  }
  /**
   * Returns HTML content displayed to a user who has completed the survey before. To identify such users, the survey uses a [cookie name](#cookieName) or [client ID](#clientId).
   *
   * To specify HTML content, use the [`completedBeforeHtml`](#completedBeforeHtml) property.
   */
  get processedCompletedBeforeHtml() {
    return this.locCompletedBeforeHtml.textOrHtml;
  }
  /**
   * Returns HTML content displayed while a survey JSON schema is [being loaded](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#beginLoading).
   *
   * To specify HTML content, use the [`loadingHtml`](#loadingHtml) property.
   */
  get processedLoadingHtml() {
    return this.locLoadingHtml.textOrHtml;
  }
  getProgressInfo() {
    var pages = this.isDesignMode ? this.pages : this.visiblePages;
    return SurveyElement.getProgressInfoByElements(pages, false);
  }
  /**
   * Returns text displayed by the progress bar (for instance, "Page 2 of 3" or "Answered 3/8 questions"). Handle the [`onGetProgressText`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#onGetProgressText) event to change this text.
   * @see progressValue
   * @see showProgressBar
   * @see progressBarType
   */
  get progressText() {
    return this.progressBar.progressText;
  }
  /**
   * Returns a percentage value that indicates user progress in the survey.
   * @see showProgressBar
   * @see progressBarType
   * @see progressText
   */
  get progressValue() {
    return this.getPropertyValue("progressValue", void 0, () => this.getProgress());
  }
  updateProgressText(onValueChanged = false) {
    if (this.isShowingPreview) return;
    if (onValueChanged && this.progressBarType == "pages" && this.onGetProgressText.isEmpty) return;
    if (this.progressBarValue) {
      this.progressBarValue.resetProgressText();
    }
    this.resetPropertyValue("progressValue");
  }
  getProgressText() {
    if (!this.isDesignMode && this.currentPage == null) return "";
    const options = {
      questionCount: 0,
      answeredQuestionCount: 0,
      requiredQuestionCount: 0,
      requiredAnsweredQuestionCount: 0,
      text: ""
    };
    var type = this.progressBarType.toLowerCase();
    if (type === "questions" || type === "requiredquestions" || type === "correctquestions" || !this.onGetProgressText.isEmpty) {
      var info = this.getProgressInfo();
      options.questionCount = info.questionCount;
      options.answeredQuestionCount = info.answeredQuestionCount;
      options.requiredQuestionCount = info.requiredQuestionCount;
      options.requiredAnsweredQuestionCount = info.requiredAnsweredQuestionCount;
    }
    options.text = this.getProgressTextCore(options);
    this.onGetProgressText.fire(this, options);
    return options.text;
  }
  getProgressTextCore(info) {
    var type = this.progressBarType.toLowerCase();
    if (type === "questions") {
      return this.getLocalizationFormatString("questionsProgressText", info.answeredQuestionCount, info.questionCount);
    }
    if (type === "requiredquestions") {
      return this.getLocalizationFormatString("questionsProgressText", info.requiredAnsweredQuestionCount, info.requiredQuestionCount);
    }
    if (type === "correctquestions") {
      var correctAnswersCount = this.getCorrectedAnswerCount();
      return this.getLocalizationFormatString("questionsProgressText", correctAnswersCount, info.questionCount);
    }
    var vPages = this.isDesignMode ? this.pages : this.visiblePages;
    var index = vPages.indexOf(this.currentPage) + 1;
    return this.getLocalizationFormatString("progressText", index, vPages.length);
  }
  getRootCss() {
    return new CssClassBuilder().append(this.css.root).append(this.css.rootProgress + "--" + this.progressBarType).append(this.css.rootMobile, this.isMobile).append(this.css.rootAnimationDisabled, !settings.animationEnabled).append(this.css.rootReadOnly, this.readOnly && !this.isDesignMode).append(this.css.rootCompact, this.isCompact).append(this.css.rootFitToContainer, this.fitToContainer).toString();
  }
  afterRenderSurvey(htmlElement) {
    this.destroyResizeObserver();
    if (Array.isArray(htmlElement)) {
      htmlElement = SurveyElement.GetFirstNonTextElement(htmlElement);
    }
    let observedElement = htmlElement;
    const cssVariables = this.css.variables;
    if (!!cssVariables) {
      const mobileWidth = Number.parseFloat(DomDocumentHelper.getComputedStyle(observedElement).getPropertyValue(cssVariables.mobileWidth));
      if (!!mobileWidth) {
        let isProcessed = false;
        this.resizeObserver = new ResizeObserver((entries) => {
          DomWindowHelper.requestAnimationFrame(() => {
            if (isProcessed || !isContainerVisible(observedElement)) {
              isProcessed = false;
            } else {
              isProcessed = this.processResponsiveness(observedElement.offsetWidth, mobileWidth, observedElement.offsetHeight);
            }
          });
        });
        this.resizeObserver.observe(observedElement);
      }
    }
    this.onAfterRenderSurvey.fire(this, {
      survey: this,
      htmlElement
    });
    this.rootElement = htmlElement;
    this.addScrollEventListener();
  }
  beforeDestroySurveyElement() {
    this.destroyResizeObserver();
    this.removeScrollEventListener();
    this.rootElement = void 0;
  }
  processResponsiveness(width, mobileWidth, height) {
    const isMobile = width < mobileWidth;
    const isMobileChanged = this.isMobile !== isMobile;
    this.setIsMobile(isMobile);
    this.layoutElements.forEach((layoutElement) => layoutElement.processResponsiveness && layoutElement.processResponsiveness(width));
    const options = {
      height,
      width
    };
    this.onResize.fire(this, options);
    return isMobileChanged;
  }
  triggerResponsiveness(hard) {
    this.getAllQuestions().forEach((question) => {
      question.triggerResponsiveness(hard);
    });
  }
  destroyResizeObserver() {
    if (!!this.resizeObserver) {
      this.resizeObserver.disconnect();
      this.resizeObserver = void 0;
    }
  }
  updateQuestionCssClasses(question, cssClasses) {
    this.onUpdateQuestionCssClasses.fire(this, {
      question,
      cssClasses
    });
  }
  updatePanelCssClasses(panel, cssClasses) {
    this.onUpdatePanelCssClasses.fire(this, {
      panel,
      cssClasses
    });
  }
  updatePageCssClasses(page, cssClasses) {
    this.onUpdatePageCssClasses.fire(this, {
      page,
      cssClasses
    });
  }
  updateChoiceItemCss(question, options) {
    options.question = question;
    this.onUpdateChoiceItemCss.fire(this, options);
  }
  afterRenderPage(htmlElement) {
    if (!this.isDesignMode && !this.focusingQuestionInfo) {
      const doScroll = this.isCurrentPageRendered === false;
      setTimeout(() => this.scrollToTopOnPageChange(doScroll), 1);
    }
    this.focusQuestionInfo();
    this.isCurrentPageRendered = true;
    if (this.onAfterRenderPage.isEmpty) return;
    this.onAfterRenderPage.fire(this, {
      page: this.activePage,
      htmlElement
    });
  }
  afterRenderHeader(htmlElement) {
    if (this.onAfterRenderHeader.isEmpty) return;
    this.onAfterRenderHeader.fire(this, {
      htmlElement
    });
  }
  afterRenderQuestion(question, htmlElement) {
    this.onAfterRenderQuestion.fire(this, {
      question,
      htmlElement
    });
  }
  afterRenderQuestionInput(question, htmlElement) {
    if (this.onAfterRenderQuestionInput.isEmpty) return;
    let id = question.inputId;
    const {
      root
    } = settings.environment;
    if (!!id && (!htmlElement || htmlElement.id !== id) && typeof root !== "undefined") {
      let el = root.getElementById(id);
      if (!!el) {
        htmlElement = el;
      }
    }
    this.onAfterRenderQuestionInput.fire(this, {
      question,
      htmlElement
    });
  }
  afterRenderPanel(panel, htmlElement) {
    this.onAfterRenderPanel.fire(this, {
      panel,
      htmlElement
    });
  }
  whenQuestionFocusIn(question) {
    this.onFocusInQuestion.fire(this, {
      question
    });
  }
  whenPanelFocusIn(panel) {
    this.onFocusInPanel.fire(this, {
      panel
    });
  }
  rebuildQuestionChoices() {
    this.getAllQuestions().forEach((q) => q.surveyChoiceItemVisibilityChange());
  }
  canChangeChoiceItemsVisibility() {
    return !this.onShowingChoiceItem.isEmpty;
  }
  getChoiceItemVisibility(question, item, val) {
    const options = {
      question,
      item,
      visible: val
    };
    this.onShowingChoiceItem.fire(this, options);
    return options.visible;
  }
  loadQuestionChoices(options) {
    this.onChoicesLazyLoad.fire(this, options);
  }
  getChoiceDisplayValue(options) {
    if (this.onGetChoiceDisplayValue.isEmpty) {
      options.setItems(null);
    } else {
      this.onGetChoiceDisplayValue.fire(this, options);
    }
  }
  matrixBeforeRowAdded(options) {
    this.onMatrixRowAdding.fire(this, options);
  }
  matrixRowAdded(question, row) {
    this.onMatrixRowAdded.fire(this, {
      question,
      row
    });
  }
  matrixColumnAdded(question, column) {
    this.onMatrixColumnAdded.fire(this, {
      question,
      column
    });
  }
  multipleTextItemAdded(question, item) {
    this.onMultipleTextItemAdded.fire(this, {
      question,
      item
    });
  }
  getQuestionByValueNameFromArray(valueName, name, index) {
    var questions = this.getQuestionsByValueName(valueName);
    if (!questions) return;
    for (var i = 0; i < questions.length; i++) {
      var res = questions[i].getQuestionFromArray(name, index);
      if (!!res) return res;
    }
    return null;
  }
  matrixRowRemoved(question, rowIndex, row) {
    this.onMatrixRowRemoved.fire(this, {
      question,
      rowIndex,
      row
    });
  }
  matrixRowRemoving(question, rowIndex, row) {
    var options = {
      question,
      rowIndex,
      row,
      allow: true
    };
    this.onMatrixRowRemoving.fire(this, options);
    return options.allow;
  }
  matrixAllowRemoveRow(question, rowIndex, row) {
    const options = {
      question,
      rowIndex,
      row,
      allow: true
    };
    this.onMatrixRenderRemoveButton.fire(this, options);
    return options.allow;
  }
  matrixDetailPanelVisibleChanged(question, rowIndex, row, visible) {
    const options = {
      question,
      rowIndex,
      row,
      visible,
      detailPanel: row.detailPanel
    };
    this.onMatrixDetailPanelVisibleChanged.fire(this, options);
  }
  matrixCellCreating(question, options) {
    options.question = question;
    this.onMatrixCellCreating.fire(this, options);
  }
  matrixCellCreated(question, options) {
    options.question = question;
    this.onMatrixCellCreated.fire(this, options);
  }
  matrixAfterCellRender(question, options) {
    options.question = question;
    this.onAfterRenderMatrixCell.fire(this, options);
  }
  matrixCellValueChanged(question, options) {
    options.question = question;
    this.onMatrixCellValueChanged.fire(this, options);
  }
  matrixCellValueChanging(question, options) {
    options.question = question;
    this.onMatrixCellValueChanging.fire(this, options);
  }
  get isValidateOnValueChanging() {
    return this.checkErrorsMode === "onValueChanging";
  }
  get isValidateOnValueChanged() {
    return this.checkErrorsMode === "onValueChanged";
  }
  get isValidateOnValueChange() {
    return this.isValidateOnValueChanged || this.isValidateOnValueChanging;
  }
  get isValidateOnComplete() {
    return this.checkErrorsMode === "onComplete" || this.validationAllowSwitchPages && !this.validationAllowComplete;
  }
  matrixCellValidate(question, options) {
    options.question = question;
    this.onMatrixCellValidate.fire(this, options);
    return options.error ? new CustomError(options.error, this) : null;
  }
  dynamicPanelAdded(question, panelIndex, panel) {
    if (!this.isLoadingFromJson && this.hasQuestionVisibleIndeces(question)) {
      this.updateVisibleIndexes(question.page);
    }
    if (this.onDynamicPanelAdded.isEmpty) return;
    var panels = question.panels;
    if (panelIndex === void 0) {
      panelIndex = panels.length - 1;
      panel = panels[panelIndex];
    }
    this.onDynamicPanelAdded.fire(this, {
      question,
      panel,
      panelIndex
    });
  }
  dynamicPanelRemoved(question, panelIndex, panel) {
    var questions = !!panel ? panel.questions : [];
    for (var i = 0; i < questions.length; i++) {
      questions[i].clearOnDeletingContainer();
    }
    if (this.hasQuestionVisibleIndeces(question)) {
      this.updateVisibleIndexes(question.page);
    }
    this.onDynamicPanelRemoved.fire(this, {
      question,
      panelIndex,
      panel
    });
  }
  hasQuestionVisibleIndeces(question) {
    const qList = question.getNestedQuestions(true);
    for (let i = 0; i < qList.length; i++) {
      if (qList[i].visibleIndex > -1) return true;
    }
    return false;
  }
  dynamicPanelRemoving(question, panelIndex, panel) {
    const options = {
      question,
      panelIndex,
      panel,
      allow: true
    };
    this.onDynamicPanelRemoving.fire(this, options);
    return options.allow;
  }
  dynamicPanelItemValueChanged(question, options) {
    options.question = question;
    this.onDynamicPanelValueChanged.fire(this, options);
  }
  dynamicPanelItemValueChanging(question, options) {
    options.question = question;
    this.onDynamicPanelValueChanging.fire(this, options);
  }
  dynamicPanelGetTabTitle(question, options) {
    options.question = question;
    this.onGetDynamicPanelTabTitle.fire(this, options);
  }
  dynamicPanelCurrentIndexChanged(question, options) {
    options.question = question;
    this.onDynamicPanelCurrentIndexChanged.fire(this, options);
  }
  dragAndDropAllow(options) {
    this.onDragDropAllow.fire(this, options);
    return options.allow;
  }
  elementContentVisibilityChanged(element) {
    if (this.currentPage) {
      this.currentPage.ensureRowsVisibility();
    }
    this.onElementContentVisibilityChanged.fire(this, {
      element
    });
  }
  getUpdatedPanelFooterActions(panel, actions, question) {
    const options = {
      question,
      panel,
      actions
    };
    this.onGetPanelFooterActions.fire(this, options);
    return options.actions;
  }
  getUpdatedElementTitleActions(element, titleActions) {
    if (element.isPage) return this.getUpdatedPageTitleActions(element, titleActions);
    if (element.isPanel) return this.getUpdatedPanelTitleActions(element, titleActions);
    return this.getUpdatedQuestionTitleActions(element, titleActions);
  }
  getTitleActionsResult(titleActions, options) {
    if (titleActions != options.actions) return options.actions;
    if (titleActions != options.titleActions) return options.titleActions;
    return titleActions;
  }
  getUpdatedQuestionTitleActions(question, titleActions) {
    const options = {
      question,
      actions: titleActions,
      titleActions
    };
    this.onGetQuestionTitleActions.fire(this, options);
    return this.getTitleActionsResult(titleActions, options);
  }
  getUpdatedPanelTitleActions(panel, titleActions) {
    const options = {
      panel,
      actions: titleActions,
      titleActions
    };
    this.onGetPanelTitleActions.fire(this, options);
    return this.getTitleActionsResult(titleActions, options);
  }
  getUpdatedPageTitleActions(page, titleActions) {
    var options = {
      page,
      actions: titleActions,
      titleActions
    };
    this.onGetPageTitleActions.fire(this, options);
    return this.getTitleActionsResult(titleActions, options);
  }
  getUpdatedMatrixRowActions(question, row, actions) {
    const options = {
      question,
      actions,
      row
    };
    this.onGetMatrixRowActions.fire(this, options);
    return options.actions;
  }
  scrollElementToTop(element, question, page, id, scrollIfVisible, scrollIntoViewOptions, passedRootElement, onScolledCallback) {
    const options = {
      element,
      question,
      page,
      elementId: id,
      cancel: false,
      allow: true
    };
    this.onScrollToTop.fire(this, options);
    if (!options.cancel && options.allow) {
      const elementPage = this.getPageByElement(element);
      if (this.isLazyRendering && !!elementPage) {
        let elementsToRenderBefore = 1;
        const {
          rootElement
        } = settings.environment;
        const surveyRootElement = this.rootElement || passedRootElement || rootElement;
        if (!!this.skeletonHeight && !!surveyRootElement && typeof surveyRootElement.getBoundingClientRect === "function") {
          elementsToRenderBefore = surveyRootElement.getBoundingClientRect().height / this.skeletonHeight - 1;
        }
        elementPage.forceRenderElement(element, () => {
          this.suspendLazyRendering();
          SurveyElement.ScrollElementToTop(options.elementId, scrollIfVisible, scrollIntoViewOptions, () => {
            this.releaseLazyRendering();
            activateLazyRenderingChecks(elementPage.id);
            onScolledCallback && onScolledCallback();
          });
        }, elementsToRenderBefore);
      } else {
        if (element.isPage && !this.isSinglePage && !this.isDesignMode && this.rootElement) {
          const elementToScroll = this.rootElement.querySelector(classesToSelector(this.css.rootWrapper));
          SurveyElement.ScrollElementToViewCore(elementToScroll, false, scrollIfVisible, scrollIntoViewOptions, onScolledCallback);
        } else {
          SurveyElement.ScrollElementToTop(options.elementId, scrollIfVisible, scrollIntoViewOptions, onScolledCallback);
        }
      }
    }
  }
  /**
   * Opens a dialog window for users to select files.
   * @param input A [file input HTML element](https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement).
   * @param callback A callback function that you can use to process selected files. Accepts an array of JavaScript <a href="https://developer.mozilla.org/en-US/docs/Web/API/File" target="_blank">File</a> objects.
   * @see onOpenFileChooser
   * @see onUploadFile
   */
  chooseFiles(input, callback, context) {
    if (this.onOpenFileChooser.isEmpty) {
      chooseFiles(input, callback);
    } else {
      this.onOpenFileChooser.fire(this, {
        input,
        element: context && context.element || this.survey,
        elementType: context && context.elementType,
        item: context && context.item,
        propertyName: context && context.propertyName,
        callback,
        context
      });
    }
  }
  /**
   * Uploads files to a server.
   *
   * The following code shows how to call this method:
   *
   * ```js
   * const question = survey.getQuestionByName("myFileQuestion");
   * survey.uploadFiles(
   *   question,
   *   question.name,
   *   question.value,
   *   (data, errors) => {
   *     // ...
   *   }
   * );
   * ```
   * @param question A [File Upload question instance](https://surveyjs.io/form-library/documentation/api-reference/file-model) or [Signature Pad question instance](https://surveyjs.io/form-library/documentation/api-reference/signature-pad-model).
   * @param name The File Upload question's [`name`](https://surveyjs.io/form-library/documentation/api-reference/file-model#name) or Signature Pad question's [`name`](https://surveyjs.io/form-library/documentation/api-reference/signature-pad-model#name).
   * @param files An array of JavaScript <a href="https://developer.mozilla.org/en-US/docs/Web/API/File" target="_blank">File</a> objects that represent files to upload.
   * @param callback A callback function that allows you to access successfully uploaded files as the first argument. If any files fail to upload, the second argument contains an array of error messages.
   * @see onUploadFiles
   * @see downloadFile
   */
  uploadFiles(question, name, files, callback) {
    if (this.onUploadFiles.isEmpty) {
      callback("error", this.getLocString("noUploadFilesHandler"));
    } else {
      this.taskManager.runTask("file", (done) => {
        this.onUploadFiles.fire(this, {
          question,
          name,
          files: files || [],
          callback: (status, data) => {
            callback(status, data);
            done();
          }
        });
      });
    }
    if (this.surveyPostId) {
      this.uploadFilesCore(name, files, callback);
    }
  }
  downloadFile(question, questionName, fileValue, callback) {
    if (this.onDownloadFile.isEmpty) {
      !!callback && callback("skipped", fileValue.content || fileValue);
    }
    this.onDownloadFile.fire(this, {
      question,
      name: questionName,
      content: fileValue.content || fileValue,
      fileValue,
      callback
    });
  }
  clearFiles(question, name, value, fileName, callback) {
    if (this.onClearFiles.isEmpty) {
      !!callback && callback("success", value);
    }
    this.onClearFiles.fire(this, {
      question,
      name,
      value,
      fileName,
      callback
    });
  }
  updateChoicesFromServer(question, choices, serverResult) {
    var options = {
      question,
      choices,
      serverResult
    };
    this.onChoicesLoaded.fire(this, options);
    return options.choices;
  }
  loadedChoicesFromServer(question) {
    this.locStrsChanged();
  }
  uploadFilesCore(name, files, uploadingCallback) {
    this.reportWarningOnUsingService();
  }
  getPage(index) {
    return this.pages[index];
  }
  /**
   * Adds an existing page to the survey.
   * @param page A page to add.
   * @param index An index at which to insert the page. If you do not specify this parameter, the page will be added to the end.
   * @see addNewPage
   * @see createNewPage
   */
  addPage(page, index = -1) {
    if (page == null) return;
    if (index < 0 || index >= this.pages.length) {
      this.pages.push(page);
    } else {
      this.pages.splice(index, 0, page);
    }
  }
  /**
   * Creates a new page and adds it to the survey.
   *
   * If you want to switch a survey to the newly added page, assign its index to the [`currentPageNo`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#currentPageNo) property or assign the entire page to the [`currentPage`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#currentPage) property.
   *
   * @param name A page name. If you do not specify this parameter, it will be generated automatically.
   * @param index An index at which to insert the page. If you do not specify this parameter, the page will be added to the end.
   * @returns The created and added page.
   * @see addPage
   * @see createNewPage
   */
  addNewPage(name = null, index = -1) {
    var page = this.createNewPage(name);
    this.addPage(page, index);
    return page;
  }
  /**
   * Removes a page from the survey.
   *
   * Pass a `PageModel` object to this method. You can get this object in different ways. For example, you can call the [`getPageByName()`](#getPageByName) method to obtain a `PageModel` object with a specific name or use the [`currentPage`](#currentPage) property to access and delete the current page, as shown in the code below.
   *
   * ```js
   * // Delete the current page
   * survey.removePage(survey.currentPage);
   * ```
   * @param page A page to remove.
   * @see addNewPage
   */
  removePage(page) {
    var index = this.pages.indexOf(page);
    if (index < 0) return;
    this.pages.splice(index, 1);
    if (this.currentPage == page) {
      this.currentPage = this.pages.length > 0 ? this.pages[0] : null;
    }
  }
  /**
   * Returns a question with a specified [`name`](https://surveyjs.io/form-library/documentation/api-reference/question#name).
   * @param name A question name
   * @param caseInsensitive *(Optional)* A Boolean value that specifies case sensitivity when searching for the question. Default value: `false` (uppercase and lowercase letters are treated as distinct).
   * @returns A question with a specified name.
   * @see getAllQuestions
   * @see getQuestionByValueName
   */
  getQuestionByName(name, caseInsensitive = false) {
    if (!name) return null;
    if (caseInsensitive) {
      name = name.toLowerCase();
    }
    var hash = !!caseInsensitive ? this.questionHashes.namesInsensitive : this.questionHashes.names;
    var res = hash[name];
    if (!res) return null;
    return res[0];
  }
  findQuestionByName(name) {
    return this.getQuestionByName(name);
  }
  getEditingSurveyElement() {
    return this.editingObjValue;
  }
  /**
   * Returns a question with a specified [`valueName`](https://surveyjs.io/form-library/documentation/api-reference/question#valueName).
   *
   * > Since `valueName` does not have to be unique, multiple questions can have the same `valueName` value. In this case, the `getQuestionByValueName()` method returns the first such question. If you need to get all questions with the same `valueName`, call the `getQuestionsByValueName()` method.
   * @param valueName A question's `valueName` property value.
   * @param caseInsensitive *(Optional)* A Boolean value that specifies case sensitivity when searching for the question. Default value: `false` (uppercase and lowercase letters are treated as distinct).
   * @returns A question with a specified `valueName`.
   * @see getAllQuestions
   * @see getQuestionByName
   */
  getQuestionByValueName(valueName, caseInsensitive = false) {
    var res = this.getQuestionsByValueName(valueName, caseInsensitive);
    return !!res ? res[0] : null;
  }
  /**
   * Returns all questions with a specified [`valueName`](https://surveyjs.io/form-library/documentation/api-reference/question#valueName). If a question's `valueName` is undefined, its [`name`](https://surveyjs.io/form-library/documentation/api-reference/question#name) property is used.
   * @param valueName A question's `valueName` property value.
   * @param caseInsensitive *(Optional)* A Boolean value that specifies case sensitivity when searching for the questions. Default value: `false` (uppercase and lowercase letters are treated as distinct).
   * @returns An array of questions with a specified `valueName`.
   * @see getAllQuestions
   * @see getQuestionByName
   */
  getQuestionsByValueName(valueName, caseInsensitive = false) {
    var hash = !!caseInsensitive ? this.questionHashes.valueNamesInsensitive : this.questionHashes.valueNames;
    var res = hash[valueName];
    if (!res) return null;
    return res;
  }
  getCalculatedValueByName(name) {
    for (var i = 0; i < this.calculatedValues.length; i++) {
      if (name == this.calculatedValues[i].name) return this.calculatedValues[i];
    }
    return null;
  }
  getQuestionsByNames(names, caseInsensitive = false) {
    var result = [];
    if (!names) return result;
    for (var i = 0; i < names.length; i++) {
      if (!names[i]) continue;
      var question = this.getQuestionByName(names[i], caseInsensitive);
      if (question) result.push(question);
    }
    return result;
  }
  /**
   * Returns a page to which a specified survey element (question or panel) belongs.
   * @param element A question or panel instance.
   */
  getPageByElement(element) {
    for (var i = 0; i < this.pages.length; i++) {
      var page = this.pages[i];
      if (page.containsElement(element)) return page;
    }
    return null;
  }
  /**
   * Returns a page to which a specified question belongs.
   * @param question A question instance.
   */
  getPageByQuestion(question) {
    return this.getPageByElement(question);
  }
  /**
   * Returns a page with a specified name.
   * @param name A page [name](https://surveyjs.io/form-library/documentation/api-reference/page-model#name).
   */
  getPageByName(name) {
    for (var i = 0; i < this.pages.length; i++) {
      if (this.pages[i].name == name) return this.pages[i];
    }
    return null;
  }
  getPagesByNames(names) {
    var result = [];
    if (!names) return result;
    for (var i = 0; i < names.length; i++) {
      if (!names[i]) continue;
      var page = this.getPageByName(names[i]);
      if (page) result.push(page);
    }
    return result;
  }
  /**
   * Returns a list of all [questions](https://surveyjs.io/form-library/documentation/api-reference/question) in the survey.
   * @param visibleOnly A Boolean value that specifies whether to include only visible questions.
   * @param includeDesignTime For internal use.
   * @param includeNested A Boolean value that specifies whether to include nested questions, such as questions within matrix cells.
   * @returns An array of questions.
   * @see getQuestionByName
   */
  getAllQuestions(visibleOnly = false, includeDesignTime = false, includeNested = false) {
    if (includeNested) includeDesignTime = false;
    var res = [];
    for (var i = 0; i < this.pages.length; i++) {
      this.pages[i].addQuestionsToList(res, visibleOnly, includeDesignTime);
    }
    if (!includeNested) return res;
    const res2 = [];
    res.forEach((q) => {
      res2.push(q);
      q.getNestedQuestions(visibleOnly).forEach((nQ) => res2.push(nQ));
    });
    return res2;
  }
  /**
   * Returns an array of quiz questions. A question counts if it is visible, has an input field, and specifies [`correctAnswer`](https://surveyjs.io/form-library/documentation/api-reference/checkbox-question-model#correctAnswer).
   *
   * For more information about quizzes, refer to the following tutorial: [Create a Quiz](https://surveyjs.io/form-library/documentation/design-survey/create-a-quiz).
   * @returns An array of quiz questions.
   * @see getQuizQuestionCount
   */
  getQuizQuestions() {
    var result = new Array();
    var startIndex = this.getPageStartIndex();
    for (var i = startIndex; i < this.pages.length; i++) {
      if (!this.pages[i].isVisible) continue;
      var questions = this.pages[i].questions;
      for (var j = 0; j < questions.length; j++) {
        var q = questions[j];
        if (q.quizQuestionCount > 0) {
          result.push(q);
        }
      }
    }
    return result;
  }
  /**
   * Returns a [panel](https://surveyjs.io/form-library/documentation/api-reference/panel-model) with a specified [`name`](https://surveyjs.io/form-library/documentation/api-reference/panel-model#name).
   * @param name A panel name.
   * @param caseInsensitive *(Optional)* A Boolean value that specifies case sensitivity when searching for the panel. Default value: `false` (uppercase and lowercase letters are treated as distinct).
   * @returns A panel with a specified name.
   * @see getAllPanels
   */
  getPanelByName(name, caseInsensitive = false) {
    var panels = this.getAllPanels();
    if (caseInsensitive) name = name.toLowerCase();
    for (var i = 0; i < panels.length; i++) {
      var panelName = panels[i].name;
      if (caseInsensitive) panelName = panelName.toLowerCase();
      if (panelName == name) return panels[i];
    }
    return null;
  }
  /**
   * Returns a list of all [panels](https://surveyjs.io/form-library/documentation/api-reference/panel-model) in the survey.
   * @param visibleOnly A Boolean value that specifies whether to include only visible panels.
   * @param includeDesignTime For internal use.
   * @returns An array of panels.
   * @see getPanelByName
   */
  getAllPanels(visibleOnly = false, includeDesignTime = false) {
    var result = new Array();
    for (var i = 0; i < this.pages.length; i++) {
      this.pages[i].addPanelsIntoList(result, visibleOnly, includeDesignTime);
    }
    return result;
  }
  /**
   * Creates and returns a new page but does not add it to the survey.
   *
   * Call the [`addPage(page)`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#addPage) method to add the created page to the survey later or the [`addNewPage(name, index)`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#addNewPage) method to create _and_ add a page to the survey.
   * @see addPage
   * @see addNewPage
   */
  createNewPage(name) {
    const page = Serializer.createClass("page");
    page.name = name;
    return page;
  }
  getValueChangeReason() {
    if (this.isSettingValueOnExpression) return "expression";
    return this.isSettingValueFromTrigger ? "trigger" : void 0;
  }
  questionOnValueChanging(valueName, newValue, questionValueName) {
    if (!!this.editingObj) {
      const prop = Serializer.findProperty(this.editingObj.getType(), valueName);
      if (!!prop) newValue = prop.settingValue(this.editingObj, newValue);
    }
    if (this.onValueChanging.isEmpty) return newValue;
    var options = {
      name: valueName,
      question: this.getQuestionByValueName(questionValueName || valueName),
      value: this.getUnbindValue(newValue),
      oldValue: this.getValue(valueName),
      reason: this.getValueChangeReason()
    };
    this.onValueChanging.fire(this, options);
    return options.value;
  }
  updateQuestionValue(valueName, newValue) {
    if (this.isLoadingFromJson) return;
    var questions = this.getQuestionsByValueName(valueName);
    if (!!questions) {
      for (var i = 0; i < questions.length; i++) {
        var qValue = questions[i].value;
        if (qValue === newValue && Array.isArray(qValue) && !!this.editingObj || !this.isTwoValueEquals(qValue, newValue)) {
          questions[i].updateValueFromSurvey(newValue, false);
        }
      }
    }
  }
  checkQuestionErrorOnValueChanged(question) {
    if (!this.isNavigationButtonPressed && (this.isValidateOnValueChanged || question.getAllErrors().length > 0)) {
      this.checkQuestionErrorOnValueChangedCore(question);
    }
  }
  checkQuestionErrorOnValueChangedCore(question) {
    var oldErrorCount = question.getAllErrors().length;
    var res = !question.validate(true, {
      isOnValueChanged: !this.isValidateOnValueChanging
    });
    if (!!question.page && this.isValidateOnValueChange && (oldErrorCount > 0 || question.getAllErrors().length > 0)) {
      this.fireValidatedErrorsOnPage(question.page);
    }
    return res;
  }
  checkErrorsOnValueChanging(valueName, newValue) {
    if (this.isLoadingFromJson) return false;
    var questions = this.getQuestionsByValueName(valueName);
    if (!questions) return false;
    var res = false;
    for (var i = 0; i < questions.length; i++) {
      var q = questions[i];
      if (!this.isTwoValueEquals(q.valueForSurvey, newValue)) {
        q.value = newValue;
      }
      if (this.checkQuestionErrorOnValueChangedCore(q)) res = true;
      res = res || q.errors.length > 0;
    }
    return res;
  }
  fireOnValueChanged(name, value, question) {
    this.onValueChanged.fire(this, {
      name,
      question,
      value,
      reason: this.getValueChangeReason()
    });
  }
  notifyQuestionOnValueChanged(valueName, newValue, questionName) {
    if (this.isLoadingFromJson) return;
    var questions = this.getQuestionsByValueName(valueName);
    if (!!questions) {
      for (var i = 0; i < questions.length; i++) {
        var question = questions[i];
        this.checkQuestionErrorOnValueChanged(question);
        question.onSurveyValueChanged(newValue);
      }
    }
    this.updateProgressText(true);
    this.fireOnValueChanged(valueName, newValue, !!questionName ? this.getQuestionByName(questionName) : void 0);
    if (this.isDisposed) return;
    this.checkElementsBindings(valueName, newValue);
    this.notifyElementsOnAnyValueOrVariableChanged(valueName, questionName);
  }
  checkElementsBindings(valueName, newValue) {
    this.isRunningElementsBindings = true;
    for (var i = 0; i < this.pages.length; i++) {
      this.pages[i].checkBindings(valueName, newValue);
    }
    this.isRunningElementsBindings = false;
    if (this.updateVisibleIndexAfterBindings) {
      this.updateVisibleIndexes();
      this.updateVisibleIndexAfterBindings = false;
    }
  }
  notifyElementsOnAnyValueOrVariableChanged(name, questionName) {
    if (this.isEndLoadingFromJson === "processing") return;
    if (this.isRunningConditions) {
      this.conditionNotifyElementsOnAnyValueOrVariableChanged = true;
      return;
    }
    for (var i = 0; i < this.pages.length; i++) {
      this.pages[i].onAnyValueChanged(name, questionName);
    }
    if (!this.isEndLoadingFromJson) {
      this.locStrsChanged();
    }
  }
  updateAllQuestionsValue(clearData) {
    var questions = this.getAllQuestions();
    for (var i = 0; i < questions.length; i++) {
      var q = questions[i];
      var valName = q.getValueName();
      q.updateValueFromSurvey(this.getValue(valName), clearData);
      if (q.requireUpdateCommentValue) {
        q.updateCommentFromSurvey(this.getComment(valName));
      }
    }
  }
  notifyAllQuestionsOnValueChanged() {
    var questions = this.getAllQuestions();
    for (var i = 0; i < questions.length; i++) {
      questions[i].onSurveyValueChanged(this.getValue(questions[i].getValueName()));
    }
  }
  checkOnPageTriggers(isOnComplete) {
    var questions = this.getCurrentPageQuestions(true);
    var values = {};
    for (var i = 0; i < questions.length; i++) {
      var question = questions[i];
      var name = question.getValueName();
      values[name] = this.getValue(name);
    }
    this.addCalculatedValuesIntoFilteredValues(values);
    this.checkTriggers(values, true, isOnComplete);
  }
  getCurrentPageQuestions(includeInvsible = false) {
    var result = [];
    var page = this.currentPage;
    if (!page) return result;
    for (var i = 0; i < page.questions.length; i++) {
      var question = page.questions[i];
      if (!includeInvsible && !question.visible || !question.name) continue;
      result.push(question);
    }
    return result;
  }
  checkTriggers(key, isOnNextPage, isOnComplete = false, isOnNavigation = false, name) {
    if (this.isCompleted || this.triggers.length == 0 || this.isDisplayMode) return;
    if (this.isTriggerIsRunning) {
      this.triggerValues = this.getFilteredValues();
      for (var k in key) {
        this.triggerKeys[k] = key[k];
      }
      return;
    }
    let isQuestionInvalid = false;
    if (!isOnComplete && name && this.hasRequiredValidQuestionTrigger) {
      const question = this.getQuestionByValueName(name);
      isQuestionInvalid = question && !question.validate(false);
    }
    this.isTriggerIsRunning = true;
    this.triggerKeys = key;
    this.triggerValues = this.getFilteredValues();
    var properties = this.getFilteredProperties();
    let prevCanBeCompleted = this.canBeCompletedByTrigger;
    for (let i = 0; i < this.triggers.length; i++) {
      const trigger = this.triggers[i];
      if (isQuestionInvalid && trigger.requireValidQuestion) continue;
      const options = {
        isOnNextPage,
        isOnComplete,
        isOnNavigation,
        keys: this.triggerKeys,
        values: this.triggerValues,
        properties
      };
      trigger.checkExpression(options);
    }
    if (prevCanBeCompleted !== this.canBeCompletedByTrigger) {
      this.updateButtonsVisibility();
    }
    this.isTriggerIsRunning = false;
  }
  checkTriggersAndRunConditions(name, newValue, oldValue) {
    var triggerKeys = {};
    triggerKeys[name] = {
      newValue,
      oldValue
    };
    this.runConditionOnValueChanged(name, newValue);
    this.checkTriggers(triggerKeys, false, false, false, name);
  }
  get hasRequiredValidQuestionTrigger() {
    for (let i = 0; i < this.triggers.length; i++) {
      if (this.triggers[i].requireValidQuestion) return true;
    }
    return false;
  }
  doElementsOnLoad() {
    for (var i = 0; i < this.pages.length; i++) {
      this.pages[i].onSurveyLoad();
    }
  }
  get isRunningConditions() {
    return !!this.conditionValues;
  }
  /**
   * Recalculates all [expressions](https://surveyjs.io/form-library/documentation/design-survey/conditional-logic#expressions) in the survey.
   */
  runExpressions() {
    this.runConditions();
  }
  runConditions() {
    if (this.isCompleted || this.isEndLoadingFromJson === "processing" || this.isRunningConditions) return;
    this.conditionValues = this.getFilteredValues();
    var properties = this.getFilteredProperties();
    var oldCurrentPageIndex = this.pages.indexOf(this.currentPage);
    this.runConditionsCore(properties);
    this.checkIfNewPagesBecomeVisible(oldCurrentPageIndex);
    this.conditionValues = null;
    if (this.isValueChangedOnRunningCondition && this.conditionRunnerCounter < settings.maxConditionRunCountOnValueChanged) {
      this.isValueChangedOnRunningCondition = false;
      this.conditionRunnerCounter++;
      this.runConditions();
    } else {
      this.isValueChangedOnRunningCondition = false;
      this.conditionRunnerCounter = 0;
      if (this.conditionUpdateVisibleIndexes) {
        this.conditionUpdateVisibleIndexes = false;
        this.updateVisibleIndexes();
      }
      if (this.conditionNotifyElementsOnAnyValueOrVariableChanged) {
        this.conditionNotifyElementsOnAnyValueOrVariableChanged = false;
        this.notifyElementsOnAnyValueOrVariableChanged("");
      }
    }
  }
  runConditionOnValueChanged(name, value) {
    if (this.isRunningConditions) {
      this.conditionValues[name] = value;
      if (this.questionTriggersKeys) {
        this.questionTriggersKeys[name] = value;
      }
      this.isValueChangedOnRunningCondition = true;
    } else {
      this.questionTriggersKeys = {};
      this.questionTriggersKeys[name] = value;
      this.runConditions();
      this.runQuestionsTriggers(name, value);
      this.questionTriggersKeys = void 0;
    }
  }
  runConditionsCore(properties) {
    var pages = this.pages;
    for (var i = 0; i < this.calculatedValues.length; i++) {
      this.calculatedValues[i].resetCalculation();
    }
    for (var i = 0; i < this.calculatedValues.length; i++) {
      this.calculatedValues[i].doCalculation(this.calculatedValues, this.conditionValues, properties);
    }
    super.runConditionCore(this.conditionValues, properties);
    for (let i2 = 0; i2 < pages.length; i2++) {
      pages[i2].runCondition(this.conditionValues, properties);
    }
  }
  runQuestionsTriggers(name, value) {
    if (this.isDisplayMode || this.isDesignMode) return;
    const questions = this.getAllQuestions();
    questions.forEach((q) => {
      q.runTriggers(name, value, this.questionTriggersKeys);
    });
  }
  checkIfNewPagesBecomeVisible(oldCurrentPageIndex) {
    var newCurrentPageIndex = this.pages.indexOf(this.currentPage);
    if (newCurrentPageIndex <= oldCurrentPageIndex + 1) return;
    for (var i = oldCurrentPageIndex + 1; i < newCurrentPageIndex; i++) {
      if (this.pages[i].isVisible) {
        this.currentPage = this.pages[i];
        break;
      }
    }
  }
  /**
   * @deprecated Self-hosted Form Library [no longer supports integration with SurveyJS Demo Service](https://surveyjs.io/stay-updated/release-notes/v2.0.0#form-library-removes-apis-for-integration-with-surveyjs-demo-service).
   */
  sendResult(postId = null, clientId = null, isPartial = false) {
    if (!this.isEditMode) return;
    if (isPartial && this.onPartialSend) {
      this.onPartialSend.fire(this, null);
    }
    if (!postId && this.surveyPostId) {
      postId = this.surveyPostId;
    }
    if (!postId) return;
    if (clientId) {
      this.clientId = clientId;
    }
    if (isPartial && !this.clientId) return;
    this.reportWarningOnUsingService();
  }
  /**
   * @deprecated Self-hosted Form Library [no longer supports integration with SurveyJS Demo Service](https://surveyjs.io/stay-updated/release-notes/v2.0.0#form-library-removes-apis-for-integration-with-surveyjs-demo-service).
   */
  getResult(resultId, questionName) {
    this.reportWarningOnUsingService();
  }
  /**
   * @deprecated Self-hosted Form Library [no longer supports integration with SurveyJS Demo Service](https://surveyjs.io/stay-updated/release-notes/v2.0.0#form-library-removes-apis-for-integration-with-surveyjs-demo-service).
   */
  loadSurveyFromService(surveyId = null, clientId = null) {
    if (surveyId) {
      this.surveyId = surveyId;
    }
    if (clientId) {
      this.clientId = clientId;
    }
    this.reportWarningOnUsingService();
  }
  reportWarningOnUsingService() {
    ConsoleWarnings.warn("Self-hosted Form Library no longer supports integration with SurveyJS Demo Service. Learn more: https://surveyjs.io/stay-updated/release-notes/v2.0.0#form-library-removes-apis-for-integration-with-surveyjs-demo-service");
  }
  loadSurveyFromServiceJson(json2) {
    if (!json2) return;
    this.fromJSON(json2);
    this.notifyAllQuestionsOnValueChanged();
    this.onLoadSurveyFromService();
    this.onLoadedSurveyFromService.fire(this, {});
  }
  onLoadingSurveyFromService() {
  }
  onLoadSurveyFromService() {
  }
  resetVisibleIndexes() {
    var questions = this.getAllQuestions(true);
    for (var i = 0; i < questions.length; i++) {
      questions[i].setVisibleIndex(-1);
    }
    this.updateVisibleIndexes();
  }
  updateVisibleIndexes(page) {
    if (this.isLoadingFromJson || !!this.isEndLoadingFromJson) return;
    if (this.isRunningConditions && this.onQuestionVisibleChanged.isEmpty && this.onPageVisibleChanged.isEmpty) {
      this.conditionUpdateVisibleIndexes = true;
      return;
    }
    if (this.isRunningElementsBindings) {
      this.updateVisibleIndexAfterBindings = true;
      return;
    }
    this.updatePageVisibleIndexes();
    this.updatePageElementsVisibleIndexes(page);
    this.updateProgressText(true);
  }
  updatePageElementsVisibleIndexes(page) {
    if (this.showQuestionNumbers == "onPage") {
      var visPages = !!page ? [page] : this.visiblePages;
      for (var i = 0; i < visPages.length; i++) {
        visPages[i].setVisibleIndex(0);
      }
    } else {
      let index = this.getStartVisibleIndex();
      const pages = this.pages;
      for (let i2 = 0; i2 < pages.length; i2++) {
        index += pages[i2].setVisibleIndex(index);
      }
    }
  }
  getStartVisibleIndex() {
    return this.showQuestionNumbers == "on" ? 0 : -1;
  }
  updatePageVisibleIndexes() {
    this.updateButtonsVisibility();
    var index = 0;
    for (var i = 0; i < this.pages.length; i++) {
      const page = this.pages[i];
      const isPageVisible = page.isVisible && (i > 0 || !page.isStartPage);
      page.visibleIndex = isPageVisible ? index++ : -1;
      page.num = isPageVisible ? page.visibleIndex + 1 : -1;
    }
  }
  fromJSON(json2, options) {
    if (!json2) return;
    this.questionHashesClear();
    this.jsonErrors = null;
    this.sjsVersion = void 0;
    const jsonConverter = new JsonObject();
    jsonConverter.toObject(json2, this, options);
    if (jsonConverter.errors.length > 0) {
      this.jsonErrors = jsonConverter.errors;
    }
    this.onStateAndCurrentPageChanged();
    this.endLoading();
    this.updateState();
    if (!!this.sjsVersion && !!settings.version) {
      if (Helpers.compareVerions(this.sjsVersion, settings.version) > 0) {
        ConsoleWarnings.warn("The version of the survey JSON schema (v" + this.sjsVersion + ") is newer than your current Form Library version (" + settings.version + "). Please update the Form Library to make sure that all survey features work as expected.");
      }
    }
  }
  startLoadingFromJson(json2) {
    super.startLoadingFromJson(json2);
    if (json2 && json2.locale) {
      this.locale = json2.locale;
    }
  }
  setJsonObject(jsonObj) {
    this.fromJSON(jsonObj);
  }
  endLoadingFromJson() {
    this.isEndLoadingFromJson = "processing";
    this.onFirstPageIsStartedChanged();
    super.endLoadingFromJson();
    if (this.hasCookie) {
      this.isCompletedBefore = true;
    }
    this.doElementsOnLoad();
    this.onQuestionsOnPageModeChanged("standard");
    this.isEndLoadingFromJson = "conditions";
    this.runConditions();
    this.notifyElementsOnAnyValueOrVariableChanged("");
    this.isEndLoadingFromJson = null;
    this.updateVisibleIndexes();
    this.updateCurrentPage();
    this.setCalculatedWidthModeUpdater();
  }
  updateNavigationCss() {
    const val = this.navigationBarValue;
    if (!!val) {
      val.cssClasses = this.css.actionBar;
      val.containerCss = this.css.footer;
      !!this.updateNavigationItemCssCallback && this.updateNavigationItemCssCallback();
    }
  }
  createNavigationBar() {
    const res = new ActionContainer();
    res.setItems(this.createNavigationActions());
    res.locOwner = this;
    return res;
  }
  createNavigationActions() {
    const defaultComponent = "sv-nav-btn";
    const navStart = new Action({
      id: "sv-nav-start",
      visible: new ComputedUpdater(() => this.isStartPageActive),
      visibleIndex: 10,
      locTitle: this.locStartSurveyText,
      action: () => this.start(),
      component: defaultComponent
    });
    const navPrev = new Action({
      id: "sv-nav-prev",
      visible: new ComputedUpdater(() => this.isShowPrevButton),
      visibleIndex: 20,
      data: {
        mouseDown: () => this.navigationMouseDown()
      },
      locTitle: this.locPagePrevText,
      action: () => this.performPrevious(),
      component: defaultComponent
    });
    const navNext = new Action({
      id: "sv-nav-next",
      visible: new ComputedUpdater(() => this.isShowNextButton),
      visibleIndex: 30,
      data: {
        mouseDown: () => this.nextPageMouseDown()
      },
      locTitle: this.locPageNextText,
      action: () => this.nextPageUIClick(),
      component: defaultComponent
    });
    const navPreview = new Action({
      id: "sv-nav-preview",
      visible: new ComputedUpdater(() => this.isPreviewButtonVisible),
      visibleIndex: 40,
      data: {
        mouseDown: () => this.navigationMouseDown()
      },
      locTitle: this.locPreviewText,
      action: () => this.showPreview(),
      component: defaultComponent
    });
    const navComplete = new Action({
      id: "sv-nav-complete",
      visible: new ComputedUpdater(() => this.isCompleteButtonVisible),
      visibleIndex: 50,
      data: {
        mouseDown: () => this.navigationMouseDown()
      },
      locTitle: this.locCompleteText,
      action: () => this.taskManager.waitAndExecute(() => this.tryComplete()),
      component: defaultComponent
    });
    this.updateNavigationItemCssCallback = () => {
      navStart.innerCss = this.cssNavigationStart;
      navPrev.innerCss = this.cssNavigationPrev;
      navNext.innerCss = this.cssNavigationNext;
      navPreview.innerCss = this.cssNavigationPreview;
      navComplete.innerCss = this.cssNavigationComplete;
    };
    return [navStart, navPrev, navNext, navPreview, navComplete];
  }
  onBeforeRunConstructor() {
  }
  onBeforeCreating() {
  }
  onCreating() {
  }
  getProcessedTextValue(textValue) {
    this.getProcessedTextValueCore(textValue);
    if (!this.onProcessDynamicText.isEmpty) {
      var wasEmpty = this.isValueEmpty(textValue.value);
      this.onProcessDynamicText.fire(this, textValue);
      textValue.isExists = textValue.isExists || wasEmpty && !this.isValueEmpty(textValue.value);
    }
  }
  getBuiltInVariableValue(name) {
    if (name === "pageno") {
      var page = this.currentPage;
      return page != null ? this.visiblePages.indexOf(page) + 1 : 0;
    }
    if (name === "pagecount") {
      return this.visiblePageCount;
    }
    if (name === "correctedanswers" || name === "correctanswers" || name === "correctedanswercount") {
      return this.getCorrectedAnswerCount();
    }
    if (name === "incorrectedanswers" || name === "incorrectanswers" || name === "incorrectedanswercount") {
      return this.getInCorrectedAnswerCount();
    }
    if (name === "questioncount") {
      return this.getQuizQuestionCount();
    }
    return void 0;
  }
  getProcessedTextValueCore(textValue) {
    var name = textValue.name.toLocaleLowerCase();
    if (["no", "require", "title"].indexOf(name) !== -1) {
      return;
    }
    const builtInVar = this.getBuiltInVariableValue(name);
    if (builtInVar !== void 0) {
      textValue.isExists = true;
      textValue.value = builtInVar;
      return;
    }
    if (name === "locale") {
      textValue.isExists = true;
      textValue.value = !!this.locale ? this.locale : surveyLocalization.defaultLocale;
      return;
    }
    var variable = this.getVariable(name);
    if (variable !== void 0) {
      textValue.isExists = true;
      textValue.value = variable;
      return;
    }
    var question = this.getFirstName(name);
    if (question) {
      const questionUseDisplayText = question.useDisplayValuesInDynamicTexts;
      textValue.isExists = true;
      const firstName = question.getValueName().toLowerCase();
      name = firstName + name.substring(firstName.length);
      name = name.toLocaleLowerCase();
      var values = {};
      values[firstName] = textValue.returnDisplayValue && questionUseDisplayText ? question.getDisplayValue(false, void 0) : question.value;
      textValue.value = new ProcessValue().getValue(name, values);
      return;
    }
    this.getProcessedValuesWithoutQuestion(textValue);
  }
  getProcessedValuesWithoutQuestion(textValue) {
    var value = this.getValue(textValue.name);
    if (value !== void 0) {
      textValue.isExists = true;
      textValue.value = value;
      return;
    }
    const processor = new ProcessValue();
    const firstName = processor.getFirstName(textValue.name);
    if (firstName === textValue.name) return;
    const data = {};
    let val = this.getValue(firstName);
    if (Helpers.isValueEmpty(val)) {
      val = this.getVariable(firstName);
    }
    if (Helpers.isValueEmpty(val)) return;
    data[firstName] = val;
    textValue.value = processor.getValue(textValue.name, data);
    textValue.isExists = processor.hasValue(textValue.name, data);
  }
  getFirstName(name) {
    name = name.toLowerCase();
    var question;
    do {
      question = this.getQuestionByValueName(name, true);
      name = this.reduceFirstName(name);
    } while (!question && !!name);
    return question;
  }
  reduceFirstName(name) {
    var pos1 = name.lastIndexOf(".");
    var pos2 = name.lastIndexOf("[");
    if (pos1 < 0 && pos2 < 0) return "";
    var pos = Math.max(pos1, pos2);
    return name.substring(0, pos);
  }
  clearUnusedValues() {
    this.isClearingUnsedValues = true;
    var questions = this.getAllQuestions();
    for (var i = 0; i < questions.length; i++) {
      questions[i].clearUnusedValues();
    }
    this.clearInvisibleQuestionValues();
    this.isClearingUnsedValues = false;
  }
  hasVisibleQuestionByValueName(valueName) {
    var questions = this.getQuestionsByValueName(valueName);
    if (!questions) return false;
    for (var i = 0; i < questions.length; i++) {
      const q = questions[i];
      if (q.isVisible && q.isParentVisible && !q.parentQuestion) return true;
    }
    return false;
  }
  questionsByValueName(valueName) {
    var questions = this.getQuestionsByValueName(valueName);
    return !!questions ? questions : [];
  }
  clearInvisibleQuestionValues() {
    const reason = this.clearInvisibleValues === "none" ? "none" : "onComplete";
    const questions = this.getAllQuestions();
    for (var i = 0; i < questions.length; i++) {
      questions[i].clearValueIfInvisible(reason);
    }
  }
  /**
   * Returns a variable value.
   *
   * [Variables help topic](https://surveyjs.io/form-library/documentation/design-survey/conditional-logic#variables (linkStyle))
   * @param name A variable name.
   * @return A variable value.
   * @see setVariable
   * @see getVariableNames
   */
  getVariable(name) {
    if (!name) return null;
    name = name.toLowerCase();
    var res = this.variablesHash[name];
    if (!this.isValueEmpty(res)) return res;
    if (name.indexOf(".") > -1 || name.indexOf("[") > -1) {
      if (new ProcessValue().hasValue(name, this.variablesHash)) return new ProcessValue().getValue(name, this.variablesHash);
    }
    return res;
  }
  /**
   * Sets a variable value.
   *
   * [Variables help topic](https://surveyjs.io/form-library/documentation/design-survey/conditional-logic#variables (linkStyle))
   * @param name A variable name.
   * @param newValue A new variable value.
   * @see getVariable
   * @see getVariableNames
   */
  setVariable(name, newValue) {
    if (!name) return;
    const oldValue = this.getVariable(name);
    if (!!this.valuesHash) {
      delete this.valuesHash[name];
    }
    name = name.toLowerCase();
    this.variablesHash[name] = newValue;
    this.notifyElementsOnAnyValueOrVariableChanged(name);
    if (!Helpers.isTwoValueEquals(oldValue, newValue)) {
      this.checkTriggersAndRunConditions(name, newValue, oldValue);
      this.onVariableChanged.fire(this, {
        name,
        value: newValue
      });
    }
  }
  /**
   * Returns the names of all variables in the survey.
   *
   * [Variables help topic](https://surveyjs.io/form-library/documentation/design-survey/conditional-logic#variables (linkStyle))
   * @returns An array of variable names.
   * @see getVariable
   * @see setVariable
   */
  getVariableNames() {
    var res = [];
    for (var key in this.variablesHash) {
      res.push(key);
    }
    return res;
  }
  //ISurvey data
  getUnbindValue(value) {
    if (!!this.editingObj) return value;
    return Helpers.getUnbindValue(value);
  }
  /**
   * Returns a value (answer) for a question with a specified `name`.
   * @param name A question name.
   * @returns A question value (answer).
   * @see data
   * @see setValue
   */
  getValue(name) {
    if (!name || name.length == 0) return null;
    var value = this.getDataValueCore(this.valuesHash, name);
    return this.getUnbindValue(value);
  }
  /**
   * Sets a question value (answer).
   *
   * > This method executes all triggers and reevaluates conditions (`visibleIf`, `requiredId`, and others). It also switches the survey to the next page if the [`autoAdvanceEnabled`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#autoAdvanceEnabled) property is enabled and all questions on the current page have correct answers.
   * @param name A question name.
   * @param newValue A new question value.
   * @param locNotification For internal use.
   * @param allowNotifyValueChanged For internal use.
   * @see data
   * @see getValue
   */
  setValue(name, newQuestionValue, locNotification = false, allowNotifyValueChanged = true, questionName) {
    var newValue = newQuestionValue;
    if (allowNotifyValueChanged) {
      newValue = this.questionOnValueChanging(name, newQuestionValue);
    }
    if (this.isValidateOnValueChanging && this.checkErrorsOnValueChanging(name, newValue)) return;
    if (!this.editingObj && this.isValueEqual(name, newValue) && this.isTwoValueEquals(newValue, newQuestionValue)) return;
    var oldValue = this.getValue(name);
    if (this.isValueEmpyOnSetValue(name, newValue)) {
      this.deleteDataValueCore(this.valuesHash, name);
    } else {
      newValue = this.getUnbindValue(newValue);
      this.setDataValueCore(this.valuesHash, name, newValue);
    }
    this.updateOnSetValue(name, newValue, oldValue, locNotification, allowNotifyValueChanged, questionName);
  }
  isValueEmpyOnSetValue(name, val) {
    if (!this.isValueEmpty(val, false)) return false;
    if (!this.editingObj || val === null || val === void 0) return true;
    return this.editingObj.getDefaultPropertyValue(name) === val;
  }
  updateOnSetValue(name, newValue, oldValue, locNotification = false, allowNotifyValueChanged = true, questionName) {
    this.updateQuestionValue(name, newValue);
    if (locNotification === true || this.isDisposed || this.isRunningElementsBindings) return;
    questionName = questionName || name;
    this.checkTriggersAndRunConditions(name, newValue, oldValue);
    if (allowNotifyValueChanged) {
      this.notifyQuestionOnValueChanged(name, newValue, questionName);
    }
    if (locNotification !== "text") {
      this.tryGoNextPageAutomatic(name);
    }
  }
  isValueEqual(name, newValue) {
    if (newValue === "" || newValue === void 0) newValue = null;
    var oldValue = this.getValue(name);
    if (oldValue === "" || oldValue === void 0) oldValue = null;
    if (newValue === null || oldValue === null) return newValue === oldValue;
    return this.isTwoValueEquals(newValue, oldValue);
  }
  doOnPageAdded(page) {
    page.setSurveyImpl(this);
    if (!page.name) page.name = this.generateNewName(this.pages, "page");
    this.questionHashesPanelAdded(page);
    this.updateVisibleIndexes();
    if (!!this.runningPages) return;
    if (!this.isLoadingFromJson) {
      this.updateProgressText();
      this.updateCurrentPage();
    }
    if (this.canFireAddPage()) {
      var options = {
        page
      };
      this.onPageAdded.fire(this, options);
    }
  }
  canFireAddPage() {
    return !this.isMovingPage;
  }
  doOnPageRemoved(page) {
    page.setSurveyImpl(null);
    if (!!this.runningPages) return;
    if (page === this.currentPage) {
      this.updateCurrentPage();
    }
    this.updateVisibleIndexes();
    this.updateProgressText();
    this.updateLazyRenderingRowsOnRemovingElements();
  }
  generateNewName(elements, baseName) {
    var keys = {};
    for (var i = 0; i < elements.length; i++) keys[elements[i]["name"]] = true;
    var index = 1;
    while (keys[baseName + index]) index++;
    return baseName + index;
  }
  tryGoNextPageAutomatic(name) {
    if (!!this.isEndLoadingFromJson || !this.autoAdvanceEnabled || !this.currentPage) return;
    const question = this.getQuestionByValueName(name);
    if (!question || !!question && (!question.visible || !question.supportAutoAdvance())) return;
    if (!question.validate(false) && !question.supportGoNextPageError()) return;
    if (!!this.currentSingleQuestion) {
      const curQuestion = this.currentSingleQuestion;
      const goNextQuestion = () => {
        if (curQuestion !== this.currentSingleQuestion) return;
        if (!this.isLastElement) {
          this.performNext();
        } else {
          if (this.autoAdvanceAllowComplete) {
            this.tryCompleteOrShowPreview();
          }
        }
      };
      surveyTimerFunctions.safeTimeOut(goNextQuestion, settings.autoAdvanceDelay);
    }
    var questions = this.getCurrentPageQuestions();
    if (questions.indexOf(question) < 0) return;
    for (var i = 0; i < questions.length; i++) {
      if (questions[i].hasInput && questions[i].isEmpty()) return;
    }
    if (this.isLastPage && (this.autoAdvanceEnabled !== true || !this.autoAdvanceAllowComplete)) return;
    if (this.checkIsCurrentPageHasErrors(false)) return;
    const curPage = this.currentPage;
    const goNextPage = () => {
      if (curPage !== this.currentPage) return;
      if (!this.isLastPage) {
        this.nextPage();
      } else {
        this.tryCompleteOrShowPreview();
      }
    };
    surveyTimerFunctions.safeTimeOut(goNextPage, settings.autoAdvanceDelay);
  }
  tryCompleteOrShowPreview() {
    if (this.showPreviewBeforeComplete) {
      this.showPreview();
    } else {
      this.tryComplete();
    }
  }
  /**
   * Returns a comment value from a question with a specified `name`.
   * @param name A question name.
   * @returns A comment.
   * @see setComment
   */
  getComment(name) {
    const res = this.getValue(name + this.commentSuffix);
    return res || "";
  }
  /**
   * Sets a comment value to a question with a specified `name`.
   * @param name A question name.
   * @param newValue A new comment value.
   * @param locNotification For internal use.
   * @see getComment
   */
  setComment(name, newValue, locNotification = false) {
    if (!newValue) newValue = "";
    if (this.isTwoValueEquals(newValue, this.getComment(name))) return;
    const commentName = name + this.commentSuffix;
    newValue = this.questionOnValueChanging(commentName, newValue, name);
    if (this.isValueEmpty(newValue)) {
      this.deleteDataValueCore(this.valuesHash, commentName);
    } else {
      this.setDataValueCore(this.valuesHash, commentName, newValue);
    }
    var questions = this.getQuestionsByValueName(name);
    if (!!questions) {
      for (var i = 0; i < questions.length; i++) {
        questions[i].updateCommentFromSurvey(newValue);
        this.checkQuestionErrorOnValueChanged(questions[i]);
      }
    }
    if (!locNotification) {
      this.checkTriggersAndRunConditions(name, this.getValue(name), void 0);
    }
    if (locNotification !== "text") {
      this.tryGoNextPageAutomatic(name);
    }
    var question = this.getQuestionByValueName(name);
    if (question) {
      this.fireOnValueChanged(commentName, newValue, question);
      question.comment = newValue;
      if (question.comment != newValue) {
        question.comment = newValue;
      }
    }
  }
  /**
   * Deletes an answer from survey results.
   * @param {string} name An object property that stores the answer to delete. Pass a question's [`valueName`](https://surveyjs.io/form-library/documentation/api-reference/question#valueName) or [`name`](https://surveyjs.io/form-library/documentation/api-reference/question#name).
   */
  clearValue(name) {
    this.setValue(name, null);
    this.setComment(name, null);
  }
  /**
   * Specifies whether to remove disabled choices from the value in [Dropdown](https://surveyjs.io/form-library/documentation/api-reference/dropdown-menu-model), [Checkboxes](https://surveyjs.io/form-library/documentation/api-reference/checkbox-question-model), and [Radio Button Group](https://surveyjs.io/form-library/documentation/api-reference/radio-button-question-model) questions.
   *
   * Default value: `false`
   *
   * > This property cannot be specified in the survey JSON schema. Use dot notation to specify it.
   */
  get clearDisabledChoices() {
    return this.getPropertyValue("clearDisabledChoices", false);
  }
  set clearDisabledChoices(val) {
    this.setPropertyValue("clearDisabledChoices", val);
  }
  /**
   * @deprecated Use the [`clearDisabledChoices`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#clearDisabledChoices) property instead.
   */
  get clearValueOnDisableItems() {
    return this.clearDisabledChoices;
  }
  set clearValueOnDisableItems(val) {
    this.clearDisabledChoices = val;
  }
  getQuestionClearIfInvisible(questionClearIf) {
    if (this.isShowingPreview || this.runningPages) return "none";
    if (questionClearIf !== "default") return questionClearIf;
    return this.clearInvisibleValues;
  }
  questionVisibilityChanged(question, newValue, resetIndexes) {
    if (resetIndexes) {
      this.updateVisibleIndexes(question.page);
    }
    this.onQuestionVisibleChanged.fire(this, {
      question,
      name: question.name,
      visible: newValue
    });
  }
  pageVisibilityChanged(page, newValue) {
    if (this.isLoadingFromJson) return;
    if (newValue && !this.currentPage || page === this.currentPage) {
      this.updateCurrentPage();
    }
    this.updateVisibleIndexes();
    this.onPageVisibleChanged.fire(this, {
      page,
      visible: newValue
    });
  }
  panelVisibilityChanged(panel, newValue) {
    this.updateVisibleIndexes(panel.page);
    this.onPanelVisibleChanged.fire(this, {
      panel,
      visible: newValue
    });
  }
  questionCreated(question) {
    this.onQuestionCreated.fire(this, {
      question
    });
  }
  questionAdded(question, index, parentPanel, rootPanel) {
    if (!question.name) {
      question.name = this.generateNewName(this.getAllQuestions(false, true), "question");
    }
    if (!!question.page) {
      this.questionHashesAdded(question);
    }
    if (!this.isLoadingFromJson) {
      if (!this.currentPage) {
        this.updateCurrentPage();
      }
      this.updateVisibleIndexes(question.page);
      this.setCalculatedWidthModeUpdater();
    }
    if (this.canFireAddElement()) {
      this.onQuestionAdded.fire(this, {
        question,
        name: question.name,
        index,
        parent: parentPanel,
        page: rootPanel,
        parentPanel,
        rootPanel
      });
    }
  }
  canFireAddElement() {
    return !this.isMovingQuestion;
  }
  questionRemoved(question) {
    this.questionHashesRemoved(question, question.name, question.getValueName());
    this.updateVisibleIndexes(question.page);
    this.onQuestionRemoved.fire(this, {
      question,
      name: question.name
    });
    this.updateLazyRenderingRowsOnRemovingElements();
  }
  questionRenamed(question, oldName, oldValueName) {
    this.questionHashesRemoved(question, oldName, oldValueName);
    this.questionHashesAdded(question);
  }
  questionHashesClear() {
    this.questionHashes.names = {};
    this.questionHashes.namesInsensitive = {};
    this.questionHashes.valueNames = {};
    this.questionHashes.valueNamesInsensitive = {};
  }
  questionHashesPanelAdded(panel) {
    if (this.isLoadingFromJson) return;
    var questions = panel.questions;
    for (var i = 0; i < questions.length; i++) {
      this.questionHashesAdded(questions[i]);
    }
  }
  questionHashesAdded(question) {
    this.questionHashAddedCore(this.questionHashes.names, question, question.name);
    this.questionHashAddedCore(this.questionHashes.namesInsensitive, question, question.name.toLowerCase());
    this.questionHashAddedCore(this.questionHashes.valueNames, question, question.getValueName());
    this.questionHashAddedCore(this.questionHashes.valueNamesInsensitive, question, question.getValueName().toLowerCase());
  }
  questionHashesRemoved(question, name, valueName) {
    if (!!name) {
      this.questionHashRemovedCore(this.questionHashes.names, question, name);
      this.questionHashRemovedCore(this.questionHashes.namesInsensitive, question, name.toLowerCase());
    }
    if (!!valueName) {
      this.questionHashRemovedCore(this.questionHashes.valueNames, question, valueName);
      this.questionHashRemovedCore(this.questionHashes.valueNamesInsensitive, question, valueName.toLowerCase());
    }
  }
  questionHashAddedCore(hash, question, name) {
    var res = hash[name];
    if (!!res) {
      var res = hash[name];
      if (res.indexOf(question) < 0) {
        res.push(question);
      }
    } else {
      hash[name] = [question];
    }
  }
  questionHashRemovedCore(hash, question, name) {
    var res = hash[name];
    if (!res) return;
    var index = res.indexOf(question);
    if (index > -1) {
      res.splice(index, 1);
    }
    if (res.length == 0) {
      delete hash[name];
    }
  }
  panelAdded(panel, index, parentPanel, rootPanel) {
    if (!panel.name) {
      panel.name = this.generateNewName(this.getAllPanels(false, true), "panel");
    }
    this.questionHashesPanelAdded(panel);
    this.updateVisibleIndexes(panel.page);
    if (this.canFireAddElement()) {
      this.onPanelAdded.fire(this, {
        panel,
        name: panel.name,
        index,
        parent: parentPanel,
        page: rootPanel,
        parentPanel,
        rootPanel
      });
    }
  }
  panelRemoved(panel) {
    this.updateVisibleIndexes(panel.page);
    this.onPanelRemoved.fire(this, {
      panel,
      name: panel.name
    });
    this.updateLazyRenderingRowsOnRemovingElements();
  }
  validateQuestion(question, errors, fireCallback) {
    if (!this.onValidateQuestion.isEmpty) {
      var options = {
        name: question.name,
        question,
        value: question.value,
        errors,
        error: null
      };
      this.onValidateQuestion.fire(this, options);
      if (options.error) {
        errors.push(new CustomError(options.error, this));
      }
    }
    if (fireCallback) {
      this.beforeSettingQuestionErrors(question, errors);
    }
  }
  validatePanel(panel, errors, fireCallback) {
    if (panel.isPanel && !this.onValidatePanel.isEmpty) {
      const options = {
        name: panel.name,
        panel,
        error: null,
        errors
      };
      this.onValidatePanel.fire(this, options);
      if (options.error) {
        errors.push(new CustomError(options.error, this));
      }
    }
    if (fireCallback) {
      this.makeRequiredErrorsInvisible(errors);
    }
  }
  processHtml(html, reason) {
    if (!reason) reason = "";
    var options = {
      html,
      reason
    };
    this.onProcessHtml.fire(this, options);
    return this.processText(options.html, true);
  }
  processText(text, returnDisplayValue) {
    return this.processTextEx({
      text,
      returnDisplayValue,
      doEncoding: false
    }).text;
  }
  processTextEx(params) {
    const doEncoding = params.doEncoding === void 0 ? settings.web.encodeUrlParams : params.doEncoding;
    let text = params.text;
    if (params.runAtDesign || !this.isDesignMode) {
      text = this.textPreProcessor.process(text, params.returnDisplayValue === true, doEncoding, params.replaceUndefinedValues);
    }
    const res = {
      text,
      hasAllValuesOnLastRun: true
    };
    res.hasAllValuesOnLastRun = this.textPreProcessor.hasAllValuesOnLastRun;
    return res;
  }
  get textPreProcessor() {
    if (!this.textPreProcessorValue) {
      this.textPreProcessorValue = new TextPreProcessor();
      this.textPreProcessorValue.onProcess = (textValue) => {
        this.getProcessedTextValue(textValue);
      };
    }
    return this.textPreProcessorValue;
  }
  getSurveyMarkdownHtml(element, text, name) {
    const options = {
      element,
      text,
      name,
      html: null
    };
    this.onTextMarkdown.fire(this, options);
    return options.html;
  }
  getCorrectedAnswerCount() {
    return this.getCorrectAnswerCount();
  }
  /**
   * Returns the number of correct answers in a quiz.
   *
   * For more information about quizzes, refer to the following tutorial: [Create a Quiz](https://surveyjs.io/form-library/documentation/design-survey/create-a-quiz).
   * @returns The number of correct answers in a quiz.
   * @see getQuizQuestionCount
   * @see getIncorrectAnswerCount
   */
  getCorrectAnswerCount() {
    return this.getCorrectedAnswerCountCore(true);
  }
  /**
   * Returns the number of quiz questions. A question counts if it is visible, has an input field, and specifies [`correctAnswer`](https://surveyjs.io/form-library/documentation/api-reference/checkbox-question-model#correctAnswer).
   *
   * This number may be different from `getQuizQuestions().length` because certain question types (for instance, matrix-like types) include more than one question.
   *
   * For more information about quizzes, refer to the following tutorial: [Create a Quiz](https://surveyjs.io/form-library/documentation/design-survey/create-a-quiz).
   * @returns The number of quiz questions.
   * @see getQuizQuestions
   */
  getQuizQuestionCount() {
    var questions = this.getQuizQuestions();
    var res = 0;
    for (var i = 0; i < questions.length; i++) {
      res += questions[i].quizQuestionCount;
    }
    return res;
  }
  getInCorrectedAnswerCount() {
    return this.getIncorrectAnswerCount();
  }
  getInCorrectAnswerCount() {
    return this.getIncorrectAnswerCount();
  }
  /**
   * Returns the number of incorrect answers in a quiz.
   *
   * For more information about quizzes, refer to the following tutorial: [Create a Quiz](https://surveyjs.io/form-library/documentation/design-survey/create-a-quiz).
   * @returns The number of incorrect answers in a quiz.
   * @see getCorrectAnswerCount
   */
  getIncorrectAnswerCount() {
    return this.getCorrectedAnswerCountCore(false);
  }
  onCorrectQuestionAnswer(question, options) {
    if (this.onIsAnswerCorrect.isEmpty) return;
    options.question = question;
    this.onIsAnswerCorrect.fire(this, options);
  }
  getCorrectedAnswerCountCore(isCorrect) {
    var questions = this.getQuizQuestions();
    var counter = 0;
    for (let i = 0; i < questions.length; i++) {
      const q = questions[i];
      const correctCount = q.correctAnswerCount;
      if (isCorrect) {
        counter += correctCount;
      } else {
        counter += q.quizQuestionCount - correctCount;
      }
    }
    return counter;
  }
  getCorrectedAnswers() {
    return this.getCorrectedAnswerCount();
  }
  getInCorrectedAnswers() {
    return this.getInCorrectedAnswerCount();
  }
  /**
   * @deprecated Use the [`showTimer`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#showTimer) and [`timerLocation`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#timerLocation) properties instead.
   */
  get showTimerPanel() {
    if (!this.showTimer) return "none";
    return this.timerLocation;
  }
  set showTimerPanel(val) {
    this.showTimer = val !== "none";
    if (this.showTimer) {
      this.timerLocation = val;
    }
  }
  /**
   * Specifies the timer's visibility. Applies only to [quiz surveys](https://surveyjs.io/form-library/documentation/design-survey-create-a-quiz).
   *
   * Default value: `false`
   *
   * If you set this property to `true`, the timer starts automatically when the survey begins. To specify time limits, use the [`timeLimit`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#timeLimit) and [`timeLimitPerPage`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#timeLimitPerPage) properties.
   *
   * The timer displays information about time spent on an individual page and the entire survey. If you want to display only the page timer or the survey timer, set the [`timerInfoMode`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#timerInfoMode) property to `"page"` or `"survey"`.
   *
   * You can enable the timer without displaying it. In this case, you need to specify the required time limits and use the [`startTimer()`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#startTimer) and [`stopTimer()`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#stopTimer) methods to control the timer.
   * @see timerLocation
   * @see timeSpent
   * @see onTimerTick
   */
  get showTimer() {
    return this.getPropertyValue("showTimer");
  }
  set showTimer(val) {
    this.setPropertyValue("showTimer", val);
  }
  /**
   * Specifies the timer's position relative to the survey. Applies only if the [`showTimer`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#showTimer) property is set to `true`.
   *
   * Possible values:
   *
   * - `"top"` (default) - Displays the timer at the top of the survey.
   * - `"bottom"` - Displays the timer at the bottom of the survey.
   * @see onTimerTick
   */
  get timerLocation() {
    return this.getPropertyValue("timerLocation");
  }
  set timerLocation(val) {
    this.setPropertyValue("timerLocation", val);
  }
  get isTimerPanelShowingOnTop() {
    return this.showTimer && this.timerLocation === "top";
  }
  get isTimerPanelShowingOnBottom() {
    return this.showTimer && this.timerLocation === "bottom";
  }
  /**
   * Specifies whether the timer panel displays timers for the current page, the entire survey, or both. Applies only if the timer panel is [visible](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#showTimer).
   *
   * Possible values:
   *
   * - `"survey"` - Displays only the survey timer.
   * - `"page"` - Displays only the page timer.
   * - `"combined"` (default) - Displays both the survey and page timers.
   * @see timeSpent
   * @see onTimerTick
   * @see startTimer
   * @see stopTimer
   */
  get timerInfoMode() {
    return this.getTimerInfoVal(this.getPropertyValue("timerInfoMode"));
  }
  set timerInfoMode(val) {
    this.setPropertyValue("timerInfoMode", val);
  }
  getTimerInfoVal(val) {
    return val === "all" ? "combined" : val;
  }
  /**
   * @deprecated Use the [`timerInfoMode`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#timerInfoMode) property instead.
   */
  get showTimerPanelMode() {
    const res = this.timerInfoMode;
    return res === "combined" ? "all" : res;
  }
  set showTimerPanelMode(val) {
    this.timerInfoMode = this.getTimerInfoVal(val);
  }
  updateGridColumns() {
    this.pages.forEach((page) => page.updateGridColumns());
  }
  /**
    * Specifies how to calculate the survey width.
    *
    * Possible values:
    *
    * - `"static"` - A survey has a [fixed width](#width).
    * - `"responsive"` - A survey occupies all available horizontal space and stretches or shrinks horizontally to fit in the screen size.
    * - `"auto"` (default) - Survey width depends on a question type and corresponds to the `"static"` or `"responsive"` mode.
  */
  // `custom/precise` - The survey width is specified by the width property. // in-future
  get widthMode() {
    return this.getPropertyValue("widthMode");
  }
  set widthMode(val) {
    this.setPropertyValue("widthMode", val);
  }
  setCalculatedWidthModeUpdater() {
    if (this.isLoadingFromJson) return;
    if (this.calculatedWidthModeUpdater) this.calculatedWidthModeUpdater.dispose();
    this.calculatedWidthModeUpdater = new ComputedUpdater(() => this.calculateWidthMode());
    this.calculatedWidthMode = this.calculatedWidthModeUpdater;
  }
  calculateWidthMode() {
    if (this.widthMode == "auto") {
      let isResponsive = false;
      this.pages.forEach((page) => {
        if (page.needResponsiveWidth()) isResponsive = true;
      });
      return isResponsive ? "responsive" : "static";
    }
    return this.widthMode;
  }
  /**
   * A survey width in CSS values.
   *
   * Default value: `undefined` (the survey inherits the width from its container)
   * @see onResize
   */
  get width() {
    return this.getPropertyValue("width");
  }
  set width(val) {
    this.setPropertyValue("width", val);
  }
  get renderedWidth() {
    const isStaticWidth = this.getPropertyValue("calculatedWidthMode") == "static";
    let width = this.getPropertyValue("width");
    if (this.isScaled && this.responsiveStartWidth > 1) {
      let initialWidth = this.responsiveStartWidth;
      try {
        width = width || this.staticStartWidth;
        initialWidth = !isNaN(width) ? width : parseFloat(width.toString().replace("px", ""));
      } catch (e) {
      }
      return (isStaticWidth ? initialWidth : this.responsiveStartWidth) * this.widthScale / 100 + "px";
    }
    if (width && !isNaN(width)) width = width + "px";
    return isStaticWidth && width || void 0;
  }
  setStaticStartWidth(width) {
    this.staticStartWidth = width;
  }
  setResponsiveStartWidth(width) {
    this.responsiveStartWidth = width;
  }
  get isScaled() {
    return Math.abs(this.widthScale - 100) > 1e-3;
  }
  get timerInfo() {
    return this.getTimerInfo();
  }
  get timerClock() {
    let major;
    let minor;
    if (!!this.currentPage) {
      let {
        spent,
        limit,
        minorSpent,
        minorLimit
      } = this.getTimerInfo();
      if (limit > 0) major = this.getDisplayClockTime(limit - spent);
      else {
        major = this.getDisplayClockTime(spent);
      }
      if (minorSpent !== void 0) {
        if (minorLimit > 0) {
          minor = this.getDisplayClockTime(minorLimit - minorSpent);
        } else {
          minor = this.getDisplayClockTime(minorSpent);
        }
      }
    }
    return {
      majorText: major,
      minorText: minor
    };
  }
  get timerInfoText() {
    const options = {
      text: this.getTimerInfoText()
    };
    this.onTimerPanelInfoText.fire(this, options);
    var loc = new LocalizableString(this, true);
    loc.text = options.text;
    return loc.textOrHtml;
  }
  getTimerInfo() {
    let page = this.currentPage;
    if (!page) return {
      spent: 0,
      limit: 0
    };
    let pageSpent = page.timeSpent;
    let surveySpent = this.timeSpent;
    let pageLimitSec = page.getMaxTimeToFinish();
    let surveyLimit = this.timeLimit;
    if (this.timerInfoMode == "page") {
      return {
        spent: pageSpent,
        limit: pageLimitSec
      };
    }
    if (this.timerInfoMode == "survey") {
      return {
        spent: surveySpent,
        limit: surveyLimit
      };
    } else {
      if (pageLimitSec > 0 && surveyLimit > 0) {
        return {
          spent: pageSpent,
          limit: pageLimitSec,
          minorSpent: surveySpent,
          minorLimit: surveyLimit
        };
      } else if (pageLimitSec > 0) {
        return {
          spent: pageSpent,
          limit: pageLimitSec,
          minorSpent: surveySpent
        };
      } else if (surveyLimit > 0) {
        return {
          spent: surveySpent,
          limit: surveyLimit,
          minorSpent: pageSpent
        };
      } else {
        return {
          spent: pageSpent,
          minorSpent: surveySpent
        };
      }
    }
  }
  getTimerInfoText() {
    var page = this.currentPage;
    if (!page) return "";
    var pageSpent = this.getDisplayTime(page.timeSpent);
    var surveySpent = this.getDisplayTime(this.timeSpent);
    var pageLimitSec = page.getMaxTimeToFinish();
    var pageLimit = this.getDisplayTime(pageLimitSec);
    var surveyLimit = this.getDisplayTime(this.timeLimit);
    if (this.timerInfoMode == "page") return this.getTimerInfoPageText(page, pageSpent, pageLimit);
    if (this.timerInfoMode == "survey") return this.getTimerInfoSurveyText(surveySpent, surveyLimit);
    if (this.timerInfoMode == "combined") {
      if (pageLimitSec <= 0 && this.timeLimit <= 0) {
        return this.getLocalizationFormatString("timerSpentAll", pageSpent, surveySpent);
      }
      if (pageLimitSec > 0 && this.timeLimit > 0) {
        return this.getLocalizationFormatString("timerLimitAll", pageSpent, pageLimit, surveySpent, surveyLimit);
      }
      let pageText = this.getTimerInfoPageText(page, pageSpent, pageLimit);
      let surveyText = this.getTimerInfoSurveyText(surveySpent, surveyLimit);
      return pageText + " " + surveyText;
    }
    return "";
  }
  getTimerInfoPageText(page, pageSpent, pageLimit) {
    return !!page && page.getMaxTimeToFinish() > 0 ? this.getLocalizationFormatString("timerLimitPage", pageSpent, pageLimit) : this.getLocalizationFormatString("timerSpentPage", pageSpent, pageLimit);
  }
  getTimerInfoSurveyText(surveySpent, surveyLimit) {
    const strName = this.timeLimit > 0 ? "timerLimitSurvey" : "timerSpentSurvey";
    return this.getLocalizationFormatString(strName, surveySpent, surveyLimit);
  }
  getDisplayClockTime(val) {
    if (val < 0) {
      val = 0;
    }
    const min2 = Math.floor(val / 60);
    const sec = val % 60;
    let secStr = sec.toString();
    if (sec < 10) {
      secStr = "0" + secStr;
    }
    return `${min2}:${secStr}`;
  }
  getDisplayTime(val) {
    const min2 = Math.floor(val / 60);
    const sec = val % 60;
    let res = "";
    if (min2 > 0) {
      res += min2 + " " + this.getLocalizationString("timerMin");
    }
    if (res && sec == 0) return res;
    if (res) res += " ";
    return res + sec + " " + this.getLocalizationString("timerSec");
  }
  get timerModel() {
    return this.timerModelValue;
  }
  /**
   * Starts a timer that calculates how many seconds a respondent has spent on the survey. Applies only to [quiz surveys](https://surveyjs.io/form-library/documentation/design-survey-create-a-quiz).
   * @see stopTimer
   * @see timeLimit
   * @see timeLimitPerPage
   * @see timeSpent
   * @see onTimerTick
   */
  startTimer() {
    if (this.isEditMode) {
      this.timerModel.start();
    }
  }
  startTimerFromUI() {
    if (this.showTimer && this.state === "running") {
      this.startTimer();
    }
  }
  /**
   * Stops the timer. Applies only to [quiz surveys](https://surveyjs.io/form-library/documentation/design-survey-create-a-quiz).
   * @see startTimer
   * @see timeLimit
   * @see timeLimitPerPage
   * @see timeSpent
   * @see onTimerTick
   */
  stopTimer() {
    this.timerModel.stop();
  }
  /**
   * A time period that a respondent has spent on the survey so far; measured in seconds. Applies only to [quiz surveys](https://surveyjs.io/form-library/documentation/design-survey-create-a-quiz).
   *
   * Assign a number to this property if you need to start the quiz timer from a specific time (for instance, if you want to continue an interrupted quiz).
   *
   * You can also find out how many seconds a respondent has spent on an individual survey page. To do this, use the [`timeSpent`](https://surveyjs.io/form-library/documentation/api-reference/page-model#timeSpent) property of a [`PageModel`](https://surveyjs.io/form-library/documentation/api-reference/page-model) object.
   * @see timeLimit
   * @see timeLimitPerPage
   * @see startTimer
   */
  get timeSpent() {
    return this.timerModel.spent;
  }
  set timeSpent(val) {
    this.timerModel.spent = val;
  }
  /**
   * A time period that a respondent has to complete the survey; measured in seconds. Applies only to [quiz surveys](https://surveyjs.io/form-library/documentation/design-survey-create-a-quiz).
   *
   * Default value: 0 (time is unlimited)
   *
   * [View Demo](https://surveyjs.io/form-library/examples/make-quiz-javascript/ (linkStyle))
   * @see timeLimitPerPage
   * @see startTimer
   * @see timeSpent
   */
  get timeLimit() {
    return this.getPropertyValue("timeLimit", 0);
  }
  set timeLimit(val) {
    this.setPropertyValue("timeLimit", val);
  }
  /**
   * @deprecated Use the [`timeLimit`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#timeLimit) property instead.
   */
  get maxTimeToFinish() {
    return this.timeLimit;
  }
  set maxTimeToFinish(val) {
    this.timeLimit = val;
  }
  /**
   * A time period that a respondent has to complete each survey page; measured in seconds. Applies only to [quiz surveys](https://surveyjs.io/form-library/documentation/design-survey-create-a-quiz).
   *
   * Default value: 0 (time is unlimited)
   *
   * You can also use `PageModel`'s [`timeLimit`](https://surveyjs.io/form-library/documentation/api-reference/page-model#timeLimit) property to specify a time period for an individual survey page.
   *
   * [View Demo](https://surveyjs.io/form-library/examples/make-quiz-javascript/ (linkStyle))
   * @see timeLimit
   * @see startTimer
   * @see timeSpent
   */
  get timeLimitPerPage() {
    return this.getPropertyValue("timeLimitPerPage", 0);
  }
  set timeLimitPerPage(val) {
    this.setPropertyValue("timeLimitPerPage", val);
  }
  /**
   * @deprecated Use the [`timeLimitPerPage`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#timeLimitPerPage) property instead.
   */
  get maxTimeToFinishPage() {
    return this.timeLimitPerPage;
  }
  set maxTimeToFinishPage(val) {
    this.timeLimitPerPage = val;
  }
  doTimer(page) {
    this.onTimerTick.fire(this, {});
    if (this.timeLimit > 0 && this.timeLimit <= this.timeSpent) {
      this.timeSpent = this.timeLimit;
      this.tryComplete();
    }
    if (page) {
      var pageLimit = page.getMaxTimeToFinish();
      if (pageLimit > 0 && pageLimit == page.timeSpent) {
        if (this.isLastPage) {
          this.tryComplete();
        } else {
          this.nextPage();
        }
      }
    }
  }
  get inSurvey() {
    return true;
  }
  //ISurveyImplementor
  getSurveyData() {
    return this;
  }
  getSurvey() {
    return this;
  }
  getTextProcessor() {
    return this;
  }
  //ISurveyTriggerOwner
  getObjects(pages, questions) {
    var result = [];
    Array.prototype.push.apply(result, this.getPagesByNames(pages));
    Array.prototype.push.apply(result, this.getQuestionsByNames(questions));
    return result;
  }
  setTriggerValue(name, value, isVariable) {
    if (!name) return;
    if (isVariable) {
      this.setVariable(name, value);
    } else {
      var question = this.getQuestionByName(name);
      this.startSetValueFromTrigger();
      if (!!question) {
        question.value = value;
      } else {
        var processor = new ProcessValue();
        var firstName = processor.getFirstName(name);
        if (firstName == name) {
          this.setValue(name, value);
        } else {
          if (!this.getQuestionByName(firstName)) return;
          var data = this.getUnbindValue(this.getFilteredValues());
          processor.setValue(data, name, value);
          this.setValue(firstName, data[firstName]);
        }
      }
      this.finishSetValueFromTrigger();
    }
  }
  copyTriggerValue(name, fromName, copyDisplayValue) {
    if (!name || !fromName) return;
    let value;
    if (copyDisplayValue) {
      value = this.processText("{" + fromName + "}", true);
    } else {
      const processor = new ProcessValue();
      value = processor.getValue(fromName, this.getFilteredValues());
    }
    this.setTriggerValue(name, value, false);
  }
  triggerExecuted(trigger) {
    this.onTriggerExecuted.fire(this, {
      trigger
    });
  }
  get isSettingValueFromTrigger() {
    return this.setValueFromTriggerCounter > 0;
  }
  startSetValueFromTrigger() {
    this.setValueFromTriggerCounter++;
  }
  finishSetValueFromTrigger() {
    this.setValueFromTriggerCounter--;
  }
  startMovingQuestion() {
    this.isMovingQuestion = true;
  }
  stopMovingQuestion() {
    this.isMovingQuestion = false;
  }
  get isQuestionDragging() {
    return this.isMovingQuestion;
  }
  startMovingPage() {
    this.isMovingPage = true;
  }
  stopMovingPage() {
    this.isMovingPage = false;
  }
  /**
   * Focuses a question with a specified name. Switches the current page if needed.
   * @param name A question name.
   * @returns `false` if the survey does not contain a question with a specified name or this question is hidden; otherwise, `true`.
   * @see focusFirstQuestion
   * @see autoFocusFirstQuestion
   */
  focusQuestion(name) {
    return this.focusQuestionByInstance(this.getQuestionByName(name, true));
  }
  focusQuestionByInstance(question, onError = false) {
    var _a;
    if (!question || !question.isVisible || !question.page) return false;
    const oldQuestion = (_a = this.focusingQuestionInfo) === null || _a === void 0 ? void 0 : _a.question;
    if (oldQuestion === question) return false;
    this.focusingQuestionInfo = {
      question,
      onError
    };
    this.skippedPages.push({
      from: this.currentPage,
      to: question.page
    });
    const isNeedWaitForPageRendered = this.activePage !== question.page && !question.page.isStartPage;
    if (isNeedWaitForPageRendered) {
      this.currentPage = question.page;
      if (this.isSingleVisibleQuestion && !this.isDesignMode) {
        this.currentSingleQuestion = question;
      }
    }
    if (!isNeedWaitForPageRendered) {
      this.focusQuestionInfo();
    }
    return true;
  }
  focusQuestionInfo() {
    var _a;
    const question = (_a = this.focusingQuestionInfo) === null || _a === void 0 ? void 0 : _a.question;
    if (!!question && !question.isDisposed) {
      question.focus(this.focusingQuestionInfo.onError);
    }
    this.focusingQuestionInfo = void 0;
  }
  questionEditFinishCallback(question, event) {
    const enterKeyAction = this.enterKeyAction || settings.enterKeyAction;
    if (enterKeyAction == "loseFocus") event.target.blur();
    if (enterKeyAction == "moveToNextEditor") {
      const allQuestions = this.currentPage.questions;
      const questionIndex = allQuestions.indexOf(question);
      if (questionIndex > -1 && questionIndex < allQuestions.length - 1) {
        allQuestions[questionIndex + 1].focus();
      } else {
        event.target.blur();
      }
    }
  }
  elementWrapperComponentNameCore(componentName, element, wrapperName, reason, item) {
    if (this.onElementWrapperComponentName.isEmpty) return componentName;
    const options = {
      componentName,
      element,
      wrapperName,
      reason,
      item
    };
    this.onElementWrapperComponentName.fire(this, options);
    return options.componentName;
  }
  elementWrapperDataCore(data, element, wrapperName, reason, item) {
    if (this.onElementWrapperComponentData.isEmpty) return data;
    const options = {
      data,
      element,
      wrapperName,
      reason,
      item
    };
    this.onElementWrapperComponentData.fire(this, options);
    return options.data;
  }
  getElementWrapperComponentName(element, reason) {
    const res = reason === "logo-image" ? "sv-logo-image" : _SurveyModel.TemplateRendererComponentName;
    return this.elementWrapperComponentNameCore(res, element, "component", reason);
  }
  getQuestionContentWrapperComponentName(element) {
    return this.elementWrapperComponentNameCore(_SurveyModel.TemplateRendererComponentName, element, "content-component");
  }
  getRowWrapperComponentName(row) {
    return this.elementWrapperComponentNameCore(_SurveyModel.TemplateRendererComponentName, row, "row");
  }
  getItemValueWrapperComponentName(item, question) {
    return this.elementWrapperComponentNameCore(_SurveyModel.TemplateRendererComponentName, question, "itemvalue", void 0, item);
  }
  getElementWrapperComponentData(element, reason) {
    return this.elementWrapperDataCore(element, element, "component", reason);
  }
  getRowWrapperComponentData(row) {
    return this.elementWrapperDataCore(row, row, "row");
  }
  getItemValueWrapperComponentData(item, question) {
    return this.elementWrapperDataCore(item, question, "itemvalue", void 0, item);
  }
  getMatrixCellTemplateData(cell) {
    const res = cell.question;
    return this.elementWrapperDataCore(res, res, "cell");
  }
  searchText(text) {
    if (!!text) text = text.toLowerCase();
    var res = [];
    for (var i = 0; i < this.pages.length; i++) {
      this.pages[i].searchText(text, res);
    }
    return res;
  }
  getSkeletonComponentName(element) {
    return this.skeletonComponentName;
  }
  /**
   * Adds an element to the survey layout.
   *
   * This method accepts an object with the following layout element properties:
   *
   * - `id`: `string` | `"timerpanel"` | `"progress-buttons"` | `"progress-questions"` | `"progress-pages"` | `"progress-correctquestions"` | `"progress-requiredquestions"` | `"toc-navigation"` | `"buttons-navigation"`\
   * A layout element identifier. You can use possible values to access and relocate or customize predefined layout elements.
   *
   * - `container`: `"header"` | `"footer"` | `"left"` | `"right"` | `"contentTop"` | `"contentBottom"`\
   * A layout container that holds the element. If you want to display the element within multiple containers, set this property to an array of possible values.
   *
   * - `component`: `string`\
   * The name of the component that renders the layout element.
   *
   * - `data`: `any`\
   * Data passed as props to `component`.
   *
   * [View Demo](https://surveyjs.io/form-library/examples/progress-bar-with-percentage/ (linkStyle))
   * @param layoutElement A layout element configuration.
   * @returns The configuration of the previous layout element with the same `id`.
   */
  addLayoutElement(layoutElement) {
    const existingLayoutElement = this.removeLayoutElement(layoutElement.id);
    this.layoutElements.push(layoutElement);
    return existingLayoutElement;
  }
  findLayoutElement(layoutElementId) {
    const layoutElement = this.layoutElements.filter((a) => a.id === layoutElementId)[0];
    return layoutElement;
  }
  removeLayoutElement(layoutElementId) {
    const layoutElement = this.findLayoutElement(layoutElementId);
    if (!!layoutElement) {
      const layoutElementIndex = this.layoutElements.indexOf(layoutElement);
      this.layoutElements.splice(layoutElementIndex, 1);
    }
    return layoutElement;
  }
  getContainerContent(container) {
    const containerLayoutElements = new Array();
    for (let layoutElement of this.layoutElements) {
      if (this.mode !== "display" && isStrCiEqual(layoutElement.id, "timerpanel")) {
        if (container === "header") {
          if (this.isTimerPanelShowingOnTop && !this.isStartPageActive) {
            containerLayoutElements.push(layoutElement);
          }
        }
        if (container === "footer") {
          if (this.isTimerPanelShowingOnBottom && !this.isStartPageActive) {
            containerLayoutElements.push(layoutElement);
          }
        }
      } else if (this.state === "running" && isStrCiEqual(layoutElement.id, this.progressBarComponentName)) {
        if (this.questionsOnPageMode != "singlePage" || this.progressBarType == "questions") {
          const headerLayoutElement = this.findLayoutElement("advanced-header");
          const advHeader = headerLayoutElement && headerLayoutElement.data;
          let isBelowHeader = !advHeader || advHeader.hasBackground;
          if (isStrCiEqual(this.progressBarLocation, "aboveHeader")) {
            isBelowHeader = false;
          }
          if (isStrCiEqual(this.progressBarLocation, "belowHeader")) {
            isBelowHeader = true;
          }
          if (container === "header" && !isBelowHeader) {
            layoutElement.index = -150;
            if (this.isShowProgressBarOnTop && !this.isStartPageActive) {
              containerLayoutElements.push(layoutElement);
            }
          }
          if (container === "center" && isBelowHeader) {
            if (!!layoutElement.index) {
              delete layoutElement.index;
            }
            if (this.isShowProgressBarOnTop && !this.isStartPageActive) {
              containerLayoutElements.push(layoutElement);
            }
          }
          if (container === "footer") {
            if (this.isShowProgressBarOnBottom && !this.isStartPageActive) {
              containerLayoutElements.push(layoutElement);
            }
          }
        }
      } else if (isStrCiEqual(layoutElement.id, "buttons-navigation")) {
        if (container === "contentTop") {
          if (["top", "both"].indexOf(this.isNavigationButtonsShowing) !== -1) {
            containerLayoutElements.push(layoutElement);
          }
        }
        if (container === "contentBottom") {
          if (["bottom", "both"].indexOf(this.isNavigationButtonsShowing) !== -1) {
            containerLayoutElements.push(layoutElement);
          }
        }
      } else if (this.state === "running" && isStrCiEqual(layoutElement.id, "toc-navigation") && this.showTOC) {
        if (container === "left") {
          if (["left", "both"].indexOf(this.tocLocation) !== -1) {
            containerLayoutElements.push(layoutElement);
          }
        }
        if (container === "right") {
          if (["right", "both"].indexOf(this.tocLocation) !== -1) {
            containerLayoutElements.push(layoutElement);
          }
        }
      } else if (isStrCiEqual(layoutElement.id, "advanced-header")) {
        if ((this.state === "running" || this.state === "starting" || this.showHeaderOnCompletePage === true && this.state === "completed") && layoutElement.container === container) {
          containerLayoutElements.push(layoutElement);
        }
      } else {
        if (Array.isArray(layoutElement.container) && layoutElement.container.indexOf(container) !== -1 || layoutElement.container === container) {
          containerLayoutElements.push(layoutElement);
        }
      }
    }
    containerLayoutElements.sort((a, b) => (a.index || 0) - (b.index || 0));
    containerLayoutElements.forEach((el) => {
      if (!!el.getData) {
        el.data = el.getData();
      }
    });
    return containerLayoutElements;
  }
  processPopupVisiblityChanged(question, popup, visible) {
    this.onPopupVisibleChanged.fire(this, {
      question,
      popup,
      visible
    });
  }
  processOpenDropdownMenu(question, options) {
    const newOptions = Object.assign({
      question
    }, options);
    this.onOpenDropdownMenu.fire(this, newOptions);
    options.menuType = newOptions.menuType;
  }
  getCssTitleExpandableSvg() {
    return null;
  }
  /**
   * Applies a specified theme to the survey.
   *
   * [Themes & Styles](https://surveyjs.io/form-library/documentation/manage-default-themes-and-styles (linkStyle))
   * @param theme An [`ITheme`](https://surveyjs.io/form-library/documentation/api-reference/itheme) object with theme settings.
   */
  applyTheme(theme) {
    if (!theme) return;
    Object.keys(theme).forEach((key) => {
      if (key === "header") {
        return;
      }
      if (key === "isPanelless") {
        this.isCompact = theme[key];
      } else {
        this[key] = theme[key];
      }
    });
    if ("header" in theme && !theme.headerView) {
      this.headerView = "advanced";
    }
    if (this.headerView !== "basic") {
      this.removeLayoutElement("advanced-header");
      const advHeader = new Cover();
      advHeader.fromTheme(theme);
      this.insertAdvancedHeader(advHeader);
    }
    this.themeChanged(theme);
  }
  themeChanged(theme) {
    this.getAllQuestions().forEach((q) => q.themeChanged(theme));
  }
  /**
   * Disposes of the survey model.
   *
   * Call this method to release resources if your application contains multiple survey models or if you re-create a survey model at runtime.
   */
  dispose() {
    this.unConnectEditingObj();
    this.removeScrollEventListener();
    this.destroyResizeObserver();
    this.rootElement = void 0;
    if (this.layoutElements) {
      for (var i = 0; i < this.layoutElements.length; i++) {
        if (!!this.layoutElements[i].data && this.layoutElements[i].data !== this && this.layoutElements[i].data.dispose) {
          this.layoutElements[i].data.dispose();
        }
      }
      this.layoutElements.splice(0, this.layoutElements.length);
    }
    super.dispose();
    this.editingObj = null;
    if (!this.pages) return;
    this.currentPage = null;
    for (var i = 0; i < this.pages.length; i++) {
      this.pages[i].setSurveyImpl(void 0);
      this.pages[i].dispose();
    }
    this.pages.splice(0, this.pages.length);
    if (this.disposeCallback) {
      this.disposeCallback();
    }
  }
  // private _lastScrollTop = 0;
  _isElementShouldBeSticky(selector) {
    if (!selector) return false;
    const topStickyContainer = this.rootElement.querySelector(selector);
    if (!!topStickyContainer) {
      return this.rootElement.scrollTop > 0 && topStickyContainer.getBoundingClientRect().y <= this.rootElement.getBoundingClientRect().y;
    }
    return false;
  }
  onScroll() {
    if (!!this.rootElement) {
      if (this._isElementShouldBeSticky(".sv-components-container-center")) {
        this.rootElement.classList && this.rootElement.classList.add("sv-root--sticky-top");
      } else {
        this.rootElement.classList && this.rootElement.classList.remove("sv-root--sticky-top");
      }
    }
    if (this.onScrollCallback) {
      this.onScrollCallback();
    }
  }
  addScrollEventListener() {
    var _a;
    this.scrollHandler = () => {
      this.onScroll();
    };
    this.rootElement.addEventListener("scroll", this.scrollHandler);
    if (!!this.rootElement.getElementsByTagName("form")[0]) {
      this.rootElement.getElementsByTagName("form")[0].addEventListener("scroll", this.scrollHandler);
    }
    if (!!this.css.rootWrapper) {
      (_a = this.rootElement.getElementsByClassName(this.css.rootWrapper)[0]) === null || _a === void 0 ? void 0 : _a.addEventListener("scroll", this.scrollHandler);
    }
  }
  removeScrollEventListener() {
    var _a;
    if (!!this.rootElement && !!this.scrollHandler) {
      this.rootElement.removeEventListener("scroll", this.scrollHandler);
      if (!!this.rootElement.getElementsByTagName("form")[0]) {
        this.rootElement.getElementsByTagName("form")[0].removeEventListener("scroll", this.scrollHandler);
      }
      if (!!this.css.rootWrapper) {
        (_a = this.rootElement.getElementsByClassName(this.css.rootWrapper)[0]) === null || _a === void 0 ? void 0 : _a.removeEventListener("scroll", this.scrollHandler);
      }
    }
  }
};
SurveyModel.TemplateRendererComponentName = "sv-template-renderer";
SurveyModel.platform = "unknown";
__decorate([property()], SurveyModel.prototype, "completedCss", void 0);
__decorate([property()], SurveyModel.prototype, "completedBeforeCss", void 0);
__decorate([property()], SurveyModel.prototype, "loadingBodyCss", void 0);
__decorate([property()], SurveyModel.prototype, "containerCss", void 0);
__decorate([property({
  onSet: (newValue, target) => {
    target.updateCss();
  }
})], SurveyModel.prototype, "fitToContainer", void 0);
__decorate([property({
  onSet: (newValue, target) => {
    if (newValue === "basic") {
      target.removeLayoutElement("advanced-header");
    } else {
      const layoutElement = target.findLayoutElement("advanced-header");
      if (!layoutElement) {
        const advHeader = new Cover();
        target.insertAdvancedHeader(advHeader);
      }
    }
  }
})], SurveyModel.prototype, "headerView", void 0);
__decorate([property()], SurveyModel.prototype, "showBrandInfo", void 0);
__decorate([property()], SurveyModel.prototype, "enterKeyAction", void 0);
__decorate([property()], SurveyModel.prototype, "lazyRenderFirstBatchSizeValue", void 0);
__decorate([property({
  defaultValue: {}
})], SurveyModel.prototype, "cssVariables", void 0);
__decorate([property()], SurveyModel.prototype, "_isMobile", void 0);
__decorate([property()], SurveyModel.prototype, "_isCompact", void 0);
__decorate([property({
  onSet: (newValue, target) => {
    target.updateCss();
  }
})], SurveyModel.prototype, "backgroundImage", void 0);
__decorate([property()], SurveyModel.prototype, "backgroundImageFit", void 0);
__decorate([property({
  onSet: (newValue, target) => {
    target.updateCss();
  }
})], SurveyModel.prototype, "backgroundImageAttachment", void 0);
__decorate([property()], SurveyModel.prototype, "wrapperFormCss", void 0);
__decorate([property({
  getDefaultValue: (self2) => {
    return self2.progressBarType === "buttons";
  }
})], SurveyModel.prototype, "progressBarShowPageTitles", void 0);
__decorate([property()], SurveyModel.prototype, "progressBarShowPageNumbers", void 0);
__decorate([property()], SurveyModel.prototype, "progressBarInheritWidthFrom", void 0);
__decorate([property({
  defaultValue: true
})], SurveyModel.prototype, "validationEnabled", void 0);
__decorate([property()], SurveyModel.prototype, "rootCss", void 0);
__decorate([property({
  onSet: (newValue, target) => {
    target.updateGridColumns();
  }
})], SurveyModel.prototype, "gridLayoutEnabled", void 0);
__decorate([property()], SurveyModel.prototype, "calculatedWidthMode", void 0);
__decorate([property({
  defaultValue: 100,
  onSet(val, target, prevVal) {
    target.pages.forEach((p) => p.updateRootStyle());
  }
})], SurveyModel.prototype, "widthScale", void 0);
__decorate([property()], SurveyModel.prototype, "staticStartWidth", void 0);
__decorate([property()], SurveyModel.prototype, "responsiveStartWidth", void 0);
__decorate([propertyArray()], SurveyModel.prototype, "layoutElements", void 0);
function isStrCiEqual(a, b) {
  if (!a) return false;
  if (!b) return false;
  return a.toUpperCase() === b.toUpperCase();
}
Serializer.addClass("survey", [{
  name: "locale",
  choices: () => {
    return surveyLocalization.getLocales(true);
  },
  onGetValue: (obj) => {
    return obj.locale == surveyLocalization.defaultLocale ? null : obj.locale;
  }
}, {
  name: "title",
  serializationProperty: "locTitle",
  dependsOn: "locale"
}, {
  name: "description:text",
  serializationProperty: "locDescription",
  dependsOn: "locale"
}, {
  name: "logo:file",
  serializationProperty: "locLogo"
}, {
  name: "logoWidth",
  default: "auto",
  minValue: 0
}, {
  name: "logoHeight",
  default: "40px",
  minValue: 0
}, {
  name: "logoFit",
  default: "contain",
  choices: ["none", "contain", "cover", "fill"]
}, {
  name: "logoPosition",
  default: "left",
  choices: ["none", "left", "right", "top", "bottom"]
}, {
  name: "autoFocusFirstQuestion:boolean",
  alternativeName: "focusFirstQuestionAutomatic"
}, {
  name: "autoFocusFirstError:boolean",
  default: true,
  alternativeName: "focusOnFirstError"
}, {
  name: "completedHtml:html",
  serializationProperty: "locCompletedHtml"
}, {
  name: "completedBeforeHtml:html",
  serializationProperty: "locCompletedBeforeHtml"
}, {
  name: "completedHtmlOnCondition:htmlconditions",
  className: "htmlconditionitem",
  isArray: true
}, {
  name: "loadingHtml:html",
  serializationProperty: "locLoadingHtml"
}, {
  name: "pages:surveypages",
  className: "page",
  isArray: true,
  onSerializeValue: (obj) => {
    return obj.originalPages || obj.pages;
  }
}, {
  name: "elements",
  alternativeName: "questions",
  baseClassName: "question",
  visible: false,
  isLightSerializable: false,
  onGetValue: function(obj) {
    return null;
  },
  onSetValue: function(obj, value, jsonConverter) {
    obj.pages.splice(0, obj.pages.length);
    var page = obj.addNewPage("");
    jsonConverter.toObject({
      questions: value
    }, page, jsonConverter === null || jsonConverter === void 0 ? void 0 : jsonConverter.options);
  }
}, {
  name: "triggers:triggers",
  baseClassName: "surveytrigger",
  classNamePart: "trigger"
}, {
  name: "calculatedValues:calculatedvalues",
  className: "calculatedvalue",
  isArray: true
}, {
  name: "sjsVersion",
  visible: false
}, {
  name: "surveyId",
  visible: false
}, {
  name: "surveyPostId",
  visible: false
}, {
  name: "surveyShowDataSaving:boolean",
  visible: false
}, "cookieName", {
  name: "partialSendEnabled:boolean",
  alternativeName: "sendResultOnPageNext"
}, {
  name: "showNavigationButtons:boolean",
  default: true
}, {
  name: "navigationButtonsLocation",
  default: "bottom",
  choices: ["top", "bottom", "topBottom"]
}, {
  name: "showPrevButton:boolean",
  default: true,
  visibleIf: (obj) => {
    return obj.showNavigationButtons !== "none";
  }
}, {
  name: "showTitle:boolean",
  default: true
}, {
  name: "showPageTitles:boolean",
  default: true
}, {
  name: "showCompletePage:boolean",
  default: true,
  alternativeName: "showCompletedPage"
}, "navigateToUrl", {
  name: "navigateToUrlOnCondition:urlconditions",
  className: "urlconditionitem",
  isArray: true
}, {
  name: "questionOrder",
  alternativeName: "questionsOrder",
  default: "initial",
  choices: ["initial", "random"]
}, {
  name: "matrixDragHandleArea",
  visible: false,
  default: "entireItem",
  choices: ["entireItem", "icon"]
}, "showPageNumbers:boolean", {
  name: "showQuestionNumbers",
  default: "off",
  choices: ["on", "onPage", "off"]
}, {
  name: "questionTitleLocation",
  default: "top",
  choices: ["top", "bottom", "left"]
}, {
  name: "questionDescriptionLocation",
  default: "underTitle",
  choices: ["underInput", "underTitle"]
}, {
  name: "questionErrorLocation",
  default: "top",
  choices: ["top", "bottom"]
}, {
  name: "showProgressBar:boolean",
  default: false,
  onSetValue: (obj, value, jsonConv) => {
    obj && obj.setShowProgressBar(value);
  }
}, {
  name: "progressBarLocation",
  default: "auto",
  choices: ["auto", "aboveheader", "belowheader", "bottom", "topbottom"]
}, {
  name: "progressBarType",
  default: "pages",
  choices: ["pages", "questions", "requiredQuestions", "correctQuestions"],
  visibleIf: (obj) => {
    return obj.showProgressBar;
  }
}, {
  name: "progressBarShowPageTitles:switch",
  category: "navigation",
  visibleIf: (obj) => {
    return obj.showProgressBar && obj.progressBarType === "pages";
  }
}, {
  name: "progressBarShowPageNumbers:switch",
  default: false,
  category: "navigation",
  visibleIf: (obj) => {
    return obj.showProgressBar && obj.progressBarType === "pages";
  }
}, {
  name: "progressBarInheritWidthFrom",
  default: "container",
  choices: ["container", "survey"],
  category: "navigation",
  visibleIf: (obj) => {
    return obj.showProgressBar && obj.progressBarType === "pages";
  }
}, {
  name: "showTOC:switch",
  default: false
}, {
  name: "tocLocation",
  default: "left",
  choices: ["left", "right"],
  dependsOn: ["showTOC"],
  visibleIf: (survey) => {
    return !!survey && survey.showTOC;
  }
}, {
  name: "readOnly:boolean",
  default: false
}, {
  name: "mode",
  default: "edit",
  choices: ["edit", "display"],
  visible: false
}, {
  name: "storeOthersAsComment:boolean",
  default: true
}, {
  name: "maxTextLength:number",
  default: 0,
  minValue: 0
}, {
  name: "maxCommentLength:number",
  default: 0,
  minValue: 0,
  alternativeName: "maxOthersLength"
}, {
  name: "autoAdvanceEnabled:boolean",
  alternativeName: "goNextPageAutomatic",
  onSetValue: function(obj, value) {
    if (value !== "autogonext") {
      value = Helpers.isTwoValueEquals(value, true);
    }
    if (value === "autogonext") {
      value = true;
    }
    obj.setPropertyValue("autoAdvanceEnabled", value);
  }
}, {
  name: "autoAdvanceAllowComplete:boolean",
  default: true,
  alternativeName: "allowCompleteSurveyAutomatic",
  visibleIf: (obj) => obj.autoAdvanceEnabled === true
}, {
  name: "clearInvisibleValues",
  default: "onComplete",
  choices: ["none", "onComplete", "onHidden", "onHiddenContainer"]
}, {
  name: "checkErrorsMode",
  default: "onNextPage",
  choices: ["onNextPage", "onValueChanged", "onComplete"]
}, {
  name: "validateVisitedEmptyFields:boolean",
  dependsOn: "checkErrorsMode",
  visibleIf: (obj) => obj.checkErrorsMode === "onValueChanged"
}, {
  name: "textUpdateMode",
  default: "onBlur",
  choices: ["onBlur", "onTyping"]
}, {
  name: "autoGrowComment:boolean",
  default: false
}, {
  name: "allowResizeComment:boolean",
  default: true
}, {
  name: "commentAreaRows:number",
  minValue: 1
}, {
  name: "startSurveyText",
  serializationProperty: "locStartSurveyText",
  visibleIf: (obj) => {
    return obj.firstPageIsStartPage;
  }
}, {
  name: "pagePrevText",
  serializationProperty: "locPagePrevText",
  visibleIf: (obj) => {
    return obj.showNavigationButtons !== "none" && obj.showPrevButton;
  }
}, {
  name: "pageNextText",
  serializationProperty: "locPageNextText",
  visibleIf: (obj) => {
    return obj.showNavigationButtons !== "none";
  }
}, {
  name: "completeText",
  serializationProperty: "locCompleteText",
  visibleIf: (obj) => {
    return obj.showNavigationButtons !== "none";
  }
}, {
  name: "previewText",
  serializationProperty: "locPreviewText",
  visibleIf: (obj) => {
    return obj.showPreviewBeforeComplete;
  }
}, {
  name: "editText",
  serializationProperty: "locEditText",
  visibleIf: (obj) => {
    return obj.showPreviewBeforeComplete;
  }
}, {
  name: "requiredMark",
  default: "*",
  alternativeName: "requiredText"
}, {
  name: "questionStartIndex",
  dependsOn: ["showQuestionNumbers"],
  visibleIf: (survey) => {
    return !survey || survey.showQuestionNumbers !== "off";
  }
}, {
  name: "questionTitlePattern",
  default: "numTitleRequire",
  dependsOn: ["questionStartIndex", "requiredMark"],
  choices: (obj) => {
    if (!obj) return [];
    return obj.getQuestionTitlePatternOptions();
  }
}, {
  name: "questionTitleTemplate",
  visible: false,
  isSerializable: false,
  serializationProperty: "locQuestionTitleTemplate"
}, {
  name: "firstPageIsStartPage:boolean",
  default: false,
  alternativeName: "firstPageIsStarted"
}, {
  name: "isSinglePage:boolean",
  default: false,
  visible: false,
  isSerializable: false
}, {
  name: "questionsOnPageMode",
  default: "standard",
  choices: ["standard", "singlePage", "questionPerPage"]
}, {
  name: "showPreviewBeforeComplete:boolean",
  default: false,
  onSetValue: (obj, value, jsonConv) => {
    obj && obj.setShowPreviewBeforeComplete(value);
  }
}, {
  name: "previewMode",
  default: "allQuestions",
  choices: ["allQuestions", "answeredQuestions"],
  visibleIf: (obj) => {
    return obj.showPreviewBeforeComplete;
  }
}, {
  name: "showTimer:boolean"
}, {
  name: "timeLimit:number",
  alternativeName: "maxTimeToFinish",
  default: 0,
  minValue: 0,
  enableIf: (obj) => obj.showTimer
}, {
  name: "timeLimitPerPage:number",
  alternativeName: "maxTimeToFinishPage",
  default: 0,
  minValue: 0,
  enableIf: (obj) => obj.showTimer
}, {
  name: "timerLocation",
  default: "top",
  choices: ["top", "bottom"],
  enableIf: (obj) => obj.showTimer
}, {
  name: "timerInfoMode",
  alternativeName: "showTimerPanelMode",
  default: "combined",
  choices: ["page", "survey", "combined"],
  enableIf: (obj) => obj.showTimer
}, {
  name: "showTimerPanel",
  visible: false,
  isSerializable: false
}, {
  name: "widthMode",
  default: "auto",
  choices: ["auto", "static", "responsive"]
}, {
  name: "gridLayoutEnabled:boolean",
  default: false
}, {
  name: "width",
  visibleIf: (obj) => {
    return obj.widthMode === "static";
  }
}, {
  name: "fitToContainer:boolean",
  default: true,
  visible: false
}, {
  name: "headerView",
  default: "basic",
  choices: ["basic", "advanced"],
  visible: false
}, {
  name: "backgroundImage:file",
  visible: false
}, {
  name: "backgroundImageFit",
  default: "cover",
  choices: ["auto", "contain", "cover"],
  visible: false
}, {
  name: "backgroundImageAttachment",
  default: "scroll",
  choices: ["scroll", "fixed"],
  visible: false
}, {
  name: "backgroundOpacity:number",
  minValue: 0,
  maxValue: 1,
  default: 1,
  visible: false
}, {
  name: "showBrandInfo:boolean",
  default: false,
  visible: false
}]);
var QuestionSelectBase = class extends Question {
  get waitingChoicesByURL() {
    return !this.isChoicesLoaded && this.hasChoicesUrl;
  }
  get selectedItemValues() {
    return this.getPropertyValue("selectedItemValues");
  }
  set selectedItemValues(val) {
    this.setPropertyValue("selectedItemValues", val);
  }
  constructor(name) {
    super(name);
    this.otherItemValue = new ItemValue("other");
    this.isSettingDefaultValue = false;
    this.isSettingComment = false;
    this.isRunningChoices = false;
    this.isFirstLoadChoicesFromUrl = true;
    this.isUpdatingChoicesDependedQuestions = false;
    this._renderedChoices = [];
    this.renderedChoicesAnimation = new AnimationGroup(this.getRenderedChoicesAnimationOptions(), (val) => {
      this._renderedChoices = val;
      this.renderedChoicesChangedCallback && this.renderedChoicesChangedCallback();
    }, () => this._renderedChoices);
    this.headItemsCount = 0;
    this.footItemsCount = 0;
    this.prevIsOtherSelected = false;
    this.noneItemValue = this.createDefaultItem(settings.noneItemValue, "noneText", "noneItemText");
    this.refuseItemValue = this.createDefaultItem(settings.refuseItemValue, "refuseText", "refuseItemText");
    this.dontKnowItemValue = this.createDefaultItem(settings.dontKnowItemValue, "dontKnowText", "dontKnowItemText");
    this.createItemValues("choices");
    this.registerPropertyChangedHandlers(["choices"], () => {
      if (!this.filterItems()) {
        this.onVisibleChoicesChanged();
      }
    });
    this.registerPropertyChangedHandlers(["choicesFromQuestion", "choicesFromQuestionMode", "choiceValuesFromQuestion", "choiceTextsFromQuestion", "showNoneItem", "showRefuseItem", "showDontKnowItem", "isUsingRestful", "isMessagePanelVisible"], () => {
      this.onVisibleChoicesChanged();
    });
    this.registerPropertyChangedHandlers(["hideIfChoicesEmpty"], () => {
      this.onVisibleChanged();
    });
    this.registerPropertyChangedHandlers(["selecteditemValues"], (newVal) => {
      this.onSelectedItemValuesChangedHandler(newVal);
    });
    this.createNewArray("visibleChoices", () => this.updateRenderedChoices(), () => this.updateRenderedChoices());
    this.setNewRestfulProperty();
    var locOtherText = this.createLocalizableString("otherText", this.otherItemValue, true, "otherItemText");
    this.createLocalizableString("otherErrorText", this, true, "otherRequiredError");
    this.createLocalizableString("otherPlaceholder", this, false, true);
    this.otherItemValue.locOwner = this;
    this.otherItemValue.setLocText(locOtherText);
    this.choicesByUrl.createItemValue = (value) => {
      return this.createItemValue(value);
    };
    this.choicesByUrl.beforeSendRequestCallback = () => {
      this.onBeforeSendRequest();
    };
    this.choicesByUrl.getResultCallback = (items) => {
      this.onLoadChoicesFromUrl(items);
    };
    this.choicesByUrl.updateResultCallback = (items, serverResult) => {
      if (this.survey) {
        return this.survey.updateChoicesFromServer(this, items, serverResult);
      }
      return items;
    };
  }
  getType() {
    return "selectbase";
  }
  dispose() {
    super.dispose();
    const q = this.getQuestionWithChoices();
    if (!!q) {
      q.removeDependedQuestion(this);
    }
  }
  get otherTextAreaModel() {
    if (!this.otherTextAreaModelValue) {
      this.otherTextAreaModelValue = new TextAreaModel(this.getOtherTextAreaOptions());
    }
    return this.otherTextAreaModelValue;
  }
  getOtherTextAreaOptions() {
    const options = {
      question: this,
      id: () => this.otherId,
      propertyName: "otherValue",
      className: () => this.cssClasses.other,
      placeholder: () => this.otherPlaceholder,
      isDisabledAttr: () => this.isInputReadOnly || false,
      rows: () => this.commentAreaRows,
      maxLength: () => this.getOthersMaxLength(),
      autoGrow: () => this.survey && this.survey.autoGrowComment,
      ariaRequired: () => this.ariaRequired || this.a11y_input_ariaRequired,
      ariaLabel: () => this.ariaLabel || this.a11y_input_ariaLabel,
      getTextValue: () => {
        return this.otherValue;
      },
      onTextAreaChange: (e) => {
        this.onOtherValueChange(e);
      },
      onTextAreaInput: (e) => {
        this.onOtherValueInput(e);
      }
    };
    return options;
  }
  resetDependedQuestion() {
    this.choicesFromQuestion = "";
  }
  get otherId() {
    return this.id + "_other";
  }
  getCommentElementsId() {
    return [this.commentId, this.otherId];
  }
  getItemValueType() {
    return "itemvalue";
  }
  createItemValue(value, text) {
    const res = Serializer.createClass(this.getItemValueType(), {
      value
    });
    res.locOwner = this;
    if (!!text) res.text = text;
    return res;
  }
  hasErrors(fireCallback = true, rec = null) {
    if (!rec || rec.isOnValueChanged !== true) {
      this.clearIncorrectValues();
    }
    return super.hasErrors(fireCallback, rec);
  }
  get isUsingCarryForward() {
    return !!this.carryForwardQuestionType;
  }
  get carryForwardQuestionType() {
    return this.getPropertyValue("carryForwardQuestionType");
  }
  setCarryForwardQuestionType(selBaseQuestion, arrayQuestion) {
    const mode = selBaseQuestion ? "select" : arrayQuestion ? "array" : void 0;
    this.setPropertyValue("carryForwardQuestionType", mode);
  }
  get isUsingRestful() {
    return this.getPropertyValueWithoutDefault("isUsingRestful") || false;
  }
  updateIsUsingRestful() {
    this.setPropertyValueDirectly("isUsingRestful", this.hasChoicesUrl);
  }
  supportGoNextPageError() {
    return !this.isOtherSelected || !!this.otherValue;
  }
  isLayoutTypeSupported(layoutType) {
    return true;
  }
  localeChanged() {
    super.localeChanged();
    if (this.choicesOrder !== "none") {
      this.updateVisibleChoices();
      this.onVisibleChoicesChanged();
    }
  }
  locStrsChanged() {
    super.locStrsChanged();
    if (!!this.choicesFromUrl) {
      ItemValue.locStrsChanged(this.choicesFromUrl);
      ItemValue.locStrsChanged(this.visibleChoices);
    }
    if (this.isUsingCarryForward) {
      ItemValue.locStrsChanged(this.visibleChoices);
    }
  }
  updatePrevOtherErrorValue(val) {
    const oldVal = this.otherValue;
    if (val !== oldVal) {
      this.prevOtherErrorValue = oldVal;
    }
  }
  get otherValue() {
    if (!this.showCommentArea) return this.comment;
    return this.otherValueCore;
  }
  set otherValue(val) {
    this.updatePrevOtherErrorValue(val);
    if (!this.showCommentArea) {
      this.comment = val;
    } else {
      this.setOtherValueInternally(val);
    }
  }
  get otherValueCore() {
    return this.getPropertyValue("otherValue");
  }
  set otherValueCore(val) {
    this.setPropertyValue("otherValue", val);
  }
  /**
   * Returns the "Other" choice item. Use this property to change the item's `value` or `text`.
   * @see showOtherItem
   */
  get otherItem() {
    return this.otherItemValue;
  }
  /**
   * Returns `true` if the "Other" choice item is selected.
   * @see showOtherItem
   */
  get isOtherSelected() {
    return this.hasOther && this.getHasOther(this.renderedValue);
  }
  get isNoneSelected() {
    return this.showNoneItem && this.getIsItemValue(this.renderedValue, this.noneItem);
  }
  /**
   * Specifies whether to display the "None" choice item.
   *
   * When users select the "None" item in multi-select questions, all other items become unselected.
   * @see noneItem
   * @see noneText
   * @see [settings.noneItemValue](https://surveyjs.io/form-library/documentation/api-reference/settings#noneItemValue)
   * @see [settings.specialChoicesOrder](https://surveyjs.io/form-library/documentation/api-reference/settings#specialChoicesOrder)
   */
  get showNoneItem() {
    return this.getPropertyValue("showNoneItem");
  }
  set showNoneItem(val) {
    this.setPropertyValue("showNoneItem", val);
  }
  get hasNone() {
    return this.showNoneItem;
  }
  set hasNone(val) {
    this.showNoneItem = val;
  }
  /**
   * Returns the "None" choice item. Use this property to change the item's `value` or `text`.
   * @see showNoneItem
   */
  get noneItem() {
    return this.noneItemValue;
  }
  /**
   * Gets or sets a caption for the "None" choice item.
   * @see showNoneItem
   */
  get noneText() {
    return this.getLocalizableStringText("noneText");
  }
  set noneText(val) {
    this.setLocalizableStringText("noneText", val);
  }
  get locNoneText() {
    return this.getLocalizableString("noneText");
  }
  /**
   * Specifies whether to display the "Refuse to answer" choice item.
   *
   * When users select the "Refuse to answer" item in multi-select questions, all other items become unselected.
   * @see refuseItem
   * @see refuseItemText
   * @see [settings.refuseItemValue](https://surveyjs.io/form-library/documentation/api-reference/settings#refuseItemValue)
   * @see [settings.specialChoicesOrder](https://surveyjs.io/form-library/documentation/api-reference/settings#specialChoicesOrder)
   */
  get showRefuseItem() {
    return this.getPropertyValue("showRefuseItem");
  }
  set showRefuseItem(val) {
    this.setPropertyValue("showRefuseItem", val);
  }
  /**
   * Returns the "Refuse to answer" choice item. Use this property to change the item's `value` or `text`.
   * @see showRefuseItem
   */
  get refuseItem() {
    return this.refuseItemValue;
  }
  /**
   * Gets or sets a caption for the "Refuse to answer" choice item.
   * @see showRefuseItem
   */
  get refuseText() {
    return this.getLocalizableStringText("refuseText");
  }
  set refuseText(val) {
    this.setLocalizableStringText("refuseText", val);
  }
  get locRefuseText() {
    return this.getLocalizableString("refuseText");
  }
  /**
   * Specifies whether to display the "Don't know" choice item.
   *
   * When users select the "Don't know" item in multi-select questions, all other items become unselected.
   * @see dontKnowItem
   * @see dontKnowItemText
   * @see [settings.dontKnowItemValue](https://surveyjs.io/form-library/documentation/api-reference/settings#dontKnowItemValue)
   * @see [settings.specialChoicesOrder](https://surveyjs.io/form-library/documentation/api-reference/settings#specialChoicesOrder)
   */
  get showDontKnowItem() {
    return this.getPropertyValue("showDontKnowItem");
  }
  set showDontKnowItem(val) {
    this.setPropertyValue("showDontKnowItem", val);
  }
  /**
   * Returns the "Don't know" choice item. Use this property to change the item's `value` or `text`.
   * @see showDontKnowItem
   */
  get dontKnowItem() {
    return this.dontKnowItemValue;
  }
  /**
   * Gets or sets a caption for the "Don't know" choice item.
   * @see showDontKnowItem
   */
  get dontKnowText() {
    return this.getLocalizableStringText("dontKnowText");
  }
  set dontKnowText(val) {
    this.setLocalizableStringText("dontKnowText", val);
  }
  get locDontKnowText() {
    return this.getLocalizableString("dontKnowText");
  }
  createDefaultItem(defaultValue, name, locName) {
    const item = new ItemValue(defaultValue);
    const locStr = this.createLocalizableString(name, item, true, locName);
    item.locOwner = this;
    item.setLocText(locStr);
    return item;
  }
  /**
   * A Boolean expression that is evaluated against each choice item. If the expression evaluates to `false`, the choice item becomes hidden.
   *
   * A survey parses and runs all expressions on startup. If any values used in the expression change, the survey re-evaluates it.
   *
   * Use the `{item}` placeholder to reference the current choice item in the expression.
   *
   * Refer to the following help topic for more information: [Conditional Visibility](https://surveyjs.io/form-library/documentation/design-survey-conditional-logic#conditional-visibility).
   * @see visibleIf
   * @see choicesEnableIf
   */
  get choicesVisibleIf() {
    return this.getPropertyValue("choicesVisibleIf", "");
  }
  set choicesVisibleIf(val) {
    this.setPropertyValue("choicesVisibleIf", val);
    this.filterItems();
  }
  /**
   * A Boolean expression that is evaluated against each choice item. If the expression evaluates to `false`, the choice item becomes read-only.
   *
   * A survey parses and runs all expressions on startup. If any values used in the expression change, the survey re-evaluates it.
   *
   * Use the `{item}` placeholder to reference the current choice item in the expression.
   *
   * Refer to the following help topic for more information: [Conditional Visibility](https://surveyjs.io/form-library/documentation/design-survey-conditional-logic#conditional-visibility).
   * @see enableIf
   * @see choicesVisibleIf
   */
  get choicesEnableIf() {
    return this.getPropertyValue("choicesEnableIf", "");
  }
  set choicesEnableIf(val) {
    this.setPropertyValue("choicesEnableIf", val);
    this.filterItems();
  }
  surveyChoiceItemVisibilityChange() {
    this.filterItems();
  }
  runConditionCore(values, properties) {
    super.runConditionCore(values, properties);
    this.runItemsEnableCondition(values, properties);
    this.runItemsCondition(values, properties);
    this.choices.forEach((item) => {
      item.runConditionCore(values, properties);
    });
  }
  isTextValue() {
    return true;
  }
  setDefaultValue() {
    this.isSettingDefaultValue = !this.isValueEmpty(this.defaultValue) && this.hasUnknownValue(this.defaultValue);
    this.prevOtherValue = void 0;
    const prevComment = this.comment;
    super.setDefaultValue();
    this.isSettingDefaultValue = false;
    if (this.comment && this.getStoreOthersAsComment() && prevComment !== this.comment) {
      this.setValueCore(this.setOtherValueIntoValue(this.value));
      this.setCommentIntoData(this.comment);
    }
  }
  getIsMultipleValue() {
    return false;
  }
  convertDefaultValue(val) {
    if (val == null || val == void 0) return val;
    if (this.getIsMultipleValue()) {
      if (!Array.isArray(val)) return [val];
    } else {
      if (Array.isArray(val) && val.length > 0) return val[0];
    }
    return val;
  }
  filterItems() {
    if (this.isLoadingFromJson || !this.data || this.areInvisibleElementsShowing) return false;
    var values = this.getDataFilteredValues();
    var properties = this.getDataFilteredProperties();
    this.runItemsEnableCondition(values, properties);
    return this.runItemsCondition(values, properties);
  }
  runItemsCondition(values, properties) {
    this.setConditionalChoicesRunner();
    var hasChanges = this.runConditionsForItems(values, properties);
    if (!!this.filteredChoicesValue && this.filteredChoicesValue.length === this.activeChoices.length) {
      this.filteredChoicesValue = void 0;
    }
    if (hasChanges) {
      this.onVisibleChoicesChanged();
      this.clearIncorrectValues();
    }
    return hasChanges;
  }
  runItemsEnableCondition(values, properties) {
    this.setConditionalEnableChoicesRunner();
    var hasChanged = ItemValue.runEnabledConditionsForItems(this.activeChoices, this.conditionChoicesEnableIfRunner, values, properties, (item, val) => {
      return val && this.onEnableItemCallBack(item);
    });
    if (hasChanged) {
      this.clearDisabledValues();
    }
    this.onAfterRunItemsEnableCondition();
  }
  onAfterRunItemsEnableCondition() {
  }
  onEnableItemCallBack(item) {
    return true;
  }
  onSelectedItemValuesChangedHandler(newValue) {
    var _a;
    (_a = this.survey) === null || _a === void 0 ? void 0 : _a.loadedChoicesFromServer(this);
  }
  getItemIfChoicesNotContainThisValue(value, text) {
    if (this.waitingChoicesByURL) {
      return this.createItemValue(value, text);
    } else {
      return null;
    }
  }
  getSingleSelectedItem() {
    const selectedItemValues = this.selectedItemValues;
    if (this.isEmpty()) return null;
    const itemValue = ItemValue.getItemByValue(this.visibleChoices, this.value);
    this.onGetSingleSelectedItem(itemValue);
    if (!itemValue && (!selectedItemValues || this.value != selectedItemValues.id)) {
      this.updateSelectedItemValues();
    }
    return itemValue || selectedItemValues || (this.isOtherSelected ? this.otherItem : this.getItemIfChoicesNotContainThisValue(this.value));
  }
  onGetSingleSelectedItem(selectedItemByValue) {
  }
  getMultipleSelectedItems() {
    return [];
  }
  setConditionalChoicesRunner() {
    if (this.choicesVisibleIf) {
      if (!this.conditionChoicesVisibleIfRunner) {
        this.conditionChoicesVisibleIfRunner = new ConditionRunner(this.choicesVisibleIf);
      }
      this.conditionChoicesVisibleIfRunner.expression = this.choicesVisibleIf;
    } else {
      this.conditionChoicesVisibleIfRunner = null;
    }
  }
  setConditionalEnableChoicesRunner() {
    if (this.choicesEnableIf) {
      if (!this.conditionChoicesEnableIfRunner) {
        this.conditionChoicesEnableIfRunner = new ConditionRunner(this.choicesEnableIf);
      }
      this.conditionChoicesEnableIfRunner.expression = this.choicesEnableIf;
    } else {
      this.conditionChoicesEnableIfRunner = null;
    }
  }
  canSurveyChangeItemVisibility() {
    return !!this.survey && this.survey.canChangeChoiceItemsVisibility();
  }
  changeItemVisibility() {
    return this.canSurveyChangeItemVisibility() ? (item, val) => this.survey.getChoiceItemVisibility(this, item, val) : null;
  }
  runConditionsForItems(values, properties) {
    this.filteredChoicesValue = [];
    const calcVisibility = this.changeItemVisibility();
    return ItemValue.runConditionsForItems(this.activeChoices, this.getFilteredChoices(), this.areInvisibleElementsShowing ? null : this.conditionChoicesVisibleIfRunner, values, properties, !this.survey || !this.survey.areInvisibleElementsShowing, (item, val) => {
      return !!calcVisibility ? calcVisibility(item, val) : val;
    });
  }
  getHasOther(val) {
    return this.getIsItemValue(val, this.otherItem);
  }
  getIsItemValue(val, item) {
    return val === item.value;
  }
  get validatedValue() {
    return this.rendredValueToDataCore(this.value);
  }
  createRestful() {
    return new ChoicesRestful();
  }
  setNewRestfulProperty() {
    this.setPropertyValue("choicesByUrl", this.createRestful());
    this.choicesByUrl.owner = this;
    this.choicesByUrl.loadingOwner = this;
  }
  get autoOtherMode() {
    return this.getPropertyValue("autoOtherMode");
  }
  set autoOtherMode(val) {
    this.setPropertyValue("autoOtherMode", val);
  }
  getQuestionComment() {
    if (this.showCommentArea) return super.getQuestionComment();
    if (!!this.otherValueCore) return this.otherValueCore;
    if (this.hasComment || this.getStoreOthersAsComment()) return super.getQuestionComment();
    return this.otherValueCore;
  }
  selectOtherValueFromComment(val) {
    if (val) {
      this.prevIsOtherSelected = true;
    }
    this.value = val ? this.otherItem.value : void 0;
  }
  setQuestionComment(newValue) {
    this.updatePrevOtherErrorValue(newValue);
    if (this.showCommentArea) {
      super.setQuestionComment(newValue);
      return;
    }
    this.onUpdateCommentOnAutoOtherMode(newValue);
    if (this.getStoreOthersAsComment()) super.setQuestionComment(newValue);
    else {
      this.setOtherValueInternally(newValue);
    }
    this.updateChoicesDependedQuestions();
  }
  onUpdateCommentOnAutoOtherMode(newValue) {
    if (!this.autoOtherMode) return;
    this.prevOtherValue = void 0;
    const isSelected = this.isOtherSelected;
    if (!isSelected && !!newValue || isSelected && !newValue) {
      this.selectOtherValueFromComment(!!newValue);
    }
  }
  setOtherValueInternally(newValue) {
    if (!this.isSettingComment && newValue != this.otherValueCore) {
      this.isSettingComment = true;
      this.otherValueCore = newValue;
      if (this.isOtherSelected && !this.isRenderedValueSetting) {
        this.value = this.rendredValueToData(this.renderedValue);
      }
      this.isSettingComment = false;
    }
  }
  clearValue(keepComment) {
    super.clearValue(keepComment);
    this.prevOtherValue = void 0;
    this.selectedItemValues = void 0;
  }
  updateCommentFromSurvey(newValue) {
    super.updateCommentFromSurvey(newValue);
    this.prevOtherValue = void 0;
  }
  get renderedValue() {
    return this.getPropertyValue("renderedValue", null);
  }
  set renderedValue(val) {
    if (this.isReadOnlyAttr) return;
    this.setPropertyValue("renderedValue", val);
    var val = this.rendredValueToData(val);
    if (!this.isTwoValueEquals(val, this.value)) {
      this.value = val;
    }
  }
  setQuestionValue(newValue, updateIsAnswered = true, updateComment = true) {
    if (this.isLoadingFromJson || this.isTwoValueEquals(this.value, newValue)) return;
    super.setQuestionValue(newValue, updateIsAnswered);
    this.setPropertyValue("renderedValue", this.rendredValueFromData(newValue));
    this.updateChoicesDependedQuestions();
    if (this.hasComment || !updateComment) return;
    var isOtherSel = this.isOtherSelected;
    if (isOtherSel && !!this.prevOtherValue) {
      var oldOtherValue = this.prevOtherValue;
      this.prevOtherValue = void 0;
      this.otherValue = oldOtherValue;
    }
    if (!isOtherSel && !!this.otherValue) {
      if (this.getStoreOthersAsComment() && !this.autoOtherMode) {
        this.prevOtherValue = this.otherValue;
      }
      this.makeCommentEmpty = true;
      this.otherValueCore = "";
      this.setPropertyValue("comment", "");
    }
  }
  setValueCore(newValue) {
    super.setValueCore(newValue);
    if (this.makeCommentEmpty) {
      this.setCommentIntoData("");
      this.makeCommentEmpty = false;
    }
  }
  setNewValue(newValue) {
    newValue = this.valueFromData(newValue);
    if (!this.choicesByUrl.isRunning && !this.choicesByUrl.isWaitingForParameters || !this.isValueEmpty(newValue)) {
      this.cachedValueForUrlRequests = newValue;
    }
    super.setNewValue(newValue);
  }
  valueFromData(val) {
    let choiceitem = ItemValue.getItemByValue(this.activeChoices, val);
    if (!!choiceitem) {
      return choiceitem.value;
    }
    return super.valueFromData(val);
  }
  rendredValueFromData(val) {
    if (this.getStoreOthersAsComment()) return val;
    return this.renderedValueFromDataCore(val);
  }
  rendredValueToData(val) {
    if (this.getStoreOthersAsComment()) return val;
    return this.rendredValueToDataCore(val);
  }
  renderedValueFromDataCore(val) {
    if (!this.hasUnknownValue(val, true, false)) return this.valueFromData(val);
    this.otherValue = val;
    return this.otherItem.value;
  }
  rendredValueToDataCore(val) {
    if (val == this.otherItem.value && this.needConvertRenderedOtherToDataValue()) {
      val = this.otherValue;
    }
    return val;
  }
  needConvertRenderedOtherToDataValue() {
    let val = this.otherValue;
    if (!val) return false;
    val = val.trim();
    if (!val) return false;
    return this.hasUnknownValue(val, true, false);
  }
  getIsQuestionReady() {
    return super.getIsQuestionReady() && !this.waitingChoicesByURL && !this.waitingGetChoiceDisplayValueResponse;
  }
  updateSelectedItemValues() {
    if (this.waitingGetChoiceDisplayValueResponse || !this.survey || this.isEmpty()) return;
    const value = this.value;
    const valueArray = Array.isArray(value) ? value : [value];
    const hasItemWithoutValues = valueArray.some((val) => !ItemValue.getItemByValue(this.choices, val));
    if (hasItemWithoutValues && (this.choicesLazyLoadEnabled || this.hasChoicesUrl)) {
      this.waitingGetChoiceDisplayValueResponse = true;
      this.updateIsReady();
      this.survey.getChoiceDisplayValue({
        question: this,
        values: valueArray,
        setItems: (displayValues, ...customValues) => {
          this.waitingGetChoiceDisplayValueResponse = false;
          if (!displayValues || !displayValues.length) {
            this.updateIsReady();
            return;
          }
          const items = displayValues.map((displayValue2, index) => this.createItemValue(valueArray[index], displayValue2));
          this.setCustomValuesIntoItems(items, customValues);
          if (Array.isArray(value)) {
            this.selectedItemValues = items;
          } else {
            this.selectedItemValues = items[0];
          }
          this.updateIsReady();
        }
      });
    }
  }
  setCustomValuesIntoItems(items, customValues) {
    if (!Array.isArray(customValues) || customValues.length === 0) return;
    customValues.forEach((customValue) => {
      const vals = customValue.values;
      const propName = customValue.propertyName;
      if (Array.isArray(vals)) {
        for (let i = 0; i < items.length && i < vals.length; i++) {
          items[i][propName] = vals[i];
        }
      }
    });
  }
  hasUnknownValue(val, includeOther = false, isFilteredChoices = true, checkEmptyValue = false) {
    if (!Array.isArray(val)) return this.hasUnknownValueItem(val, includeOther, isFilteredChoices, checkEmptyValue);
    for (let i = 0; i < val.length; i++) {
      if (this.hasUnknownValueItem(val, includeOther, isFilteredChoices, checkEmptyValue)) return true;
    }
    return false;
  }
  hasUnknownValueItem(val, includeOther = false, isFilteredChoices = true, checkEmptyValue = false) {
    if (!checkEmptyValue && this.isValueEmpty(val)) return false;
    if (includeOther && val == this.otherItem.value) return false;
    if (this.showNoneItem && val == this.noneItem.value) return false;
    if (this.showRefuseItem && val == this.refuseItem.value) return false;
    if (this.showDontKnowItem && val == this.dontKnowItem.value) return false;
    var choices = isFilteredChoices ? this.getFilteredChoices() : this.activeChoices;
    return ItemValue.getItemByValue(choices, val) == null;
  }
  isValueDisabled(val) {
    var itemValue = ItemValue.getItemByValue(this.getFilteredChoices(), val);
    return !!itemValue && !itemValue.isEnabled;
  }
  endLoadingFromJson() {
    super.endLoadingFromJson();
    this.updateVisibleChoices();
  }
  /**
   * Configures access to a RESTful service that returns choice items. Refer to the [`ChoicesRestful`](https://surveyjs.io/form-library/documentation/choicesrestful) class description for more information. You can also specify additional application-wide settings using the [`settings.web`](https://surveyjs.io/form-library/documentation/api-reference/settings#web) object.
   *
   * [View Demo](https://surveyjs.io/form-library/examples/dropdown-menu-load-data-from-restful-service/ (linkStyle))
   * @see choices
   * @see [settings.specialChoicesOrder](https://surveyjs.io/form-library/documentation/api-reference/settings#specialChoicesOrder)
   */
  get choicesByUrl() {
    return this.getPropertyValue("choicesByUrl");
  }
  set choicesByUrl(val) {
    if (!val) return;
    this.setNewRestfulProperty();
    this.choicesByUrl.fromJSON(val.toJSON());
  }
  /**
   * Gets or sets choice items. This property accepts an array of objects with the following structure:
   *
   * ```js
   * {
   *   "value": any, // A unique value to be saved in the survey results.
   *   "text": String, // A display text. This property supports Markdown. When `text` is undefined, `value` is used.
   *   "imageLink": String // A link to the image or video that represents this choice value. Applies only to Image Picker questions.
   *   "customProperty": any // Any property that you find useful.
   * }
   * ```
   *
   * To enable Markdown support for the `text` property, implement Markdown-to-HTML conversion in the [`onTextMarkdown`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#onTextMarkdown) event handler. For an example, refer to the following demo: [Convert Markdown to HTML with markdown-it](https://surveyjs.io/form-library/examples/edit-survey-questions-markdown/).
   *
   * If you add custom properties, refer to the following help topic to learn how to serialize them into JSON: [Add Custom Properties to Property Grid](https://surveyjs.io/survey-creator/documentation/property-grid#add-custom-properties-to-the-property-grid).
   *
   * If you need to specify only the `value` property, you can set the `choices` property to an array of primitive values, for example, `[ "item1", "item2", "item3" ]`. These values are both saved in survey results and used as display text.
   * @see choicesByUrl
   * @see choicesFromQuestion
   * @see [settings.specialChoicesOrder](https://surveyjs.io/form-library/documentation/api-reference/settings#specialChoicesOrder)
   */
  get choices() {
    return this.getPropertyValue("choices");
  }
  set choices(newValue) {
    this.setPropertyValue("choices", newValue);
  }
  /**
   * Copies choice items from a specified question. Accepts a question name.
   *
   * If you specify this property, the `choices`, `choicesVisibleIf`, `choicesEnableIf`, and `choicesOrder` properties do not apply because their values are copied.
   *
   * In addition, you can specify the `choicesFromQuestionMode` property if you do not want to copy all choice items.
   * @see choicesFromQuestionMode
   * @see choices
   */
  get choicesFromQuestion() {
    return this.getPropertyValue("choicesFromQuestion");
  }
  set choicesFromQuestion(val) {
    var question = this.getQuestionWithChoices();
    this.isLockVisibleChoices = !!question && question.name === val;
    if (!!question && question.name !== val) {
      question.removeDependedQuestion(this);
      if (this.isInDesignMode && !this.isLoadingFromJson && !!val) {
        this.setPropertyValue("choicesFromQuestion", void 0);
      }
    }
    this.setPropertyValue("choicesFromQuestion", val);
    this.isLockVisibleChoices = false;
  }
  /**
   * Specifies which choice items to copy from another question. Applies only when the `choicesFromQuestion` property is specified.
   *
   * Possible values:
   *
   * - `"all"` (default) - Copies all choice items.
   * - `"selected"` - Copies only selected choice items.
   * - `"unselected"` - Copies only unselected choice items.
   *
   * Use the `visibleChoices` property to access copied choice items.
   * @see choicesFromQuestion
   * @see visibleChoices
   */
  get choicesFromQuestionMode() {
    return this.getPropertyValue("choicesFromQuestionMode");
  }
  set choicesFromQuestionMode(val) {
    this.setPropertyValue("choicesFromQuestionMode", val);
  }
  /**
   * Specifies which matrix column or dynamic panel question supplies choice values. Use this property to construct choice items based on cell values in Dynamic Matrix and question values in Dynamic Panel.
   *
   * Each choice item consists of a value saved in survey results and a text displayed in the UI. To construct a choice item, assign the `name` of a Dynamic Matrix or Dynamic Panel to the [`choicesFromQuestion`](#choicesFromQuestion) property and specify which dynamic panel question or matrix column supplies values and which provides texts. Use the `choiceValuesFromQuestion` and [`choiceTextsFromQuestion`](#choiceTextsFromQuestion) properties for this purpose. If a choice text is empty, a choice value is used as a display text and saved in survey results.
   */
  get choiceValuesFromQuestion() {
    return this.getPropertyValue("choiceValuesFromQuestion");
  }
  set choiceValuesFromQuestion(val) {
    this.setPropertyValue("choiceValuesFromQuestion", val);
  }
  /**
   * Specifies which matrix column or dynamic panel question supplies choice texts. Use this property to construct choice items based on cell values in Dynamic Matrix and question values in Dynamic Panel.
   *
   * Each choice item consists of a value saved in survey results and a text displayed in the UI. To construct a choice item, assign the `name` of a Dynamic Matrix or Dynamic Panel to the [`choicesFromQuestion`](#choicesFromQuestion) property and specify which dynamic panel question or matrix column supplies values and which provides texts. Use the [`choiceValuesFromQuestion`](#choiceValuesFromQuestion) and `choiceTextsFromQuestion` properties for this purpose. If a choice text is empty, a choice value is used as a display text and saved in survey results.
   */
  get choiceTextsFromQuestion() {
    return this.getPropertyValue("choiceTextsFromQuestion");
  }
  set choiceTextsFromQuestion(val) {
    this.setPropertyValue("choiceTextsFromQuestion", val);
  }
  /**
   * Specifies whether to hide the question if no choice items are visible.
   *
   * This property is useful if you show or hide choice items at runtime based on a [condition](https://surveyjs.io/form-library/documentation/questionselectbase#choicesVisibleIf).
   */
  get hideIfChoicesEmpty() {
    return this.getPropertyValue("hideIfChoicesEmpty");
  }
  set hideIfChoicesEmpty(val) {
    this.setPropertyValue("hideIfChoicesEmpty", val);
  }
  /**
   * Specifies whether to keep values that cannot be assigned to this question, for example, choices unlisted in the `choices` array.
   *
   * > This property cannot be specified in the survey JSON schema. Use dot notation to specify it.
   * @see clearIncorrectValues
   */
  get keepIncorrectValues() {
    return this.getPropertyValue("keepIncorrectValues", false);
  }
  set keepIncorrectValues(val) {
    this.setPropertyValue("keepIncorrectValues", val);
  }
  get storeOthersAsComment() {
    return this.getPropertyValue("storeOthersAsComment");
  }
  set storeOthersAsComment(val) {
    this.setPropertyValue("storeOthersAsComment", val);
  }
  hasOtherChanged() {
    this.onVisibleChoicesChanged();
  }
  /**
   * Specifies the sort order of choice items.
   *
   * Possible values:
   *
   * - `"none"` (default) - Preserves the original order of choice items.
   * - `"asc"`- Sorts choice items in ascending order.
   * - `"desc"`- Sorts choice items in ascending order.
   * - `"random"` - Displays choice items in random order.
   * @see [settings.specialChoicesOrder](https://surveyjs.io/form-library/documentation/api-reference/settings#specialChoicesOrder)
   */
  get choicesOrder() {
    return this.getPropertyValue("choicesOrder");
  }
  set choicesOrder(val) {
    val = val.toLowerCase();
    if (val == this.choicesOrder) return;
    this.setPropertyValue("choicesOrder", val);
    this.onVisibleChoicesChanged();
  }
  /**
   * Gets or sets a caption for the "Other" choice item.
   * @see showOtherItem
   */
  get otherText() {
    return this.getLocalizableStringText("otherText");
  }
  set otherText(val) {
    this.setLocalizableStringText("otherText", val);
    this.onVisibleChoicesChanged();
  }
  get locOtherText() {
    return this.getLocalizableString("otherText");
  }
  /**
   * Displays the "Select All", "None", and "Other" choices on individual rows.
   * @see showNoneItem
   * @see showOtherItem
   * @see [settings.specialChoicesOrder](https://surveyjs.io/form-library/documentation/api-reference/settings#specialChoicesOrder)
   */
  get separateSpecialChoices() {
    return this.getPropertyValue("separateSpecialChoices");
  }
  set separateSpecialChoices(val) {
    this.setPropertyValue("separateSpecialChoices", val);
  }
  /**
   * A placeholder for the comment area. Applies when the `showOtherItem` or `showCommentArea` property is `true`.
   * @see showOtherItem
   * @see showCommentArea
   */
  get otherPlaceholder() {
    return this.getLocalizableStringText("otherPlaceholder");
  }
  set otherPlaceholder(val) {
    this.setLocalizableStringText("otherPlaceholder", val);
  }
  get locOtherPlaceholder() {
    return this.getLocalizableString("otherPlaceholder");
  }
  get otherPlaceHolder() {
    return this.otherPlaceholder;
  }
  set otherPlaceHolder(newValue) {
    this.otherPlaceholder = newValue;
  }
  /**
   * Gets or sets an error message displayed when users select the "Other" choice item but leave the comment area empty.
   * @see showOtherItem
   */
  get otherErrorText() {
    return this.getLocalizableStringText("otherErrorText");
  }
  set otherErrorText(val) {
    this.setLocalizableStringText("otherErrorText", val);
  }
  get locOtherErrorText() {
    return this.getLocalizableString("otherErrorText");
  }
  /**
   * An array of visible choice items. Includes the "Select All", "Other", and "None" choice items if they are visible. Items are sorted according to the `choicesOrder` value.
   * @see showNoneItem
   * @see showOtherItem
   * @see choicesOrder
   * @see choices
   * @see enabledChoices
   */
  get visibleChoices() {
    return this.getPropertyValue("visibleChoices");
  }
  /**
   * An array of choice items with which users can interact. Includes the "Select All", "Other", and "None" choice items if they are not disabled. Items are sorted according to the `choicesOrder` value.
   * @see showNoneItem
   * @see showOtherItem
   * @see choicesOrder
   * @see choices
   * @see visibleChoices
   */
  get enabledChoices() {
    var res = [];
    var items = this.visibleChoices;
    for (var i = 0; i < items.length; i++) {
      if (items[i].isEnabled) res.push(items[i]);
    }
    return res;
  }
  updateVisibleChoices() {
    if (this.isLoadingFromJson || this.isDisposed) return;
    var newValue = new Array();
    var calcValue = this.calcVisibleChoices();
    if (!calcValue) calcValue = [];
    for (var i = 0; i < calcValue.length; i++) {
      newValue.push(calcValue[i]);
    }
    const oldValue = this.visibleChoices;
    if (!this.isTwoValueEquals(oldValue, newValue) || this.choicesLazyLoadEnabled) {
      this.setArrayPropertyDirectly("visibleChoices", newValue);
      this.updateRenderedChoices();
    }
  }
  calcVisibleChoices() {
    if (this.canUseFilteredChoices()) return this.getFilteredChoices();
    var res = this.sortVisibleChoices(this.getFilteredChoices().slice());
    this.addToVisibleChoices(res, this.isAddDefaultItems);
    return res;
  }
  canUseFilteredChoices() {
    return !this.isAddDefaultItems && !this.showNoneItem && !this.showRefuseItem && !this.showDontKnowItem && !this.hasOther && this.choicesOrder == "none";
  }
  setCanShowOptionItemCallback(func) {
    this.canShowOptionItemCallback = func;
    if (!!func) {
      this.onVisibleChoicesChanged();
    }
  }
  get newItem() {
    return this.newItemValue;
  }
  addToVisibleChoices(items, isAddAll) {
    this.headItemsCount = 0;
    this.footItemsCount = 0;
    if (!this.isEmptyActiveChoicesInDesign) {
      this.addNewItemToVisibleChoices(items, isAddAll);
    }
    const dict = new Array();
    this.addNonChoicesItems(dict, isAddAll);
    dict.sort((a, b) => {
      if (a.index === b.index) return 0;
      return a.index < b.index ? -1 : 1;
    });
    for (let i = 0; i < dict.length; i++) {
      const rec = dict[i];
      if (rec.index < 0) {
        items.splice(i, 0, rec.item);
        this.headItemsCount++;
      } else {
        items.push(rec.item);
        this.footItemsCount++;
      }
    }
  }
  addNewItemToVisibleChoices(items, isAddAll) {
    if (!isAddAll) return;
    if (!this.newItemValue) {
      this.newItemValue = this.createItemValue("newitem");
      this.newItemValue.isGhost = true;
      this.newItemValue.registerFunctionOnPropertyValueChanged("isVisible", () => {
        this.updateVisibleChoices();
      });
    }
    if (this.newItemValue.isVisible && !this.isUsingCarryForward && this.canShowOptionItem(this.newItemValue, isAddAll, false)) {
      this.footItemsCount = 1;
      items.push(this.newItemValue);
    }
  }
  addNonChoicesItems(dict, isAddAll) {
    if (this.supportNone()) {
      this.addNonChoiceItem(dict, this.noneItem, isAddAll, this.showNoneItem, settings.specialChoicesOrder.noneItem);
    }
    if (this.supportRefuse()) {
      this.addNonChoiceItem(dict, this.refuseItem, isAddAll, this.showRefuseItem, settings.specialChoicesOrder.refuseItem);
    }
    if (this.supportDontKnow()) {
      this.addNonChoiceItem(dict, this.dontKnowItem, isAddAll, this.showDontKnowItem, settings.specialChoicesOrder.dontKnowItem);
    }
    if (this.supportOther()) {
      this.addNonChoiceItem(dict, this.otherItem, isAddAll, this.hasOther, settings.specialChoicesOrder.otherItem);
    }
  }
  addNonChoiceItem(dict, item, isAddAll, showItem, order) {
    if (this.canShowOptionItem(item, isAddAll, showItem)) {
      order.forEach((val) => dict.push({
        index: val,
        item
      }));
    }
  }
  canShowOptionItem(item, isAddAll, hasItem) {
    let res = isAddAll && (!!this.canShowOptionItemCallback ? this.canShowOptionItemCallback(item) : true) || hasItem;
    if (this.canSurveyChangeItemVisibility()) {
      const calc = this.changeItemVisibility();
      return calc(item, res);
    }
    return res;
  }
  isItemInList(item) {
    if (item === this.otherItem) return this.hasOther;
    if (item === this.noneItem) return this.showNoneItem;
    if (item === this.refuseItem) return this.showRefuseItem;
    if (item === this.dontKnowItem) return this.showDontKnowItem;
    if (item === this.newItemValue) return false;
    return true;
  }
  get isAddDefaultItems() {
    return settings.showDefaultItemsInCreator && this.isInDesignMode && !this.customWidget;
  }
  getPlainData(options = {
    includeEmpty: true,
    includeQuestionTypes: false
  }) {
    var questionPlainData = super.getPlainData(options);
    if (!!questionPlainData) {
      var values = Array.isArray(this.value) ? this.value : [this.value];
      questionPlainData.isNode = true;
      questionPlainData.data = (questionPlainData.data || []).concat(values.map((dataValue, index) => {
        var choice = ItemValue.getItemByValue(this.visibleChoices, dataValue);
        var choiceDataItem = {
          name: index,
          title: this.getLocalizationString("choices_Choice"),
          value: dataValue,
          displayValue: this.getChoicesDisplayValue(this.visibleChoices, dataValue),
          getString: (val) => typeof val === "object" ? JSON.stringify(val) : val,
          isNode: false
        };
        if (!!choice) {
          (options.calculations || []).forEach((calculation) => {
            choiceDataItem[calculation.propertyName] = choice[calculation.propertyName];
          });
        }
        if (this.isOtherSelected && this.otherItemValue === choice) {
          choiceDataItem.isOther = true;
          choiceDataItem.displayValue = this.otherValue;
        }
        return choiceDataItem;
      }));
    }
    return questionPlainData;
  }
  getDisplayValueCore(keysAsText, value) {
    if (!this.useDisplayValuesInDynamicTexts) return value;
    return this.getChoicesDisplayValue(this.visibleChoices, value);
  }
  getDisplayValueEmpty() {
    return ItemValue.getTextOrHtmlByValue(this.visibleChoices, void 0);
  }
  getChoicesDisplayValue(items, val) {
    if (val == this.otherItemValue.value) return this.otherValue ? this.otherValue : this.locOtherText.textOrHtml;
    const selItem = this.getSingleSelectedItem();
    if (!!selItem && this.isTwoValueEquals(selItem.value, val)) return selItem.locText.textOrHtml;
    var str = ItemValue.getTextOrHtmlByValue(items, val);
    return str == "" && val ? val : str;
  }
  getDisplayArrayValue(keysAsText, value, onGetValueCallback) {
    var items = this.visibleChoices;
    var strs = [];
    const vals = [];
    for (var i = 0; i < value.length; i++) {
      vals.push(!onGetValueCallback ? value[i] : onGetValueCallback(i));
    }
    if (Helpers.isTwoValueEquals(this.value, vals)) {
      this.getMultipleSelectedItems().forEach((item, index) => strs.push(this.getItemDisplayValue(item, vals[index])));
    }
    if (strs.length === 0) {
      for (var i = 0; i < vals.length; i++) {
        let valStr = this.getChoicesDisplayValue(items, vals[i]);
        if (valStr) {
          strs.push(valStr);
        }
      }
    }
    return strs.join(settings.choicesSeparator);
  }
  getItemDisplayValue(item, val) {
    if (item === this.otherItem) {
      if (this.hasOther && this.showCommentArea && !!val) {
        return val;
      }
      if (this.comment) {
        return this.comment;
      }
    }
    return item.locText.textOrHtml;
  }
  getFilteredChoices() {
    return this.filteredChoicesValue ? this.filteredChoicesValue : this.activeChoices;
  }
  get activeChoices() {
    const question = this.getCarryForwardQuestion();
    if (this.carryForwardQuestionType === "select") {
      question.addDependedQuestion(this);
      return this.getChoicesFromSelectQuestion(question);
    }
    if (this.carryForwardQuestionType === "array") {
      question.addDependedQuestion(this);
      return this.getChoicesFromArrayQuestion(question);
    }
    if (this.isEmptyActiveChoicesInDesign) return [];
    return this.choicesFromUrl ? this.choicesFromUrl : this.getChoices();
  }
  get isMessagePanelVisible() {
    return this.getPropertyValue("isMessagePanelVisible", false);
  }
  set isMessagePanelVisible(val) {
    this.setPropertyValue("isMessagePanelVisible", val);
  }
  get isEmptyActiveChoicesInDesign() {
    return this.isInDesignMode && (this.hasChoicesUrl || this.isMessagePanelVisible);
  }
  getCarryForwardQuestion(data) {
    const question = this.findCarryForwardQuestion(data);
    const selBaseQuestion = this.getQuestionWithChoicesCore(question);
    const arrayQuestion = !selBaseQuestion ? this.getQuestionWithArrayValue(question) : null;
    this.setCarryForwardQuestionType(!!selBaseQuestion, !!arrayQuestion);
    return !!selBaseQuestion || !!arrayQuestion ? question : null;
  }
  getIsReadyDependsOn() {
    const res = super.getIsReadyDependsOn();
    if (this.carryForwardQuestion) {
      res.push(this.carryForwardQuestion);
    }
    return res;
  }
  getQuestionWithChoices() {
    return this.getQuestionWithChoicesCore(this.findCarryForwardQuestion());
  }
  findCarryForwardQuestion(data) {
    if (!data) data = this.data;
    this.carryForwardQuestion = null;
    if (this.choicesFromQuestion && data) {
      this.carryForwardQuestion = data.findQuestionByName(this.choicesFromQuestion);
    }
    return this.carryForwardQuestion;
  }
  getQuestionWithChoicesCore(question) {
    if (!!question && !!question.visibleChoices && Serializer.isDescendantOf(question.getType(), "selectbase") && question !== this) return question;
    return null;
  }
  getQuestionWithArrayValue(question) {
    return !!question && question.isValueArray ? question : null;
  }
  getChoicesFromArrayQuestion(question) {
    if (this.isInDesignMode) return [];
    const val = question.value;
    if (!Array.isArray(val)) return [];
    const res = [];
    for (var i = 0; i < val.length; i++) {
      const obj = val[i];
      if (!Helpers.isValueObject(obj)) continue;
      const key = this.getValueKeyName(obj);
      if (!!key && !this.isValueEmpty(obj[key])) {
        const text = !!this.choiceTextsFromQuestion ? obj[this.choiceTextsFromQuestion] : void 0;
        res.push(this.createItemValue(obj[key], text));
      }
    }
    return res;
  }
  getValueKeyName(obj) {
    if (this.choiceValuesFromQuestion) return this.choiceValuesFromQuestion;
    const keys = Object.keys(obj);
    return keys.length > 0 ? keys[0] : void 0;
  }
  getChoicesFromSelectQuestion(question) {
    if (this.isInDesignMode) return [];
    const res = [];
    var isSelected = this.choicesFromQuestionMode == "selected" ? true : this.choicesFromQuestionMode == "unselected" ? false : void 0;
    const choices = question.visibleChoices;
    for (var i = 0; i < choices.length; i++) {
      if (question.isBuiltInChoice(choices[i])) continue;
      if (isSelected === void 0) {
        res.push(this.copyChoiceItem(choices[i]));
        continue;
      }
      var itemsSelected = question.isItemSelected(choices[i]);
      if (itemsSelected && isSelected || !itemsSelected && !isSelected) {
        res.push(this.copyChoiceItem(choices[i]));
      }
    }
    if (this.choicesFromQuestionMode === "selected" && !this.showOtherItem && question.isOtherSelected && !!question.comment) {
      res.push(this.createItemValue(question.otherItem.value, question.comment));
    }
    return res;
  }
  copyChoiceItem(item) {
    const res = this.createItemValue(item.value);
    res.setData(item);
    return res;
  }
  get hasActiveChoices() {
    var choices = this.visibleChoices;
    if (!choices || choices.length == 0) {
      this.onVisibleChoicesChanged();
      choices = this.visibleChoices;
    }
    for (var i = 0; i < choices.length; i++) {
      if (!this.isBuiltInChoice(choices[i])) return true;
    }
    return false;
  }
  isBuiltInChoice(item) {
    return this.isNoneItem(item) || item === this.otherItem || item === this.newItemValue;
  }
  isNoneItem(item) {
    return this.getNoneItems().indexOf(item) > -1;
  }
  getNoneItems() {
    return [this.noneItem, this.refuseItem, this.dontKnowItem];
  }
  getChoices() {
    return this.choices;
  }
  supportOther() {
    return this.isSupportProperty("showOtherItem");
  }
  supportNone() {
    return this.isSupportProperty("showNoneItem");
  }
  supportRefuse() {
    return this.isSupportProperty("showRefuseItem");
  }
  supportDontKnow() {
    return this.isSupportProperty("showDontKnowItem");
  }
  isSupportProperty(propName) {
    return !this.isDesignMode || this.getPropertyByName(propName).visible;
  }
  onCheckForErrors(errors, isOnValueChanged, fireCallback) {
    super.onCheckForErrors(errors, isOnValueChanged, fireCallback);
    if (!this.hasOther || !this.isOtherSelected || this.otherValue || isOnValueChanged && !this.prevOtherErrorValue) return;
    const otherEmptyError = new OtherEmptyError(this.otherErrorText, this);
    otherEmptyError.onUpdateErrorTextCallback = (err) => {
      err.text = this.otherErrorText;
    };
    errors.push(otherEmptyError);
  }
  setSurveyImpl(value, isLight) {
    this.isRunningChoices = true;
    super.setSurveyImpl(value, isLight);
    this.isRunningChoices = false;
    this.runChoicesByUrl();
    if (this.isAddDefaultItems) {
      this.updateVisibleChoices();
    }
  }
  setSurveyCore(value) {
    super.setSurveyCore(value);
    if (!!value && !!this.choicesFromQuestion) {
      this.onVisibleChoicesChanged();
    }
  }
  getStoreOthersAsComment() {
    if (this.isSettingDefaultValue) return false;
    if (this.showCommentArea) return false;
    return this.storeOthersAsComment === true || this.storeOthersAsComment == "default" && (this.survey != null ? this.survey.storeOthersAsComment : true) || this.hasChoicesUrl && !this.choicesFromUrl;
  }
  onSurveyLoad() {
    this.runChoicesByUrl();
    this.onVisibleChoicesChanged();
    super.onSurveyLoad();
  }
  onAnyValueChanged(name, questionName) {
    super.onAnyValueChanged(name, questionName);
    if (name != this.getValueName()) {
      this.runChoicesByUrl();
    }
    const chQuestion = this.choicesFromQuestion;
    if (!!name && chQuestion && (name === chQuestion || questionName === chQuestion)) {
      this.onVisibleChoicesChanged();
      this.clearIncorrectValues();
    }
  }
  updateValueFromSurvey(newValue, clearData) {
    var newComment = "";
    if (this.hasOther && !this.isRunningChoices && !this.choicesByUrl.isRunning && this.getStoreOthersAsComment()) {
      if (this.hasUnknownValue(newValue) && !this.getHasOther(newValue)) {
        newComment = this.getCommentFromValue(newValue);
        newValue = this.setOtherValueIntoValue(newValue);
      } else {
        if (this.data) {
          newComment = this.data.getComment(this.getValueName());
        }
      }
    }
    super.updateValueFromSurvey(newValue, clearData);
    if ((this.isRunningChoices || this.choicesByUrl.isRunning) && !this.isEmpty()) {
      this.cachedValueForUrlRequests = this.value;
    }
    if (!!newComment) {
      this.setNewComment(newComment);
    }
  }
  getCommentFromValue(newValue) {
    return newValue;
  }
  setOtherValueIntoValue(newValue) {
    return this.otherItem.value;
  }
  onOtherValueInput(event) {
    if (this.isInputTextUpdate) {
      if (event.target) {
        this.otherValue = event.target.value;
      }
    } else {
      this.updateCommentElements();
    }
  }
  onOtherValueChange(event) {
    this.otherValue = event.target.value;
    if (this.otherValue !== event.target.value) {
      event.target.value = this.otherValue;
    }
  }
  runChoicesByUrl() {
    this.updateIsUsingRestful();
    if (!this.choicesByUrl || this.isLoadingFromJson || this.isRunningChoices || this.isInDesignMode) return;
    var processor = this.surveyImpl ? this.surveyImpl.getTextProcessor() : this.textProcessor;
    if (!processor) processor = this.survey;
    if (!processor) return;
    this.updateIsReady();
    this.isRunningChoices = true;
    this.choicesByUrl.run(processor);
    this.isRunningChoices = false;
  }
  onBeforeSendRequest() {
    if (settings.web.disableQuestionWhileLoadingChoices === true && !this.isReadOnly) {
      this.enableOnLoadingChoices = true;
      this.readOnly = true;
    }
  }
  onLoadChoicesFromUrl(array) {
    if (this.enableOnLoadingChoices) {
      this.readOnly = false;
    }
    const errors = [];
    if (!this.isReadOnly) {
      if (this.choicesByUrl && this.choicesByUrl.error) {
        errors.push(this.choicesByUrl.error);
      }
    }
    var newChoices = null;
    var checkCachedValuesOnExisting = true;
    if (this.isFirstLoadChoicesFromUrl && !this.cachedValueForUrlRequests && this.defaultValue) {
      this.cachedValueForUrlRequests = this.defaultValue;
      checkCachedValuesOnExisting = false;
    }
    if (this.isValueEmpty(this.cachedValueForUrlRequests)) {
      this.cachedValueForUrlRequests = this.value;
    }
    var cachedValues = this.createCachedValueForUrlRequests(this.cachedValueForUrlRequests, checkCachedValuesOnExisting);
    if (array && (array.length > 0 || this.choicesByUrl.allowEmptyResponse)) {
      newChoices = new Array();
      ItemValue.setData(newChoices, array);
    }
    if (!!newChoices) {
      for (var i = 0; i < newChoices.length; i++) {
        newChoices[i].locOwner = this;
      }
    }
    this.setChoicesFromUrl(newChoices, errors, cachedValues);
  }
  canAvoidSettChoicesFromUrl(newChoices) {
    if (this.isFirstLoadChoicesFromUrl) return false;
    const chocesAreEmpty = !newChoices || Array.isArray(newChoices) && newChoices.length === 0;
    if (chocesAreEmpty && !this.isEmpty()) return false;
    return Helpers.isTwoValueEquals(this.choicesFromUrl, newChoices);
  }
  setChoicesFromUrl(newChoices, errors, cachedValues) {
    if (this.canAvoidSettChoicesFromUrl(newChoices)) return;
    this.isFirstLoadChoicesFromUrl = false;
    this.choicesFromUrl = newChoices;
    this.filterItems();
    this.onVisibleChoicesChanged();
    if (newChoices) {
      var newValue = this.updateCachedValueForUrlRequests(cachedValues, newChoices);
      if (!!newValue && !this.isReadOnly) {
        var hasChanged = !this.isTwoValueEquals(this.value, newValue.value);
        try {
          if (!this.isValueEmpty(newValue.value)) {
            this.allowNotifyValueChanged = false;
            this.setQuestionValue(void 0, true, false);
          }
          this.allowNotifyValueChanged = hasChanged;
          if (hasChanged) {
            this.value = newValue.value;
          } else {
            this.setQuestionValue(newValue.value);
          }
        } finally {
          this.allowNotifyValueChanged = true;
        }
      }
    }
    if (!this.isReadOnly && !newChoices && !this.isFirstLoadChoicesFromUrl) {
      this.value = null;
    }
    this.errors = errors;
    this.choicesLoaded();
  }
  createCachedValueForUrlRequests(val, checkOnExisting) {
    if (this.isValueEmpty(val)) return null;
    if (Array.isArray(val)) {
      var res = [];
      for (var i = 0; i < val.length; i++) {
        res.push(this.createCachedValueForUrlRequests(val[i], true));
      }
      return res;
    }
    var isExists = checkOnExisting ? !this.hasUnknownValue(val) : true;
    return {
      value: val,
      isExists
    };
  }
  updateCachedValueForUrlRequests(val, newChoices) {
    if (this.isValueEmpty(val)) return null;
    if (Array.isArray(val)) {
      var res = [];
      for (var i = 0; i < val.length; i++) {
        var updatedValue = this.updateCachedValueForUrlRequests(val[i], newChoices);
        if (updatedValue && !this.isValueEmpty(updatedValue.value)) {
          var newValue = updatedValue.value;
          var item = ItemValue.getItemByValue(newChoices, updatedValue.value);
          if (!!item) {
            newValue = item.value;
          }
          res.push(newValue);
        }
      }
      return {
        value: res
      };
    }
    var value = val.isExists && this.hasUnknownValue(val.value) ? null : val.value;
    var item = ItemValue.getItemByValue(newChoices, value);
    if (!!item) {
      value = item.value;
    }
    return {
      value
    };
  }
  updateChoicesDependedQuestions() {
    if (this.isLoadingFromJson || this.isUpdatingChoicesDependedQuestions || !this.allowNotifyValueChanged || this.choicesByUrl.isRunning) return;
    this.isUpdatingChoicesDependedQuestions = true;
    this.updateDependedQuestions();
    this.isUpdatingChoicesDependedQuestions = false;
  }
  updateDependedQuestion() {
    this.onVisibleChoicesChanged();
    this.clearIncorrectValues();
  }
  onSurveyValueChanged(newValue) {
    super.onSurveyValueChanged(newValue);
    this.updateChoicesDependedQuestions();
  }
  onVisibleChoicesChanged() {
    if (this.isLoadingFromJson || this.isLockVisibleChoices) return;
    this.updateVisibleChoices();
    this.onVisibleChanged();
    if (!!this.visibleChoicesChangedCallback) {
      this.visibleChoicesChangedCallback();
    }
    this.updateChoicesDependedQuestions();
  }
  isVisibleCore() {
    const superVal = super.isVisibleCore();
    if (!this.hideIfChoicesEmpty || !superVal) return superVal;
    var choices = this.isUsingCarryForward ? this.visibleChoices : this.getFilteredChoices();
    return !choices || choices.length > 0;
  }
  sortVisibleChoices(array) {
    if (this.isInDesignMode) return array;
    var order = this.choicesOrder.toLowerCase();
    if (order == "asc") return this.sortArray(array, 1);
    if (order == "desc") return this.sortArray(array, -1);
    if (order == "random") return this.randomizeArray(array);
    return array;
  }
  sortArray(array, mult) {
    return array.sort(function(a, b) {
      return Helpers.compareStrings(a.calculatedText, b.calculatedText) * mult;
    });
  }
  randomizeArray(array) {
    return Helpers.randomizeArray(array);
  }
  get hasChoicesUrl() {
    return this.choicesByUrl && !!this.choicesByUrl.url;
  }
  clearIncorrectValues() {
    if (!this.hasValueToClearIncorrectValues() || !this.canClearIncorrectValues()) return;
    if (this.clearIncorrectValuesCallback) {
      this.clearIncorrectValuesCallback();
    } else {
      this.clearIncorrectValuesCore();
    }
  }
  canClearIncorrectValues() {
    if (this.carryForwardQuestion && !this.carryForwardQuestion.isReady) return false;
    if (!!this.survey && this.survey.questionsByValueName(this.getValueName()).length > 1) return false;
    if (this.hasChoicesUrl && (!this.choicesFromUrl || this.choicesFromUrl.length == 0)) return false;
    return true;
  }
  hasValueToClearIncorrectValues() {
    if (!!this.survey && this.survey.keepIncorrectValues) return false;
    return !this.keepIncorrectValues && !this.isEmpty();
  }
  clearValueIfInvisibleCore(reason) {
    super.clearValueIfInvisibleCore(reason);
    this.clearIncorrectValues();
  }
  /**
   * Returns `true` if a passed choice item is selected.
   *
   * To obtain a choice item to check, use the `noneItem` or `otherItem` property or the `choices` array.
   * @param item A choice item.
   * @see noneItem
   * @see otherItem
   * @see choices
   */
  isItemSelected(item) {
    if (item === this.otherItem) return this.isOtherSelected;
    return this.isItemSelectedCore(item);
  }
  isItemSelectedCore(item) {
    return item.value === this.value;
  }
  clearDisabledValues() {
    if (!this.survey || !this.survey.clearDisabledChoices) return;
    this.clearDisabledValuesCore();
  }
  clearIncorrectValuesCore() {
    var val = this.value;
    if (this.canClearValueAnUnknown(val)) {
      this.clearValue(true);
    }
  }
  canClearValueAnUnknown(val) {
    if (!this.getStoreOthersAsComment() && this.isOtherSelected) return false;
    return this.hasUnknownValue(val, true, true, true);
  }
  clearDisabledValuesCore() {
    if (this.isValueDisabled(this.value)) {
      this.clearValue(true);
    }
  }
  clearUnusedValues() {
    super.clearUnusedValues();
    if (!this.isOtherSelected) {
      this.otherValue = "";
    }
    if (!this.showCommentArea && !this.getStoreOthersAsComment() && !this.isOtherSelected) {
      this.comment = "";
    }
  }
  getColumnClass() {
    return new CssClassBuilder().append(this.cssClasses.column).append("sv-q-column-" + this.colCount, this.hasColumns).toString();
  }
  getItemIndex(item) {
    return this.visibleChoices.indexOf(item);
  }
  getItemClass(item) {
    const options = {
      item
    };
    var res = this.getItemClassCore(item, options);
    options.css = res;
    if (!!this.survey) {
      this.survey.updateChoiceItemCss(this, options);
    }
    return options.css;
  }
  getCurrentColCount() {
    return this.colCount;
  }
  getItemClassCore(item, options) {
    const builder = new CssClassBuilder().append(this.cssClasses.item).append(this.cssClasses.itemInline, !this.hasColumns && this.colCount === 0).append("sv-q-col-" + this.getCurrentColCount(), !this.hasColumns && this.colCount !== 0).append(this.cssClasses.itemOnError, this.hasCssError());
    const readOnlyStyles = this.getIsDisableAndReadOnlyStyles(!item.isEnabled);
    const isReadOnly = readOnlyStyles[0];
    const isDisabled = readOnlyStyles[1];
    const isChecked = this.isItemSelected(item) || this.isOtherSelected && this.otherItem.value === item.value;
    const allowHover = !isDisabled && !isChecked && !(!!this.survey && this.survey.isDesignMode);
    const isNone = item === this.noneItem;
    options.isDisabled = isDisabled || isReadOnly;
    options.isChecked = isChecked;
    options.isNone = isNone;
    return builder.append(this.cssClasses.itemDisabled, isDisabled).append(this.cssClasses.itemReadOnly, isReadOnly).append(this.cssClasses.itemPreview, this.isPreviewStyle).append(this.cssClasses.itemChecked, isChecked).append(this.cssClasses.itemHover, allowHover).append(this.cssClasses.itemNone, isNone).toString();
  }
  getLabelClass(item) {
    return new CssClassBuilder().append(this.cssClasses.label).append(this.cssClasses.labelChecked, this.isItemSelected(item)).toString();
  }
  getControlLabelClass(item) {
    return new CssClassBuilder().append(this.cssClasses.controlLabel).append(this.cssClasses.controlLabelChecked, this.isItemSelected(item)).toString() || void 0;
  }
  updateRenderedChoices() {
    this.renderedChoices = this.onGetRenderedChoicesCallback ? this.onGetRenderedChoicesCallback(this.visibleChoices) : this.visibleChoices;
  }
  getRenderedChoicesAnimationOptions() {
    return {
      isAnimationEnabled: () => {
        return this.animationAllowed;
      },
      getRerenderEvent: () => {
        return this.onElementRerendered;
      },
      getKey: (item) => item != this.newItemValue ? item.value : this.newItemValue,
      getLeaveOptions: (item) => {
        let cssClass = this.cssClasses.itemLeave;
        if (this.hasColumns) {
          const index = this.bodyItems.indexOf(item);
          if (index !== -1 && index !== this.bodyItems.length - 1) {
            cssClass = "";
          }
        }
        return {
          cssClass,
          onBeforeRunAnimation: prepareElementForVerticalAnimation,
          onAfterRunAnimation: cleanHtmlElementAfterAnimation
        };
      },
      getAnimatedElement: (item) => {
        return item.getRootElement();
      },
      getEnterOptions: (item) => {
        let cssClass = this.cssClasses.itemEnter;
        if (this.hasColumns) {
          const index = this.bodyItems.indexOf(item);
          if (index !== -1 && index !== this.bodyItems.length - 1) {
            cssClass = "";
          }
        }
        return {
          cssClass,
          onBeforeRunAnimation: (el) => {
            if (this.getCurrentColCount() == 0 && this.bodyItems.indexOf(item) >= 0) {
              const leftPosition = el.parentElement.firstElementChild.offsetLeft;
              if (el.offsetLeft > leftPosition) {
                setPropertiesOnElementForAnimation(el, {
                  moveAnimationDuration: "0s",
                  fadeAnimationDelay: "0s"
                }, "--");
              }
            }
            prepareElementForVerticalAnimation(el);
          },
          onAfterRunAnimation: cleanHtmlElementAfterAnimation
        };
      }
    };
  }
  get renderedChoices() {
    return this._renderedChoices;
  }
  set renderedChoices(val) {
    this.renderedChoicesAnimation.sync(val);
  }
  get headItems() {
    const count2 = this.separateSpecialChoices || this.isInDesignMode ? this.headItemsCount : 0;
    const res = [];
    for (let i = 0; i < count2; i++) {
      if (this.renderedChoices[i]) {
        res.push(this.renderedChoices[i]);
      }
    }
    return res;
  }
  get footItems() {
    const count2 = this.separateSpecialChoices || this.isInDesignMode ? this.footItemsCount : 0;
    const res = [];
    const items = this.renderedChoices;
    for (let i = 0; i < count2; i++) {
      if (this.renderedChoices[items.length - count2 + i]) {
        res.push(this.renderedChoices[items.length - count2 + i]);
      }
    }
    return res;
  }
  get dataChoices() {
    return this.renderedChoices.filter((item) => !this.isBuiltInChoice(item));
  }
  get bodyItems() {
    return this.hasHeadItems || this.hasFootItems ? this.dataChoices : this.renderedChoices;
  }
  get hasHeadItems() {
    return this.headItems.length > 0;
  }
  get hasFootItems() {
    return this.footItems.length > 0;
  }
  get itemFlowDirection() {
    return settings.itemFlowDirection;
  }
  get columns() {
    if (!this.hasColumns || this.renderedChoices.length === 0) return [];
    const colCount = this.getCurrentColCount();
    let choicesToBuildColumns = !this.separateSpecialChoices && !this.isInDesignMode ? this.renderedChoices : this.dataChoices;
    if (this.itemFlowDirection === "column") {
      return this.getColumnsWithColumnItemFlow(choicesToBuildColumns, colCount);
    } else {
      return this.getColumnsWithRowItemFlow(choicesToBuildColumns, colCount);
    }
  }
  getColumnsWithColumnItemFlow(choices, colCount) {
    const columns = [];
    let maxColumnHeight = Math.floor(choices.length / colCount);
    if (choices.length % colCount) {
      maxColumnHeight += 1;
    }
    let choicesLeft = choices.length;
    let columnsLeft = colCount;
    let indexShift = 0;
    for (let i = 0; i < colCount; i++) {
      const column = [];
      for (let j = 0; j < maxColumnHeight; j++) {
        if (choicesLeft <= columnsLeft) {
          maxColumnHeight = 1;
        }
        const choice = choices[j + indexShift];
        if (choice) {
          column.push(choice);
          choicesLeft--;
        }
      }
      columns.push(column);
      columnsLeft--;
      indexShift += column.length;
    }
    return columns;
  }
  getColumnsWithRowItemFlow(choices, colCount) {
    const columns = [];
    for (let i = 0; i < colCount; i++) {
      const column = [];
      for (let j = i; j < choices.length; j += colCount) {
        column.push(choices[j]);
      }
      columns.push(column);
    }
    return columns;
  }
  getItemsColumnKey(itemsColumn) {
    return (itemsColumn || []).map((c) => c.value || "").join("");
  }
  get hasColumns() {
    return !this.isMobile && this.getCurrentColCount() > 1;
  }
  get rowLayout() {
    return this.getCurrentColCount() == 0 && !(this.hasFootItems || this.hasHeadItems);
  }
  get blockedRow() {
    return this.getCurrentColCount() == 0 && (this.hasFootItems || this.hasHeadItems);
  }
  choicesLoaded() {
    this.isChoicesLoaded = true;
    this.updateIsReady();
    if (this.survey) {
      this.survey.loadedChoicesFromServer(this);
    }
    if (this.loadedChoicesFromServerCallback) {
      this.loadedChoicesFromServerCallback();
    }
  }
  getItemValueWrapperComponentName(item) {
    const survey = this.survey;
    if (survey) {
      return survey.getItemValueWrapperComponentName(item, this);
    }
    return SurveyModel.TemplateRendererComponentName;
  }
  getItemValueWrapperComponentData(item) {
    const survey = this.survey;
    if (survey) {
      return survey.getItemValueWrapperComponentData(item, this);
    }
    return item;
  }
  ariaItemChecked(item) {
    return this.renderedValue === item.value ? "true" : "false";
  }
  isOtherItem(item) {
    return this.hasOther && item.value == this.otherItem.value;
  }
  get itemSvgIcon() {
    if (this.isPreviewStyle && this.cssClasses.itemPreviewSvgIconId) {
      return this.cssClasses.itemPreviewSvgIconId;
    }
    return this.cssClasses.itemSvgIconId;
  }
  getSelectBaseRootCss() {
    return new CssClassBuilder().append(this.getQuestionRootCss()).append(this.cssClasses.rootRow, this.rowLayout).toString();
  }
  allowMobileInDesignMode() {
    return true;
  }
  getAriaItemLabel(item) {
    return item.locText.renderedHtml;
  }
  getItemId(item) {
    return this.inputId + "_" + this.getItemIndex(item);
  }
  get questionName() {
    return this.name + "_" + this.id;
  }
  getItemEnabled(item) {
    return !this.isDisabledAttr && item.isEnabled;
  }
  focusOtherComment() {
    var _a;
    SurveyElement.FocusElement(this.otherId, false, (_a = this.survey) === null || _a === void 0 ? void 0 : _a.rootElement);
  }
  onValueChanged() {
    super.onValueChanged();
    if (!this.isDesignMode && !this.prevIsOtherSelected && this.isOtherSelected) {
      this.focusOtherComment();
    }
    this.prevIsOtherSelected = this.isOtherSelected;
  }
  getDefaultItemComponent() {
    return "";
  }
  /**
   * The name of a component used to render items.
   *
   * [View Dropdown Demo](https://surveyjs.io/form-library/examples/dropdown-box-with-custom-items/ (linkStyle))
   *
   * [View Ranking Demo](https://surveyjs.io/form-library/examples/ranking-with-custom-items/ (linkStyle))
   */
  get itemComponent() {
    return this.getPropertyValue("itemComponent", this.getDefaultItemComponent());
  }
  set itemComponent(value) {
    this.setPropertyValue("itemComponent", value);
  }
};
__decorate([propertyArray()], QuestionSelectBase.prototype, "_renderedChoices", void 0);
var QuestionCheckboxBase = class extends QuestionSelectBase {
  constructor(name) {
    super(name);
  }
  /**
   * Gets or sets the number of columns used to arrange choice items.
   *
   * Set this property to 0 if you want to display all items in one line. The default value depends on the available width.
   * @see separateSpecialChoices
   */
  get colCount() {
    return this.getPropertyValue("colCount", this.isFlowLayout ? 0 : void 0);
  }
  set colCount(value) {
    if (value < 0 || value > 5 || this.isFlowLayout) return;
    this.setPropertyValue("colCount", value);
    this.fireCallback(this.colCountChangedCallback);
  }
  onParentChanged() {
    super.onParentChanged();
    if (this.isFlowLayout) {
      this.setPropertyValue("colCount", null);
    }
  }
  onParentQuestionChanged() {
    this.onVisibleChoicesChanged();
  }
  getSearchableItemValueKeys(keys) {
    keys.push("choices");
  }
};
function checkCopyPropVisibility(obj, mode) {
  var _a;
  if (!obj) return false;
  if (!!obj.templateQuestion) {
    const data = (_a = obj.colOwner) === null || _a === void 0 ? void 0 : _a.data;
    obj = obj.templateQuestion;
    if (!obj.getCarryForwardQuestion(data)) return false;
  }
  return obj.carryForwardQuestionType === mode;
}
Serializer.addClass("selectbase", [{
  name: "showCommentArea:switch",
  layout: "row",
  visible: true,
  category: "general"
}, "choicesFromQuestion:question_carryforward", {
  name: "choices:itemvalue[]",
  uniqueProperty: "value",
  baseValue: function() {
    return getLocaleString("choices_Item");
  },
  dependsOn: "choicesFromQuestion",
  visibleIf: (obj) => {
    return !obj.choicesFromQuestion;
  }
}, {
  name: "choicesFromQuestionMode",
  default: "all",
  choices: ["all", "selected", "unselected"],
  dependsOn: "choicesFromQuestion",
  visibleIf: (obj) => {
    return checkCopyPropVisibility(obj, "select");
  }
}, {
  name: "choiceValuesFromQuestion",
  dependsOn: "choicesFromQuestion",
  visibleIf: (obj) => {
    return checkCopyPropVisibility(obj, "array");
  }
}, {
  name: "choiceTextsFromQuestion",
  dependsOn: "choicesFromQuestion",
  visibleIf: (obj) => {
    return checkCopyPropVisibility(obj, "array");
  }
}, {
  name: "choicesOrder",
  default: "none",
  choices: ["none", "asc", "desc", "random"],
  dependsOn: "choicesFromQuestion",
  visibleIf: (obj) => {
    return !obj.choicesFromQuestion;
  }
}, {
  name: "choicesByUrl:restfull",
  className: "choicesByUrl",
  onGetValue: function(obj) {
    return obj.choicesByUrl.getData();
  },
  onSetValue: function(obj, value) {
    obj.choicesByUrl.setData(value);
  }
}, "hideIfChoicesEmpty:boolean", "choicesVisibleIf:condition", {
  name: "choicesEnableIf:condition",
  dependsOn: "choicesFromQuestion",
  visibleIf: (obj) => {
    return !obj.choicesFromQuestion;
  }
}, {
  name: "defaultValue:value",
  visibleIf: (obj) => !obj.choicesFromQuestion,
  dependsOn: "choicesFromQuestion"
}, {
  name: "correctAnswer:value",
  visibleIf: (obj) => !obj.choicesFromQuestion,
  dependsOn: "choicesFromQuestion"
}, {
  name: "separateSpecialChoices:boolean",
  visible: false
}, {
  name: "showOtherItem:boolean",
  alternativeName: "hasOther"
}, {
  name: "showNoneItem:boolean",
  alternativeName: "hasNone"
}, {
  name: "showRefuseItem:boolean",
  visible: false,
  version: "1.9.128"
}, {
  name: "showDontKnowItem:boolean",
  visible: false,
  version: "1.9.128"
}, {
  name: "otherPlaceholder",
  alternativeName: "otherPlaceHolder",
  serializationProperty: "locOtherPlaceholder",
  dependsOn: "showOtherItem",
  visibleIf: function(obj) {
    return obj.hasOther;
  }
}, {
  name: "noneText",
  serializationProperty: "locNoneText",
  dependsOn: "showNoneItem",
  visibleIf: function(obj) {
    return obj.showNoneItem;
  }
}, {
  name: "refuseText",
  serializationProperty: "locRefuseText",
  dependsOn: "showRefuseItem",
  visibleIf: function(obj) {
    return obj.showRefuseItem;
  }
}, {
  name: "dontKnowText",
  serializationProperty: "locDontKnowText",
  dependsOn: "showDontKnowItem",
  visibleIf: function(obj) {
    return obj.showDontKnowItem;
  }
}, {
  name: "otherText",
  serializationProperty: "locOtherText",
  dependsOn: "showOtherItem",
  visibleIf: function(obj) {
    return obj.hasOther;
  }
}, {
  name: "otherErrorText",
  serializationProperty: "locOtherErrorText",
  dependsOn: "showOtherItem",
  visibleIf: function(obj) {
    return obj.hasOther;
  }
}, {
  name: "storeOthersAsComment",
  default: "default",
  choices: ["default", true, false],
  visible: false
}], null, "question");
Serializer.addClass("checkboxbase", [{
  name: "colCount:number",
  default: 1,
  choices: [0, 1, 2, 3, 4, 5],
  layout: "row"
}], null, "selectbase");
var Rect = class {
  constructor(x, y, width, height) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
  }
  get left() {
    return this.x;
  }
  get top() {
    return this.y;
  }
  get right() {
    return this.x + this.width;
  }
  get bottom() {
    return this.y + this.height;
  }
};
var PopupUtils = class _PopupUtils {
  static calculatePosition(targetRect, height, width, verticalPosition, horizontalPosition, positionMode = "flex") {
    let currentLeft = targetRect.left;
    let currentTop = targetRect.top;
    if (positionMode === "flex") {
      if (horizontalPosition == "center") currentLeft = (targetRect.left + targetRect.right - width) / 2;
      else if (horizontalPosition == "left") currentLeft = targetRect.left - width;
      else currentLeft = targetRect.right;
    }
    if (verticalPosition == "middle") currentTop = (targetRect.top + targetRect.bottom - height) / 2;
    else if (verticalPosition == "top") currentTop = targetRect.top - height;
    else currentTop = targetRect.bottom;
    if (horizontalPosition != "center" && verticalPosition != "middle") {
      if (verticalPosition == "top") {
        currentTop = currentTop + targetRect.height;
      } else {
        currentTop = currentTop - targetRect.height;
      }
    }
    return {
      left: Math.round(currentLeft),
      top: Math.round(currentTop)
    };
  }
  static getCorrectedVerticalDimensions(top, height, windowHeight, verticalPosition, canShrink = true, margins = {
    top: 0,
    bottom: 0
  }) {
    let result;
    const maxHeight = windowHeight - _PopupUtils.bottomIndent;
    if (verticalPosition === "top") {
      result = {
        height,
        top
      };
    }
    if (top < -margins.top) {
      result = {
        height: canShrink ? height + top : height,
        top: -margins.top
      };
    } else if (height + top > windowHeight) {
      let newHeight = Math.min(height, maxHeight - top);
      result = {
        height: canShrink ? newHeight : height,
        top: canShrink ? top : top - (height - newHeight)
      };
    }
    if (result) {
      result.height = Math.min(result.height, maxHeight);
      result.top = Math.max(result.top, -margins.top);
    }
    return result;
  }
  static updateHorizontalDimensions(left, width, windowWidth, horizontalPosition, positionMode = "flex", margins = {
    left: 0,
    right: 0
  }) {
    width += margins.left + margins.right;
    let newWidth = void 0, newLeft = left;
    if (horizontalPosition === "center") {
      if (positionMode === "fixed") {
        if (left + width > windowWidth) {
          newWidth = windowWidth - left;
        }
        newLeft -= margins.left;
      } else {
        if (left < 0) {
          newLeft = margins.left;
          newWidth = Math.min(width, windowWidth);
        } else if (width + left > windowWidth) {
          newLeft = windowWidth - width;
          newLeft = Math.max(newLeft, margins.left);
          newWidth = Math.min(width, windowWidth);
        }
      }
    }
    if (horizontalPosition === "left") {
      if (left < 0) {
        newLeft = margins.left;
        newWidth = Math.min(width, windowWidth);
      }
    }
    if (horizontalPosition === "right") {
      if (width + left > windowWidth) {
        newWidth = windowWidth - left;
      }
    }
    return {
      width: newWidth - margins.left - margins.right,
      left: newLeft
    };
  }
  static updateVerticalPosition(targetRect, height, horizontalPosition, verticalPosition, windowHeight) {
    if (verticalPosition === "middle") return verticalPosition;
    let deltaTop = height - (targetRect.top + (horizontalPosition !== "center" ? targetRect.height : 0));
    let deltaBottom = height + targetRect.bottom - (horizontalPosition !== "center" ? targetRect.height : 0) - windowHeight;
    if (deltaTop > 0 && deltaBottom <= 0 && verticalPosition == "top") {
      verticalPosition = "bottom";
    } else if (deltaBottom > 0 && deltaTop <= 0 && verticalPosition == "bottom") {
      verticalPosition = "top";
    } else if (deltaBottom > 0 && deltaTop > 0) {
      verticalPosition = deltaTop < deltaBottom ? "top" : "bottom";
    }
    return verticalPosition;
  }
  static updateHorizontalPosition(targetRect, width, horizontalPosition, windowWidth) {
    if (horizontalPosition === "center") return horizontalPosition;
    let deltaLeft = width - targetRect.left;
    let deltaRight = width + targetRect.right - windowWidth;
    if (deltaLeft > 0 && deltaRight <= 0 && horizontalPosition == "left") {
      horizontalPosition = "right";
    } else if (deltaRight > 0 && deltaLeft <= 0 && horizontalPosition == "right") {
      horizontalPosition = "left";
    } else if (deltaRight > 0 && deltaLeft > 0) {
      horizontalPosition = deltaLeft < deltaRight ? "left" : "right";
    }
    return horizontalPosition;
  }
  static calculatePopupDirection(verticalPosition, horizontalPosition) {
    var popupDirection;
    if (horizontalPosition == "center" && verticalPosition != "middle") {
      popupDirection = verticalPosition;
    } else if (horizontalPosition != "center") {
      popupDirection = horizontalPosition;
    }
    return popupDirection;
  }
  //called when showPointer  is true
  static calculatePointerTarget(targetRect, top, left, verticalPosition, horizontalPosition, marginLeft = 0, marginRight = 0) {
    var targetPos = {};
    if (horizontalPosition != "center") {
      targetPos.top = targetRect.top + targetRect.height / 2;
      targetPos.left = targetRect[horizontalPosition];
    } else if (verticalPosition != "middle") {
      targetPos.top = targetRect[verticalPosition];
      targetPos.left = targetRect.left + targetRect.width / 2;
    }
    targetPos.left = Math.round(targetPos.left - left);
    targetPos.top = Math.round(targetPos.top - top);
    if (horizontalPosition == "left") {
      targetPos.left -= marginLeft + marginRight;
    }
    if (horizontalPosition === "center") {
      targetPos.left -= marginLeft;
    }
    return targetPos;
  }
};
PopupUtils.bottomIndent = 16;
var FOCUS_INPUT_SELECTOR = 'input:not(:disabled):not([readonly]):not([type=hidden]),select:not(:disabled):not([readonly]),textarea:not(:disabled):not([readonly]), button:not(:disabled):not([readonly]), [tabindex]:not([tabindex^="-"])';
var PopupBaseViewModel = class extends Base {
  updateIsVisible(val) {
    this._isVisible = val;
    this.onVisibilityChanged.fire(this, {
      isVisible: val
    });
  }
  updateBeforeShowing() {
    this.model.onShow();
  }
  updateAfterHiding() {
    this.model.onHiding();
  }
  getLeaveOptions() {
    return {
      cssClass: "sv-popup--leave",
      onBeforeRunAnimation: (el) => {
        el.setAttribute("inert", "");
      },
      onAfterRunAnimation: (el) => el.removeAttribute("inert")
    };
  }
  getEnterOptions() {
    return {
      cssClass: "sv-popup--enter"
    };
  }
  getAnimatedElement() {
    return this.getAnimationContainer();
  }
  isAnimationEnabled() {
    return this.model.displayMode !== "overlay" && settings.animationEnabled;
  }
  getRerenderEvent() {
    return this.onElementRerendered;
  }
  getAnimationContainer() {
    var _a;
    return (_a = this.container) === null || _a === void 0 ? void 0 : _a.querySelector(this.fixedPopupContainer);
  }
  get isVisible() {
    return this._isVisible;
  }
  set isVisible(val) {
    this.visibilityAnimation.sync(val);
  }
  get container() {
    return this.containerElement || this.createdContainer;
  }
  getLocale() {
    if (!!this.locale) return this.locale;
    return super.getLocale();
  }
  hidePopup() {
    this.model.isVisible = false;
  }
  getStyleClass() {
    return new CssClassBuilder().append(this.model.cssClass).append(`sv-popup--${this.model.displayMode}`, this.isOverlay);
  }
  getShowFooter() {
    return this.isOverlay;
  }
  getShowHeader() {
    return false;
  }
  getPopupHeaderTemplate() {
    return void 0;
  }
  createFooterActionBar() {
    this.footerToolbarValue = new ActionContainer();
    this.footerToolbar.updateCallback = (isResetInitialized) => {
      this.footerToolbarValue.actions.forEach((action) => action.cssClasses = {
        item: "sv-popup__body-footer-item sv-popup__button sd-btn"
      });
    };
    let footerActions = [{
      id: "cancel",
      visibleIndex: 10,
      title: this.cancelButtonText,
      innerCss: "sv-popup__button--cancel sd-btn",
      action: () => {
        this.cancel();
      }
    }];
    footerActions = this.model.updateFooterActions(footerActions);
    this.footerToolbarValue.setItems(footerActions);
  }
  resetDimensionsAndPositionStyleProperties() {
    const nullableValue = "";
    this.top = nullableValue;
    this.left = nullableValue;
    this.height = nullableValue;
    this.width = nullableValue;
    this.minWidth = nullableValue;
  }
  onModelChanging(newModel) {
  }
  setupModel(model) {
    if (!!this.model) {
      this.model.onVisibilityChanged.remove(this.onModelIsVisibleChangedCallback);
    }
    this.onModelChanging(model);
    this._model = model;
    model.onVisibilityChanged.add(this.onModelIsVisibleChangedCallback);
    this.onModelIsVisibleChangedCallback();
  }
  get model() {
    return this._model;
  }
  set model(model) {
    this.setupModel(model);
  }
  constructor(model) {
    super();
    this.popupSelector = ".sv-popup";
    this.fixedPopupContainer = ".sv-popup";
    this.containerSelector = ".sv-popup__container";
    this.scrollingContentSelector = ".sv-popup__scrolling-content";
    this.visibilityAnimation = new AnimationBoolean(this, (val) => {
      if (this._isVisible !== val) {
        if (!val) {
          this.updateOnHiding();
          this.updateIsVisible(val);
          this.updateAfterHiding();
          this._isPositionSetValue = false;
        } else {
          this.updateBeforeShowing();
          this.updateIsVisible(val);
        }
      }
    }, () => this._isVisible);
    this.onVisibilityChanged = new EventBase();
    this.onModelIsVisibleChangedCallback = () => {
      this.isVisible = this.model.isVisible;
    };
    this._isPositionSetValue = false;
    this.model = model;
    this.locale = this.model.locale;
  }
  get title() {
    return this.model.title;
  }
  get contentComponentName() {
    return this.model.contentComponentName;
  }
  get contentComponentData() {
    return this.model.contentComponentData;
  }
  get isModal() {
    return this.model.isModal;
  }
  get isFocusedContent() {
    return this.model.isFocusedContent;
  }
  get isFocusedContainer() {
    return this.model.isFocusedContainer;
  }
  get showFooter() {
    return this.getShowFooter();
  }
  get showHeader() {
    return this.getShowHeader();
  }
  get popupHeaderTemplate() {
    return this.getPopupHeaderTemplate();
  }
  get isOverlay() {
    return this.model.displayMode === "overlay";
  }
  get styleClass() {
    return this.getStyleClass().toString();
  }
  get cancelButtonText() {
    return this.getLocalizationString("modalCancelButtonText");
  }
  get footerToolbar() {
    if (!this.footerToolbarValue) {
      this.createFooterActionBar();
    }
    return this.footerToolbarValue;
  }
  onKeyDown(event) {
    if (event.key === "Tab" || event.keyCode === 9) {
      this.trapFocus(event);
    } else if (event.key === "Escape" || event.keyCode === 27) {
      this.hidePopup();
    }
  }
  trapFocus(event) {
    const focusableElements = this.container.querySelectorAll(FOCUS_INPUT_SELECTOR);
    const firstFocusableElement = focusableElements[0];
    const lastFocusableElement = focusableElements[focusableElements.length - 1];
    if (event.shiftKey) {
      if (settings.environment.root.activeElement === firstFocusableElement) {
        lastFocusableElement.focus();
        event.preventDefault();
      }
    } else {
      if (settings.environment.root.activeElement === lastFocusableElement) {
        firstFocusableElement.focus();
        event.preventDefault();
      }
    }
  }
  switchFocus() {
    if (this.isFocusedContent) {
      this.focusFirstInput();
    } else if (this.isFocusedContainer) {
      this.focusContainer();
    }
  }
  get isPositionSet() {
    return this._isPositionSetValue;
  }
  updateOnShowing() {
    this.prevActiveElement = settings.environment.root.activeElement;
    if (this.isOverlay) {
      this.resetDimensionsAndPositionStyleProperties();
    }
    this.switchFocus();
    this._isPositionSetValue = true;
  }
  updateOnHiding() {
    if (this.isFocusedContent && this.prevActiveElement) {
      this.prevActiveElement.focus({
        preventScroll: true
      });
    }
  }
  focusContainer() {
    if (!this.container) return;
    const popup = this.container.querySelector(this.popupSelector);
    popup === null || popup === void 0 ? void 0 : popup.focus();
  }
  focusFirstInput() {
    setTimeout(() => {
      if (!this.container) return;
      var el = this.container.querySelector(this.model.focusFirstInputSelector || FOCUS_INPUT_SELECTOR);
      if (!!el) el.focus();
      else this.focusContainer();
    }, 100);
  }
  clickOutside(event) {
    this.hidePopup();
    event === null || event === void 0 ? void 0 : event.stopPropagation();
  }
  cancel() {
    this.model.onCancel();
    this.hidePopup();
  }
  dispose() {
    super.dispose();
    if (this.model) {
      this.model.onVisibilityChanged.remove(this.onModelIsVisibleChangedCallback);
    }
    if (!!this.createdContainer) {
      this.createdContainer.remove();
      this.createdContainer = void 0;
    }
    if (!!this.footerToolbarValue) {
      this.footerToolbarValue.dispose();
    }
    this.resetComponentElement();
  }
  initializePopupContainer() {
    if (!this.container) {
      const container = DomDocumentHelper.createElement("div");
      this.createdContainer = container;
      getElement(settings.environment.popupMountContainer).appendChild(container);
    }
  }
  setComponentElement(componentRoot) {
    if (!!componentRoot) {
      this.containerElement = componentRoot;
    }
  }
  resetComponentElement() {
    this.containerElement = void 0;
    this.prevActiveElement = void 0;
  }
  preventScrollOuside(event, deltaY) {
    let currentElement = event.target;
    while (currentElement !== this.container) {
      if (DomDocumentHelper.getComputedStyle(currentElement).overflowY === "auto" && currentElement.scrollHeight !== currentElement.offsetHeight) {
        const {
          scrollHeight,
          scrollTop,
          clientHeight
        } = currentElement;
        if (!(deltaY > 0 && Math.abs(scrollHeight - clientHeight - scrollTop) < 1) && !(deltaY < 0 && scrollTop <= 0)) {
          return;
        }
      }
      currentElement = currentElement.parentElement;
    }
    if (event.cancelable) {
      event.preventDefault();
    }
  }
};
__decorate([property({
  defaultValue: "0px"
})], PopupBaseViewModel.prototype, "top", void 0);
__decorate([property({
  defaultValue: "0px"
})], PopupBaseViewModel.prototype, "left", void 0);
__decorate([property({
  defaultValue: "auto"
})], PopupBaseViewModel.prototype, "height", void 0);
__decorate([property({
  defaultValue: "auto"
})], PopupBaseViewModel.prototype, "width", void 0);
__decorate([property({
  defaultValue: "auto"
})], PopupBaseViewModel.prototype, "minWidth", void 0);
__decorate([property({
  defaultValue: false
})], PopupBaseViewModel.prototype, "_isVisible", void 0);
__decorate([property()], PopupBaseViewModel.prototype, "locale", void 0);
function calculateIsTablet(windowWidth, windowHeight) {
  const _windowWidth = windowWidth || DomWindowHelper.getInnerWidth();
  const _windowHeight = windowHeight || DomWindowHelper.getInnerHeight();
  const width = Math.min(_windowWidth, _windowHeight);
  const isTablet = width >= PopupDropdownViewModel.tabletSizeBreakpoint;
  return isTablet;
}
var PopupDropdownViewModel = class extends PopupBaseViewModel {
  calculateIsTablet(windowWidth, windowHeight) {
    this.isTablet = calculateIsTablet(windowWidth, windowHeight);
  }
  getAvailableAreaRect() {
    const areaElement = this.model.getAreaCallback ? this.model.getAreaCallback(this.container) : void 0;
    if (areaElement) {
      const areaRect = areaElement.getBoundingClientRect();
      return new Rect(areaRect.x, areaRect.y, areaRect.width, areaRect.height);
    }
    return new Rect(0, 0, DomWindowHelper.getInnerWidth(), DomWindowHelper.getInnerHeight());
  }
  getTargetElementRect() {
    const componentRoot = this.container;
    let targetElement = this.model.getTargetCallback ? this.model.getTargetCallback(componentRoot) : void 0;
    if (!!componentRoot && !!componentRoot.parentElement && !this.isModal && !targetElement) {
      targetElement = componentRoot.parentElement;
    }
    if (!targetElement) return null;
    const rect = targetElement.getBoundingClientRect();
    const areaRect = this.getAvailableAreaRect();
    return new Rect(rect.left - areaRect.left, rect.top - areaRect.top, rect.width, rect.height);
  }
  _updatePosition() {
    var _a, _b, _c;
    const targetElementRect = this.getTargetElementRect();
    if (!targetElementRect) return;
    const area = this.getAvailableAreaRect();
    const popupContainer = (_a = this.container) === null || _a === void 0 ? void 0 : _a.querySelector(this.containerSelector);
    if (!popupContainer) return;
    const fixedPopupContainer = (_b = this.container) === null || _b === void 0 ? void 0 : _b.querySelector(this.fixedPopupContainer);
    const scrollContent = popupContainer.querySelector(this.scrollingContentSelector);
    const popupComputedStyle = DomDocumentHelper.getComputedStyle(popupContainer);
    const marginLeft = parseFloat(popupComputedStyle.marginLeft) || 0;
    const marginRight = parseFloat(popupComputedStyle.marginRight) || 0;
    const marginTop = parseFloat(popupComputedStyle.marginTop) || 0;
    const marginBottom = parseFloat(popupComputedStyle.marginBottom) || 0;
    let height = popupContainer.offsetHeight - scrollContent.offsetHeight + scrollContent.scrollHeight;
    const width = popupContainer.getBoundingClientRect().width;
    this.model.setWidthByTarget && (this.minWidth = targetElementRect.width + "px");
    let verticalPosition = this.model.verticalPosition;
    let actualHorizontalPosition = this.getActualHorizontalPosition();
    if (DomWindowHelper.isAvailable()) {
      const heightValues = [height, DomWindowHelper.getInnerHeight() * 0.9, (_c = DomWindowHelper.getVisualViewport()) === null || _c === void 0 ? void 0 : _c.height];
      height = Math.ceil(Math.min(...heightValues.filter((each) => typeof each === "number")));
      verticalPosition = PopupUtils.updateVerticalPosition(targetElementRect, height, this.model.horizontalPosition, this.model.verticalPosition, area.height);
      actualHorizontalPosition = PopupUtils.updateHorizontalPosition(targetElementRect, width, actualHorizontalPosition, area.width);
    }
    this.popupDirection = PopupUtils.calculatePopupDirection(verticalPosition, actualHorizontalPosition);
    const pos = PopupUtils.calculatePosition(targetElementRect, height, width + marginLeft + marginRight, verticalPosition, actualHorizontalPosition, this.model.positionMode);
    if (DomWindowHelper.isAvailable()) {
      const newVerticalDimensions = PopupUtils.getCorrectedVerticalDimensions(pos.top, height, area.height, verticalPosition, this.model.canShrink, {
        top: marginTop,
        bottom: marginBottom
      });
      if (!!newVerticalDimensions) {
        this.height = newVerticalDimensions.height + "px";
        pos.top = newVerticalDimensions.top;
      }
      if (this.model.setWidthByTarget) {
        this.width = targetElementRect.width + "px";
        pos.left = targetElementRect.left;
      } else {
        const newHorizontalDimensions = PopupUtils.updateHorizontalDimensions(pos.left, width, DomWindowHelper.getInnerWidth(), actualHorizontalPosition, this.model.positionMode, {
          left: marginLeft,
          right: marginRight
        });
        if (!!newHorizontalDimensions) {
          this.width = newHorizontalDimensions.width ? newHorizontalDimensions.width + "px" : void 0;
          pos.left = newHorizontalDimensions.left;
        }
      }
    }
    if (!!fixedPopupContainer) {
      const rect = fixedPopupContainer.getBoundingClientRect();
      pos.top -= rect.top;
      pos.left -= rect.left;
    }
    pos.left += area.left;
    pos.top += area.top;
    this.left = pos.left + "px";
    this.top = pos.top + "px";
    if (this.showHeader) {
      this.pointerTarget = PopupUtils.calculatePointerTarget(targetElementRect, pos.top, pos.left, verticalPosition, actualHorizontalPosition, marginLeft, marginRight);
      this.pointerTarget.top += "px";
      this.pointerTarget.left += "px";
    }
  }
  getActualHorizontalPosition() {
    let actualHorizontalPosition = this.model.horizontalPosition;
    if (DomDocumentHelper.isAvailable()) {
      let isRtl = DomDocumentHelper.getComputedStyle(DomDocumentHelper.getBody()).direction == "rtl";
      if (isRtl) {
        if (this.model.horizontalPosition === "left") {
          actualHorizontalPosition = "right";
        } else if (this.model.horizontalPosition === "right") {
          actualHorizontalPosition = "left";
        }
      }
    }
    return actualHorizontalPosition;
  }
  getStyleClass() {
    const overlayMode = this.model.overlayDisplayMode;
    return super.getStyleClass().append("sv-popup--dropdown", !this.isOverlay).append("sv-popup--dropdown-overlay", this.isOverlay && overlayMode !== "plain").append("sv-popup--tablet", this.isOverlay && (overlayMode == "tablet-dropdown-overlay" || overlayMode == "auto" && this.isTablet)).append("sv-popup--show-pointer", !this.isOverlay && this.showHeader).append(`sv-popup--${this.popupDirection}`, !this.isOverlay && (this.showHeader || this.popupDirection == "top" || this.popupDirection == "bottom"));
  }
  getShowHeader() {
    return this.model.showPointer && !this.isOverlay;
  }
  getPopupHeaderTemplate() {
    return "popup-pointer";
  }
  constructor(model) {
    super(model);
    this.scrollEventCallBack = (event) => {
      if (this.isOverlay && IsTouch) {
        event.stopPropagation();
        event.preventDefault();
        return;
      }
      this.hidePopup();
    };
    this.resizeEventCallback = () => {
      if (!DomWindowHelper.isAvailable()) return;
      const visualViewport = DomWindowHelper.getVisualViewport();
      const documentElement = DomDocumentHelper.getDocumentElement();
      if (!!documentElement && !!visualViewport) {
        documentElement.style.setProperty("--sv-popup-overlay-height", `${visualViewport.height * visualViewport.scale}px`);
      }
    };
    this.resizeWindowCallback = () => {
      if (!this.isOverlay) {
        this.updatePosition(true, SurveyModel.platform === "vue" || SurveyModel.platform === "vue3" || SurveyModel.platform == "react" || SurveyModel.platform == "js-ui");
      }
    };
    this.clientY = 0;
    this.isTablet = false;
    this.touchStartEventCallback = (event) => {
      this.clientY = event.touches[0].clientY;
    };
    this.touchMoveEventCallback = (event) => {
      this.preventScrollOuside(event, this.clientY - event.changedTouches[0].clientY);
    };
    this.model.onRecalculatePosition.add(this.recalculatePositionHandler);
  }
  setComponentElement(componentRoot) {
    super.setComponentElement(componentRoot);
  }
  resetComponentElement() {
    super.resetComponentElement();
  }
  updateOnShowing() {
    const {
      root
    } = settings.environment;
    this.prevActiveElement = root.activeElement;
    if (this.isOverlay) {
      this.resetDimensionsAndPositionStyleProperties();
    } else {
      this.updatePosition(true, false);
    }
    this.switchFocus();
    DomWindowHelper.addEventListener("resize", this.resizeWindowCallback);
    if (this.shouldCreateResizeCallback) {
      DomWindowHelper.getVisualViewport().addEventListener("resize", this.resizeEventCallback);
      if (this.container) {
        this.container.addEventListener("touchstart", this.touchStartEventCallback);
        this.container.addEventListener("touchmove", this.touchMoveEventCallback);
      }
      this.calculateIsTablet();
      this.resizeEventCallback();
    }
    DomWindowHelper.addEventListener("scroll", this.scrollEventCallBack);
    this._isPositionSetValue = true;
  }
  get shouldCreateResizeCallback() {
    return !!DomWindowHelper.getVisualViewport() && this.isOverlay && IsTouch;
  }
  updatePosition(isResetHeight, isDelayUpdating = true) {
    if (isResetHeight) {
      this.height = "auto";
    }
    if (isDelayUpdating) {
      setTimeout(() => {
        this._updatePosition();
      }, 1);
    } else {
      this._updatePosition();
    }
  }
  updateOnHiding() {
    super.updateOnHiding();
    DomWindowHelper.removeEventListener("resize", this.resizeWindowCallback);
    if (this.shouldCreateResizeCallback) {
      DomWindowHelper.getVisualViewport().removeEventListener("resize", this.resizeEventCallback);
      if (this.container) {
        this.container.removeEventListener("touchstart", this.touchStartEventCallback);
        this.container.removeEventListener("touchmove", this.touchMoveEventCallback);
      }
    }
    DomWindowHelper.removeEventListener("scroll", this.scrollEventCallBack);
    if (!this.isDisposed) {
      this.top = void 0;
      this.left = void 0;
      this.height = void 0;
      this.width = void 0;
      this.minWidth = void 0;
    }
  }
  onModelChanging(newModel) {
    if (!!this.model) {
      this.model.onRecalculatePosition.remove(this.recalculatePositionHandler);
    }
    if (!this.recalculatePositionHandler) {
      this.recalculatePositionHandler = (_, options) => {
        if (!this.isOverlay) {
          this.updatePosition(options.isResetHeight);
        }
      };
    }
    super.onModelChanging(newModel);
    newModel.onRecalculatePosition.add(this.recalculatePositionHandler);
  }
  dispose() {
    super.dispose();
    this.updateOnHiding();
    if (!!this.model) {
      this.model.onRecalculatePosition.remove(this.recalculatePositionHandler);
      this.recalculatePositionHandler = void 0;
    }
    this.resetComponentElement();
  }
};
PopupDropdownViewModel.tabletSizeBreakpoint = 600;
__decorate([property()], PopupDropdownViewModel.prototype, "isTablet", void 0);
__decorate([property({
  defaultValue: "left"
})], PopupDropdownViewModel.prototype, "popupDirection", void 0);
__decorate([property({
  defaultValue: {
    left: "0px",
    top: "0px"
  }
})], PopupDropdownViewModel.prototype, "pointerTarget", void 0);
var DropdownListModel = class extends Base {
  get focusFirstInputSelector() {
    return this.getFocusFirstInputSelector();
  }
  getFocusFirstInputSelector() {
    if (IsTouch) {
      return this.isValueEmpty(this.question.value) ? this.itemSelector : this.selectedItemSelector;
    } else {
      return !this.listModel.showFilter && !!this.question.value ? this.selectedItemSelector : "";
    }
  }
  resetItemsSettings() {
    this.itemsSettings.skip = 0;
    this.itemsSettings.take = Math.max(this.minPageSize, this.question.choicesLazyLoadPageSize);
    this.itemsSettings.totalCount = 0;
    this.itemsSettings.items = [];
  }
  setItems(items, totalCount) {
    this.itemsSettings.items = [].concat(this.itemsSettings.items, items);
    this.itemsSettings.totalCount = totalCount;
    this.listModel.isAllDataLoaded = this.question.choicesLazyLoadEnabled && this.itemsSettings.items.length == this.itemsSettings.totalCount;
    this.question.choices = this.itemsSettings.items;
  }
  loadQuestionChoices(callbackAfterItemsLoaded) {
    this.question.survey.loadQuestionChoices({
      question: this.question,
      filter: this.filterString,
      skip: this.itemsSettings.skip,
      take: this.itemsSettings.take,
      setItems: (items, totalCount) => {
        this.setItems(items || [], totalCount || 0);
        this.popupRecalculatePosition(this.itemsSettings.skip === this.itemsSettings.take);
        if (!!callbackAfterItemsLoaded) {
          callbackAfterItemsLoaded();
        }
      }
    });
    this.itemsSettings.skip += this.itemsSettings.take;
  }
  updateQuestionChoices(callbackAfterItemsLoaded) {
    const isUpdate = this.itemsSettings.skip + 1 < this.itemsSettings.totalCount;
    if (!this.itemsSettings.skip || isUpdate) {
      this.resetTimer();
      if (!!this.filterString && settings.dropdownSearchDelay > 0) {
        this.timer = setTimeout(() => {
          this.loadQuestionChoices(callbackAfterItemsLoaded);
        }, settings.dropdownSearchDelay);
      } else {
        this.loadQuestionChoices(callbackAfterItemsLoaded);
      }
    }
  }
  resetTimer() {
    if (!!this.timer) {
      clearTimeout(this.timer);
      this.timer = void 0;
    }
  }
  updatePopupFocusFirstInputSelector() {
    this._popupModel.focusFirstInputSelector = this.focusFirstInputSelector;
  }
  getDropdownMenuOptions() {
    const windowWidth = DomWindowHelper.getInnerWidth();
    const windowHeight = DomWindowHelper.getInnerHeight();
    const isTablet = calculateIsTablet(windowWidth, windowHeight);
    let menuType = "dropdown";
    let deviceType = "desktop";
    if (IsTouch) {
      menuType = isTablet ? "popup" : "overlay";
      deviceType = isTablet ? "tablet" : "mobile";
    }
    return {
      menuType,
      deviceType,
      hasTouchScreen: IsTouch,
      screenHeight: windowHeight,
      screenWidth: windowWidth
    };
  }
  createPopup() {
    const popupOptions = {
      verticalPosition: "bottom",
      horizontalPosition: "center",
      showPointer: false
    };
    this._popupModel = new PopupModel("sv-list", {
      model: this.listModel
    }, popupOptions);
    this._popupModel.displayMode = IsTouch ? "overlay" : "popup";
    this._popupModel.positionMode = "fixed";
    this._popupModel.isFocusedContainer = false;
    this._popupModel.isFocusedContent = IsTouch;
    this._popupModel.setWidthByTarget = !IsTouch;
    this._popupModel.locale = this.question.getLocale();
    this.updatePopupFocusFirstInputSelector();
    this.listModel.registerPropertyChangedHandlers(["showFilter"], () => {
      this.updatePopupFocusFirstInputSelector();
    });
    this._popupModel.onVisibilityChanged.add((_, option) => {
      if (option.isVisible) {
        this.listModel.renderElements = true;
      }
      if (option.isVisible && this.question.choicesLazyLoadEnabled) {
        this.listModel.actions = [];
        this.resetItemsSettings();
        this.updateQuestionChoices();
      }
      if (option.isVisible) {
        this.updatePopupFocusFirstInputSelector();
        const dropdownMenuOptions = this.getDropdownMenuOptions();
        const prevMenuType = dropdownMenuOptions.menuType;
        this.question.processOpenDropdownMenu(dropdownMenuOptions);
        if (prevMenuType !== dropdownMenuOptions.menuType) {
          this._popupModel.updateDisplayMode(dropdownMenuOptions.menuType);
          this.listModel.setSearchEnabled(this.searchEnabled && dropdownMenuOptions.menuType !== "dropdown");
        }
        if (!!this.question.onOpenedCallBack) {
          this.question.onOpenedCallBack();
        }
      }
      if (!option.isVisible) {
        this.onHidePopup();
        if (this.question.choicesLazyLoadEnabled) {
          this.resetItemsSettings();
        }
      }
      this.question.ariaExpanded = option.isVisible ? "true" : "false";
      this.question.processPopupVisiblilityChanged(this.popupModel, option.isVisible);
    });
  }
  setFilterStringToListModel(newValue) {
    this.listModel.filterString = newValue;
    this.listModel.resetFocusedItem();
    if (this.question.selectedItem && this.question.selectedItem.text.indexOf(newValue) >= 0) {
      this.listModel.focusedItem = this.getAvailableItems().filter((item) => item.id == this.question.selectedItem.value)[0];
      if (this.listModel.filterString) {
        this.listModel.actions.map((a) => a.selectedValue = false);
      }
      return;
    }
    if (!this.listModel.focusedItem || !this.listModel.isItemVisible(this.listModel.focusedItem)) {
      this.listModel.focusFirstVisibleItem();
    }
  }
  setTextWrapEnabled(newValue) {
    this.listModel.textWrapEnabled = newValue;
  }
  popupRecalculatePosition(isResetHeight) {
    setTimeout(() => {
      this.popupModel.recalculatePosition(isResetHeight);
    }, 1);
  }
  onHidePopup() {
    this.resetFilterString();
    this.question.suggestedItem = null;
  }
  getAvailableItems() {
    return this.question.visibleChoices;
  }
  setOnTextSearchCallbackForListModel(listModel) {
    listModel.setOnTextSearchCallback((item, textToSearch) => {
      if (this.filteredItems) return this.filteredItems.indexOf(item) >= 0;
      let textInLow = item.text.toLocaleLowerCase();
      textInLow = settings.comparator.normalizeTextCallback(textInLow, "filter");
      const index = textInLow.indexOf(textToSearch.toLocaleLowerCase());
      return this.question.searchMode == "startsWith" ? index == 0 : index > -1;
    });
  }
  createListModel() {
    const visibleItems = this.getAvailableItems();
    let _onSelectionChanged = this.onSelectionChanged;
    if (!_onSelectionChanged) {
      _onSelectionChanged = (item) => {
        this.question.value = item.id;
        if (this.question.searchEnabled) this.applyInputString(item);
        this.popupModel.hide();
      };
    }
    const listOptions = {
      items: visibleItems,
      onSelectionChanged: _onSelectionChanged,
      allowSelection: false,
      locOwner: this.question,
      elementId: this.listElementId
    };
    const res = new ListModel(listOptions);
    this.setOnTextSearchCallbackForListModel(res);
    res.renderElements = false;
    res.forceShowFilter = true;
    res.areSameItemsCallback = (item1, item2) => {
      return item1 === item2;
    };
    return res;
  }
  updateAfterListModelCreated(model) {
    model.isItemSelected = (action) => !!action.selected;
    model.onPropertyChanged.add((sender, options) => {
      if (options.name == "hasVerticalScroller") {
        this.hasScroll = options.newValue;
      }
    });
    model.isAllDataLoaded = !this.question.choicesLazyLoadEnabled;
    model.actions.forEach((a) => a.disableTabStop = true);
  }
  getPopupCssClasses() {
    return "sv-single-select-list";
  }
  updateCssClasses(popupCssClass, listCssClasses) {
    this.popupModel.cssClass = new CssClassBuilder().append(popupCssClass).append(this.getPopupCssClasses()).toString();
    this.listModel.cssClasses = listCssClasses;
  }
  resetFilterString() {
    if (!!this.filterString) {
      this.filterString = void 0;
    }
  }
  clear() {
    this.inputString = null;
    this.hintString = "";
    this.resetFilterString();
  }
  onSetFilterString() {
    this.filteredItems = void 0;
    if (!this.filterString && !this.popupModel.isVisible) return;
    const options = {
      question: this.question,
      choices: this.getAvailableItems(),
      filter: this.filterString,
      filteredChoices: void 0
    };
    this.question.survey.onChoicesSearch.fire(this.question.survey, options);
    this.filteredItems = options.filteredChoices;
    if (!!this.filterString && !this.popupModel.isVisible) {
      this.popupModel.show();
    }
    const updateAfterFilterStringChanged = () => {
      this.setFilterStringToListModel(this.filterString);
      this.popupRecalculatePosition(true);
    };
    if (this.question.choicesLazyLoadEnabled) {
      this.resetItemsSettings();
      this.updateQuestionChoices(updateAfterFilterStringChanged);
    } else {
      updateAfterFilterStringChanged();
    }
  }
  get isAllDataLoaded() {
    return !!this.itemsSettings.totalCount && this.itemsSettings.items.length == this.itemsSettings.totalCount;
  }
  get canShowSelectedItem() {
    return !this.focused || this._markdownMode || !this.searchEnabled;
  }
  applyInputString(item) {
    const hasHtml = item === null || item === void 0 ? void 0 : item.locText.hasHtml;
    if (hasHtml || this.question.inputFieldComponentName) {
      this._markdownMode = true;
      this.inputString = this.cleanHtml(item === null || item === void 0 ? void 0 : item.locText.getHtmlValue());
      this.hintString = "";
    } else {
      this.inputString = item === null || item === void 0 ? void 0 : item.title;
      this.hintString = item === null || item === void 0 ? void 0 : item.title;
    }
  }
  cleanHtml(html) {
    if (!this.htmlCleanerElement) return "";
    this.htmlCleanerElement.innerHTML = html;
    return this.htmlCleanerElement.textContent;
  }
  fixInputCase() {
    const hintStringMiddle = this.hintStringMiddle;
    if (hintStringMiddle && this.inputString != hintStringMiddle) this.inputString = hintStringMiddle;
  }
  applyHintString(item) {
    const hasHtml = item === null || item === void 0 ? void 0 : item.locText.hasHtml;
    if (hasHtml || this.question.inputFieldComponentName) {
      this._markdownMode = true;
      this.hintString = "";
    } else {
      this.hintString = item === null || item === void 0 ? void 0 : item.title;
    }
  }
  get inputStringRendered() {
    return this.inputString || "";
  }
  set inputStringRendered(val) {
    this.inputString = val;
    this.filterString = val;
    if (!val) {
      this.hintString = "";
    } else {
      this.applyHintString(this.listModel.focusedItem || this.question.selectedItem);
    }
  }
  get placeholderRendered() {
    return this.hintString ? "" : this.question.readOnlyText;
  }
  get listElementId() {
    return this.question.inputId + "_list";
  }
  get hintStringLC() {
    var _a;
    return ((_a = this.hintString) === null || _a === void 0 ? void 0 : _a.toLowerCase()) || "";
  }
  get inputStringLC() {
    var _a;
    return ((_a = this.inputString) === null || _a === void 0 ? void 0 : _a.toLowerCase()) || "";
  }
  get showHintPrefix() {
    return !!this.inputString && this.hintStringLC.indexOf(this.inputStringLC) > 0;
  }
  get hintStringPrefix() {
    if (!this.inputString) return null;
    return this.hintString.substring(0, this.hintStringLC.indexOf(this.inputStringLC));
  }
  get showHintString() {
    return !!this.question.searchEnabled && !!(this.hintStringLC || this.inputStringLC) || !this.question.searchEnabled && this.hintStringLC && this.question.isEmpty();
  }
  get hintStringSuffix() {
    return this.hintString.substring(this.hintStringLC.indexOf(this.inputStringLC) + this.inputStringLC.length);
  }
  get hintStringMiddle() {
    const start = this.hintStringLC.indexOf(this.inputStringLC);
    if (start == -1) return null;
    return this.hintString.substring(start, start + this.inputStringLC.length);
  }
  constructor(question, onSelectionChanged) {
    super();
    this.question = question;
    this.onSelectionChanged = onSelectionChanged;
    this.minPageSize = 25;
    this.loadingItemHeight = 40;
    this.timer = void 0;
    this._markdownMode = false;
    this.filteredItems = void 0;
    this.selectedItemSelector = ".sv-list__item--selected";
    this.itemSelector = ".sv-list__item";
    this.itemsSettings = {
      skip: 0,
      take: 0,
      totalCount: 0,
      items: []
    };
    this.listModelFilterStringChanged = (newValue) => {
      if (this.filterString !== newValue) {
        this.filterString = newValue;
      }
    };
    this.questionPropertyChangedHandler = (sender, options) => {
      this.onPropertyChangedHandler(sender, options);
    };
    this.htmlCleanerElement = DomDocumentHelper.createElement("div");
    question.onPropertyChanged.add(this.questionPropertyChangedHandler);
    this.showInputFieldComponent = this.question.showInputFieldComponent;
    this.listModel = this.createListModel();
    this.updateAfterListModelCreated(this.listModel);
    this.setChoicesLazyLoadEnabled(this.question.choicesLazyLoadEnabled);
    this.setSearchEnabled(this.question.searchEnabled);
    this.setTextWrapEnabled(this.question.textWrapEnabled);
    this.createPopup();
    this.resetItemsSettings();
    const classes = question.cssClasses;
    this.updateCssClasses(classes.popup, classes.list);
  }
  get popupModel() {
    return this._popupModel;
  }
  get noTabIndex() {
    return this.question.isInputReadOnly || this.searchEnabled;
  }
  get filterReadOnly() {
    return this.question.isInputReadOnly || !this.searchEnabled || !this.focused;
  }
  get filterStringEnabled() {
    return !this.question.isInputReadOnly && this.searchEnabled;
  }
  get inputMode() {
    return IsTouch ? "none" : "text";
  }
  setSearchEnabled(newValue) {
    this.listModel.setSearchEnabled(IsTouch && newValue);
    this.searchEnabled = newValue;
  }
  setChoicesLazyLoadEnabled(newValue) {
    this.listModel.setOnFilterStringChangedCallback(newValue ? this.listModelFilterStringChanged : void 0);
  }
  updateItems() {
    this.listModel.setItems(this.getAvailableItems());
  }
  onClick(event) {
    if (this.question.readOnly || this.question.isDesignMode || this.question.isPreviewStyle || this.question.isReadOnlyAttr) return;
    this._popupModel.toggleVisibility();
    this.focusItemOnClickAndPopup();
    this.question.focusInputElement(false);
  }
  chevronPointerDown(event) {
    if (this._popupModel.isVisible) {
      event.preventDefault();
    }
  }
  onPropertyChangedHandler(sender, options) {
    if (options.name == "value") {
      this.showInputFieldComponent = this.question.showInputFieldComponent;
    }
    if (options.name == "textWrapEnabled") {
      this.setTextWrapEnabled(options.newValue);
    }
  }
  focusItemOnClickAndPopup() {
    if (this._popupModel.isVisible && this.question.value) this.changeSelectionWithKeyboard(false);
  }
  onClear(event) {
    this.question.clearValue(true);
    this._popupModel.hide();
    if (event) {
      event.preventDefault();
      event.stopPropagation();
    }
  }
  getSelectedAction() {
    return this.question.selectedItem || null;
  }
  changeSelectionWithKeyboard(reverse) {
    var _a;
    let focusedItem = this.listModel.focusedItem;
    if (!focusedItem && this.question.selectedItem) {
      if (ItemValue.getItemByValue(this.question.visibleChoices, this.question.value)) {
        this.listModel.focusedItem = this.question.selectedItem;
      }
    } else {
      if (reverse) {
        this.listModel.focusPrevVisibleItem();
      } else {
        this.listModel.focusNextVisibleItem();
      }
    }
    this.beforeScrollToFocusedItem(focusedItem);
    this.scrollToFocusedItem();
    this.afterScrollToFocusedItem();
    this.ariaActivedescendant = (_a = this.listModel.focusedItem) === null || _a === void 0 ? void 0 : _a.elementId;
  }
  beforeScrollToFocusedItem(focusedItem) {
    if (this.question.value && focusedItem) {
      focusedItem.selectedValue = false;
      this.listModel.focusedItem.selectedValue = !this.listModel.filterString;
      this.question.suggestedItem = this.listModel.focusedItem;
    }
  }
  afterScrollToFocusedItem() {
    var _a;
    if (this.question.value && !this.listModel.filterString && this.question.searchEnabled) {
      this.applyInputString(this.listModel.focusedItem || this.question.selectedItem);
    } else {
      this.applyHintString(this.listModel.focusedItem || this.question.selectedItem);
    }
    this.fixInputCase();
    this.ariaActivedescendant = (_a = this.listModel.focusedItem) === null || _a === void 0 ? void 0 : _a.elementId;
  }
  keyHandler(event) {
    const char = event.which || event.keyCode;
    if (this.popupModel.isVisible && event.keyCode === 38) {
      this.changeSelectionWithKeyboard(true);
      event.preventDefault();
      event.stopPropagation();
    } else if (event.keyCode === 40) {
      this.popupModel.show();
      this.changeSelectionWithKeyboard(false);
      event.preventDefault();
      event.stopPropagation();
    }
    if (event.keyCode === 9) {
      this.popupModel.hide();
    } else if (!this.popupModel.isVisible && (event.keyCode === 13 || event.keyCode === 32)) {
      if (event.keyCode === 32) {
        this.popupModel.show();
        this.changeSelectionWithKeyboard(false);
      }
      if (event.keyCode === 13) {
        this.question.survey.questionEditFinishCallback(this.question, event);
      }
      event.preventDefault();
      event.stopPropagation();
    } else if (this.popupModel.isVisible && (event.keyCode === 13 || event.keyCode === 32 && (!this.question.searchEnabled || !this.inputString))) {
      if (event.keyCode === 13 && this.question.searchEnabled && !this.inputString && this.question instanceof QuestionDropdownModel && !this._markdownMode && this.question.value) {
        this._popupModel.hide();
        this.onClear(event);
      } else {
        this.listModel.selectFocusedItem();
        this.onFocus(event);
      }
      event.preventDefault();
      event.stopPropagation();
    } else if (char === 46 || char === 8) {
      if (!this.searchEnabled) {
        this.onClear(event);
      }
    } else if (event.keyCode === 27) {
      this._popupModel.hide();
      this.hintString = "";
      this.onEscape();
    } else {
      if (event.keyCode === 38 || event.keyCode === 40 || event.keyCode === 32 && !this.question.searchEnabled) {
        event.preventDefault();
        event.stopPropagation();
      }
      if (event.keyCode === 32 && this.question.searchEnabled) {
        return;
      }
      doKey2ClickUp(event, {
        processEsc: false,
        disableTabStop: this.question.isInputReadOnly
      });
    }
  }
  onEscape() {
    if (this.question.searchEnabled) this.applyInputString(this.question.selectedItem);
  }
  onScroll(event) {
    const target = event.target;
    if (target.scrollHeight - (target.scrollTop + target.offsetHeight) <= this.loadingItemHeight) {
      this.updateQuestionChoices();
    }
  }
  onBlur(event) {
    this.focused = false;
    if (this.popupModel.isVisible && this.popupModel.displayMode == "overlay") {
      return;
    }
    doKey2ClickBlur(event);
    this._popupModel.hide();
    this.resetFilterString();
    this.inputString = null;
    this.hintString = "";
    event.stopPropagation();
  }
  onFocus(event) {
    this.focused = true;
    this.setInputStringFromSelectedItem(this.question.selectedItem);
  }
  setInputStringFromSelectedItem(newValue) {
    if (!this.focused) return;
    if (this.question.searchEnabled && !!newValue) {
      this.applyInputString(newValue);
    } else {
      this.inputString = null;
    }
  }
  dispose() {
    super.dispose();
    this.question && this.question.onPropertyChanged.remove(this.questionPropertyChangedHandler);
    this.questionPropertyChangedHandler = void 0;
    if (!!this.listModel) {
      this.listModel.dispose();
    }
    if (!!this.popupModel) {
      this.popupModel.dispose();
    }
    this.htmlCleanerElement = void 0;
  }
  scrollToFocusedItem() {
    this.listModel.scrollToFocusedItem();
  }
};
__decorate([property({
  defaultValue: false
})], DropdownListModel.prototype, "focused", void 0);
__decorate([property({
  defaultValue: true
})], DropdownListModel.prototype, "searchEnabled", void 0);
__decorate([property({
  defaultValue: "",
  onSet: (_, target) => {
    target.onSetFilterString();
  }
})], DropdownListModel.prototype, "filterString", void 0);
__decorate([property({
  defaultValue: "",
  onSet: (newValue, target) => {
    target.question.inputHasValue = !!newValue;
  }
})], DropdownListModel.prototype, "inputString", void 0);
__decorate([property({})], DropdownListModel.prototype, "showInputFieldComponent", void 0);
__decorate([property()], DropdownListModel.prototype, "ariaActivedescendant", void 0);
__decorate([property({
  defaultValue: false,
  onSet: (newVal, target) => {
    if (newVal) {
      target.listModel.addScrollEventListener((e) => {
        target.onScroll(e);
      });
    } else {
      target.listModel.removeScrollEventListener();
    }
  }
})], DropdownListModel.prototype, "hasScroll", void 0);
__decorate([property({
  defaultValue: ""
})], DropdownListModel.prototype, "hintString", void 0);
var QuestionDropdownModel = class extends QuestionSelectBase {
  constructor(name) {
    super(name);
    this.lastSelectedItemValue = null;
    this.minMaxChoices = [];
    this.onOpened = this.addEvent();
    this.ariaExpanded = "false";
    this.createLocalizableString("placeholder", this, false, true);
    this.createLocalizableString("clearCaption", this, false, true);
    this.registerPropertyChangedHandlers(["choicesMin", "choicesMax", "choicesStep"], () => {
      this.onVisibleChoicesChanged();
    });
    this.registerPropertyChangedHandlers(["value", "renderAs", "showOtherItem", "otherText", "placeholder", "choices", "visibleChoices"], () => {
      this.getSingleSelectedItem();
      this.resetReadOnlyText();
    });
  }
  locStrsChanged() {
    super.locStrsChanged();
    this.resetReadOnlyText();
  }
  get showOptionsCaption() {
    return this.allowClear;
  }
  set showOptionsCaption(val) {
    this.allowClear = val;
  }
  get showClearButton() {
    return this.allowClear && !this.isEmpty();
  }
  get optionsCaption() {
    return this.placeholder;
  }
  set optionsCaption(val) {
    this.placeholder = val;
  }
  /**
   * A placeholder for the input field.
   */
  get placeholder() {
    return this.getLocalizableStringText("placeholder");
  }
  set placeholder(val) {
    this.setLocalizableStringText("placeholder", val);
  }
  get locPlaceholder() {
    return this.getLocalizableString("placeholder");
  }
  get clearCaption() {
    return this.getLocalizableStringText("clearCaption");
  }
  set clearCaption(value) {
    this.setLocalizableStringText("clearCaption", value);
  }
  get locClearCaption() {
    return this.getLocalizableString("clearCaption");
  }
  getType() {
    return "dropdown";
  }
  get ariaRole() {
    return "combobox";
  }
  get selectedItem() {
    return this.getSingleSelectedItem();
  }
  onGetSingleSelectedItem(selectedItemByValue) {
    if (!!selectedItemByValue) {
      this.lastSelectedItemValue = selectedItemByValue;
    }
  }
  supportAutoAdvance() {
    return !this.isOtherSelected;
  }
  getChoices() {
    var items = super.getChoices();
    if (this.choicesMax <= this.choicesMin) return items;
    var res = [];
    for (var i = 0; i < items.length; i++) {
      res.push(items[i]);
    }
    if (this.minMaxChoices.length === 0 || this.minMaxChoices.length !== (this.choicesMax - this.choicesMin) / this.choicesStep + 1) {
      this.minMaxChoices = [];
      for (var i = this.choicesMin; i <= this.choicesMax; i += this.choicesStep) {
        this.minMaxChoices.push(this.createItemValue(i));
      }
    }
    res = res.concat(this.minMaxChoices);
    return res;
  }
  /**
   * Use the `choicesMin`, `choicesMax`, and `choicesStep` properties to generate choice items automatically. For example, the configuration below generates three choice items: [10, 20, 30].
   *
   * ```js
   * "choicesMin": 10,
   * "choicesMax": 30
   * "choicesStep": 10
   * ```
   * @see choicesMax
   * @see choicesStep
   */
  get choicesMin() {
    return this.getPropertyValue("choicesMin");
  }
  set choicesMin(val) {
    this.setPropertyValue("choicesMin", val);
  }
  /**
   * Use the `choicesMin`, `choicesMax`, and `choicesStep` properties to generate choice items automatically. For example, the configuration below generates three choice items: [10, 20, 30].
   *
   * ```js
   * "choicesMin": 10,
   * "choicesMax": 30
   * "choicesStep": 10
   * ```
   * @see choicesMin
   * @see choicesStep
   */
  get choicesMax() {
    return this.getPropertyValue("choicesMax");
  }
  set choicesMax(val) {
    this.setPropertyValue("choicesMax", val);
  }
  /**
   * Use the `choicesMin`, `choicesMax`, and `choicesStep` properties to generate choice items automatically. For example, the configuration below generates three choice items: [10, 20, 30].
   *
   * ```js
   * "choicesMin": 10,
   * "choicesMax": 30
   * "choicesStep": 10
   * ```
   *
   * The default value of the `choicesStep` property is 1.
   * @see choicesMin
   * @see choicesMax
   */
  get choicesStep() {
    return this.getPropertyValue("choicesStep");
  }
  set choicesStep(val) {
    if (val < 1) val = 1;
    this.setPropertyValue("choicesStep", val);
  }
  get autocomplete() {
    return this.getPropertyValue("autocomplete", "");
  }
  set autocomplete(val) {
    this.setPropertyValue("autocomplete", val);
  }
  get readOnlyText() {
    return this.getPropertyValue("readOnlyText", void 0, () => this.calculateReadOnlyText());
  }
  calculateReadOnlyText() {
    if (this.renderAs == "select") {
      if (this.isOtherSelected) return this.otherText;
      if (this.isNoneSelected) return this.noneText;
      if (!!this.selectedItem) return this.selectedItemText;
    }
    return !!this.selectedItem ? "" : this.placeholder;
  }
  resetReadOnlyText() {
    this.resetPropertyValue("readOnlyText");
  }
  getControlClass() {
    return new CssClassBuilder().append(this.cssClasses.control).append(this.cssClasses.controlEmpty, this.isEmpty()).append(this.cssClasses.onError, this.hasCssError()).append(this.cssClasses.controlDisabled, this.isDisabledStyle).append(this.cssClasses.controlReadOnly, this.isReadOnlyStyle).append(this.cssClasses.controlPreview, this.isPreviewStyle).append(this.cssClasses.controlInputFieldComponent, !!this.inputFieldComponentName).toString();
  }
  updateCssClasses(res, css) {
    super.updateCssClasses(res, css);
    if (this.useDropdownList) {
      updateListCssValues(res, css);
    }
  }
  calcCssClasses(css) {
    const classes = super.calcCssClasses(css);
    if (this.dropdownListModelValue) {
      this.dropdownListModel.updateCssClasses(classes.popup, classes.list);
    }
    return classes;
  }
  get selectedItemLocText() {
    const item = this.suggestedItem || this.selectedItem;
    return item === null || item === void 0 ? void 0 : item.locText;
  }
  get inputFieldComponentName() {
    return this.inputFieldComponent || this.itemComponent;
  }
  get showSelectedItemLocText() {
    return !this.inputHasValue && !this.inputFieldComponentName && !!this.selectedItemLocText && this.dropdownListModel.canShowSelectedItem;
  }
  get showInputFieldComponent() {
    return !this.inputHasValue && !!this.inputFieldComponentName && !this.isEmpty();
  }
  get selectedItemText() {
    const item = this.selectedItem;
    return !!item ? item.text : "";
  }
  get useDropdownList() {
    return this.renderAs !== "select";
  }
  get dropdownListModel() {
    if (this.useDropdownList && !this.dropdownListModelValue) {
      this.dropdownListModelValue = new DropdownListModel(this);
    }
    return this.dropdownListModelValue;
  }
  set dropdownListModel(val) {
    this.dropdownListModelValue = val;
  }
  get popupModel() {
    return this.dropdownListModel.popupModel;
  }
  onOpenedCallBack() {
    this.onOpened.fire(this, {
      question: this,
      choices: this.choices
    });
  }
  onSelectedItemValuesChangedHandler(newValue) {
    var _a;
    (_a = this.dropdownListModelValue) === null || _a === void 0 ? void 0 : _a.setInputStringFromSelectedItem(newValue);
    super.onSelectedItemValuesChangedHandler(newValue);
  }
  hasUnknownValue(val, includeOther, isFilteredChoices, checkEmptyValue) {
    if (this.choicesLazyLoadEnabled) {
      return false;
    }
    return super.hasUnknownValue(val, includeOther, isFilteredChoices, checkEmptyValue);
  }
  needConvertRenderedOtherToDataValue() {
    var _a;
    const val = (_a = this.otherValue) === null || _a === void 0 ? void 0 : _a.trim();
    if (!val) return false;
    return super.hasUnknownValue(val, true, false);
  }
  getItemIfChoicesNotContainThisValue(value, text) {
    if (this.choicesLazyLoadEnabled) {
      return this.createItemValue(value, text);
    } else {
      return super.getItemIfChoicesNotContainThisValue(value, text);
    }
  }
  onVisibleChoicesChanged() {
    super.onVisibleChoicesChanged();
    if (!!this.dropdownListModelValue) {
      this.dropdownListModel.updateItems();
    }
  }
  getFirstInputElementId() {
    return this.inputId + (this.searchEnabled ? "_0" : "");
  }
  getInputId() {
    return this.inputId + "_0";
  }
  clearValue(keepComment) {
    var _a;
    super.clearValue(keepComment);
    this.lastSelectedItemValue = null;
    (_a = this.dropdownListModelValue) === null || _a === void 0 ? void 0 : _a.clear();
  }
  afterRenderCore(el) {
    super.afterRenderCore(el);
    if (!!this.dropdownListModelValue) {
      this.dropdownListModelValue.clear();
    }
  }
  onClick(e) {
    !!this.onOpenedCallBack && this.onOpenedCallBack();
  }
  onKeyUp(event) {
    const char = event.which || event.keyCode;
    if (char === 46) {
      this.clearValue(true);
      event.preventDefault();
      event.stopPropagation();
    }
  }
  supportEmptyValidation() {
    return true;
  }
  onBlurCore(event) {
    this.dropdownListModel.onBlur(event);
    super.onBlurCore(event);
  }
  onFocusCore(event) {
    this.dropdownListModel.onFocus(event);
    super.onFocusCore(event);
  }
  dispose() {
    super.dispose();
    if (!!this.dropdownListModelValue) {
      this.dropdownListModelValue.dispose();
      this.dropdownListModelValue = void 0;
    }
  }
};
__decorate([property()], QuestionDropdownModel.prototype, "allowClear", void 0);
__decorate([property({
  onSet: (newValue, target) => {
    if (!!target.dropdownListModelValue) {
      target.dropdownListModel.setSearchEnabled(newValue);
    }
  }
})], QuestionDropdownModel.prototype, "searchEnabled", void 0);
__decorate([property()], QuestionDropdownModel.prototype, "searchMode", void 0);
__decorate([property()], QuestionDropdownModel.prototype, "textWrapEnabled", void 0);
__decorate([property({
  defaultValue: false
})], QuestionDropdownModel.prototype, "inputHasValue", void 0);
__decorate([property({
  onSet: (newValue, target) => {
    if (!!target.dropdownListModelValue) {
      target.dropdownListModel.setChoicesLazyLoadEnabled(newValue);
    }
  }
})], QuestionDropdownModel.prototype, "choicesLazyLoadEnabled", void 0);
__decorate([property()], QuestionDropdownModel.prototype, "choicesLazyLoadPageSize", void 0);
__decorate([property()], QuestionDropdownModel.prototype, "suggestedItem", void 0);
Serializer.addClass("dropdown", [{
  name: "placeholder",
  alternativeName: "optionsCaption",
  serializationProperty: "locPlaceholder"
}, {
  name: "allowClear:boolean",
  alternativeName: "showOptionsCaption",
  default: true
}, {
  name: "choicesMin:number",
  default: 0
}, {
  name: "choicesMax:number",
  default: 0
}, {
  name: "choicesStep:number",
  default: 1,
  minValue: 1
}, {
  name: "autocomplete",
  alternativeName: "autoComplete",
  choices: settings.questions.dataList
}, {
  name: "textWrapEnabled:boolean",
  default: true
}, {
  name: "renderAs",
  default: "default",
  visible: false
}, {
  name: "searchEnabled:boolean",
  default: true,
  visible: false
}, {
  name: "searchMode",
  default: "contains",
  choices: ["contains", "startsWith"]
}, {
  name: "choicesLazyLoadEnabled:boolean",
  default: false,
  visible: false
}, {
  name: "choicesLazyLoadPageSize:number",
  default: 25,
  visible: false
}, {
  name: "inputFieldComponent",
  visible: false
}, {
  name: "itemComponent",
  visible: false,
  default: ""
}], function() {
  return new QuestionDropdownModel("");
}, "selectbase");
QuestionFactory.Instance.registerQuestion("dropdown", (name) => {
  var q = new QuestionDropdownModel(name);
  q.choices = QuestionFactory.DefaultChoices;
  return q;
});
var MatrixRowModel = class extends Base {
  constructor(item, fullName, data, value) {
    super();
    this.item = item;
    this.fullName = fullName;
    this.data = data;
    this.setValueDirectly(value);
    this.cellClick = (column) => {
      this.value = column.value;
    };
    this.registerPropertyChangedHandlers(["value"], () => {
      if (this.data) this.data.onMatrixRowChanged(this);
    });
    if (this.data && this.data.hasErrorInRow(this)) {
      this.hasError = true;
    }
  }
  get name() {
    return this.item.value;
  }
  get text() {
    return this.item.text;
  }
  get locText() {
    return this.item.locText;
  }
  get value() {
    return this.getPropertyValue("value");
  }
  set value(val) {
    if (!this.isReadOnly) {
      this.setValueDirectly(this.data.getCorrectedRowValue(val));
    }
  }
  setValueDirectly(val) {
    this.setPropertyValue("value", val);
  }
  get isReadOnly() {
    return !this.item.enabled || this.data.isInputReadOnly;
  }
  get isReadOnlyAttr() {
    return this.data.isReadOnlyAttr;
  }
  get isDisabledAttr() {
    return !this.item.enabled || this.data.isDisabledAttr;
  }
  get rowTextClasses() {
    return new CssClassBuilder().append(this.data.cssClasses.rowTextCell).toString();
  }
  get hasError() {
    return this.getPropertyValue("hasError", false);
  }
  set hasError(val) {
    this.setPropertyValue("hasError", val);
  }
  get rowClasses() {
    const cssClasses = this.data.cssClasses;
    return new CssClassBuilder().append(cssClasses.row).append(cssClasses.rowError, this.hasError).append(cssClasses.rowReadOnly, this.isReadOnly).append(cssClasses.rowDisabled, this.data.isDisabledStyle).toString();
  }
};
var MatrixCells = class extends Base {
  constructor(cellsOwner) {
    super();
    this.cellsOwner = cellsOwner;
    this.values = {};
    this.locs = {};
  }
  getType() {
    return "cells";
  }
  get isEmpty() {
    return Object.keys(this.values).length == 0;
  }
  valuesChanged() {
    if (!this.locNotification && !!this.onValuesChanged) {
      this.onValuesChanged();
    }
  }
  getDefaultCellLocText(column) {
    return this.getCellLocCore(this.defaultRowValue, column);
  }
  getCellDisplayLocText(row, column) {
    return this.getCellLocCore(row, column);
  }
  getCellLocCore(row, col) {
    row = this.getCellRowColumnValue(row, this.rows);
    col = this.getCellRowColumnValue(col, this.columns);
    if (Helpers.isValueEmpty(row) || Helpers.isValueEmpty(col)) return null;
    if (!this.locs[row]) {
      this.locs[row] = {};
    }
    let res = this.locs[row][col];
    if (!res) {
      res = this.createString();
      res.setJson(this.getCellLocData(row, col));
      res.onGetTextCallback = (str) => {
        if (!str) {
          const column = ItemValue.getItemByValue(this.columns, col);
          if (column) {
            return column.locText.getJson() || column.value;
          }
        }
        return str;
      };
      res.onStrChanged = (oldValue, newValue) => {
        this.updateValues(row, col, newValue);
      };
      this.locs[row][col] = res;
    }
    return res;
  }
  get defaultRowValue() {
    return settings.matrix.defaultRowName;
  }
  getCellLocData(row, col) {
    let data = this.getCellLocDataFromValue(row, col);
    if (data) return data;
    return this.getCellLocDataFromValue(this.defaultRowValue, col);
  }
  getCellLocDataFromValue(row, column) {
    if (!this.values[row]) return null;
    if (!this.values[row][column]) return null;
    return this.values[row][column];
  }
  getCellText(row, column) {
    var loc = this.getCellLocCore(row, column);
    return loc ? loc.calculatedText : null;
  }
  setCellText(row, column, val) {
    const loc = this.getCellLocCore(row, column);
    if (loc) {
      loc.text = val;
    }
  }
  updateValues(row, column, val) {
    if (val) {
      if (!this.values[row]) this.values[row] = {};
      this.values[row][column] = val;
      this.valuesChanged();
    } else {
      if (this.values[row] && this.values[row][column]) {
        delete this.values[row][column];
        if (Object.keys(this.values[row]).length == 0) {
          delete this.values[row];
        }
        this.valuesChanged();
      }
    }
  }
  getDefaultCellText(column) {
    var loc = this.getCellLocCore(this.defaultRowValue, column);
    return loc ? loc.calculatedText : null;
  }
  setDefaultCellText(column, val) {
    this.setCellText(this.defaultRowValue, column, val);
  }
  getCellDisplayText(row, column) {
    var loc = this.getCellDisplayLocText(row, column);
    return loc ? loc.calculatedText : null;
  }
  get rows() {
    return this.cellsOwner ? this.cellsOwner.getRows() : [];
  }
  get columns() {
    return this.cellsOwner ? this.cellsOwner.getColumns() : [];
  }
  getCellRowColumnValue(val, values) {
    if (val === null || val === void 0) return null;
    if (typeof val == "number") {
      if (val < 0 || val >= values.length) return null;
      val = values[val].value;
    }
    if (val.value) return val.value;
    return val;
  }
  getJson() {
    if (this.isEmpty) return null;
    const defaultRow = this.values[this.defaultRowValue];
    const res = {};
    for (let row in this.values) {
      const resRow = {};
      const rowValues = this.values[row];
      for (let col in rowValues) {
        if (row === this.defaultRowValue || !defaultRow || defaultRow[col] !== rowValues[col]) {
          resRow[col] = rowValues[col];
        }
      }
      res[row] = resRow;
    }
    return res;
  }
  setJson(value, isLoading) {
    this.values = {};
    if (!!value) {
      for (var row in value) {
        if (row == "pos") continue;
        var rowValues = value[row];
        this.values[row] = {};
        for (var col in rowValues) {
          if (col == "pos") continue;
          this.values[row][col] = rowValues[col];
        }
      }
    }
    this.locNotification = true;
    this.runFuncOnLocs((row2, col2, loc) => loc.setJson(this.getCellLocData(row2, col2)));
    this.locNotification = false;
    this.valuesChanged();
  }
  locStrsChanged() {
    this.runFuncOnLocs((row, col, loc) => loc.strChanged());
  }
  runFuncOnLocs(func) {
    for (let row in this.locs) {
      const rowValues = this.locs[row];
      for (let col in rowValues) {
        func(row, col, rowValues[col]);
      }
    }
  }
  createString() {
    return new LocalizableString(this.cellsOwner, true);
  }
};
var QuestionMatrixModel = class extends QuestionMatrixBaseModel {
  constructor(name) {
    super(name);
    this.isRowChanging = false;
    this.emptyLocalizableString = new LocalizableString(this);
    this.cellsValue = new MatrixCells(this);
    this.cellsValue.onValuesChanged = () => {
      this.updateHasCellText();
      this.propertyValueChanged("cells", this.cells, this.cells);
    };
    this.registerPropertyChangedHandlers(["columns"], () => {
      this.onColumnsChanged();
    });
    this.registerPropertyChangedHandlers(["rows"], () => {
      this.runCondition(this.getDataFilteredValues(), this.getDataFilteredProperties());
      this.onRowsChanged();
    });
    this.registerPropertyChangedHandlers(["hideIfRowsEmpty"], () => {
      this.updateVisibilityBasedOnRows();
    });
  }
  getType() {
    return "matrix";
  }
  /**
   * The name of a component used to render cells.
   */
  get cellComponent() {
    return this.getPropertyValue("cellComponent");
  }
  set itemComponent(value) {
    this.setPropertyValue("cellComponent", value);
  }
  get hasSingleInput() {
    return false;
  }
  /**
   * Specifies whether each row requires an answer. If a respondent skips a row, the question displays a validation error.
   * @see isRequired
   * @see eachRowUnique
   * @see validators
   */
  get eachRowRequired() {
    return this.getPropertyValue("eachRowRequired");
  }
  set eachRowRequired(val) {
    this.setPropertyValue("eachRowRequired", val);
  }
  /**
   * @deprecated Use the [`eachRowRequired`](https://surveyjs.io/form-library/documentation/api-reference/matrix-table-question-model#eachRowRequired) property instead.
   */
  get isAllRowRequired() {
    return this.eachRowRequired;
  }
  set isAllRowRequired(val) {
    this.eachRowRequired = val;
  }
  /**
   * Specifies whether answers in all rows should be unique. If any answers duplicate, the question displays a validation error.
   * @see eachRowRequired
   * @see validators
   */
  get eachRowUnique() {
    return this.getPropertyValue("eachRowUnique");
  }
  set eachRowUnique(val) {
    this.setPropertyValue("eachRowUnique", val);
  }
  get hasRows() {
    return this.rows.length > 0;
  }
  /**
   * Specifies a sort order for matrix rows.
   *
   * Possible values:
   *
   * - `"initial"` (default) - Preserves the original order of the `rows` array.
   * - `"random"` - Arranges matrix rows in random order each time the question is displayed.
   * @see rows
   */
  get rowOrder() {
    return this.getPropertyValue("rowOrder");
  }
  set rowOrder(val) {
    val = val.toLowerCase();
    if (val == this.rowOrder) return;
    this.setPropertyValue("rowOrder", val);
    this.onRowsChanged();
  }
  /**
   * @deprecated Use the [`rowOrder`](https://surveyjs.io/form-library/documentation/api-reference/matrix-table-question-model#rowOrder) property instead.
   */
  get rowsOrder() {
    return this.rowOrder;
  }
  set rowsOrder(val) {
    this.rowOrder = val;
  }
  /**
   * Specifies whether to hide the question when the matrix has no visible rows.
   * @see rowsVisibleIf
   */
  get hideIfRowsEmpty() {
    return this.getPropertyValue("hideIfRowsEmpty");
  }
  set hideIfRowsEmpty(val) {
    this.setPropertyValue("hideIfRowsEmpty", val);
  }
  getRows() {
    return this.rows;
  }
  getColumns() {
    return this.visibleColumns;
  }
  addColumn(value, text) {
    var col = new ItemValue(value, text);
    this.columns.push(col);
    return col;
  }
  getItemClass(row, column) {
    const isChecked = row.value == column.value;
    const isDisabled = this.isReadOnly;
    const allowHover = !isChecked && !isDisabled;
    const hasCellText = this.hasCellText;
    const css = this.cssClasses;
    return new CssClassBuilder().append(css.cell, hasCellText).append(hasCellText ? css.cellText : css.label).append(css.itemOnError, !hasCellText && (this.eachRowRequired || this.eachRowUnique ? row.hasError : this.hasCssError())).append(hasCellText ? css.cellTextSelected : css.itemChecked, isChecked).append(hasCellText ? css.cellTextDisabled : css.itemDisabled, this.isDisabledStyle).append(hasCellText ? css.cellTextReadOnly : css.itemReadOnly, this.isReadOnlyStyle).append(hasCellText ? css.cellTextPreview : css.itemPreview, this.isPreviewStyle).append(css.itemHover, allowHover && !hasCellText).toString();
  }
  get itemSvgIcon() {
    if (this.isPreviewStyle && this.cssClasses.itemPreviewSvgIconId) {
      return this.cssClasses.itemPreviewSvgIconId;
    }
    return this.cssClasses.itemSvgIconId;
  }
  locStrsChanged() {
    super.locStrsChanged();
    this.cells.locStrsChanged();
  }
  getQuizQuestionCount() {
    var res = 0;
    for (var i = 0; i < this.rows.length; i++) {
      if (!this.isValueEmpty(this.correctAnswer[this.rows[i].value])) res++;
    }
    return res;
  }
  getCorrectAnswerCount() {
    var res = 0;
    var value = this.value;
    for (var i = 0; i < this.rows.length; i++) {
      var row = this.rows[i].value;
      if (!this.isValueEmpty(value[row]) && this.isTwoValueEquals(this.correctAnswer[row], value[row])) res++;
    }
    return res;
  }
  runConditionCore(values, properties) {
    ItemValue.runEnabledConditionsForItems(this.rows, void 0, values, properties);
    super.runConditionCore(values, properties);
  }
  createRowsVisibleIfRunner() {
    return !!this.rowsVisibleIf ? new ConditionRunner(this.rowsVisibleIf) : null;
  }
  onRowsChanged() {
    this.clearGeneratedRows();
    super.onRowsChanged();
  }
  getVisibleRows() {
    if (!!this.generatedVisibleRows) return this.generatedVisibleRows;
    const result = new Array();
    let val = this.value;
    if (!val) val = {};
    const rows = this.filteredRows || this.rows;
    for (let i = 0; i < rows.length; i++) {
      const row = rows[i];
      if (this.isValueEmpty(row.value)) continue;
      const rowId = this.id + "_" + row.value.toString().replace(/\s/g, "_");
      result.push(this.createMatrixRow(row, rowId, val[row.value]));
    }
    this.generatedVisibleRows = result;
    return result;
  }
  sortVisibleRows(array) {
    if (!!this.survey && this.survey.isDesignMode) return array;
    var order = this.rowOrder.toLowerCase();
    if (order === "random") return Helpers.randomizeArray(array);
    return array;
  }
  endLoadingFromJson() {
    super.endLoadingFromJson();
    this.rows = this.sortVisibleRows(this.rows);
    this.onRowsChanged();
    this.onColumnsChanged();
  }
  isNewValueCorrect(val) {
    return Helpers.isValueObject(val, true);
  }
  processRowsOnSet(newRows) {
    return this.sortVisibleRows(newRows);
  }
  get visibleRows() {
    return this.getVisibleRows();
  }
  /**
   * An array of matrix cells. Use this array to get or set cell values.
   *
   * [View Demo](https://surveyjs.io/form-library/examples/questiontype-matrix-rubric/ (linkStyle))
   */
  get cells() {
    return this.cellsValue;
  }
  set cells(value) {
    this.cells.setJson(value && value.getJson ? value.getJson() : null);
  }
  get hasCellText() {
    return this.getPropertyValue("hasCellText", false);
  }
  updateHasCellText() {
    this.setPropertyValue("hasCellText", !this.cells.isEmpty);
  }
  setCellText(row, column, val) {
    this.cells.setCellText(row, column, val);
  }
  getCellText(row, column) {
    return this.cells.getCellText(row, column);
  }
  setDefaultCellText(column, val) {
    this.cells.setDefaultCellText(column, val);
  }
  getDefaultCellText(column) {
    return this.cells.getDefaultCellText(column);
  }
  getCellDisplayText(row, column) {
    return this.cells.getCellDisplayText(row, column);
  }
  getCellDisplayLocText(row, column) {
    var loc = this.cells.getCellDisplayLocText(row, column);
    return loc ? loc : this.emptyLocalizableString;
  }
  supportAutoAdvance() {
    return this.isMouseDown === true && this.hasValuesInAllRows();
  }
  onCheckForErrors(errors, isOnValueChanged, fireCallback) {
    super.onCheckForErrors(errors, isOnValueChanged, fireCallback);
    if (!isOnValueChanged || this.hasCssError()) {
      const rowsErrors = {
        noValue: false,
        isNotUnique: false
      };
      this.checkErrorsAllRows(fireCallback, rowsErrors);
      if (rowsErrors.noValue) {
        errors.push(new RequiredInAllRowsError(null, this));
      }
      if (rowsErrors.isNotUnique) {
        errors.push(new EachRowUniqueError(null, this));
      }
    }
  }
  hasValuesInAllRows() {
    const rowsErrors = {
      noValue: false,
      isNotUnique: false
    };
    this.checkErrorsAllRows(false, rowsErrors, true);
    return !rowsErrors.noValue;
  }
  checkErrorsAllRows(modifyErrors, res, allRowsRequired) {
    var rows = this.generatedVisibleRows;
    if (!rows) rows = this.visibleRows;
    if (!rows) return;
    const rowsRequired = this.eachRowRequired || allRowsRequired;
    const rowsUnique = this.eachRowUnique;
    res.noValue = false;
    res.isNotUnique = false;
    if (modifyErrors) {
      this.errorsInRow = void 0;
    }
    if (!rowsRequired && !rowsUnique) return;
    const hash = {};
    for (var i = 0; i < rows.length; i++) {
      const val = rows[i].value;
      let isEmpty = this.isValueEmpty(val);
      const isNotUnique = rowsUnique && !isEmpty && hash[val] === true;
      isEmpty = isEmpty && rowsRequired;
      if (modifyErrors && (isEmpty || isNotUnique)) {
        this.addErrorIntoRow(rows[i]);
      }
      if (!isEmpty) {
        hash[val] = true;
      }
      res.noValue = res.noValue || isEmpty;
      res.isNotUnique = res.isNotUnique || isNotUnique;
    }
    if (modifyErrors) {
      rows.forEach((row) => {
        row.hasError = this.hasErrorInRow(row);
      });
    }
  }
  addErrorIntoRow(row) {
    if (!this.errorsInRow) this.errorsInRow = {};
    this.errorsInRow[row.name] = true;
    row.hasError = true;
  }
  refreshRowsErrors() {
    if (!this.errorsInRow) return;
    this.checkErrorsAllRows(true, {
      noValue: false,
      isNotUnique: false
    });
  }
  getIsAnswered() {
    return super.getIsAnswered() && this.hasValuesInAllRows();
  }
  createMatrixRow(item, fullName, value) {
    var row = new MatrixRowModel(item, fullName, this, value);
    this.onMatrixRowCreated(row);
    return row;
  }
  onMatrixRowCreated(row) {
  }
  setQuestionValue(newValue, updateIsAnswered = true) {
    super.setQuestionValue(newValue, this.isRowChanging || updateIsAnswered);
    if (!this.generatedVisibleRows || this.generatedVisibleRows.length == 0) return;
    this.isRowChanging = true;
    var val = this.value;
    if (!val) val = {};
    if (this.rows.length == 0) {
      this.generatedVisibleRows[0].setValueDirectly(val);
    } else {
      for (var i = 0; i < this.generatedVisibleRows.length; i++) {
        var row = this.generatedVisibleRows[i];
        var rowVal = val[row.name];
        if (this.isValueEmpty(rowVal)) rowVal = null;
        this.generatedVisibleRows[i].setValueDirectly(rowVal);
      }
    }
    this.refreshRowsErrors();
    this.updateIsAnswered();
    this.isRowChanging = false;
  }
  getDisplayValueCore(keysAsText, value) {
    var res = {};
    for (var key in value) {
      var newKey = keysAsText ? ItemValue.getTextOrHtmlByValue(this.rows, key) : key;
      if (!newKey) newKey = key;
      var newValue = ItemValue.getTextOrHtmlByValue(this.columns, value[key]);
      if (!newValue) newValue = value[key];
      res[newKey] = newValue;
    }
    return res;
  }
  getPlainData(options = {
    includeEmpty: true
  }) {
    var questionPlainData = super.getPlainData(options);
    if (!!questionPlainData) {
      var values = this.createValueCopy();
      questionPlainData.isNode = true;
      questionPlainData.data = Object.keys(values || {}).map((rowName) => {
        var row = this.rows.filter((r) => r.value === rowName)[0];
        var rowDataItem = {
          name: rowName,
          title: !!row ? row.text : "row",
          value: values[rowName],
          displayValue: ItemValue.getTextOrHtmlByValue(this.visibleColumns, values[rowName]),
          getString: (val) => typeof val === "object" ? JSON.stringify(val) : val,
          isNode: false
        };
        var item = ItemValue.getItemByValue(this.visibleColumns, values[rowName]);
        if (!!item) {
          (options.calculations || []).forEach((calculation) => {
            rowDataItem[calculation.propertyName] = item[calculation.propertyName];
          });
        }
        return rowDataItem;
      });
    }
    return questionPlainData;
  }
  addConditionObjectsByContext(objects, context) {
    for (var i = 0; i < this.rows.length; i++) {
      var row = this.rows[i];
      if (!!row.value) {
        objects.push({
          name: this.getValueName() + "." + row.value,
          text: this.processedTitle + "." + row.calculatedText,
          question: this
        });
      }
    }
  }
  getConditionJson(operator = null, path = null) {
    if (!path) return super.getConditionJson(operator);
    var question = new QuestionDropdownModel(path);
    question.choices = this.columns;
    var json2 = new JsonObject().toJsonObject(question);
    json2["type"] = question.getType();
    return json2;
  }
  clearIncorrectValues() {
    this.clearInvisibleValuesInRowsAndColumns(true, true, true);
    super.clearIncorrectValues();
  }
  clearValueIfInvisibleCore(reason) {
    super.clearValueIfInvisibleCore(reason);
    this.clearInvisibleValuesInRowsAndColumns(true, true, false);
  }
  clearInvisibleColumnValues() {
    this.clearInvisibleValuesInRowsAndColumns(false, true, false);
  }
  clearInvisibleValuesInRows() {
    this.clearInvisibleValuesInRowsAndColumns(true, false, false);
  }
  clearInvisibleValuesInRowsAndColumns(inRows, inColumns, inCorrectRows) {
    if (this.isEmpty()) return;
    let updatedData = this.getUnbindValue(this.value);
    const newData = {};
    var rows = this.rows;
    for (var i = 0; i < rows.length; i++) {
      var key = rows[i].value;
      if (!!updatedData[key]) {
        if (inRows && !rows[i].isVisible || inColumns && !this.getVisibleColumnByValue(updatedData[key])) {
          delete updatedData[key];
        } else {
          newData[key] = updatedData[key];
        }
      }
    }
    if (inCorrectRows) {
      updatedData = newData;
    }
    if (this.isTwoValueEquals(updatedData, this.value)) return;
    this.value = updatedData;
  }
  getVisibleColumnByValue(val) {
    const col = ItemValue.getItemByValue(this.columns, val);
    return !!col && col.isVisible ? col : null;
  }
  getFirstInputElementId() {
    var rows = this.generatedVisibleRows;
    if (!rows) rows = this.visibleRows;
    if (rows.length > 0 && this.visibleColumns.length > 0) {
      return this.inputId + "_" + rows[0].name + "_0";
    }
    return super.getFirstInputElementId();
  }
  //IMatrixData
  onMatrixRowChanged(row) {
    if (this.isRowChanging) return;
    this.isRowChanging = true;
    if (!this.hasRows) {
      this.setNewValue(row.value);
    } else {
      var newValue = this.value;
      if (!newValue) {
        newValue = {};
      }
      newValue[row.name] = row.value;
      this.setNewValue(newValue);
    }
    this.isRowChanging = false;
  }
  getCorrectedRowValue(value) {
    for (var i = 0; i < this.columns.length; i++) {
      if (value === this.columns[i].value) return value;
    }
    for (var i = 0; i < this.columns.length; i++) {
      if (this.isTwoValueEquals(value, this.columns[i].value)) return this.columns[i].value;
    }
    return value;
  }
  hasErrorInRow(row) {
    return !!this.errorsInRow && !!this.errorsInRow[row.name];
  }
  getSearchableItemValueKeys(keys) {
    keys.push("columns");
    keys.push("rows");
  }
  get SurveyModel() {
    return this.survey;
  }
  getColumnHeaderWrapperComponentName(cell) {
    return this.SurveyModel.getElementWrapperComponentName({
      column: cell
    }, "column-header");
  }
  getColumnHeaderWrapperComponentData(cell) {
    return this.SurveyModel.getElementWrapperComponentData({
      column: cell
    }, "column-header");
  }
  getRowHeaderWrapperComponentName(cell) {
    return this.SurveyModel.getElementWrapperComponentName({
      row: cell
    }, "row-header");
  }
  getRowHeaderWrapperComponentData(cell) {
    return this.SurveyModel.getElementWrapperComponentData({
      row: cell
    }, "row-header");
  }
};
Serializer.addClass("matrix", ["rowTitleWidth", {
  name: "columns:itemvalue[]",
  uniqueProperty: "value",
  baseValue: function() {
    return getLocaleString("matrix_column");
  }
}, {
  name: "rows:itemvalue[]",
  uniqueProperty: "value",
  baseValue: function() {
    return getLocaleString("matrix_row");
  }
}, {
  name: "cells:cells",
  serializationProperty: "cells"
}, {
  name: "rowOrder",
  alternativeName: "rowsOrder",
  default: "initial",
  choices: ["initial", "random"]
}, {
  name: "eachRowRequired:boolean",
  alternativeName: "isAllRowRequired"
}, {
  name: "eachRowUnique:boolean",
  category: "validation"
}, "hideIfRowsEmpty:boolean", {
  name: "cellComponent",
  visible: false,
  default: "survey-matrix-cell"
}], function() {
  return new QuestionMatrixModel("");
}, "matrixbase");
QuestionFactory.Instance.registerQuestion("matrix", (name) => {
  var q = new QuestionMatrixModel(name);
  q.rows = QuestionFactory.DefaultRows;
  q.columns = QuestionFactory.DefaultColums;
  return q;
});
var CharacterCounter = class extends Base {
  updateRemainingCharacterCounter(newValue, maxLength) {
    this.remainingCharacterCounter = Helpers.getRemainingCharacterCounterText(newValue, maxLength);
  }
};
__decorate([property()], CharacterCounter.prototype, "remainingCharacterCounter", void 0);
var QuestionTextBase = class extends Question {
  constructor(name) {
    super(name);
    this.characterCounter = new CharacterCounter();
  }
  isTextValue() {
    return true;
  }
  /**
   * The maximum text length measured in characters. Assign 0 if the length should be unlimited.
   *
   * Default value: -1 (inherits the actual value from the `SurveyModel`'s [`maxTextLength`](https://surveyjs.io/form-library/documentation/surveymodel#maxTextLength) property).
   */
  get maxLength() {
    return this.getPropertyValue("maxLength");
  }
  set maxLength(val) {
    this.setPropertyValue("maxLength", val);
    this.updateRemainingCharacterCounter(this.value);
  }
  getMaxLength() {
    return Helpers.getMaxLength(this.maxLength, this.survey ? this.survey.maxTextLength : -1);
  }
  updateRemainingCharacterCounter(newValue) {
    this.characterCounter.updateRemainingCharacterCounter(newValue, this.getMaxLength());
  }
  get placeHolder() {
    return this.placeholder;
  }
  set placeHolder(val) {
    this.placeholder = val;
  }
  get locPlaceHolder() {
    return this.locPlaceholder;
  }
  getType() {
    return "textbase";
  }
  isEmpty() {
    return super.isEmpty() || this.value === "";
  }
  /**
   * Specifies when to update the question value.
   *
   * Possible values:
   *
   * - `"onBlur"` - Updates the value after the input field loses focus.
   * - `"onTyping"` - Updates the value on every key press.
   * - `"default"` (default) - Inherits the value from the `SurveyModel`'s [`textUpdateMode`](https://surveyjs.io/form-library/documentation/surveymodel#textUpdateMode) property.
   *
   * > Do not use the `"onTyping"` mode if your survey contains many expressions. Expressions are reevaluated each time a question value is changed. In `"onTyping"` mode, the question value changes frequently. This may cause performance degradation.
   */
  get textUpdateMode() {
    return this.getPropertyValue("textUpdateMode");
  }
  set textUpdateMode(val) {
    this.setPropertyValue("textUpdateMode", val);
  }
  getIsInputTextUpdate() {
    if (this.textUpdateMode == "default") return super.getIsInputTextUpdate();
    return this.textUpdateMode == "onTyping";
  }
  get renderedPlaceholder() {
    const func = () => {
      return this.hasPlaceholder() ? this.placeHolder : void 0;
    };
    return this.getPropertyValue("renderedPlaceholder", void 0, func);
  }
  onReadOnlyChanged() {
    super.onReadOnlyChanged();
    this.resetRenderedPlaceholder();
  }
  localeChanged() {
    super.localeChanged();
    this.resetRenderedPlaceholder();
  }
  supportEmptyValidation() {
    return true;
  }
  resetRenderedPlaceholder() {
    this.resetPropertyValue("renderedPlaceholder");
  }
  hasPlaceholder() {
    return !this.isReadOnly;
  }
  setNewValue(newValue) {
    super.setNewValue(newValue);
    this.updateRemainingCharacterCounter(newValue);
  }
  setQuestionValue(newValue, updateIsAnswered = true) {
    super.setQuestionValue(newValue, updateIsAnswered);
    this.updateRemainingCharacterCounter(newValue);
  }
  convertToCorrectValue(val) {
    if (Array.isArray(val)) return val.join(this.getValueSeparator());
    return val;
  }
  getValueSeparator() {
    return ", ";
  }
  getControlCssClassBuilder() {
    return new CssClassBuilder().append(this.cssClasses.root).append(this.cssClasses.onError, this.hasCssError()).append(this.cssClasses.controlDisabled, this.isDisabledStyle).append(this.cssClasses.controlReadOnly, this.isReadOnlyStyle).append(this.cssClasses.controlPreview, this.isPreviewStyle);
  }
  getControlClass() {
    return this.getControlCssClassBuilder().toString();
  }
  //a11y
  get isNewA11yStructure() {
    return true;
  }
};
__decorate([property({
  localizable: true,
  onSet: (val, target) => target.resetRenderedPlaceholder()
})], QuestionTextBase.prototype, "placeholder", void 0);
Serializer.addClass("textbase", [], function() {
  return new QuestionTextBase("");
}, "question");
var InputElementAdapter = class {
  setInputValue(value) {
    if (this.inputElement.maxLength >= 0 && this.inputElement.maxLength < value.length) {
      value = value.slice(0, this.inputElement.maxLength);
    }
    this.inputElement.value = value;
  }
  constructor(inputMaskInstance, inputElement, value) {
    this.inputMaskInstance = inputMaskInstance;
    this.inputElement = inputElement;
    this.prevUnmaskedValue = void 0;
    this.inputMaskInstancePropertyChangedHandler = (sender, options) => {
      if (options.name !== "saveMaskedValue") {
        const maskedValue = this.inputMaskInstance.getMaskedValue(this.prevUnmaskedValue);
        this.setInputValue(maskedValue);
      }
    };
    this.clickHandler = (event) => {
      if (this.inputElement.value == this.inputMaskInstance.getMaskedValue("")) {
        this.inputElement.setSelectionRange(0, 0);
      }
    };
    this.beforeInputHandler = (event) => {
      const args = this.createArgs(event);
      const result = this.inputMaskInstance.processInput(args);
      this.setInputValue(result.value);
      this.inputElement.setSelectionRange(result.caretPosition, result.caretPosition);
      if (!result.cancelPreventDefault) {
        event.preventDefault();
      }
    };
    this.changeHandler = (event) => {
      const result = this.inputMaskInstance.processInput({
        prevValue: "",
        insertedChars: event.target.value,
        selectionStart: 0,
        selectionEnd: 0
      });
      this.setInputValue(result.value);
    };
    let _value = value;
    if (_value === null || _value === void 0) {
      _value = "";
    }
    this.setInputValue(inputMaskInstance.getMaskedValue(_value));
    this.prevUnmaskedValue = _value;
    inputMaskInstance.onPropertyChanged.add(this.inputMaskInstancePropertyChangedHandler);
    this.addInputEventListener();
  }
  createArgs(event) {
    const args = {
      insertedChars: event.data,
      selectionStart: event.target.selectionStart,
      selectionEnd: event.target.selectionEnd,
      prevValue: event.target.value,
      inputDirection: "forward"
    };
    if (event.inputType === "deleteContentBackward") {
      args.inputDirection = "backward";
      if (args.selectionStart === args.selectionEnd) {
        args.selectionStart = Math.max(args.selectionStart - 1, 0);
      }
    }
    if (event.inputType === "deleteContentForward" && args.selectionStart === args.selectionEnd) {
      args.selectionEnd += 1;
    }
    return args;
  }
  addInputEventListener() {
    if (!!this.inputElement) {
      this.inputElement.addEventListener("beforeinput", this.beforeInputHandler);
      this.inputElement.addEventListener("click", this.clickHandler);
      this.inputElement.addEventListener("focus", this.clickHandler);
      this.inputElement.addEventListener("change", this.changeHandler);
    }
  }
  removeInputEventListener() {
    if (!!this.inputElement) {
      this.inputElement.removeEventListener("beforeinput", this.beforeInputHandler);
      this.inputElement.removeEventListener("click", this.clickHandler);
      this.inputElement.removeEventListener("focus", this.clickHandler);
      this.inputElement.removeEventListener("change", this.changeHandler);
    }
  }
  dispose() {
    this.removeInputEventListener();
    this.inputElement = void 0;
    this.inputMaskInstance.onPropertyChanged.remove(this.inputMaskInstancePropertyChangedHandler);
  }
};
var numberDefinition = /[0-9]/;
function getAvailableMaskTypeChoices() {
  const classes = Serializer.getChildrenClasses("masksettings") || [];
  const choices = classes.map((cl) => {
    let value = cl.name;
    if (cl.name.indexOf("mask") !== -1) {
      value = value.slice(0, value.indexOf("mask"));
    }
    return value;
  });
  choices.unshift("none");
  return choices;
}
var QuestionTextModel = class extends QuestionTextBase {
  createMaskAdapter() {
    if (!!this.input && !this.maskTypeIsEmpty) {
      this.maskInputAdapter = new InputElementAdapter(this.maskInstance, this.input, this.value);
    }
  }
  deleteMaskAdapter() {
    if (this.maskInputAdapter) {
      this.maskInputAdapter.dispose();
      this.maskInputAdapter = void 0;
    }
  }
  updateMaskAdapter() {
    this.deleteMaskAdapter();
    this.createMaskAdapter();
  }
  onSetMaskType(newValue) {
    this.setNewMaskSettingsProperty();
    this.updateMaskAdapter();
  }
  get maskTypeIsEmpty() {
    switch (this.inputType) {
      case "tel":
      case "text":
        return this.maskType === "none";
      default:
        return true;
    }
  }
  /**
   * An object with properties that configure the mask applied to the input.
   *
   * Available properties depend on the specified [`maskType`](https://surveyjs.io/form-library/documentation/api-reference/text-entry-question-model#maskType) and belong to corresponding classes. Refer to the class APIs for a full list of properties:
   *
   * | `maskType` | Class |
   * | ---------- | ----- |
   * | `"numeric"` | [`InputMaskNumeric`](https://surveyjs.io/form-library/documentation/api-reference/inputmasknumeric) |
   * | `"currency"` | [`InputMaskCurrency`](https://surveyjs.io/form-library/documentation/api-reference/inputmaskcurrency) |
   * | `"datetime"` | [`InputMaskDateTime`](https://surveyjs.io/form-library/documentation/api-reference/inputmaskdatetime) |
   * | `"pattern"` | [`InputMaskPattern`](https://surveyjs.io/form-library/documentation/api-reference/inputmaskpattern) |
   *
   * [View Demo](https://surveyjs.io/form-library/examples/masked-input-fields/ (linkStyle))
   */
  get maskSettings() {
    return this.getPropertyValue("maskSettings");
  }
  set maskSettings(val) {
    if (!val) return;
    this.setNewMaskSettingsProperty();
    this.maskSettings.fromJSON(val.toJSON());
    this.updateMaskAdapter();
  }
  setNewMaskSettingsProperty() {
    this.setPropertyValue("maskSettings", this.createMaskSettings());
  }
  createMaskSettings() {
    let maskClassName = !this.maskType || this.maskType === "none" ? "masksettings" : this.maskType + "mask";
    if (!Serializer.findClass(maskClassName)) {
      maskClassName = "masksettings";
    }
    const inputMask = Serializer.createClass(maskClassName);
    inputMask.owner = this.survey;
    return inputMask;
  }
  constructor(name) {
    super(name);
    this._isWaitingForEnter = false;
    this.onCompositionUpdate = (event) => {
      if (this.isInputTextUpdate) {
        setTimeout(() => {
          this.updateValueOnEvent(event);
        }, 1);
      }
      this.updateRemainingCharacterCounter(event.target.value);
    };
    this.onKeyUp = (event) => {
      this.updateDateValidationMessage(event);
      if (this.isInputTextUpdate) {
        if (!this._isWaitingForEnter || event.keyCode === 13) {
          this.updateValueOnEvent(event);
          this._isWaitingForEnter = false;
        }
      } else {
        if (event.keyCode === 13) {
          this.updateValueOnEvent(event);
        }
      }
      this.updateRemainingCharacterCounter(event.target.value);
    };
    this.onKeyDown = (event) => {
      this.onKeyDownPreprocess && this.onKeyDownPreprocess(event);
      if (this.isInputTextUpdate) {
        this._isWaitingForEnter = event.keyCode === 229;
      }
      this.onTextKeyDownHandler(event);
    };
    this.onChange = (event) => {
      this.updateDateValidationMessage(event);
      const elementIsFocused = event.target === settings.environment.root.activeElement;
      if (elementIsFocused) {
        if (this.isInputTextUpdate) {
          this.updateValueOnEvent(event);
        }
      } else {
        this.updateValueOnEvent(event);
      }
      this.updateRemainingCharacterCounter(event.target.value);
    };
    this.createLocalizableString("minErrorText", this, true, "minError");
    this.createLocalizableString("maxErrorText", this, true, "maxError");
    this.setNewMaskSettingsProperty();
    this.locDataListValue = new LocalizableStrings(this);
    this.locDataListValue.onValueChanged = (oldValue, newValue) => {
      this.propertyValueChanged("dataList", oldValue, newValue);
    };
    this.registerPropertyChangedHandlers(["min", "max", "inputType", "minValueExpression", "maxValueExpression"], () => {
      this.setRenderedMinMax();
    });
    this.registerPropertyChangedHandlers(["inputType", "inputSize"], () => {
      this.resetInputSize();
      this.resetRenderedPlaceholder();
    });
  }
  isTextValue() {
    return this.isDateInputType || ["text", "number", "password"].indexOf(this.inputType) > -1;
  }
  getType() {
    return "text";
  }
  onSurveyLoad() {
    super.onSurveyLoad();
    this.setRenderedMinMax();
  }
  /**
   * A value passed on to the [`type`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#input_types) attribute of the underlying `<input>` element.
   *
   * Default value: `"text"`
   */
  get inputType() {
    return this.getPropertyValue("inputType");
  }
  set inputType(val) {
    val = val.toLowerCase();
    if (val === "datetime_local" || val === "datetime") val = "datetime-local";
    this.setPropertyValue("inputType", val.toLowerCase());
    if (!this.isLoadingFromJson) {
      this.min = void 0;
      this.max = void 0;
      this.step = void 0;
    }
    this.updateMaskAdapter();
  }
  getMaxLength() {
    if (!this.isTextInput) return null;
    return super.getMaxLength();
  }
  runConditionCore(values, properties) {
    super.runConditionCore(values, properties);
    if (!!this.minValueExpression || !!this.maxValueExpression) {
      this.setRenderedMinMax(values, properties);
    }
  }
  getDisplayValueCore(keysAsText, value) {
    if (!this.maskTypeIsEmpty && !Helpers.isValueEmpty(value)) return this.maskInstance.getMaskedValue(value);
    return super.getDisplayValueCore(keysAsText, value);
  }
  isLayoutTypeSupported(layoutType) {
    return true;
  }
  /**
   * A value passed on to the [`size`](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/size) attribute of the underlying `<input>` element.
   */
  get inputSize() {
    return this.getPropertyValue("inputSize");
  }
  set inputSize(val) {
    this.setPropertyValue("inputSize", val);
  }
  /**
   * @deprecated Use the [`inputSize`](https://surveyjs.io/form-library/documentation/api-reference/text-entry-question-model#inputSize) property instead.
   */
  get size() {
    return this.inputSize;
  }
  set size(val) {
    this.inputSize = val;
  }
  get isTextInput() {
    return ["text", "search", "tel", "url", "email", "password"].indexOf(this.inputType) > -1;
  }
  get renderedInputSize() {
    return this.getPropertyValue("renderedInputSize", void 0, () => {
      const size = this.calInputSize();
      return size > 0 ? size : void 0;
    });
  }
  get inputWidth() {
    return this.getPropertyValue("inputWidth", void 0, () => {
      return this.calInputSize() > 0 ? "auto" : "";
    });
  }
  calInputSize() {
    if (!this.isTextInput) return 0;
    let size = this.inputSize > 0 ? this.inputSize : 0;
    if (size < 1 && this.parent && !!this.parent["inputSize"]) {
      size = this.parent["inputSize"];
    }
    return size;
  }
  resetInputSize() {
    this.resetPropertyValue("renderedInputSize");
    this.resetPropertyValue("inputWidth");
  }
  /**
   * A value passed on to the [`autocomplete`](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete) attribute of the underlying `<input>` element.
   */
  get autocomplete() {
    return this.getPropertyValue("autocomplete", null);
  }
  set autocomplete(val) {
    this.setPropertyValue("autocomplete", val);
  }
  /**
   * A value passed on to the [`min`](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/min) attribute of the underlying `<input>` element.
   * @see minValueExpression
   */
  get min() {
    return this.getPropertyValue("min");
  }
  set min(val) {
    if (this.isValueExpression(val)) {
      this.minValueExpression = val.substring(1);
      return;
    }
    this.setPropertyValue("min", val);
  }
  /**
   * A value passed on to the [`max`](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/max) attribute of the underlying `<input>` element.
   * @see maxValueExpression
   */
  get max() {
    return this.getPropertyValue("max");
  }
  set max(val) {
    if (this.isValueExpression(val)) {
      this.maxValueExpression = val.substring(1);
      return;
    }
    this.setPropertyValue("max", val);
  }
  /**
   * The minimum value specified as an expression. For example, `"minValueExpression": "today(-1)"` sets the minimum value to yesterday.
   * @see min
   */
  get minValueExpression() {
    return this.getPropertyValue("minValueExpression", "");
  }
  set minValueExpression(val) {
    this.setPropertyValue("minValueExpression", val);
  }
  /**
   * The maximum value specified as an expression. For example, `"maxValueExpression": "today(1)"` sets the maximum value to tomorrow.
   * @see max
   */
  get maxValueExpression() {
    return this.getPropertyValue("maxValueExpression", "");
  }
  set maxValueExpression(val) {
    this.setPropertyValue("maxValueExpression", val);
  }
  get renderedMin() {
    return this.getPropertyValue("renderedMin");
  }
  get renderedMax() {
    return this.getPropertyValue("renderedMax");
  }
  /**
   * An error message to display when the question value is less than the minimum accepted value.
   * @see min
   * @see minValueExpression
   */
  get minErrorText() {
    return this.getLocalizableStringText("minErrorText");
  }
  set minErrorText(val) {
    this.setLocalizableStringText("minErrorText", val);
  }
  get locMinErrorText() {
    return this.getLocalizableString("minErrorText");
  }
  /**
   * An error message to display when the question value exceeds the maximum accepted value.
   * @see max
   * @see maxValueExpression
   */
  get maxErrorText() {
    return this.getLocalizableStringText("maxErrorText");
  }
  set maxErrorText(val) {
    this.setLocalizableStringText("maxErrorText", val);
  }
  get locMaxErrorText() {
    return this.getLocalizableString("maxErrorText");
  }
  /**
   * Returns `true` if the specified `inputType` supports the `min` and `max` properties.
   * @see inputType
   * @see min
   * @see max
   */
  get isMinMaxType() {
    return isMinMaxType(this);
  }
  get maskInstance() {
    return this.maskSettings;
  }
  get inputValue() {
    if (!this._inputValue && !this.maskTypeIsEmpty) return this.maskInstance.getMaskedValue("");
    return this._inputValue;
  }
  set inputValue(val) {
    let value = val;
    this._inputValue = val;
    if (!this.maskTypeIsEmpty) {
      value = this.maskInstance.getUnmaskedValue(val);
      this._inputValue = this.maskInstance.getMaskedValue(value);
      if (!!value && this.maskSettings.saveMaskedValue) {
        value = this.maskInstance.getMaskedValue(value);
      }
    }
    this.value = value;
  }
  onChangeQuestionValue(newValue) {
    super.onChangeQuestionValue(newValue);
    this.updateInputValue();
  }
  updateInputValue() {
    if (this.maskTypeIsEmpty) {
      this._inputValue = this.value;
    } else if (this.maskSettings.saveMaskedValue) {
      this._inputValue = !!this.value ? this.value : this.maskInstance.getMaskedValue("");
    } else {
      this._inputValue = this.maskInstance.getMaskedValue(this.value);
    }
  }
  hasToConvertToUTC(val) {
    return settings.storeUtcDates && this.isDateTimeLocaleType() && !!val;
  }
  createDate(val) {
    return createDate("question-text", val);
  }
  valueForSurveyCore(val) {
    if (this.hasToConvertToUTC(val)) {
      val = this.createDate(val).toISOString();
    }
    return super.valueForSurveyCore(val);
  }
  valueFromDataCore(val) {
    if (this.hasToConvertToUTC(val)) {
      const d = this.createDate(val);
      const locale_d = this.createDate(d.getTime() - d.getTimezoneOffset() * 60 * 1e3);
      let res = locale_d.toISOString();
      val = res.substring(0, res.length - 2);
    }
    return super.valueFromDataCore(val);
  }
  onCheckForErrors(errors, isOnValueChanged, fireCallback) {
    super.onCheckForErrors(errors, isOnValueChanged, fireCallback);
    if (isOnValueChanged) return;
    if (this.isValueLessMin) {
      const minError = new CustomError(this.getMinMaxErrorText(this.minErrorText, this.getCalculatedMinMax(this.renderedMin)), this);
      minError.onUpdateErrorTextCallback = (err) => {
        err.text = this.getMinMaxErrorText(this.minErrorText, this.getCalculatedMinMax(this.renderedMin));
      };
      errors.push(minError);
    }
    if (this.isValueGreaterMax) {
      const maxError = new CustomError(this.getMinMaxErrorText(this.maxErrorText, this.getCalculatedMinMax(this.renderedMax)), this);
      maxError.onUpdateErrorTextCallback = (err) => {
        err.text = this.getMinMaxErrorText(this.maxErrorText, this.getCalculatedMinMax(this.renderedMax));
      };
      errors.push(maxError);
    }
    if (!!this.dateValidationMessage) {
      errors.push(new CustomError(this.dateValidationMessage, this));
    }
    const valName = this.getValidatorTitle();
    const emailValidator = new EmailValidator();
    emailValidator.errorOwner = this;
    if (this.inputType === "email" && !this.validators.some((v) => v.getType() === "emailvalidator")) {
      const validateResult = emailValidator.validate(this.value, valName);
      if (!!validateResult && !!validateResult.error) {
        errors.push(validateResult.error);
      }
    }
  }
  canSetValueToSurvey() {
    if (!this.isMinMaxType) return true;
    const isValid = !this.isValueLessMin && !this.isValueGreaterMax;
    if ((!isValid || this.errors.length > 0) && !!this.survey && (this.survey.isValidateOnValueChanging || this.survey.isValidateOnValueChanged)) {
      this.hasErrors();
    }
    return isValid;
  }
  convertFuncValuetoQuestionValue(val) {
    let type = this.maskTypeIsEmpty ? this.inputType : this.maskSettings.getTypeForExpressions();
    return Helpers.convertValToQuestionVal(val, type);
  }
  getMinMaxErrorText(errorText, value) {
    if (Helpers.isValueEmpty(value)) return errorText;
    let errorValue = value.toString();
    if (this.inputType === "date" && !!value.toDateString) {
      errorValue = value.toDateString();
    }
    return errorText.replace("{0}", errorValue);
  }
  get isValueLessMin() {
    return !this.isValueEmpty(this.renderedMin) && !this.isEmpty() && this.getCalculatedMinMax(this.value) < this.getCalculatedMinMax(this.renderedMin);
  }
  get isValueGreaterMax() {
    return !this.isValueEmpty(this.renderedMax) && !this.isEmpty() && this.getCalculatedMinMax(this.value) > this.getCalculatedMinMax(this.renderedMax);
  }
  get isDateInputType() {
    return this.inputType === "date" || this.isDateTimeLocaleType();
  }
  isDateTimeLocaleType() {
    return this.inputType === "datetime-local";
  }
  getCalculatedMinMax(minMax) {
    if (this.isValueEmpty(minMax)) return minMax;
    return this.isDateInputType ? this.createDate(minMax) : minMax;
  }
  setRenderedMinMax(values = null, properties = null) {
    this.minValueRunner = this.getDefaultRunner(this.minValueRunner, this.minValueExpression);
    this.setValueAndRunExpression(this.minValueRunner, this.min, (val) => {
      if (!val && this.isDateInputType && !!settings.minDate) {
        val = settings.minDate;
      }
      this.setPropertyValue("renderedMin", val);
    }, values, properties);
    this.maxValueRunner = this.getDefaultRunner(this.maxValueRunner, this.maxValueExpression);
    this.setValueAndRunExpression(this.maxValueRunner, this.max, (val) => {
      if (!val && this.isDateInputType) {
        val = !!settings.maxDate ? settings.maxDate : "2999-12-31";
      }
      this.setPropertyValue("renderedMax", val);
    }, values, properties);
  }
  /**
   * A value passed on to the [`step`](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/step) attribute of the underlying `<input>` element.
   */
  get step() {
    return this.getPropertyValue("step");
  }
  set step(val) {
    this.setPropertyValue("step", val);
  }
  get renderedStep() {
    if (this.isValueEmpty(this.step)) {
      return this.inputType !== "number" ? void 0 : "any";
    }
    return this.step;
  }
  getIsInputTextUpdate() {
    return this.maskTypeIsEmpty ? super.getIsInputTextUpdate() : false;
  }
  supportAutoAdvance() {
    return !this.getIsInputTextUpdate() && !this.isDateInputType;
  }
  supportGoNextPageError() {
    return !this.isDateInputType;
  }
  /**
   * An array of predefined options from which users can select. This property configures an HTML [`<datalist>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/datalist) element and associates it with the underlying `input` element.
   */
  get dataList() {
    return this.locDataList.value;
  }
  set dataList(val) {
    this.locDataList.value = val;
  }
  get locDataList() {
    return this.locDataListValue;
  }
  get dataListId() {
    return this.locDataList.hasValue() ? this.id + "_datalist" : void 0;
  }
  setNewValue(newValue) {
    newValue = this.correctValueType(newValue);
    if (!!newValue) {
      this.dateValidationMessage = void 0;
    }
    super.setNewValue(newValue);
  }
  correctValueType(newValue) {
    if (!newValue) return newValue;
    if (this.inputType === "number" || this.inputType === "range") {
      return Helpers.isNumber(newValue) ? Helpers.getNumber(newValue) : "";
    }
    if (this.inputType === "month") {
      const d = this.createDate(newValue);
      const isUtc = d.toISOString().indexOf(newValue) == 0 && newValue.indexOf("T") == -1;
      const month2 = isUtc ? d.getUTCMonth() : d.getMonth();
      const year2 = isUtc ? d.getUTCFullYear() : d.getFullYear();
      const m = month2 + 1;
      return year2 + "-" + (m < 10 ? "0" : "") + m;
    }
    return newValue;
  }
  hasPlaceholder() {
    return !this.isReadOnly && this.inputType !== "range";
  }
  getControlCssClassBuilder() {
    const maxLength = this.getMaxLength();
    return super.getControlCssClassBuilder().append(this.cssClasses.constrolWithCharacterCounter, !!maxLength).append(this.cssClasses.characterCounterBig, maxLength > 99);
  }
  isReadOnlyRenderDiv() {
    return this.isReadOnly && settings.readOnly.textRenderMode === "div";
  }
  get inputStyle() {
    var style = {};
    style.width = this.inputWidth;
    this.updateTextAlign(style);
    return style;
  }
  updateTextAlign(style) {
    if (this.inputTextAlignment !== "auto") {
      style.textAlign = this.inputTextAlignment;
    } else if (!this.maskTypeIsEmpty && this.maskSettings.getTextAlignment() !== "auto") {
      style.textAlign = this.maskSettings.getTextAlignment();
    }
  }
  updateValueOnEvent(event) {
    const newValue = event.target.value;
    if (!this.isTwoValueEquals(this.value, newValue)) {
      this.inputValue = newValue;
    }
  }
  updateDateValidationMessage(event) {
    this.dateValidationMessage = this.isDateInputType && !!event.target ? event.target.validationMessage : void 0;
  }
  onBlurCore(event) {
    this.updateDateValidationMessage(event);
    this.updateValueOnEvent(event);
    this.updateRemainingCharacterCounter(event.target.value);
    super.onBlurCore(event);
  }
  onFocusCore(event) {
    this.updateRemainingCharacterCounter(event.target.value);
    super.onFocusCore(event);
  }
  afterRenderQuestionElement(el) {
    if (!!el) {
      this.input = el instanceof HTMLInputElement ? el : el.querySelector("input");
      this.createMaskAdapter();
    }
    super.afterRenderQuestionElement(el);
  }
  beforeDestroyQuestionElement(el) {
    this.deleteMaskAdapter();
    this.input = void 0;
  }
};
__decorate([property({
  onSet: (newValue, target) => {
    target.onSetMaskType(newValue);
  }
})], QuestionTextModel.prototype, "maskType", void 0);
__decorate([property()], QuestionTextModel.prototype, "inputTextAlignment", void 0);
__decorate([property()], QuestionTextModel.prototype, "_inputValue", void 0);
var minMaxTypes = ["number", "range", "date", "datetime-local", "month", "time", "week"];
function isMinMaxType(obj) {
  const t = !!obj ? obj.inputType : "";
  if (!t) return false;
  return minMaxTypes.indexOf(t) > -1;
}
function getWeekTimeNumber(str, delimiter) {
  const strs = str.split(delimiter);
  if (strs.length !== 2) return -1;
  if (!Helpers.isNumber(strs[0]) || !Helpers.isNumber(strs[1])) return -1;
  return parseFloat(strs[0]) * 60 + parseFloat(strs[1]);
}
function isMinBiggerWeekTime(minStr, maxStr, delimiter) {
  const min2 = getWeekTimeNumber(minStr, delimiter);
  const max2 = getWeekTimeNumber(maxStr, delimiter);
  if (min2 < 0 || max2 < 0) return false;
  return min2 > max2;
}
function getCorrectMinMax(obj, min2, max2, isMax) {
  let val = isMax ? max2 : min2;
  if (!isMinMaxType(obj)) return val;
  if (Helpers.isValueEmpty(min2) || Helpers.isValueEmpty(max2)) return val;
  if (obj.inputType.indexOf("date") === 0 || obj.inputType === "month") {
    const isMonth = obj.inputType === "month";
    const reason = "question-text-minmax";
    const dMin = createDate(reason, isMonth ? min2 + "-01" : min2);
    const dMax = createDate(reason, isMonth ? max2 + "-01" : max2);
    if (!dMin || !dMax) return val;
    if (dMin > dMax) return isMax ? min2 : max2;
  }
  if (obj.inputType === "week" || obj.inputType === "time") {
    const delimiter = obj.inputType === "week" ? "-W" : ":";
    if (isMinBiggerWeekTime(min2, max2, delimiter)) return isMax ? min2 : max2;
    return val;
  }
  if (obj.inputType === "number") {
    if (!Helpers.isNumber(min2) || !Helpers.isNumber(max2)) return val;
    if (Helpers.getNumber(min2) > Helpers.getNumber(max2)) return isMax ? min2 : max2;
  }
  if (typeof min2 === "string" || typeof max2 === "string") return val;
  if (min2 > max2) return isMax ? min2 : max2;
  return val;
}
function propertyEditorMinMaxUpdate(obj, propertyEditor) {
  if (!!obj && !!obj.inputType) {
    propertyEditor.inputType = obj.inputType !== "range" ? obj.inputType : "number";
    propertyEditor.textUpdateMode = "onBlur";
  }
}
Serializer.addClass("text", [{
  name: "inputType",
  default: "text",
  choices: settings.questions.inputTypes
}, {
  name: "inputSize:number",
  alternativeName: "size",
  minValue: 0,
  dependsOn: "inputType",
  visibleIf: function(obj) {
    if (!obj) return false;
    return obj.isTextInput;
  }
}, {
  name: "textUpdateMode",
  default: "default",
  choices: ["default", "onBlur", "onTyping"],
  dependsOn: "inputType",
  visibleIf: function(obj) {
    if (!obj) return false;
    return obj.isTextInput;
  }
}, {
  name: "autocomplete",
  alternativeName: "autoComplete",
  choices: settings.questions.dataList
}, {
  name: "min",
  dependsOn: "inputType",
  visibleIf: function(obj) {
    return isMinMaxType(obj);
  },
  onPropertyEditorUpdate: function(obj, propertyEditor) {
    propertyEditorMinMaxUpdate(obj, propertyEditor);
  },
  onSettingValue: (obj, val) => {
    return getCorrectMinMax(obj, val, obj.max, false);
  }
}, {
  name: "max",
  dependsOn: "inputType",
  nextToProperty: "*min",
  visibleIf: function(obj) {
    return isMinMaxType(obj);
  },
  onSettingValue: (obj, val) => {
    return getCorrectMinMax(obj, obj.min, val, true);
  },
  onPropertyEditorUpdate: function(obj, propertyEditor) {
    propertyEditorMinMaxUpdate(obj, propertyEditor);
  }
}, {
  name: "minValueExpression:expression",
  category: "logic",
  dependsOn: "inputType",
  visibleIf: function(obj) {
    return isMinMaxType(obj);
  }
}, {
  name: "maxValueExpression:expression",
  category: "logic",
  dependsOn: "inputType",
  visibleIf: function(obj) {
    return isMinMaxType(obj);
  }
}, {
  name: "minErrorText",
  serializationProperty: "locMinErrorText",
  dependsOn: "inputType",
  visibleIf: function(obj) {
    return isMinMaxType(obj);
  }
}, {
  name: "maxErrorText",
  serializationProperty: "locMaxErrorText",
  dependsOn: "inputType",
  visibleIf: function(obj) {
    return isMinMaxType(obj);
  }
}, {
  name: "inputTextAlignment",
  default: "auto",
  choices: ["left", "right", "auto"]
}, {
  name: "maskType",
  default: "none",
  visibleIndex: 0,
  dependsOn: "inputType",
  visibleIf: (obj) => {
    return obj.inputType === "text" || obj.inputType === "tel";
  },
  choices: (obj) => {
    const choices = getAvailableMaskTypeChoices();
    return choices;
  }
}, {
  name: "maskSettings:masksettings",
  className: "masksettings",
  visibleIndex: 1,
  dependsOn: ["inputType", "maskType"],
  visibleIf: (obj) => {
    return obj.inputType === "text" || obj.inputType === "tel";
  },
  onGetValue: function(obj) {
    return obj.maskSettings.getData();
  },
  onSetValue: function(obj, value) {
    obj.maskSettings.setData(value);
  }
}, {
  name: "step:number",
  dependsOn: "inputType",
  visibleIf: function(obj) {
    if (!obj) return false;
    return obj.inputType === "number" || obj.inputType === "range";
  }
}, {
  name: "maxLength:number",
  default: -1,
  dependsOn: "inputType",
  visibleIf: function(obj) {
    if (!obj) return false;
    return obj.isTextInput;
  }
}, {
  name: "placeholder",
  alternativeName: "placeHolder",
  serializationProperty: "locPlaceholder",
  dependsOn: "inputType",
  visibleIf: function(obj) {
    if (!obj) return false;
    return obj.isTextInput;
  }
}, {
  name: "dataList:string[]",
  serializationProperty: "locDataList",
  dependsOn: "inputType",
  visibleIf: function(obj) {
    if (!obj) return false;
    return obj.inputType === "text";
  }
}], function() {
  return new QuestionTextModel("");
}, "textbase");
QuestionFactory.Instance.registerQuestion("text", (name) => {
  return new QuestionTextModel(name);
});
var MultipleTextEditorModel = class extends QuestionTextModel {
  get a11y_input_ariaLabel() {
    return this.locTitle.renderedHtml;
  }
  get a11y_input_ariaLabelledBy() {
    return null;
  }
  get a11y_input_ariaDescribedBy() {
    return null;
  }
};
var MultipleTextItemModel = class extends Base {
  constructor(name = null, title = null) {
    super();
    this.focusIn = () => {
      this.editor.focusIn();
    };
    this.editorValue = this.createEditor(name);
    this.maskSettings = this.editorValue.maskSettings;
    this.editor.questionTitleTemplateCallback = function() {
      return "";
    };
    this.editor.titleLocation = "left";
    if (title) {
      this.title = title;
    }
    this.editor.onPropertyChanged.add((sender, options) => {
      this.onPropertyChanged.fire(this, options);
    });
  }
  getType() {
    return "multipletextitem";
  }
  get id() {
    return this.editor.id;
  }
  getOriginalObj() {
    return this.editor;
  }
  /**
   * An item ID that is not visible to respondents.
   *
   * > Item IDs must be unique.
   * @see title
   */
  get name() {
    return this.editor.name;
  }
  set name(val) {
    this.editor.name = val;
  }
  get question() {
    return this.data;
  }
  get editor() {
    return this.editorValue;
  }
  createEditor(name) {
    return new MultipleTextEditorModel(name);
  }
  addUsedLocales(locales) {
    super.addUsedLocales(locales);
    this.editor.addUsedLocales(locales);
  }
  localeChanged() {
    super.localeChanged();
    this.editor.localeChanged();
  }
  locStrsChanged() {
    super.locStrsChanged();
    this.editor.locStrsChanged();
  }
  setData(data) {
    this.data = data;
    if (!!data) {
      this.editor.defaultValue = data.getItemDefaultValue(this.name);
      this.editor.setSurveyImpl(this);
      this.editor.parent = data;
      this.editor.setParentQuestion(data);
    }
  }
  /**
   * Marks the item as required. If a respondent leaves this item empty, the question displays a [validation error](#requiredErrorText).
   */
  get isRequired() {
    return this.editor.isRequired;
  }
  set isRequired(val) {
    this.editor.isRequired = val;
  }
  /**
   * A value passed on to the [`type`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#input_types) attribute of the underlying `<input>` element.
   *
   * Default value: `"text"`
   */
  get inputType() {
    return this.editor.inputType;
  }
  set inputType(val) {
    this.editor.inputType = val;
  }
  /**
   * A user-friendly item label to display. If `title` is undefined, [`name`](https://surveyjs.io/form-library/documentation/api-reference/multipletextitemmodel#name) is displayed instead.
   */
  get title() {
    return this.editor.title;
  }
  set title(val) {
    this.editor.title = val;
  }
  get locTitle() {
    return this.editor.locTitle;
  }
  get fullTitle() {
    return this.editor.fullTitle;
  }
  /**
   * The maximum text length measured in characters. Assign 0 if the length should be unlimited.
   *
   * Default value: -1 (inherits the actual value from the `SurveyModel`'s [`maxTextLength`](https://surveyjs.io/form-library/documentation/surveymodel#maxTextLength) property).
   */
  get maxLength() {
    return this.editor.maxLength;
  }
  set maxLength(val) {
    this.editor.maxLength = val;
  }
  getMaxLength() {
    var survey = this.getSurvey();
    return Helpers.getMaxLength(this.maxLength, survey ? survey.maxTextLength : -1);
  }
  /**
   * A placeholder for the input field.
   */
  get placeholder() {
    return this.editor.placeholder;
  }
  set placeholder(val) {
    this.editor.placeholder = val;
  }
  get locPlaceholder() {
    return this.editor.locPlaceholder;
  }
  get placeHolder() {
    return this.placeholder;
  }
  set placeHolder(val) {
    this.placeholder = val;
  }
  get locPlaceHolder() {
    return this.locPlaceholder;
  }
  /**
   * Specifies a custom error message for a [required item](#isRequired).
   */
  get requiredErrorText() {
    return this.editor.requiredErrorText;
  }
  set requiredErrorText(val) {
    this.editor.requiredErrorText = val;
  }
  get locRequiredErrorText() {
    return this.editor.locRequiredErrorText;
  }
  /**
   * A value passed on to the [`size`](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/size) attribute of the underlying `<input>` element.
   *
   * If you want to set a uniform `inputSize` for all text box items, use the [`inputSize`](https://surveyjs.io/form-library/documentation/api-reference/multiple-text-entry-question-model#inputSize) property within the Multiple Textboxes configuration.
   */
  get inputSize() {
    return this.editor.inputSize;
  }
  set inputSize(val) {
    this.editor.inputSize = val;
  }
  /**
   * @deprecated Use the [`inputSize`](https://surveyjs.io/form-library/documentation/api-reference/multipletextitemmodel#inputSize) property instead.
   */
  get size() {
    return this.inputSize;
  }
  set size(val) {
    this.inputSize = val;
  }
  /**
   * An [expression](https://surveyjs.io/form-library/documentation/design-survey/conditional-logic#expressions) used to calculate the default item value.
   * @see minValueExpression
   * @see maxValueExpression
   */
  get defaultValueExpression() {
    return this.editor.defaultValueExpression;
  }
  set defaultValueExpression(val) {
    this.editor.defaultValueExpression = val;
  }
  /**
   * An [expression](https://surveyjs.io/form-library/documentation/design-survey/conditional-logic#expressions) used to calculate the minimum item value.
   * @see maxValueExpression
   * @see defaultValueExpression
   */
  get minValueExpression() {
    return this.editor.minValueExpression;
  }
  set minValueExpression(val) {
    this.editor.minValueExpression = val;
  }
  /**
   * An [expression](https://surveyjs.io/form-library/documentation/design-survey/conditional-logic#expressions) used to calculate the maximum item value.
   * @see minValueExpression
   * @see defaultValueExpression
   */
  get maxValueExpression() {
    return this.editor.maxValueExpression;
  }
  set maxValueExpression(val) {
    this.editor.maxValueExpression = val;
  }
  /**
   * Item validators.
   *
   * [Data Validation](https://surveyjs.io/form-library/documentation/data-validation (linkStyle))
   */
  get validators() {
    return this.editor.validators;
  }
  set validators(val) {
    this.editor.validators = val;
  }
  getValidators() {
    return this.validators;
  }
  /**
   * Specifies the type of a mask applied to the input.
   *
   * Possible values:
   *
   * - `"none"` (default)
   * - `"numeric"`
   * - `"currency"`
   * - `"datetime"`
   * - `"pattern"`
   *
   * [View Demo](https://surveyjs.io/form-library/examples/masked-input-fields/ (linkStyle))
   * @see maskSettings
   */
  get maskType() {
    return this.editor.maskType;
  }
  set maskType(val) {
    this.editor.maskType = val;
    this.maskSettings = this.editor.maskSettings;
  }
  /**
   * An object with properties that configure the mask applied to the input.
   *
   * Available properties depend on the specified [`maskType`](#maskType) and belong to corresponding classes. Refer to the class APIs for a full list of properties:
   *
   * | `maskType` | Class |
   * | ---------- | ----- |
   * | `"numeric"` | [`InputMaskNumeric`](https://surveyjs.io/form-library/documentation/api-reference/inputmasknumeric) |
   * | `"currency"` | [`InputMaskCurrency`](https://surveyjs.io/form-library/documentation/api-reference/inputmaskcurrency) |
   * | `"datetime"` | [`InputMaskDateTime`](https://surveyjs.io/form-library/documentation/api-reference/inputmaskdatetime) |
   * | `"pattern"` | [`InputMaskPattern`](https://surveyjs.io/form-library/documentation/api-reference/inputmaskpattern) |
   *
   * [View Demo](https://surveyjs.io/form-library/examples/masked-input-fields/ (linkStyle))
   */
  get maskSettings() {
    return this.getPropertyValue("maskSettings");
  }
  set maskSettings(val) {
    this.setPropertyValue("maskSettings", val);
    if (this.editor.maskSettings !== val) {
      this.editor.maskSettings = val;
    }
  }
  /**
   * Specifies text alignment within the input field.
   *
   * Possible values:
   *
   * - `"left"` - Aligns input text to the left side.
   * - `"right"` - Aligns input text to the right side.
   * - `"auto"` (default) - Applies right alignment if a [numeric or currency input mask](https://surveyjs.io/form-library/documentation/api-reference/multipletextitemmodel#maskType) is specified. Otherwise, applies left alignment.
   */
  get inputTextAlignment() {
    return this.editor.inputTextAlignment;
  }
  set inputTextAlignment(val) {
    this.editor.inputTextAlignment = val;
  }
  /**
   * An item value.
   */
  get value() {
    return this.data ? this.data.getMultipleTextValue(this.name) : null;
  }
  set value(value) {
    if (this.data != null) {
      this.data.setMultipleTextValue(this.name, value);
    }
  }
  isEmpty() {
    return this.editor.isEmpty();
  }
  onValueChanged(newValue) {
    if (this.valueChangedCallback) this.valueChangedCallback(newValue);
  }
  //ISurveyImpl
  getSurveyData() {
    return this;
  }
  getSurvey() {
    return this.data ? this.data.getSurvey() : null;
  }
  getTextProcessor() {
    return this.data ? this.data.getTextProcessor() : null;
  }
  //ISurveyData
  getValue(name) {
    if (!this.data) return null;
    return this.data.getMultipleTextValue(name);
  }
  setValue(name, value) {
    if (this.data) {
      this.data.setMultipleTextValue(name, value);
    }
  }
  getVariable(name) {
    return void 0;
  }
  setVariable(name, newValue) {
  }
  getComment(name) {
    return null;
  }
  setComment(name, newValue) {
  }
  getAllValues() {
    if (this.data) return this.data.getAllValues();
    return this.value;
  }
  getFilteredValues() {
    return this.getAllValues();
  }
  getFilteredProperties() {
    return {
      survey: this.getSurvey()
    };
  }
  findQuestionByName(name) {
    const survey = this.getSurvey();
    return !!survey ? survey.getQuestionByName(name) : null;
  }
  getEditingSurveyElement() {
    return void 0;
  }
  //IValidatorOwner
  getValidatorTitle() {
    return this.title;
  }
  get validatedValue() {
    return this.value;
  }
  set validatedValue(val) {
    this.value = val;
  }
  getDataFilteredValues() {
    return this.getFilteredValues();
  }
  getDataFilteredProperties() {
    return this.getFilteredProperties();
  }
};
var QuestionMultipleTextModel = class extends Question {
  static addDefaultItems(question) {
    var names = QuestionFactory.DefaultMutlipleTextItems;
    for (var i = 0; i < names.length; i++) question.addItem(names[i]);
  }
  constructor(name) {
    super(name);
    this.isMultipleItemValueChanging = false;
    this.createNewArray("items", (item) => {
      item.setData(this);
      if (this.survey) {
        this.survey.multipleTextItemAdded(this, item);
      }
    });
    this.registerPropertyChangedHandlers(["items", "colCount", "itemErrorLocation"], () => {
      this.calcVisibleRows();
    });
    this.registerPropertyChangedHandlers(["inputSize"], () => {
      this.resetItemsSize();
    });
  }
  getType() {
    return "multipletext";
  }
  setSurveyImpl(value, isLight) {
    super.setSurveyImpl(value, isLight);
    for (var i = 0; i < this.items.length; i++) {
      this.items[i].setData(this);
    }
  }
  get isAllowTitleLeft() {
    return false;
  }
  get hasSingleInput() {
    return false;
  }
  get isContainer() {
    return true;
  }
  get id() {
    return this.getPropertyValue("id");
  }
  set id(val) {
    var _a;
    (_a = this.items) === null || _a === void 0 ? void 0 : _a.map((item, index) => item.editor.id = val + "_" + index);
    this.setPropertyValue("id", val);
  }
  onSurveyLoad() {
    this.editorsOnSurveyLoad();
    super.onSurveyLoad();
    if (!Helpers.isValueEmpty(this.rows)) {
      this.calcVisibleRows();
    }
  }
  setQuestionValue(newValue, updateIsAnswered = true) {
    super.setQuestionValue(newValue, updateIsAnswered);
    this.performForEveryEditor((item) => {
      item.editor.updateValueFromSurvey(item.value);
    });
    this.updateIsAnswered();
  }
  onSurveyValueChanged(newValue) {
    super.onSurveyValueChanged(newValue);
    this.performForEveryEditor((item) => {
      item.editor.onSurveyValueChanged(item.value);
    });
  }
  resetItemsSize() {
    this.performForEveryEditor((item) => {
      item.editor.resetInputSize();
    });
  }
  editorsOnSurveyLoad() {
    this.performForEveryEditor((item) => {
      item.editor.onSurveyLoad();
    });
  }
  performForEveryEditor(func) {
    for (var i = 0; i < this.items.length; i++) {
      var item = this.items[i];
      if (item.editor) {
        func(item);
      }
    }
  }
  /**
   * Gets or sets an array of [`MultipleTextItemModel`](https://surveyjs.io/form-library/documentation/api-reference/multipletextitemmodel) objects that represent input items.
   *
   * Each object in this array should have at least the following properties:
   *
   * ```js
   * {
   *   "name": any, // A unique value used to identify an input item and save an item value to survey results.
   *   "title": String // An item caption. When `title` is undefined, `name` is used. This property supports Markdown.
   * }
   * ```
   *
   * To enable Markdown support for the `title` property, implement Markdown-to-HTML conversion in the [`onTextMarkdown`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#onTextMarkdown) event handler. For an example, refer to the following demo: [Convert Markdown to HTML with markdown-it](https://surveyjs.io/form-library/examples/edit-survey-questions-markdown/).
   * @see itemTitleWidth
   * @see addItem
   */
  get items() {
    return this.getPropertyValue("items");
  }
  set items(val) {
    this.setPropertyValue("items", val);
  }
  /**
   * Adds a new input item.
   * @param name An item name.
   * @param title *(Optional)* An item title.
   * @see items
   */
  addItem(name, title = null) {
    var item = this.createTextItem(name, title);
    this.items.push(item);
    return item;
  }
  getItemByName(name) {
    for (var i = 0; i < this.items.length; i++) {
      if (this.items[i].name == name) return this.items[i];
    }
    return null;
  }
  getElementsInDesign(includeHidden = false) {
    let elements;
    elements = super.getElementsInDesign(includeHidden);
    return elements.concat(this.items);
  }
  addConditionObjectsByContext(objects, context) {
    for (var i = 0; i < this.items.length; i++) {
      var item = this.items[i];
      objects.push({
        name: this.getValueName() + "." + item.name,
        text: this.processedTitle + "." + item.fullTitle,
        question: this
      });
    }
  }
  collectNestedQuestionsCore(questions, visibleOnly) {
    this.items.forEach((item) => item.editor.collectNestedQuestions(questions, visibleOnly));
  }
  getConditionJson(operator = null, path = null) {
    if (!path) return super.getConditionJson(operator);
    var item = this.getItemByName(path);
    if (!item) return null;
    var json2 = new JsonObject().toJsonObject(item);
    json2["type"] = "text";
    return json2;
  }
  locStrsChanged() {
    super.locStrsChanged();
    for (var i = 0; i < this.items.length; i++) {
      this.items[i].locStrsChanged();
    }
  }
  localeChanged() {
    super.localeChanged();
    for (var i = 0; i < this.items.length; i++) {
      this.items[i].localeChanged();
    }
  }
  /**
   * Specifies the error message position relative to individual input fields.
   *
   * Possible values:
   *
   * - `"default"` (default) - Inherits the setting from the [`errorLocation`](#errorLocation) property.
   * - `"top"` - Displays error messages above input fields.
   * - `"bottom"` - Displays error messages below input fields.
   */
  get itemErrorLocation() {
    return this.getPropertyValue("itemErrorLocation");
  }
  set itemErrorLocation(val) {
    this.setPropertyValue("itemErrorLocation", val);
  }
  getQuestionErrorLocation() {
    if (this.itemErrorLocation !== "default") return this.itemErrorLocation;
    return this.getErrorLocation();
  }
  get showItemErrorOnTop() {
    return this.getQuestionErrorLocation() == "top";
  }
  get showItemErrorOnBottom() {
    return this.getQuestionErrorLocation() == "bottom";
  }
  getChildErrorLocation(child) {
    return this.getQuestionErrorLocation();
  }
  isNewValueCorrect(val) {
    return Helpers.isValueObject(val, true);
  }
  supportAutoAdvance() {
    for (var i = 0; i < this.items.length; i++) {
      if (this.items[i].isEmpty()) return false;
    }
    return true;
  }
  /**
   * The number of columns used to arrange input items. Accepts the following values: 1, 2, 3, 4, 5.
   *
   * Default value: 1
   */
  get colCount() {
    return this.getPropertyValue("colCount");
  }
  set colCount(val) {
    if (val < 1 || val > 5) return;
    this.setPropertyValue("colCount", val);
  }
  /**
   * A value passed on to the [`inputSize`](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/size) attribute of the underlying `<input>` elements.
   */
  get inputSize() {
    return this.getPropertyValue("inputSize");
  }
  set inputSize(val) {
    this.setPropertyValue("inputSize", val);
  }
  /**
   * @deprecated Use the [`inputSize`](https://surveyjs.io/form-library/documentation/api-reference/multiple-text-entry-question-model#inputSize) property instead.
   */
  get itemSize() {
    return this.inputSize;
  }
  set itemSize(val) {
    this.inputSize = val;
  }
  /**
   * Specifies a uniform width for all text box titles. Accepts CSS values.
   *
   * Default value: `""` (the width of each title depends on the title length)
   * @see items
   * @see itemErrorLocation
   */
  get itemTitleWidth() {
    return this.getPropertyValue("itemTitleWidth") || "";
  }
  set itemTitleWidth(val) {
    this.setPropertyValue("itemTitleWidth", val);
  }
  onRowCreated(row) {
    return row;
  }
  calcVisibleRows() {
    const colCount = this.colCount;
    const items = this.items;
    let index = 0;
    let row;
    let errorRow;
    let rows = [];
    for (var i = 0; i < items.length; i++) {
      if (index == 0) {
        row = this.onRowCreated(new MutlipleTextRow());
        errorRow = this.onRowCreated(new MutlipleTextErrorRow());
        if (this.showItemErrorOnTop) {
          rows.push(errorRow);
          rows.push(row);
        } else {
          rows.push(row);
          rows.push(errorRow);
        }
      }
      row.cells.push(new MultipleTextCell(items[i], this));
      errorRow.cells.push(new MultipleTextErrorCell(items[i], this));
      index++;
      if (index >= colCount || i == items.length - 1) {
        index = 0;
        errorRow.onAfterCreated();
      }
    }
    this.rows = rows;
  }
  getRows() {
    if (Helpers.isValueEmpty(this.rows)) {
      this.calcVisibleRows();
    }
    return this.rows;
  }
  onValueChanged() {
    super.onValueChanged();
    this.onItemValueChanged();
  }
  createTextItem(name, title) {
    return new MultipleTextItemModel(name, title);
  }
  onItemValueChanged() {
    if (this.isMultipleItemValueChanging) return;
    for (var i = 0; i < this.items.length; i++) {
      var itemValue = null;
      if (this.value && this.items[i].name in this.value) {
        itemValue = this.value[this.items[i].name];
      }
      this.items[i].onValueChanged(itemValue);
    }
  }
  runConditionCore(values, properties) {
    super.runConditionCore(values, properties);
    this.items.forEach((item) => item.editor.runCondition(values, properties));
  }
  getIsRunningValidators() {
    if (super.getIsRunningValidators()) return true;
    for (var i = 0; i < this.items.length; i++) {
      if (this.items[i].editor.isRunningValidators) return true;
    }
    return false;
  }
  hasErrors(fireCallback = true, rec = null) {
    var res = false;
    for (var i = 0; i < this.items.length; i++) {
      this.items[i].editor.onCompletedAsyncValidators = (hasErrors) => {
        this.raiseOnCompletedAsyncValidators();
      };
      if (!!rec && rec.isOnValueChanged === true && this.items[i].editor.isEmpty()) continue;
      res = this.items[i].editor.hasErrors(fireCallback, rec) || res;
    }
    return super.hasErrors(fireCallback) || res;
  }
  getAllErrors() {
    var result = super.getAllErrors();
    for (var i = 0; i < this.items.length; i++) {
      var errors = this.items[i].editor.getAllErrors();
      if (errors && errors.length > 0) {
        result = result.concat(errors);
      }
    }
    return result;
  }
  clearErrors() {
    super.clearErrors();
    for (var i = 0; i < this.items.length; i++) {
      this.items[i].editor.clearErrors();
    }
  }
  getContainsErrors() {
    var res = super.getContainsErrors();
    if (res) return res;
    var items = this.items;
    for (var i = 0; i < items.length; i++) {
      if (items[i].editor.containsErrors) return true;
    }
    return false;
  }
  getIsAnswered() {
    if (!super.getIsAnswered()) return false;
    for (var i = 0; i < this.items.length; i++) {
      var editor = this.items[i].editor;
      if (editor.isVisible && !editor.isAnswered) return false;
    }
    return true;
  }
  getProgressInfo() {
    var elements = [];
    for (var i = 0; i < this.items.length; i++) {
      elements.push(this.items[i].editor);
    }
    return SurveyElement.getProgressInfoByElements(elements, this.isRequired);
  }
  getDisplayValueCore(keysAsText, value) {
    if (!value) return value;
    var res = {};
    for (var i = 0; i < this.items.length; i++) {
      var item = this.items[i];
      var val = value[item.name];
      if (Helpers.isValueEmpty(val)) continue;
      var itemName = item.name;
      if (keysAsText && !!item.title) {
        itemName = item.title;
      }
      res[itemName] = item.editor.getDisplayValue(keysAsText, val);
    }
    return res;
  }
  allowMobileInDesignMode() {
    return true;
  }
  //IMultipleTextData
  getMultipleTextValue(name) {
    if (!this.value) return null;
    return this.value[name];
  }
  setMultipleTextValue(name, value) {
    this.isMultipleItemValueChanging = true;
    if (this.isValueEmpty(value)) {
      value = void 0;
    }
    var newValue = this.value;
    if (!newValue) {
      newValue = {};
    }
    newValue[name] = value;
    this.setNewValue(newValue);
    this.isMultipleItemValueChanging = false;
  }
  getItemDefaultValue(name) {
    return !!this.defaultValue ? this.defaultValue[name] : null;
  }
  getTextProcessor() {
    return this.textProcessor;
  }
  getAllValues() {
    return this.data ? this.data.getAllValues() : null;
  }
  //IPanel
  addElement(element, index) {
  }
  removeElement(element) {
    return false;
  }
  getQuestionTitleLocation() {
    return "left";
  }
  getQuestionTitleWidth() {
    return void 0;
  }
  getColumsForElement(el) {
    return [];
  }
  updateColumns() {
  }
  getQuestionStartIndex() {
    return this.getStartIndex();
  }
  getChildrenLayoutType() {
    return "row";
  }
  elementWidthChanged(el) {
  }
  get elements() {
    return [];
  }
  indexOf(el) {
    return -1;
  }
  ensureRowsVisibility() {
  }
  validateContainerOnly() {
  }
  onQuestionValueChanged(el) {
  }
  getItemLabelCss(item) {
    return new CssClassBuilder().append(this.cssClasses.itemLabel).append(this.cssClasses.itemLabelDisabled, this.isDisabledStyle).append(this.cssClasses.itemLabelReadOnly, this.isReadOnlyStyle).append(this.cssClasses.itemLabelPreview, this.isPreviewStyle).append(this.cssClasses.itemLabelAnswered, item.editor.isAnswered).append(this.cssClasses.itemLabelAllowFocus, !this.isDesignMode).append(this.cssClasses.itemLabelOnError, item.editor.errors.length > 0).append(this.cssClasses.itemWithCharacterCounter, !!item.getMaxLength()).toString();
  }
  getItemCss() {
    return new CssClassBuilder().append(this.cssClasses.item).toString();
  }
  getItemTitleCss() {
    return new CssClassBuilder().append(this.cssClasses.itemTitle).toString();
  }
};
__decorate([propertyArray()], QuestionMultipleTextModel.prototype, "rows", void 0);
var MutlipleTextRow = class extends Base {
  constructor() {
    super(...arguments);
    this.isVisible = true;
    this.cells = [];
  }
};
__decorate([property()], MutlipleTextRow.prototype, "isVisible", void 0);
__decorate([propertyArray()], MutlipleTextRow.prototype, "cells", void 0);
var MutlipleTextErrorRow = class extends MutlipleTextRow {
  onAfterCreated() {
    const callback = () => {
      this.isVisible = this.cells.some((cell) => {
        var _a, _b;
        return ((_a = cell.item) === null || _a === void 0 ? void 0 : _a.editor) && ((_b = cell.item) === null || _b === void 0 ? void 0 : _b.editor.hasVisibleErrors);
      });
    };
    this.cells.forEach((cell) => {
      var _a, _b;
      if ((_a = cell.item) === null || _a === void 0 ? void 0 : _a.editor) {
        (_b = cell.item) === null || _b === void 0 ? void 0 : _b.editor.registerFunctionOnPropertyValueChanged("hasVisibleErrors", callback);
      }
    });
    callback();
  }
};
var MultipleTextCell = class {
  constructor(item, question) {
    this.item = item;
    this.question = question;
    this.isErrorsCell = false;
  }
  getClassName() {
    return new CssClassBuilder().append(this.question.cssClasses.cell).toString();
  }
  get className() {
    return this.getClassName();
  }
};
var MultipleTextErrorCell = class extends MultipleTextCell {
  constructor() {
    super(...arguments);
    this.isErrorsCell = true;
  }
  getClassName() {
    return new CssClassBuilder().append(super.getClassName()).append(this.question.cssClasses.cellError).append(this.question.cssClasses.cellErrorTop, this.question.showItemErrorOnTop).append(this.question.cssClasses.cellErrorBottom, this.question.showItemErrorOnBottom).toString();
  }
};
Serializer.addClass("multipletextitem", [{
  name: "!name",
  isUnique: true
}, "isRequired:boolean", {
  name: "placeholder",
  alternativeName: "placeHolder",
  serializationProperty: "locPlaceholder"
}, {
  name: "inputType",
  default: "text",
  choices: settings.questions.inputTypes
}, {
  name: "maskType",
  default: "none",
  visibleIndex: 0,
  dependsOn: "inputType",
  visibleIf: (obj) => {
    return obj.inputType === "text";
  },
  choices: (obj) => {
    const choices = getAvailableMaskTypeChoices();
    return choices;
  }
}, {
  name: "maskSettings:masksettings",
  className: "masksettings",
  visibleIndex: 1,
  dependsOn: "inputType",
  visibleIf: (obj) => {
    return obj.inputType === "text";
  },
  onGetValue: function(obj) {
    return obj.maskSettings.getData();
  },
  onSetValue: function(obj, value) {
    obj.maskSettings.setData(value);
  }
}, {
  name: "inputTextAlignment",
  default: "auto",
  choices: ["left", "right", "auto"]
}, {
  name: "title",
  serializationProperty: "locTitle"
}, {
  name: "maxLength:number",
  default: -1
}, {
  name: "inputSize:number",
  alternativeName: "size",
  minValue: 0
}, {
  name: "requiredErrorText:text",
  serializationProperty: "locRequiredErrorText"
}, {
  name: "defaultValueExpression:expression",
  visible: false
}, {
  name: "minValueExpression:expression",
  category: "logic",
  dependsOn: "inputType",
  visibleIf: function(obj) {
    return isMinMaxType(obj);
  }
}, {
  name: "maxValueExpression:expression",
  category: "logic",
  dependsOn: "inputType",
  visibleIf: function(obj) {
    return isMinMaxType(obj);
  }
}, {
  name: "validators:validators",
  baseClassName: "surveyvalidator",
  classNamePart: "validator"
}], function() {
  return new MultipleTextItemModel("");
});
Serializer.addClass("multipletext", [{
  name: "!items:textitems",
  className: "multipletextitem",
  isArray: true
}, {
  name: "inputSize:number",
  minValue: 0,
  visible: false,
  alternativeName: "itemSize"
}, {
  name: "colCount:number",
  default: 1,
  choices: [1, 2, 3, 4, 5]
}, {
  name: "itemErrorLocation",
  default: "default",
  choices: ["default", "top", "bottom"],
  visible: false
}, {
  name: "itemTitleWidth",
  category: "layout"
}], function() {
  return new QuestionMultipleTextModel("");
}, "question");
QuestionFactory.Instance.registerQuestion("multipletext", (name) => {
  var q = new QuestionMultipleTextModel(name);
  QuestionMultipleTextModel.addDefaultItems(q);
  return q;
});
var FlowPanelModel = class _FlowPanelModel extends PanelModel {
  constructor(name = "") {
    super(name);
    this.createLocalizableString("content", this, true);
    this.registerPropertyChangedHandlers(["content"], () => {
      this.onContentChanged();
    });
  }
  getType() {
    return "flowpanel";
  }
  getChildrenLayoutType() {
    return "flow";
  }
  onSurveyLoad() {
    super.onSurveyLoad();
    this.onContentChanged();
  }
  get content() {
    return this.getLocalizableStringText("content");
  }
  set content(val) {
    this.setLocalizableStringText("content", val);
  }
  get locContent() {
    return this.getLocalizableString("content");
  }
  get html() {
    return this.getPropertyValue("html", "");
  }
  set html(val) {
    this.setPropertyValue("html", val);
  }
  onContentChanged() {
    var html = "";
    if (!!this.onCustomHtmlProducing) {
      html = this.onCustomHtmlProducing();
    } else {
      html = this.produceHtml();
    }
    this.html = html;
    if (!!this.contentChangedCallback) this.contentChangedCallback();
  }
  produceHtml() {
    var html = [];
    var regEx = /{(.*?(element:)[^$].*?)}/g;
    var str = this.content;
    var startIndex = 0;
    var res = null;
    while ((res = regEx.exec(str)) !== null) {
      if (res.index > startIndex) {
        html.push(str.substring(startIndex, res.index));
        startIndex = res.index;
      }
      var question = this.getQuestionFromText(res[0]);
      if (!!question) {
        html.push(this.getHtmlForQuestion(question));
      } else {
        html.push(str.substring(startIndex, res.index + res[0].length));
      }
      startIndex = res.index + res[0].length;
    }
    if (startIndex < str.length) {
      html.push(str.substring(startIndex, str.length));
    }
    return html.join("").replace(new RegExp("<br>", "g"), "<br/>");
  }
  getQuestionFromText(str) {
    str = str.substring(1, str.length - 1);
    str = str.replace(_FlowPanelModel.contentElementNamePrefix, "").trim();
    return this.getQuestionByName(str);
  }
  getHtmlForQuestion(question) {
    if (!!this.onGetHtmlForQuestion) return this.onGetHtmlForQuestion(question);
    return "";
  }
  getQuestionHtmlId(question) {
    return this.name + "_" + question.id;
  }
  onAddElement(element, index) {
    super.onAddElement(element, index);
    this.addElementToContent(element);
    element.renderWidth = "";
  }
  onRemoveElement(element) {
    var searchStr = this.getElementContentText(element);
    this.content = this.content.replace(searchStr, "");
    super.onRemoveElement(element);
  }
  dragDropMoveElement(src, target, targetIndex) {
  }
  addElementToContent(element) {
    if (this.isLoadingFromJson) return;
    var text = this.getElementContentText(element);
    if (!this.insertTextAtCursor(text)) {
      this.content = this.content + text;
    }
  }
  insertTextAtCursor(text, prevName = null) {
    if (!this.isDesignMode || !DomWindowHelper.isAvailable()) return false;
    let sel = DomWindowHelper.getSelection();
    if (sel.getRangeAt && sel.rangeCount) {
      let range = sel.getRangeAt(0);
      range.deleteContents();
      const textElement = new Text(text);
      range.insertNode(textElement);
      var self2 = this;
      if (self2.getContent) {
        var str = self2.getContent(prevName);
        this.content = str;
      }
      return true;
    }
    return false;
  }
  getElementContentText(element) {
    return "{" + _FlowPanelModel.contentElementNamePrefix + element.name + "}";
  }
};
FlowPanelModel.contentElementNamePrefix = "element:";
Serializer.addClass("flowpanel", [{
  name: "content:html",
  serializationProperty: "locContent"
}], function() {
  return new FlowPanelModel();
}, "panel");
var QuestionNonValue = class extends Question {
  constructor(name) {
    super(name);
  }
  getType() {
    return "nonvalue";
  }
  get hasInput() {
    return false;
  }
  get hasTitle() {
    return false;
  }
  getTitleLocation() {
    return "";
  }
  get hasComment() {
    return false;
  }
  hasErrors(fireCallback = true, rec = null) {
    return false;
  }
  getAllErrors() {
    return [];
  }
  supportAutoAdvance() {
    return false;
  }
  addConditionObjectsByContext(objects, context) {
  }
  getConditionJson(operator = null, path = null) {
    return null;
  }
  get ariaRole() {
    return null;
  }
  get ariaRequired() {
    return null;
  }
};
Serializer.addClass("nonvalue", [{
  name: "title",
  visible: false
}, {
  name: "description",
  visible: false
}, {
  name: "valueName",
  visible: false
}, {
  name: "enableIf",
  visible: false
}, {
  name: "defaultValue",
  visible: false
}, {
  name: "correctAnswer",
  visible: false
}, {
  name: "clearIfInvisible",
  visible: false
}, {
  name: "isRequired",
  visible: false,
  isSerializable: false
}, {
  name: "requiredErrorText",
  visible: false
}, {
  name: "readOnly",
  visible: false
}, {
  name: "requiredIf",
  visible: false
}, {
  name: "validators",
  visible: false
}, {
  name: "titleLocation",
  visible: false
}, {
  name: "showCommentArea",
  visible: false
}, {
  name: "useDisplayValuesInDynamicTexts",
  alternativeName: "useDisplayValuesInTitle",
  visible: false
}], function() {
  return new QuestionNonValue("");
}, "question");
var QuestionEmptyModel = class extends Question {
  constructor(name) {
    super(name);
  }
  getType() {
    return "empty";
  }
};
Serializer.addClass("empty", [], function() {
  return new QuestionEmptyModel("");
}, "question");
var QuestionCheckboxModel = class extends QuestionCheckboxBase {
  constructor(name) {
    super(name);
    this.invisibleOldValues = {};
    this.isChangingValueOnClearIncorrect = false;
    this.selectAllItemValue = new ItemValue("");
    this.selectAllItemValue.id = "selectall";
    this.selectAllItemText = this.createLocalizableString("selectAllText", this.selectAllItem, true, "selectAllItemText");
    this.selectAllItem.locOwner = this;
    this.selectAllItem.setLocText(this.selectAllItemText);
    this.registerPropertyChangedHandlers(["showSelectAllItem", "selectAllText"], () => {
      this.onVisibleChoicesChanged();
    });
  }
  getDefaultItemComponent() {
    return "survey-checkbox-item";
  }
  getType() {
    return "checkbox";
  }
  onCreating() {
    super.onCreating();
    this.createNewArray("renderedValue");
    this.createNewArray("value");
  }
  getFirstInputElementId() {
    return this.inputId + "_0";
  }
  /**
   * Specifies a property name used to store selected values.
   *
   * Set this property if you want to store selected values in an array of objects instead of an array of primitive values. For example, if you set `valuePropertyName` to `"car"`, the `value` property will contain an array of objects `[{ car: "Ford" }, { car: "Tesla" }]`, not an array of string values `[ "Ford", "Tesla" ]`.
   */
  get valuePropertyName() {
    return this.getPropertyValue("valuePropertyName");
  }
  set valuePropertyName(val) {
    this.setPropertyValue("valuePropertyName", val);
  }
  getQuestionFromArray(name, index) {
    if (!!name && name === this.valuePropertyName) {
      const v = this.value;
      if (Array.isArray(v) && index < v.length) return this;
    }
    return null;
  }
  /**
   * Returns the "Select All" choice item. Use this property to change the item's `value` or `text`.
   * @see showSelectAllItem
   */
  get selectAllItem() {
    return this.selectAllItemValue;
  }
  /**
   * Gets or sets a caption for the "Select All" choice item.
   * @see showSelectAllItem
   */
  get selectAllText() {
    return this.getLocalizableStringText("selectAllText");
  }
  set selectAllText(val) {
    this.setLocalizableStringText("selectAllText", val);
  }
  get locSelectAllText() {
    return this.getLocalizableString("selectAllText");
  }
  /**
   * Enable this property to display a "Select All" item. When users select it, all other choice items, except "Other" and "None", also become selected.
   * @see selectAll
   * @see isAllSelected
   * @see separateSpecialChoices
   */
  get showSelectAllItem() {
    return this.getPropertyValue("showSelectAllItem");
  }
  set showSelectAllItem(val) {
    this.setPropertyValue("showSelectAllItem", val);
  }
  get hasSelectAll() {
    return this.showSelectAllItem;
  }
  set hasSelectAll(val) {
    this.showSelectAllItem = val;
  }
  /**
   * Returns `true` if all choice items, except "Other" and "None", are selected.
   * @see showSelectAllItem
   */
  get isAllSelected() {
    return this.allElementsSelected();
  }
  set isAllSelected(val) {
    if (val) {
      this.selectAll();
    } else {
      this.clearValue(true);
    }
  }
  toggleSelectAll() {
    this.isAllSelected = !this.isAllSelected;
  }
  allElementsSelected() {
    const noneItems = this.getNoneItems();
    for (let i = 0; i < noneItems.length; i++) {
      if (this.isItemSelected(noneItems[i])) return false;
    }
    const items = this.getVisibleEnableItems();
    if (items.length === 0) return false;
    const val = this.value;
    if (!val || !Array.isArray(val) || val.length === 0) return false;
    if (val.length < items.length) return false;
    const rVal = [];
    for (let i = 0; i < val.length; i++) {
      rVal.push(this.getRealValue(val[i]));
    }
    for (let i = 0; i < items.length; i++) {
      if (rVal.indexOf(items[i].value) < 0) return false;
    }
    return true;
  }
  /**
   * Selects all choice items, except "Other" and "None".
   *
   * To clear selection, call the `clearValue()` method.
   * @see clearValue
   */
  selectAll() {
    const val = [];
    const items = this.getVisibleEnableItems();
    for (let i = 0; i < items.length; i++) {
      val.push(items[i].value);
    }
    this.renderedValue = val;
  }
  clickItemHandler(item, checked) {
    if (this.isReadOnlyAttr) return;
    if (item === this.selectAllItem) {
      if (checked === true || checked === false) {
        this.isAllSelected = checked;
      } else {
        this.toggleSelectAll();
      }
    } else {
      if (this.isNoneItem(item)) {
        this.renderedValue = checked ? [item.value] : [];
      } else {
        const newValue = [].concat(this.renderedValue || []);
        const index = newValue.indexOf(item.value);
        if (checked) {
          if (index < 0) {
            newValue.push(item.value);
          }
        } else {
          if (index > -1) {
            newValue.splice(index, 1);
          }
        }
        this.renderedValue = newValue;
      }
    }
  }
  isItemSelectedCore(item) {
    if (item === this.selectAllItem) return this.isAllSelected;
    var val = this.renderedValue;
    if (!val || !Array.isArray(val)) return false;
    for (var i = 0; i < val.length; i++) {
      if (this.isTwoValueEquals(val[i], item.value)) return true;
    }
    return false;
  }
  hasUnknownValueItem(val, includeOther = false, isFilteredChoices = true, checkEmptyValue = false) {
    const propName = this.valuePropertyName;
    if (!!propName && typeof val === "object" && val[propName] !== void 0) {
      val = val[propName];
    }
    return super.hasUnknownValueItem(val, includeOther, isFilteredChoices, checkEmptyValue);
  }
  convertFuncValuetoQuestionValue(val) {
    if (!!this.valuePropertyName && Array.isArray(val) && val.length > 0) {
      const res = [];
      val.forEach((item) => {
        const isObj = typeof item === "object";
        let obj = isObj ? item : {};
        if (!isObj) {
          obj[this.valuePropertyName] = item;
        }
        res.push(obj);
      });
      val = res;
    }
    return super.convertDefaultValue(val);
  }
  getRealValue(val) {
    if (!val) return val;
    return !this.valuePropertyName ? val : val[this.valuePropertyName];
  }
  get isValueArray() {
    return true;
  }
  /**
   * Specifies the maximum number of selected choices.
   *
   * Default value: 0 (unlimited)
   *
   * > This property only limits the number of choice items that can be selected by users. You can select any number of choice items in code, regardless of the `maxSelectedChoices` value.
   * @see minSelectedChoices
   */
  get maxSelectedChoices() {
    return this.getPropertyValue("maxSelectedChoices");
  }
  set maxSelectedChoices(val) {
    if (val < 0) val = 0;
    this.setPropertyValue("maxSelectedChoices", val);
    this.filterItems();
  }
  /**
   * Specifies the minimum number of selected choices.
   *
   * Default value: 0 (unlimited)
   *
   * > This property only limits the number of choice items that can be selected by users. You can select any number of choice items in code, regardless of the `minSelectedChoices` value.
   * @see maxSelectedChoices
   */
  get minSelectedChoices() {
    return this.getPropertyValue("minSelectedChoices");
  }
  set minSelectedChoices(val) {
    if (val < 0) val = 0;
    this.setPropertyValue("minSelectedChoices", val);
  }
  /**
   * An array of selected choice items. Includes the "Other" and "None" choice items if they are selected, but not "Select All". Items are sorted in the order they were selected.
   * @see visibleChoices
   * @see enabledChoices
   */
  get selectedChoices() {
    const val = this.renderedValue;
    const visChoices = this.visibleChoices;
    const selectedItemValues = this.selectedItemValues;
    if (this.isEmpty()) return [];
    const allChoices = !!this.defaultSelectedItemValues ? [].concat(this.defaultSelectedItemValues, visChoices) : visChoices;
    const itemValues = val.map((item) => {
      return ItemValue.getItemByValue(allChoices, item);
    }).filter((item) => !!item);
    if (!itemValues.length && !selectedItemValues) {
      this.updateSelectedItemValues();
    }
    const validValues = this.validateItemValues(itemValues);
    return validValues;
  }
  get selectedItems() {
    return this.selectedChoices;
  }
  get hasFilteredValue() {
    return !!this.valuePropertyName;
  }
  getFilteredName() {
    let res = super.getFilteredName();
    if (this.hasFilteredValue) {
      res += "-unwrapped";
    }
    return res;
  }
  getFilteredValue() {
    if (this.hasFilteredValue) return this.renderedValue;
    return super.getFilteredValue();
  }
  getMultipleSelectedItems() {
    return this.selectedChoices;
  }
  validateItemValues(itemValues) {
    if (!!itemValues.length) return itemValues;
    const selectedItemValues = this.selectedItemValues;
    if (!!selectedItemValues && !!selectedItemValues.length) {
      this.defaultSelectedItemValues = [].concat(selectedItemValues);
      return selectedItemValues;
    }
    const val = this.renderedValue;
    return val.map((item) => this.createItemValue(item));
  }
  getAnswerCorrectIgnoreOrder() {
    return true;
  }
  onCheckForErrors(errors, isOnValueChanged, fireCallback) {
    super.onCheckForErrors(errors, isOnValueChanged, fireCallback);
    if (isOnValueChanged) return;
    if (this.minSelectedChoices > 0 && this.checkMinSelectedChoicesUnreached()) {
      const minError = new CustomError(this.getLocalizationFormatString("minSelectError", this.minSelectedChoices), this);
      errors.push(minError);
    }
  }
  onVisibleChoicesChanged() {
    super.onVisibleChoicesChanged();
    this.updateSelectAllItemProps();
  }
  onEnableItemCallBack(item) {
    if (!this.shouldCheckMaxSelectedChoices()) return true;
    return this.isItemSelected(item);
  }
  onAfterRunItemsEnableCondition() {
    this.updateSelectAllItemProps();
    if (this.maxSelectedChoices < 1) {
      this.otherItem.setIsEnabled(true);
      return;
    }
    if (this.hasOther) {
      this.otherItem.setIsEnabled(!this.shouldCheckMaxSelectedChoices() || this.isOtherSelected);
    }
  }
  updateSelectAllItemProps() {
    if (!this.hasSelectAll) return;
    this.selectAllItem.setIsEnabled(this.getSelectAllEnabled());
  }
  getSelectAllEnabled() {
    if (!this.hasSelectAll) return true;
    let visCount = this.getVisibleEnableItems().length;
    const max2 = this.maxSelectedChoices;
    if (max2 > 0 && max2 < visCount) return false;
    return visCount > 0;
  }
  getVisibleEnableItems() {
    const res = new Array();
    const items = this.visibleChoices;
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      if (item.isEnabled && !this.isBuiltInChoice(item)) {
        res.push(item);
      }
    }
    return res;
  }
  shouldCheckMaxSelectedChoices() {
    if (this.maxSelectedChoices < 1) return false;
    var val = this.value;
    var len = !Array.isArray(val) ? 0 : val.length;
    return len >= this.maxSelectedChoices;
  }
  checkMinSelectedChoicesUnreached() {
    if (this.minSelectedChoices < 1) return false;
    var val = this.value;
    var len = !Array.isArray(val) ? 0 : val.length;
    return len < this.minSelectedChoices;
  }
  getItemClassCore(item, options) {
    this.value;
    options.isSelectAllItem = item === this.selectAllItem;
    return new CssClassBuilder().append(super.getItemClassCore(item, options)).append(this.cssClasses.itemSelectAll, options.isSelectAllItem).toString();
  }
  updateValueFromSurvey(newValue, clearData) {
    super.updateValueFromSurvey(newValue, clearData);
    this.invisibleOldValues = {};
  }
  setDefaultValue() {
    super.setDefaultValue();
    const val = this.defaultValue;
    if (Array.isArray(val)) {
      for (var i = 0; i < val.length; i++) {
        const rVal = this.getRealValue(val[i]);
        if (this.canClearValueAnUnknown(rVal)) {
          this.addIntoInvisibleOldValues(rVal);
        }
      }
    }
  }
  addIntoInvisibleOldValues(val) {
    this.invisibleOldValues[val] = val;
  }
  hasValueToClearIncorrectValues() {
    return super.hasValueToClearIncorrectValues() || !Helpers.isValueEmpty(this.invisibleOldValues);
  }
  setNewValue(newValue) {
    if (!this.isChangingValueOnClearIncorrect) {
      this.invisibleOldValues = {};
    }
    newValue = this.valueFromData(newValue);
    var value = this.value;
    if (!newValue) newValue = [];
    if (!value) value = [];
    if (this.isTwoValueEquals(value, newValue)) return;
    this.removeNoneItemsValues(value, newValue);
    super.setNewValue(newValue);
  }
  getIsMultipleValue() {
    return true;
  }
  getCommentFromValue(newValue) {
    var ind = this.getFirstUnknownIndex(newValue);
    if (ind < 0) return "";
    return newValue[ind];
  }
  getStoreOthersAsComment() {
    if (!!this.valuePropertyName) return false;
    return super.getStoreOthersAsComment();
  }
  setOtherValueIntoValue(newValue) {
    var ind = this.getFirstUnknownIndex(newValue);
    if (ind < 0) return newValue;
    let otherVal = this.otherItem.value;
    const propName = this.valuePropertyName;
    if (propName) {
      const obj = {};
      obj[propName] = otherVal;
      otherVal = obj;
    }
    newValue.splice(ind, 1, otherVal);
    return newValue;
  }
  getFirstUnknownIndex(newValue) {
    if (!Array.isArray(newValue)) return -1;
    for (var i = 0; i < newValue.length; i++) {
      if (this.hasUnknownValueItem(newValue[i], false, false)) return i;
    }
    return -1;
  }
  removeNoneItemsValues(value, newValue) {
    const noneValues = [];
    if (this.showNoneItem) noneValues.push(this.noneItem.value);
    if (this.showRefuseItem) noneValues.push(this.refuseItem.value);
    if (this.showDontKnowItem) noneValues.push(this.dontKnowItem.value);
    if (noneValues.length > 0) {
      const prevNone = this.noneIndexInArray(value, noneValues);
      const newNone = this.noneIndexInArray(newValue, noneValues);
      if (prevNone.index > -1) {
        if (prevNone.val === newNone.val) {
          if (newValue.length > 0) {
            newValue.splice(newNone.index, 1);
          }
        } else {
          const prevNewNone = this.noneIndexInArray(newValue, [prevNone.val]);
          if (prevNewNone.index > -1 && prevNewNone.index < newValue.length - 1) {
            newValue.splice(prevNewNone.index, 1);
          }
        }
      } else {
        if (newNone.index > -1 && newValue.length > 1) {
          const itemVal = this.convertValueToObject([newNone.val])[0];
          newValue.splice(0, newValue.length, itemVal);
        }
      }
    }
  }
  noneIndexInArray(val, noneValues) {
    if (!Array.isArray(val)) return {
      index: -1,
      val: void 0
    };
    for (var i = val.length - 1; i >= 0; i--) {
      const index = noneValues.indexOf(this.getRealValue(val[i]));
      if (index > -1) return {
        index: i,
        val: noneValues[index]
      };
    }
    return {
      index: -1,
      val: void 0
    };
  }
  canUseFilteredChoices() {
    return !this.hasSelectAll && super.canUseFilteredChoices();
  }
  supportSelectAll() {
    return this.isSupportProperty("showSelectAllItem");
  }
  addNonChoicesItems(dict, isAddAll) {
    super.addNonChoicesItems(dict, isAddAll);
    if (this.supportSelectAll()) {
      this.addNonChoiceItem(dict, this.selectAllItem, isAddAll, this.hasSelectAll, settings.specialChoicesOrder.selectAllItem);
    }
  }
  isBuiltInChoice(item) {
    return item === this.selectAllItem || super.isBuiltInChoice(item);
  }
  isItemInList(item) {
    if (item == this.selectAllItem) return this.hasSelectAll;
    return super.isItemInList(item);
  }
  getDisplayValueEmpty() {
    return ItemValue.getTextOrHtmlByValue(this.visibleChoices.filter((choice) => choice != this.selectAllItemValue), void 0);
  }
  getDisplayValueCore(keysAsText, value) {
    if (!Array.isArray(value)) return super.getDisplayValueCore(keysAsText, value);
    const valuePropName = this.valuePropertyName;
    const onGetValueCallback = (index) => {
      let val = value[index];
      if (!!valuePropName && !!val[valuePropName]) {
        val = val[valuePropName];
      }
      return val;
    };
    return this.getDisplayArrayValue(keysAsText, value, onGetValueCallback);
  }
  clearIncorrectValuesCore() {
    this.clearIncorrectAndDisabledValues(false);
  }
  clearDisabledValuesCore() {
    this.clearIncorrectAndDisabledValues(true);
  }
  clearIncorrectAndDisabledValues(clearDisabled) {
    var val = this.value;
    var hasChanged = false;
    var restoredValues = this.restoreValuesFromInvisible();
    if (!val && restoredValues.length == 0) return;
    if (!Array.isArray(val) || val.length == 0) {
      this.isChangingValueOnClearIncorrect = true;
      if (!clearDisabled) {
        if (this.hasComment) {
          this.value = null;
        } else {
          this.clearValue(true);
        }
      }
      this.isChangingValueOnClearIncorrect = false;
      if (restoredValues.length == 0) return;
      val = [];
    }
    var newValue = [];
    for (var i = 0; i < val.length; i++) {
      const rItemVal = this.getRealValue(val[i]);
      var isUnkown = this.canClearValueAnUnknown(rItemVal);
      if (!clearDisabled && !isUnkown || clearDisabled && !this.isValueDisabled(rItemVal)) {
        newValue.push(val[i]);
      } else {
        hasChanged = true;
        if (isUnkown) {
          this.addIntoInvisibleOldValues(val[i]);
        }
      }
    }
    for (var i = 0; i < restoredValues.length; i++) {
      newValue.push(restoredValues[i]);
      hasChanged = true;
    }
    if (!hasChanged) return;
    this.isChangingValueOnClearIncorrect = true;
    if (newValue.length == 0) {
      this.clearValue(true);
    } else {
      this.value = newValue;
    }
    this.isChangingValueOnClearIncorrect = false;
  }
  restoreValuesFromInvisible() {
    var res = [];
    var visItems = this.visibleChoices;
    for (var i = 0; i < visItems.length; i++) {
      const item = visItems[i];
      if (item === this.selectAllItem) continue;
      var val = visItems[i].value;
      if (Helpers.isTwoValueEquals(val, this.invisibleOldValues[val])) {
        if (!this.isItemSelected(item)) {
          res.push(val);
        }
        delete this.invisibleOldValues[val];
      }
    }
    return res;
  }
  getConditionJson(operator = null, path = null) {
    const json2 = super.getConditionJson(operator, path);
    if (operator == "contains" || operator == "notcontains") {
      json2["type"] = "radiogroup";
    }
    json2["maxSelectedChoices"] = 0;
    json2["minSelectedChoices"] = 0;
    return json2;
  }
  isAnswerCorrect() {
    return Helpers.isArrayContainsEqual(this.value, this.correctAnswer);
  }
  setDefaultValueWithOthers() {
    this.value = this.renderedValueFromDataCore(this.defaultValue);
  }
  getIsItemValue(val, item) {
    if (!val || !Array.isArray(val)) return false;
    return val.indexOf(item.value) >= 0;
  }
  valueFromData(val) {
    if (!val) return val;
    if (!Array.isArray(val)) return [super.valueFromData(val)];
    let value = [];
    for (let i = 0; i < val.length; i++) {
      let choiceitem = ItemValue.getItemByValue(this.visibleChoices, val[i]);
      if (!!choiceitem) {
        value.push(choiceitem.value);
      } else {
        value.push(val[i]);
      }
    }
    return value;
  }
  rendredValueFromData(val) {
    val = this.convertValueFromObject(val);
    return super.rendredValueFromData(val);
  }
  rendredValueToData(val) {
    val = super.rendredValueToData(val);
    return this.convertValueToObject(val);
  }
  convertValueFromObject(val) {
    if (!this.valuePropertyName) return val;
    return Helpers.convertArrayObjectToValue(val, this.valuePropertyName);
  }
  convertValueToObject(val) {
    if (!this.valuePropertyName) return val;
    let dest = void 0;
    if (!!this.survey && this.survey.questionsByValueName(this.getValueName()).length > 1) {
      dest = this.data.getValue(this.getValueName());
    }
    return Helpers.convertArrayValueToObject(val, this.valuePropertyName, dest);
  }
  renderedValueFromDataCore(val) {
    if (!val || !Array.isArray(val)) val = [];
    if (!this.hasActiveChoices) return val;
    for (var i = 0; i < val.length; i++) {
      if (val[i] == this.otherItem.value) return val;
      if (this.hasUnknownValueItem(val[i], true, false)) {
        this.otherValue = val[i];
        var newVal = val.slice();
        newVal[i] = this.otherItem.value;
        return newVal;
      }
    }
    return val;
  }
  rendredValueToDataCore(val) {
    if (!val || !val.length) return val;
    for (var i = 0; i < val.length; i++) {
      if (val[i] == this.otherItem.value) {
        if (this.needConvertRenderedOtherToDataValue()) {
          var newVal = val.slice();
          newVal[i] = this.otherValue;
          return newVal;
        }
      }
    }
    return val;
  }
  selectOtherValueFromComment(val) {
    var newVal = [];
    const rendVal = this.renderedValue;
    if (Array.isArray(rendVal)) {
      for (var i = 0; i < rendVal.length; i++) {
        if (rendVal[i] !== this.otherItem.value) {
          newVal.push(rendVal[i]);
        }
      }
    }
    if (val) {
      newVal.push(this.otherItem.value);
    }
    this.value = newVal;
  }
  get checkBoxSvgPath() {
    return "M5,13l2-2l3,3l7-7l2,2l-9,9L5,13z";
  }
  //a11y
  get isNewA11yStructure() {
    return true;
  }
  get a11y_input_ariaRole() {
    return "group";
  }
  get a11y_input_ariaRequired() {
    return null;
  }
};
Serializer.addClass("checkbox", [{
  name: "showSelectAllItem:boolean",
  alternativeName: "hasSelectAll"
}, {
  name: "separateSpecialChoices",
  visible: true
}, {
  name: "maxSelectedChoices:number",
  default: 0,
  onSettingValue: (obj, val) => {
    if (val <= 0) return 0;
    const min2 = obj.minSelectedChoices;
    return min2 > 0 && val < min2 ? min2 : val;
  }
}, {
  name: "minSelectedChoices:number",
  default: 0,
  onSettingValue: (obj, val) => {
    if (val <= 0) return 0;
    const max2 = obj.maxSelectedChoices;
    return max2 > 0 && val > max2 ? max2 : val;
  }
}, {
  name: "selectAllText",
  serializationProperty: "locSelectAllText",
  dependsOn: "showSelectAllItem",
  visibleIf: function(obj) {
    return obj.hasSelectAll;
  }
}, {
  name: "valuePropertyName",
  category: "data"
}, {
  name: "itemComponent",
  visible: false,
  default: "survey-checkbox-item"
}], function() {
  return new QuestionCheckboxModel("");
}, "checkboxbase");
QuestionFactory.Instance.registerQuestion("checkbox", (name) => {
  var q = new QuestionCheckboxModel(name);
  q.choices = QuestionFactory.DefaultChoices;
  return q;
});
var MultiSelectListModel = class extends ListModel {
  updateItemState() {
    this.actions.forEach((action) => {
      const isSelected = this.isItemSelected(action);
      action.visible = this.hideSelectedItems ? !isSelected : true;
    });
  }
  constructor(options) {
    super(options);
    this.onItemClick = (item) => {
      if (this.isItemDisabled(item)) return;
      this.isExpanded = false;
      if (this.isItemSelected(item)) {
        this.selectedItems.splice(this.selectedItems.indexOf(item), 1)[0];
        !!this.onSelectionChanged && this.onSelectionChanged(item, "removed");
      } else {
        this.selectedItems.push(item);
        !!this.onSelectionChanged && this.onSelectionChanged(item, "added");
      }
    };
    this.isItemDisabled = (itemValue) => {
      return itemValue.enabled !== void 0 && !itemValue.enabled;
    };
    this.isItemSelected = (itemValue) => {
      return !!this.allowSelection && this.selectedItems.filter((item) => this.areSameItems(item, itemValue)).length > 0;
    };
    this.setSelectedItems(options.selectedItems || []);
  }
  updateState() {
    this.updateItemState();
    this.isEmpty = this.renderedActions.filter((action) => this.isItemVisible(action)).length === 0;
  }
  setSelectedItems(newItems) {
    this.selectedItems = newItems;
    this.updateState();
  }
  selectFocusedItem() {
    super.selectFocusedItem();
    if (this.hideSelectedItems) {
      this.focusNextVisibleItem();
    }
  }
};
__decorate([property()], MultiSelectListModel.prototype, "hideSelectedItems", void 0);
var DropdownMultiSelectListModel = class extends DropdownListModel {
  locStrsChanged() {
    super.locStrsChanged();
    this.syncFilterStringPlaceholder();
  }
  updateListState() {
    this.listModel.updateState();
    this.syncFilterStringPlaceholder();
  }
  syncFilterStringPlaceholder() {
    const selectedActions = this.getSelectedActions();
    if (selectedActions.length || this.question.selectedItems.length || this.listModel.focusedItem) {
      this.filterStringPlaceholder = void 0;
    } else {
      this.filterStringPlaceholder = this.question.placeholder;
    }
  }
  getSelectedActions() {
    return this.listModel.actions.filter((item) => item.selected);
  }
  getFocusFirstInputSelector() {
    if (this.listModel.hideSelectedItems && IsTouch && !this.isValueEmpty(this.question.value)) {
      return this.itemSelector;
    } else {
      return super.getFocusFirstInputSelector();
    }
  }
  getPopupCssClasses() {
    return "sv-multi-select-list";
  }
  createListModel() {
    const visibleItems = this.getAvailableItems();
    let _onSelectionChanged = this.onSelectionChanged;
    if (!_onSelectionChanged) {
      _onSelectionChanged = (item, status) => {
        this.resetFilterString();
        if (item.id === "selectall") {
          this.selectAllItems();
        } else if (status === "added" && item.value === settings.noneItemValue) {
          this.selectNoneItem();
        } else if (status === "added") {
          this.selectItem(item.value);
        } else if (status === "removed") {
          this.deselectItem(item.value);
        }
        this.popupRecalculatePosition(false);
        if (this.closeOnSelect) {
          this.popupModel.isVisible = false;
        }
      };
    }
    const listOptions = {
      items: visibleItems,
      onSelectionChanged: _onSelectionChanged,
      allowSelection: false,
      locOwner: this.question,
      elementId: this.listElementId
    };
    const res = new MultiSelectListModel(listOptions);
    this.setOnTextSearchCallbackForListModel(res);
    res.forceShowFilter = true;
    return res;
  }
  resetFilterString() {
    super.resetFilterString();
    this.inputString = null;
    this.hintString = "";
  }
  get shouldResetAfterCancel() {
    return IsTouch && !this.closeOnSelect;
  }
  createPopup() {
    super.createPopup();
    this.popupModel.onFooterActionsCreated.add((_, opt) => {
      if (this.shouldResetAfterCancel) {
        opt.actions.push({
          id: "sv-dropdown-done-button",
          title: this.doneButtonCaption,
          innerCss: "sv-popup__button--done",
          needSpace: true,
          action: () => {
            this.popupModel.isVisible = false;
          },
          enabled: new ComputedUpdater(() => !this.isTwoValueEquals(this.question.renderedValue, this.previousValue))
        });
      }
    });
    this.popupModel.onVisibilityChanged.add((_, opt) => {
      if (this.shouldResetAfterCancel && opt.isVisible) {
        this.previousValue = [].concat(this.question.renderedValue || []);
      }
    });
    this.popupModel.onCancel = () => {
      if (this.shouldResetAfterCancel) {
        this.question.renderedValue = this.previousValue;
        this.updateListState();
      }
    };
  }
  selectAllItems() {
    this.question.toggleSelectAll();
    if (this.question.isAllSelected && this.question.hideSelectedItems) {
      this.popupModel.hide();
    }
    this.updateListState();
  }
  selectNoneItem() {
    this.question.renderedValue = [settings.noneItemValue];
    this.updateListState();
  }
  selectItem(id) {
    let newValue = [].concat(this.question.renderedValue || []);
    newValue.push(id);
    this.question.renderedValue = newValue;
    this.updateListState();
  }
  deselectItem(id) {
    let newValue = [].concat(this.question.renderedValue || []);
    newValue.splice(newValue.indexOf(id), 1);
    this.question.renderedValue = newValue;
    this.applyHintString(this.listModel.focusedItem);
    this.updateListState();
  }
  clear() {
    super.clear();
    this.syncFilterStringPlaceholder();
  }
  onClear(event) {
    super.onClear(event);
    this.updateListState();
  }
  setHideSelectedItems(newValue) {
    this.listModel.hideSelectedItems = newValue;
    this.updateListState();
  }
  removeLastSelectedItem() {
    this.deselectItem(this.question.renderedValue[this.question.renderedValue.length - 1]);
    this.popupRecalculatePosition(false);
  }
  constructor(question, onSelectionChanged) {
    super(question, onSelectionChanged);
    this.setHideSelectedItems(question.hideSelectedItems);
    this.syncFilterStringPlaceholder();
    this.closeOnSelect = question.closeOnSelect;
  }
  inputKeyHandler(event) {
    if (event.keyCode === 8 && !this.filterString) {
      this.removeLastSelectedItem();
      event.preventDefault();
      event.stopPropagation();
    }
  }
  setInputStringFromSelectedItem(newValue) {
    if (this.question.searchEnabled) {
      this.inputString = null;
    }
  }
  focusItemOnClickAndPopup() {
    return;
  }
  onEscape() {
    return;
  }
  beforeScrollToFocusedItem(focusedItem) {
    return;
  }
  afterScrollToFocusedItem() {
    var _a;
    if (!((_a = this.listModel.focusedItem) === null || _a === void 0 ? void 0 : _a.selected)) {
      this.applyHintString(this.listModel.focusedItem || this.question.selectedItem);
    } else {
      this.hintString = "";
    }
    this.syncFilterStringPlaceholder();
  }
  onPropertyChangedHandler(sender, options) {
    super.onPropertyChangedHandler(sender, options);
    if (options.name === "value" || options.name === "renderedValue" || options.name === "placeholder") {
      this.syncFilterStringPlaceholder();
    }
  }
};
__decorate([property({
  defaultValue: ""
})], DropdownMultiSelectListModel.prototype, "filterStringPlaceholder", void 0);
__decorate([property({
  defaultValue: true
})], DropdownMultiSelectListModel.prototype, "closeOnSelect", void 0);
__decorate([property()], DropdownMultiSelectListModel.prototype, "previousValue", void 0);
__decorate([property({
  localizable: {
    defaultStr: "tagboxDoneButtonCaption"
  }
})], DropdownMultiSelectListModel.prototype, "doneButtonCaption", void 0);
var QuestionTagboxModel = class extends QuestionCheckboxModel {
  constructor(name) {
    super(name);
    this.itemDisplayNameMap = {};
    this.onOpened = this.addEvent();
    this.ariaExpanded = "false";
    this.createLocalizableString("placeholder", this, false, true);
    this.createLocalizableString("clearCaption", this, false, true);
    this.createLocalizableString("readOnlyText", this, true);
    this.deselectAllItemText = this.createLocalizableString("deselectAllText", this.selectAllItem, true, "deselectAllItemText");
    this.registerPropertyChangedHandlers(["value", "renderAs", "showOtherItem", "otherText", "placeholder", "choices", "visibleChoices"], () => {
      this.updateReadOnlyText();
    });
    this.updateReadOnlyText();
  }
  locStrsChanged() {
    var _a;
    super.locStrsChanged();
    this.updateReadOnlyText();
    (_a = this.dropdownListModelValue) === null || _a === void 0 ? void 0 : _a.locStrsChanged();
  }
  updateReadOnlyText() {
    this.readOnlyText = this.displayValue || this.placeholder;
  }
  getDefaultItemComponent() {
    return "";
  }
  get dropdownListModel() {
    if (!this.dropdownListModelValue) {
      this.dropdownListModelValue = new DropdownMultiSelectListModel(this);
    }
    return this.dropdownListModelValue;
  }
  set dropdownListModel(val) {
    this.dropdownListModelValue = val;
  }
  /**
   * A text displayed in the input field when it doesn't have a value.
   */
  get placeholder() {
    return this.getLocalizableStringText("placeholder");
  }
  set placeholder(val) {
    this.setLocalizableStringText("placeholder", val);
  }
  get locPlaceholder() {
    return this.getLocalizableString("placeholder");
  }
  get clearCaption() {
    return this.getLocalizableStringText("clearCaption");
  }
  set clearCaption(value) {
    this.setLocalizableStringText("clearCaption", value);
  }
  get locClearCaption() {
    return this.getLocalizableString("clearCaption");
  }
  get readOnlyText() {
    return this.getLocalizableStringText("readOnlyText");
  }
  set readOnlyText(val) {
    this.setLocalizableStringText("readOnlyText", val);
  }
  get locReadOnlyText() {
    return this.getLocalizableString("readOnlyText");
  }
  getType() {
    return "tagbox";
  }
  get ariaRole() {
    return "combobox";
  }
  get popupModel() {
    return this.dropdownListModel.popupModel;
  }
  getControlClass() {
    return new CssClassBuilder().append(this.cssClasses.control).append(this.cssClasses.controlEmpty, this.isEmpty()).append(this.cssClasses.onError, this.hasCssError()).append(this.cssClasses.controlEditable, !this.isDisabledStyle && !this.isReadOnlyStyle && !this.isPreviewStyle).append(this.cssClasses.controlDisabled, this.isDisabledStyle).append(this.cssClasses.controlReadOnly, this.isReadOnlyStyle).append(this.cssClasses.controlPreview, this.isPreviewStyle).toString();
  }
  updateCssClasses(res, css) {
    super.updateCssClasses(res, css);
    updateListCssValues(res, css);
  }
  calcCssClasses(css) {
    const classes = super.calcCssClasses(css);
    if (this.dropdownListModelValue) {
      this.dropdownListModel.updateCssClasses(classes.popup, classes.list);
    }
    return classes;
  }
  onOpenedCallBack() {
    this.onOpened.fire(this, {
      question: this,
      choices: this.choices
    });
  }
  hasUnknownValue(val, includeOther = false, isFilteredChoices = true, checkEmptyValue = false) {
    if (this.choicesLazyLoadEnabled) return false;
    return super.hasUnknownValue(val, includeOther, isFilteredChoices, checkEmptyValue);
  }
  needConvertRenderedOtherToDataValue() {
    var _a;
    const val = (_a = this.otherValue) === null || _a === void 0 ? void 0 : _a.trim();
    if (!val) return false;
    return super.hasUnknownValue(val, true, false);
  }
  onVisibleChoicesChanged() {
    super.onVisibleChoicesChanged();
    if (!!this.dropdownListModelValue) {
      this.dropdownListModel.updateItems();
    }
  }
  getItemIfChoicesNotContainThisValue(value, text) {
    if (this.choicesLazyLoadEnabled) {
      return this.createItemValue(value, text);
    } else {
      return super.getItemIfChoicesNotContainThisValue(value, text);
    }
  }
  validateItemValues(itemValues) {
    this.updateItemDisplayNameMap();
    const val = this.renderedValue;
    if (!!itemValues.length && itemValues.length === val.length) return itemValues;
    const selectedItemValues = this.selectedItemValues;
    if (!itemValues.length && !!selectedItemValues && !!selectedItemValues.length) {
      this.defaultSelectedItemValues = [].concat(selectedItemValues);
      return selectedItemValues;
    }
    const itemValueValues = itemValues.map((iV) => iV.value);
    val.filter((item) => {
      return itemValueValues.indexOf(item) === -1;
    }).forEach((item) => {
      const newItem = this.getItemIfChoicesNotContainThisValue(item, this.itemDisplayNameMap[item]);
      if (newItem) {
        itemValues.push(newItem);
      }
    });
    itemValues.sort((a, b) => {
      return val.indexOf(a.value) - val.indexOf(b.value);
    });
    return itemValues;
  }
  updateItemDisplayNameMap() {
    const func = (item) => {
      this.itemDisplayNameMap[item.value] = item.text;
    };
    (this.defaultSelectedItemValues || []).forEach(func);
    (this.selectedItemValues || []).forEach(func);
    this.visibleChoices.forEach(func);
  }
  getFirstInputElementId() {
    return this.inputId + (this.searchEnabled ? "_0" : "");
  }
  getInputId() {
    return this.inputId + "_0";
  }
  supportEmptyValidation() {
    return true;
  }
  onBlurCore(event) {
    this.dropdownListModel.onBlur(event);
    super.onBlurCore(event);
  }
  onFocusCore(event) {
    this.dropdownListModel.onFocus(event);
    super.onFocusCore(event);
  }
  allElementsSelected() {
    const result = super.allElementsSelected();
    this.updateSelectAllItemText(result);
    return result;
  }
  updateSelectAllItemText(isAllSelected) {
    this.selectAllItem.setLocText(isAllSelected ? this.deselectAllItemText : this.selectAllItemText);
  }
  dispose() {
    super.dispose();
    if (!!this.dropdownListModelValue) {
      this.dropdownListModelValue.dispose();
      this.dropdownListModelValue = void 0;
    }
  }
  clearValue(keepComment) {
    var _a;
    super.clearValue(keepComment);
    (_a = this.dropdownListModelValue) === null || _a === void 0 ? void 0 : _a.clear();
  }
  get showClearButton() {
    return this.allowClear && !this.isEmpty();
  }
  //a11y
  get isNewA11yStructure() {
    return false;
  }
};
__decorate([property()], QuestionTagboxModel.prototype, "searchMode", void 0);
__decorate([property()], QuestionTagboxModel.prototype, "allowClear", void 0);
__decorate([property({
  onSet: (newValue, target) => {
    if (!!target.dropdownListModelValue) {
      target.dropdownListModel.setSearchEnabled(newValue);
    }
  }
})], QuestionTagboxModel.prototype, "searchEnabled", void 0);
__decorate([property({
  onSet: (newValue, target) => {
    if (!!target.dropdownListModelValue) {
      target.dropdownListModel.setHideSelectedItems(newValue);
    }
  }
})], QuestionTagboxModel.prototype, "hideSelectedItems", void 0);
__decorate([property({
  onSet: (newValue, target) => {
    if (!!target.dropdownListModelValue) {
      target.dropdownListModel.setChoicesLazyLoadEnabled(newValue);
    }
  }
})], QuestionTagboxModel.prototype, "choicesLazyLoadEnabled", void 0);
__decorate([property()], QuestionTagboxModel.prototype, "choicesLazyLoadPageSize", void 0);
__decorate([property({
  getDefaultValue: () => {
    return settings.tagboxCloseOnSelect;
  }
})], QuestionTagboxModel.prototype, "closeOnSelect", void 0);
__decorate([property()], QuestionTagboxModel.prototype, "textWrapEnabled", void 0);
Serializer.addClass("tagbox", [{
  name: "placeholder",
  serializationProperty: "locPlaceholder"
}, {
  name: "allowClear:boolean",
  default: true
}, {
  name: "searchEnabled:boolean",
  default: true
}, {
  name: "textWrapEnabled:boolean",
  default: true
}, {
  name: "choicesLazyLoadEnabled:boolean",
  default: false,
  visible: false
}, {
  name: "choicesLazyLoadPageSize:number",
  default: 25,
  visible: false
}, {
  name: "hideSelectedItems:boolean",
  default: false
}, {
  name: "closeOnSelect:boolean"
}, {
  name: "itemComponent",
  visible: false,
  default: ""
}, {
  name: "searchMode",
  default: "contains",
  choices: ["contains", "startsWith"]
}], function() {
  return new QuestionTagboxModel("");
}, "checkbox");
QuestionFactory.Instance.registerQuestion("tagbox", (name) => {
  const q = new QuestionTagboxModel(name);
  q.choices = QuestionFactory.DefaultChoices;
  return q;
});
var DragDropChoices = class extends DragDropCore {
  constructor() {
    super(...arguments);
    this.doDragOver = () => {
      if (this.parentElement.getType() === "imagepicker") return;
      const node = this.domAdapter.draggedElementShortcut.querySelector(".svc-item-value-controls__button");
      node.style.cursor = "grabbing";
    };
    this.doBanDropHere = () => {
      if (this.parentElement.getType() === "imagepicker") return;
      const node = this.domAdapter.draggedElementShortcut.querySelector(".svc-item-value-controls__button");
      node.style.cursor = "not-allowed";
    };
  }
  get draggedElementType() {
    return "item-value";
  }
  createDraggedElementShortcut(text, draggedElementNode, event) {
    if (this.parentElement.getType() === "imagepicker") {
      return this.createImagePickerShortcut(this.draggedElement, text, draggedElementNode, event);
    }
    const draggedElementShortcut = DomDocumentHelper.createElement("div");
    if (!draggedElementShortcut) return;
    draggedElementShortcut.className = "sv-drag-drop-choices-shortcut";
    const isDeepClone = true;
    const clone = draggedElementNode.closest("[data-sv-drop-target-item-value]").cloneNode(isDeepClone);
    clone.classList.add("sv-drag-drop-choices-shortcut__content");
    const dragIcon = clone.querySelector(".svc-item-value-controls__drag-icon");
    dragIcon.style.visibility = "visible";
    const removeIcon = clone.querySelector(".svc-item-value-controls__remove");
    removeIcon.style.backgroundColor = "transparent";
    clone.classList.remove("svc-item-value--moveup");
    clone.classList.remove("svc-item-value--movedown");
    this.draggedElement.isDragDropMoveDown = false;
    this.draggedElement.isDragDropMoveUp = false;
    draggedElementShortcut.appendChild(clone);
    const rect = draggedElementNode.getBoundingClientRect();
    draggedElementShortcut.shortcutXOffset = event.clientX - rect.x;
    draggedElementShortcut.shortcutYOffset = event.clientY - rect.y;
    this.isBottom = null;
    if (typeof this.onShortcutCreated === "function") {
      this.onShortcutCreated(draggedElementShortcut);
    }
    return draggedElementShortcut;
  }
  createImagePickerShortcut(item, text, draggedElementNode, event) {
    const draggedElementShortcut = DomDocumentHelper.createElement("div");
    if (!draggedElementShortcut) return;
    draggedElementShortcut.classList.add("sv-drag-drop-image-picker-shortcut");
    const itemValueNode = draggedElementNode.closest("[data-sv-drop-target-item-value]");
    this.imagepickerControlsNode = itemValueNode.querySelector(".svc-image-item-value-controls");
    const imageContainerNode = itemValueNode.querySelector(".sd-imagepicker__image-container");
    let imageNode = itemValueNode.querySelector(item.imageLink ? "img" : ".sd-imagepicker__no-image").cloneNode(true);
    if (!!this.imagepickerControlsNode) {
      this.imagepickerControlsNode.style.display = "none";
    }
    imageContainerNode.style.width = imageNode.width + "px";
    imageContainerNode.style.height = imageNode.height + "px";
    imageNode.style.objectFit = "cover";
    imageNode.style.borderRadius = "4px";
    draggedElementShortcut.appendChild(imageNode);
    return draggedElementShortcut;
  }
  getDropTargetByDataAttributeValue(dataAttributeValue) {
    let dragOverChoice;
    dragOverChoice = this.parentElement.choices.filter((choice) => "" + choice.value == dataAttributeValue)[0];
    return dragOverChoice;
  }
  getChoices() {
    const parent = this.parentElement;
    if (parent.getType() === "ranking") {
      if (parent.selectToRankEnabled) {
        return parent.unRankingChoices;
      } else {
        return parent.rankingChoices;
      }
    }
    return parent.visibleChoices;
  }
  isDropTargetValid(dropTarget, dropTargetNode) {
    const choices = this.getChoices();
    if (this.parentElement.getType() !== "imagepicker") {
      const dropTargetIndex = choices.indexOf(this.dropTarget);
      const draggedElementIndex = choices.indexOf(this.draggedElement);
      if (draggedElementIndex > dropTargetIndex && this.dropTarget.isDragDropMoveUp) {
        this.dropTarget.isDragDropMoveUp = false;
        return false;
      }
      if (draggedElementIndex < dropTargetIndex && this.dropTarget.isDragDropMoveDown) {
        this.dropTarget.isDragDropMoveDown = false;
        return false;
      }
    }
    if (choices.indexOf(dropTarget) === -1) return false;
    return true;
  }
  isDropTargetDoesntChanged(newIsBottom) {
    return this.dropTarget === this.prevDropTarget && newIsBottom === this.isBottom;
  }
  calculateIsBottom(clientY, dropTargetNode) {
    const rect = dropTargetNode.getBoundingClientRect();
    return clientY >= rect.y + rect.height / 2;
  }
  afterDragOver(dropTargetNode) {
    const choices = this.getChoices();
    const dropTargetIndex = choices.indexOf(this.dropTarget);
    const draggedElementIndex = choices.indexOf(this.draggedElement);
    if (draggedElementIndex < dropTargetIndex && this.isBottom === true) {
      choices.splice(draggedElementIndex, 1);
      choices.splice(dropTargetIndex, 0, this.draggedElement);
    } else if (draggedElementIndex > dropTargetIndex && this.isBottom === false) {
      choices.splice(dropTargetIndex, 1);
      choices.splice(draggedElementIndex, 0, this.dropTarget);
    } else {
      return;
    }
    if (this.parentElement.getType() === "imagepicker") return;
    if (draggedElementIndex !== dropTargetIndex) {
      dropTargetNode.classList.remove("svc-item-value--moveup");
      dropTargetNode.classList.remove("svc-item-value--movedown");
      this.dropTarget.isDragDropMoveDown = false;
      this.dropTarget.isDragDropMoveUp = false;
    }
    if (draggedElementIndex > dropTargetIndex) {
      this.dropTarget.isDragDropMoveDown = true;
    }
    if (draggedElementIndex < dropTargetIndex) {
      this.dropTarget.isDragDropMoveUp = true;
    }
    super.ghostPositionChanged();
  }
  doDrop() {
    const choices = this.parentElement.choices;
    const filteredChoices = this.getChoices().filter((item) => {
      return choices.indexOf(item) !== -1;
    });
    const oldIndex = choices.indexOf(this.draggedElement);
    let newIndex = filteredChoices.indexOf(this.draggedElement);
    choices.splice(oldIndex, 1);
    choices.splice(newIndex, 0, this.draggedElement);
    return this.parentElement;
  }
  clear() {
    if (!!this.parentElement) {
      this.updateVisibleChoices(this.parentElement);
    }
    if (!!this.imagepickerControlsNode) {
      this.imagepickerControlsNode.style.display = "flex";
      this.imagepickerControlsNode = null;
    }
    super.clear();
  }
  updateVisibleChoices(parent) {
    parent.getType() === "ranking" ? parent.updateRankingChoices() : parent["updateVisibleChoices"]();
  }
};
var DragDropRankingChoices = class extends DragDropChoices {
  constructor() {
    super(...arguments);
    this.isDragOverRootNode = false;
    this.doDragOver = () => {
      const node = this.domAdapter.draggedElementShortcut.querySelector(".sv-ranking-item");
      node.style.cursor = "grabbing";
    };
    this.reorderRankedItem = (questionModel, fromIndex, toIndex) => {
      if (fromIndex == toIndex) return;
      const rankingChoices = questionModel.rankingChoices;
      const item = rankingChoices[fromIndex];
      questionModel.isValueSetByUser = true;
      rankingChoices.splice(fromIndex, 1);
      rankingChoices.splice(toIndex, 0, item);
      this.updateDraggedElementShortcut(toIndex + 1);
    };
    this.doBanDropHere = () => {
      if (this.isDragOverRootNode) {
        this.allowDropHere = true;
        return;
      }
      const node = this.domAdapter.draggedElementShortcut.querySelector(".sv-ranking-item");
      node.style.cursor = "not-allowed";
      if (IsTouch) {
        this.parentElement.updateRankingChoices(true);
      }
    };
  }
  get draggedElementType() {
    return "ranking-item";
  }
  createDraggedElementShortcut(text, draggedElementNode, event) {
    const draggedElementShortcut = DomDocumentHelper.createElement("div");
    if (!draggedElementShortcut) return;
    draggedElementShortcut.className = this.shortcutClass + " sv-ranking-shortcut";
    const isDeepClone = true;
    const clone = draggedElementNode.cloneNode(isDeepClone);
    draggedElementShortcut.appendChild(clone);
    const rect = draggedElementNode.getBoundingClientRect();
    draggedElementShortcut.style.left = rect.x;
    draggedElementShortcut.style.top = rect.y;
    this.domAdapter.rootElement.append(draggedElementShortcut);
    const shortcutHeight = draggedElementShortcut.offsetHeight;
    let clientY = event.clientY;
    if (clientY > rect.y + shortcutHeight) {
      clientY = rect.y + shortcutHeight - 10;
    }
    draggedElementShortcut.shortcutXOffset = event.clientX - rect.x;
    draggedElementShortcut.shortcutYOffset = clientY - rect.y;
    if (this.parentElement && this.parentElement.useFullItemSizeForShortcut) {
      draggedElementShortcut.style.width = draggedElementNode.offsetWidth + "px";
      draggedElementShortcut.style.height = draggedElementNode.offsetHeight + "px";
    }
    return draggedElementShortcut;
  }
  get shortcutClass() {
    return new CssClassBuilder().append(this.parentElement.cssClasses.root).append(this.parentElement.cssClasses.rootMobileMod, IsMobile).toString();
  }
  getDropTargetByDataAttributeValue(dataAttributeValue) {
    return this.parentElement.rankingChoices[dataAttributeValue];
  }
  findDropTargetNodeByDragOverNode(dragOverNode) {
    this.isDragOverRootNode = this.getIsDragOverRootNode(dragOverNode);
    return super.findDropTargetNodeByDragOverNode(dragOverNode);
  }
  getIsDragOverRootNode(dragOverNode) {
    return typeof dragOverNode.className === "string" && dragOverNode.className.indexOf("sv-ranking") !== -1;
  }
  isDropTargetValid(dropTarget, dropTargetNode) {
    const choices = this.parentElement.rankingChoices;
    if (choices.indexOf(dropTarget) === -1)
      return false;
    return true;
  }
  calculateIsBottom(clientY, dropTargetNode) {
    if (this.dropTarget instanceof ItemValue && this.draggedElement !== this.dropTarget) {
      return super.calculateIsBottom(clientY, dropTargetNode);
    }
    return false;
  }
  getIndices(model, fromChoicesArray, toChoicesArray) {
    let fromIndex = fromChoicesArray.indexOf(this.draggedElement);
    let toIndex = toChoicesArray.indexOf(this.dropTarget);
    if (fromIndex < 0 && !!this.draggedElement) {
      this.draggedElement = ItemValue.getItemByValue(fromChoicesArray, this.draggedElement.value) || this.draggedElement;
      fromIndex = fromChoicesArray.indexOf(this.draggedElement);
    }
    if (toIndex === -1) {
      const length = model.value.length;
      toIndex = length;
    } else if (fromChoicesArray == toChoicesArray) {
      if (!this.isBottom && fromIndex < toIndex) toIndex--;
      if (this.isBottom && fromIndex > toIndex) toIndex++;
    } else if (fromChoicesArray != toChoicesArray) {
      if (this.isBottom) toIndex++;
    }
    return {
      fromIndex,
      toIndex
    };
  }
  afterDragOver(dropTargetNode) {
    const {
      fromIndex,
      toIndex
    } = this.getIndices(this.parentElement, this.parentElement.rankingChoices, this.parentElement.rankingChoices);
    this.reorderRankedItem(this.parentElement, fromIndex, toIndex);
  }
  updateDraggedElementShortcut(newIndex) {
    var _a;
    if ((_a = this.domAdapter) === null || _a === void 0 ? void 0 : _a.draggedElementShortcut) {
      const newIndexText = newIndex !== null ? newIndex + "" : "";
      const indexNode = this.domAdapter.draggedElementShortcut.querySelector(".sv-ranking-item__index");
      indexNode.innerText = newIndexText;
    }
  }
  ghostPositionChanged() {
    this.parentElement.currentDropTarget = this.draggedElement;
    super.ghostPositionChanged();
  }
  doDrop() {
    this.parentElement.setValue();
    return this.parentElement;
  }
  clear() {
    if (!!this.parentElement) {
      this.parentElement.dropTargetNodeMove = null;
      this.parentElement.updateRankingChoices(true);
    }
    super.clear();
  }
};
var DragDropRankingSelectToRank = class extends DragDropRankingChoices {
  constructor() {
    super(...arguments);
    this.selectToRank = (questionModel, fromIndex, toIndex) => {
      const rankingChoices = [].concat(questionModel.rankingChoices);
      const unRankingChoices = questionModel.unRankingChoices;
      const item = unRankingChoices[fromIndex];
      rankingChoices.splice(toIndex, 0, item);
      this.updateChoices(questionModel, rankingChoices);
    };
    this.unselectFromRank = (questionModel, fromIndex, toIndex) => {
      const rankingChoices = [].concat(questionModel.rankingChoices);
      rankingChoices.splice(fromIndex, 1);
      this.updateChoices(questionModel, rankingChoices);
    };
  }
  findDropTargetNodeByDragOverNode(dragOverNode) {
    if (dragOverNode.dataset.ranking === "from-container" || dragOverNode.dataset.ranking === "to-container") {
      return dragOverNode;
    }
    let toContainer = dragOverNode.closest("[data-ranking='to-container']");
    let fromContainer = dragOverNode.closest("[data-ranking='from-container']");
    if (this.parentElement.unRankingChoices.length === 0 && fromContainer) return fromContainer;
    if (this.parentElement.rankingChoices.length === 0 && toContainer) return toContainer;
    return super.findDropTargetNodeByDragOverNode(dragOverNode);
  }
  getDropTargetByDataAttributeValue(dataAttributeValue) {
    return this.parentElement.rankingChoices[dataAttributeValue] || this.parentElement.unRankingChoices[dataAttributeValue];
  }
  getDropTargetByNode(dropTargetNode, event) {
    if (dropTargetNode.dataset.ranking === "to-container") {
      return "to-container";
    }
    if (dropTargetNode.dataset.ranking === "from-container" || dropTargetNode.closest("[data-ranking='from-container']")) {
      return "from-container";
    }
    return super.getDropTargetByNode(dropTargetNode, event);
  }
  isDropTargetValid(dropTarget, dropTargetNode) {
    if (dropTarget === "to-container" || dropTarget === "from-container") {
      return true;
    } else {
      return super.isDropTargetValid(dropTarget, dropTargetNode);
    }
  }
  afterDragOver(dropTargetNode) {
    const questionModel = this.parentElement;
    const rankingChoices = questionModel.rankingChoices;
    const unRankingChoices = questionModel.unRankingChoices;
    if (this.isDraggedElementUnranked && this.isDropTargetRanked) {
      this.doRankBetween(dropTargetNode, unRankingChoices, rankingChoices, this.selectToRank);
      return;
    }
    if (this.isDraggedElementRanked && this.isDropTargetRanked) {
      this.doRankBetween(dropTargetNode, rankingChoices, rankingChoices, this.reorderRankedItem);
      return;
    }
    if (this.isDraggedElementRanked && !this.isDropTargetRanked) {
      this.doRankBetween(dropTargetNode, rankingChoices, unRankingChoices, this.unselectFromRank);
      return;
    }
  }
  doRankBetween(dropTargetNode, fromChoicesArray, toChoicesArray, rankFunction) {
    const questionModel = this.parentElement;
    let {
      fromIndex,
      toIndex
    } = this.getIndices(questionModel, fromChoicesArray, toChoicesArray);
    rankFunction(questionModel, fromIndex, toIndex, dropTargetNode);
  }
  get isDraggedElementRanked() {
    return this.parentElement.rankingChoices.indexOf(this.draggedElement) !== -1;
  }
  get isDropTargetRanked() {
    if (this.dropTarget === "to-container") return true;
    return this.parentElement.rankingChoices.indexOf(this.dropTarget) !== -1;
  }
  get isDraggedElementUnranked() {
    return !this.isDraggedElementRanked;
  }
  updateChoices(questionModel, rankingChoices) {
    questionModel.isValueSetByUser = true;
    questionModel.rankingChoices = rankingChoices;
    questionModel.updateUnRankingChoices(rankingChoices);
  }
};
var QuestionRankingModel = class extends QuestionCheckboxModel {
  constructor(name) {
    super(name);
    this.domNode = null;
    this.onVisibleChoicesChanged = () => {
      super.onVisibleChoicesChanged();
      if (this.carryForwardStartUnranked && !this.isValueSetByUser && !this.selectToRankEnabled && !this.defaultValue) {
        this.value = [];
      }
      if (this.visibleChoices.length === 1 && !this.selectToRankEnabled) {
        this.value = [];
        this.value.push(this.visibleChoices[0].value);
        this.updateRankingChoices();
        return;
      }
      if (this.isEmpty()) {
        this.updateRankingChoices();
        return;
      }
      if (this.selectToRankEnabled) {
        this.updateRankingChoices();
        return;
      }
      if (this.visibleChoices.length > this.value.length) this.addToValueByVisibleChoices();
      if (this.visibleChoices.length < this.value.length) this.removeFromValueByVisibleChoices();
      this.updateRankingChoices();
    };
    this.localeChanged = () => {
      super.localeChanged();
      this.updateRankingChoicesSync();
    };
    this._rankingChoicesAnimation = new AnimationGroup(this.getChoicesAnimationOptions(true), (val) => {
      this._renderedRankingChoices = val;
    }, () => this.renderedRankingChoices);
    this._unRankingChoicesAnimation = new AnimationGroup(this.getChoicesAnimationOptions(false), (val) => {
      this._renderedUnRankingChoices = val;
    }, () => this.renderedUnRankingChoices);
    this.rankingChoices = [];
    this.unRankingChoices = [];
    this._renderedRankingChoices = [];
    this._renderedUnRankingChoices = [];
    this.handlePointerDown = (event, choice, node) => {
      const target = event.target;
      if (!this.isDragStartNodeValid(target)) return;
      if (this.isAllowStartDrag(target, choice)) {
        this.draggedChoiceValue = choice.value;
        this.draggedTargetNode = node;
        this.dragOrClickHelper.onPointerDown(event);
      }
    };
    this.startDrag = (event) => {
      const choice = ItemValue.getItemByValue(this.visibleChoices, this.draggedChoiceValue);
      this.dragDropRankingChoices.startDrag(event, choice, this, this.draggedTargetNode);
    };
    this.handlePointerUp = (event, choice, node) => {
      if (!this.selectToRankEnabled) return;
      const target = event.target;
      if (this.isAllowStartDrag(target, choice)) {
        this.handleKeydownSelectToRank(event, choice, " ", false);
      }
    };
    this.handleKeydown = (event, choice) => {
      if (this.isReadOnlyAttr) return;
      if (!this.isDesignMode) {
        const key = event.key;
        const index = this.rankingChoices.indexOf(choice);
        if (this.selectToRankEnabled) {
          this.handleKeydownSelectToRank(event, choice);
          return;
        }
        if (key === "ArrowUp" && index || key === "ArrowDown" && index !== this.rankingChoices.length - 1) {
          const toIndex = key == "ArrowUp" ? index - 1 : index + 1;
          this.dragDropRankingChoices.reorderRankedItem(this, index, toIndex);
          this.setValueAfterKeydown(toIndex, "", true, event);
        }
      }
    };
    this.focusItem = (index, container) => {
      if (!this.domNode) return;
      if (this.selectToRankEnabled && container) {
        const containerSelector = "[data-ranking='" + container + "']";
        const itemsNodes = this.domNode.querySelectorAll(containerSelector + " ." + this.cssClasses.item);
        itemsNodes[index].focus();
      } else {
        const itemsNodes = this.domNode.querySelectorAll("." + this.cssClasses.item);
        itemsNodes[index].focus();
      }
    };
    this.isValueSetByUser = false;
    this.setValue = () => {
      const value = [];
      this.rankingChoices.forEach((choice) => {
        value.push(choice.value);
      });
      this.value = value;
      this.isValueSetByUser = true;
    };
    this.registerFunctionOnPropertyValueChanged("selectToRankEnabled", () => {
      this.clearValue(true);
      this.setDragDropRankingChoices();
      this.updateRankingChoicesSync();
    });
    this.dragOrClickHelper = new DragOrClickHelper(this.startDrag);
  }
  getType() {
    return "ranking";
  }
  getItemTabIndex(item) {
    if (this.isDesignMode || item.disabled) return void 0;
    return 0;
  }
  supportContainerQueries() {
    return this.selectToRankEnabled;
  }
  get rootClass() {
    return new CssClassBuilder().append(this.cssClasses.root).append(this.cssClasses.rootMobileMod, this.isMobileMode()).append(this.cssClasses.rootDisabled, this.isDisabledStyle).append(this.cssClasses.rootReadOnly, this.isReadOnlyStyle).append(this.cssClasses.rootPreview, this.isPreviewStyle).append(this.cssClasses.rootDesignMode, !!this.isDesignMode).append(this.cssClasses.itemOnError, this.hasCssError()).append(this.cssClasses.rootDragHandleAreaIcon, settings.rankingDragHandleArea === "icon").append(this.cssClasses.rootSelectToRankMod, this.selectToRankEnabled).append(this.cssClasses.rootSelectToRankEmptyValueMod, this.isEmpty()).append(this.cssClasses.rootSelectToRankAlignHorizontal, this.selectToRankEnabled && this.renderedSelectToRankAreasLayout === "horizontal").append(this.cssClasses.rootSelectToRankAlignVertical, this.selectToRankEnabled && this.renderedSelectToRankAreasLayout === "vertical").append(this.cssClasses.rootSelectToRankSwapAreas, this.selectToRankEnabled && this.renderedSelectToRankAreasLayout === "horizontal" && this.selectToRankSwapAreas).toString();
  }
  isItemSelectedCore(item) {
    if (this.selectToRankEnabled) {
      return super.isItemSelectedCore(item);
    }
    return true;
  }
  getItemClassCore(item, options) {
    return new CssClassBuilder().append(super.getItemClassCore(item, options)).append(this.cssClasses.itemGhostMod, this.currentDropTarget === item).toString();
  }
  getContainerClasses(containerType) {
    let isEmpty = false;
    const isToContainer = containerType === "to";
    const isFromContainer = containerType === "from";
    if (isToContainer) {
      isEmpty = this.renderedRankingChoices.length === 0;
    } else if (isFromContainer) {
      isEmpty = this.renderedUnRankingChoices.length === 0;
    }
    return new CssClassBuilder().append(this.cssClasses.container).append(this.cssClasses.containerToMode, isToContainer).append(this.cssClasses.containerFromMode, isFromContainer).append(this.cssClasses.containerEmptyMode, isEmpty).toString();
  }
  isItemCurrentDropTarget(item) {
    return this.dragDropRankingChoices.dropTarget === item;
  }
  get ghostPositionCssClass() {
    if (this.ghostPosition === "top") return this.cssClasses.dragDropGhostPositionTop;
    if (this.ghostPosition === "bottom") return this.cssClasses.dragDropGhostPositionBottom;
    return "";
  }
  getItemIndexClasses(item) {
    let noNumber;
    if (this.selectToRankEnabled) {
      noNumber = this.unRankingChoices.indexOf(item) !== -1;
    } else {
      noNumber = this.isEmpty();
    }
    return new CssClassBuilder().append(this.cssClasses.itemIndex).append(this.cssClasses.itemIndexEmptyMode, noNumber).toString();
  }
  getNumberByIndex(index) {
    return this.isEmpty() ? "" : index + 1 + "";
  }
  updateRankingChoicesSync() {
    this.blockAnimations();
    this.updateRankingChoices();
    this.releaseAnimations();
  }
  setSurveyImpl(value, isLight) {
    super.setSurveyImpl(value, isLight);
    this.setDragDropRankingChoices();
    this.updateRankingChoicesSync();
  }
  isAnswerCorrect() {
    return Helpers.isArraysEqual(this.value, this.correctAnswer, false);
  }
  get requireStrictCompare() {
    return true;
  }
  onSurveyValueChanged(newValue) {
    super.onSurveyValueChanged(newValue);
    if (this.isLoadingFromJson) return;
    this.updateRankingChoices();
  }
  onSurveyLoad() {
    this.blockAnimations();
    super.onSurveyLoad();
    this.updateRankingChoices();
    this.releaseAnimations();
  }
  updateValueFromSurvey(newValue, clearData) {
    super.updateValueFromSurvey(newValue, clearData);
    if (newValue) this.isValueSetByUser = true;
  }
  addToValueByVisibleChoices() {
    const newValue = this.value.slice();
    this.visibleChoices.forEach((choice) => {
      if (newValue.indexOf(choice.value) === -1) {
        newValue.push(choice.value);
      }
    });
    this.value = newValue;
  }
  removeFromValueByVisibleChoices() {
    const newValue = this.value.slice();
    const choices = this.visibleChoices;
    for (let i = this.value.length - 1; i >= 0; i--) {
      if (!ItemValue.getItemByValue(choices, this.value[i])) {
        newValue.splice(i, 1);
      }
    }
    this.value = newValue;
  }
  getChoicesAnimationOptions(isRankingChoices) {
    return {
      getKey(item) {
        return item.value;
      },
      getRerenderEvent: () => {
        return this.onElementRerendered;
      },
      isAnimationEnabled: () => this.animationAllowed && !this.isDesignMode && this.isVisible && !!this.domNode,
      getReorderOptions: (item, movedForward) => {
        let cssClass = "";
        if (item !== this.currentDropTarget) {
          cssClass = movedForward ? "sv-dragdrop-movedown" : "sv-dragdrop-moveup";
        }
        return {
          cssClass
        };
      },
      getLeaveOptions: (item) => {
        const choices = isRankingChoices ? this.renderedRankingChoices : this.renderedUnRankingChoices;
        if (this.renderedSelectToRankAreasLayout == "vertical" && choices.length == 1 && choices.indexOf(item) >= 0) {
          return {
            cssClass: "sv-ranking-item--animate-item-removing-empty"
          };
        }
        return {
          cssClass: "sv-ranking-item--animate-item-removing",
          onBeforeRunAnimation: (el) => {
            el.style.setProperty("--animation-height", el.offsetHeight + "px");
          }
        };
      },
      getEnterOptions: (item) => {
        const choices = isRankingChoices ? this.renderedRankingChoices : this.renderedUnRankingChoices;
        if (this.renderedSelectToRankAreasLayout == "vertical" && choices.length == 1 && choices.indexOf(item) >= 0) {
          return {
            cssClass: "sv-ranking-item--animate-item-adding-empty"
          };
        }
        return {
          cssClass: "sv-ranking-item--animate-item-adding",
          onBeforeRunAnimation: (el) => {
            el.style.setProperty("--animation-height", el.offsetHeight + "px");
          }
        };
      },
      getAnimatedElement: (item) => {
        var _a;
        const cssClasses = this.cssClasses;
        let containerSelector = "";
        if (this.selectToRankEnabled) {
          if (!isRankingChoices && cssClasses.containerFromMode) {
            containerSelector = classesToSelector(cssClasses.containerFromMode);
          } else if (isRankingChoices && cssClasses.containerToMode) {
            containerSelector = classesToSelector(cssClasses.containerToMode);
          }
        }
        const index = isRankingChoices ? this.renderedRankingChoices.indexOf(item) : this.renderedUnRankingChoices.indexOf(item);
        return (_a = this.domNode) === null || _a === void 0 ? void 0 : _a.querySelector(`${containerSelector} [data-sv-drop-target-ranking-item='${index}']`);
      },
      allowSyncRemovalAddition: true
    };
  }
  get rankingChoicesAnimation() {
    return this._rankingChoicesAnimation;
  }
  get unRankingChoicesAnimation() {
    return this._unRankingChoicesAnimation;
  }
  get renderedRankingChoices() {
    return this._renderedRankingChoices;
  }
  set renderedRankingChoices(val) {
    this.rankingChoicesAnimation.sync(val);
  }
  get renderedUnRankingChoices() {
    return this._renderedUnRankingChoices;
  }
  set renderedUnRankingChoices(val) {
    this.unRankingChoicesAnimation.sync(val);
  }
  updateRenderedRankingChoices() {
    this.renderedRankingChoices = this.rankingChoices;
  }
  updateRenderedUnRankingChoices() {
    this.renderedUnRankingChoices = this.unRankingChoices;
  }
  updateRankingChoices(forceUpdate = false) {
    if (this.selectToRankEnabled) {
      this.updateRankingChoicesSelectToRankMode(forceUpdate);
      return;
    }
    const newRankingChoices = [];
    if (forceUpdate) this.rankingChoices = [];
    if (this.isEmpty()) {
      this.rankingChoices = this.visibleChoices;
      return;
    }
    this.value.forEach((valueItem) => {
      this.visibleChoices.forEach((choice) => {
        if (choice.value === valueItem) newRankingChoices.push(choice);
      });
    });
    this.rankingChoices = newRankingChoices;
  }
  updateUnRankingChoices(newRankingChoices) {
    const unRankingChoices = [];
    this.visibleChoices.forEach((choice) => {
      unRankingChoices.push(choice);
    });
    newRankingChoices.forEach((rankingChoice) => {
      unRankingChoices.forEach((choice, index) => {
        if (choice.value === rankingChoice.value) unRankingChoices.splice(index, 1);
      });
    });
    this.unRankingChoices = unRankingChoices;
  }
  updateRankingChoicesSelectToRankMode(forceUpdate) {
    const newRankingChoices = [];
    if (!this.isEmpty()) {
      this.value.forEach((valueItem) => {
        this.visibleChoices.forEach((choice) => {
          if (choice.value === valueItem) newRankingChoices.push(choice);
        });
      });
    }
    this.updateUnRankingChoices(newRankingChoices);
    this.rankingChoices = newRankingChoices;
  }
  endLoadingFromJson() {
    super.endLoadingFromJson();
    this.setDragDropRankingChoices();
  }
  setDragDropRankingChoices() {
    this.dragDropRankingChoices = this.createDragDropRankingChoices();
  }
  createDragDropRankingChoices() {
    if (this.selectToRankEnabled) return new DragDropRankingSelectToRank(this.survey, null, this.longTap);
    return new DragDropRankingChoices(this.survey, null, this.longTap);
  }
  isDragStartNodeValid(target) {
    if (settings.rankingDragHandleArea === "icon") {
      return target.classList.contains(this.cssClasses.itemIconHoverMod);
    }
    return true;
  }
  isAllowStartDrag(target, choice) {
    return !this.isReadOnly && !this.isDesignMode && this.canStartDragDueMaxSelectedChoices(target) && this.canStartDragDueItemEnabled(choice);
  }
  canStartDragDueMaxSelectedChoices(target) {
    if (!this.selectToRankEnabled) return true;
    let fromContainer = target.closest("[data-ranking='from-container']");
    if (fromContainer) {
      return this.checkMaxSelectedChoicesUnreached();
    }
    return true;
  }
  canStartDragDueItemEnabled(item) {
    return item.enabled;
  }
  checkMaxSelectedChoicesUnreached() {
    if (this.maxSelectedChoices < 1) return true;
    var val = this.value;
    var len = !Array.isArray(val) ? 0 : val.length;
    return len < this.maxSelectedChoices;
  }
  //cross framework initialization
  afterRenderQuestionElement(el) {
    this.domNode = el;
    super.afterRenderQuestionElement(el);
  }
  //cross framework destroy
  beforeDestroyQuestionElement(el) {
    this.domNode = void 0;
    super.beforeDestroyQuestionElement(el);
  }
  supportSelectAll() {
    return false;
  }
  supportOther() {
    return false;
  }
  supportNone() {
    return false;
  }
  supportRefuse() {
    return false;
  }
  supportDontKnow() {
    return false;
  }
  handleKeydownSelectToRank(event, movedElement, hardKey, isNeedFocus = true) {
    if (this.isDesignMode) return;
    let key = event.key;
    if (hardKey) key = hardKey;
    if (key !== " " && key !== "ArrowUp" && key !== "ArrowDown") return;
    const dnd = this.dragDropRankingChoices;
    const rankingChoices = this.rankingChoices;
    const isMovedElementRanked = rankingChoices.indexOf(movedElement) !== -1;
    const choices = isMovedElementRanked ? rankingChoices : this.unRankingChoices;
    const fromIndex = choices.indexOf(movedElement);
    if (fromIndex < 0) return;
    let toIndex;
    if (key === " " && !isMovedElementRanked) {
      if (!this.checkMaxSelectedChoicesUnreached() || !this.canStartDragDueItemEnabled(movedElement)) return;
      toIndex = this.value.length;
      dnd.selectToRank(this, fromIndex, toIndex);
      this.setValueAfterKeydown(toIndex, "to-container", isNeedFocus, event);
      return;
    }
    if (!isMovedElementRanked) return;
    if (key === " ") {
      dnd.unselectFromRank(this, fromIndex);
      toIndex = this.unRankingChoices.indexOf(movedElement);
      this.setValueAfterKeydown(toIndex, "from-container", isNeedFocus, event);
      return;
    }
    const delta = key === "ArrowUp" ? -1 : key === "ArrowDown" ? 1 : 0;
    if (delta === 0) return;
    toIndex = fromIndex + delta;
    if (toIndex < 0 || toIndex >= rankingChoices.length) return;
    dnd.reorderRankedItem(this, fromIndex, toIndex);
    this.setValueAfterKeydown(toIndex, "to-container", isNeedFocus, event);
  }
  setValueAfterKeydown(index, container, isNeedFocus = true, event) {
    this.setValue();
    if (isNeedFocus) {
      setTimeout(() => {
        this.focusItem(index, container);
      }, 1);
    }
    event && event.preventDefault();
  }
  getIconHoverCss() {
    return new CssClassBuilder().append(this.cssClasses.itemIcon).append(this.cssClasses.itemIconHoverMod).toString();
  }
  getIconFocusCss() {
    return new CssClassBuilder().append(this.cssClasses.itemIcon).append(this.cssClasses.itemIconFocusMod).toString();
  }
  /**
   * Specifies whether to use a long tap (press and hold) gesture to start dragging.
   *
   * Default value: `true`
   *
   * Disable this property if you want to start dragging when users perform a scroll gesture.
  */
  get longTap() {
    return this.getPropertyValue("longTap");
  }
  set longTap(val) {
    this.setPropertyValue("longTap", val);
  }
  getDefaultItemComponent() {
    return "sv-ranking-item";
  }
  /**
   * Specifies whether users can select choices they want to rank.
   *
   * When you enable this property, the Ranking question displays two areas for ranked and unranked choices. To order choices, users should first drag them from the unranked to the ranked area. Use this mode if you want to let users order only the choices they select.
   *
   * Default value: `false`
   * @see selectToRankAreasLayout
  */
  get selectToRankEnabled() {
    return this.getPropertyValue("selectToRankEnabled", false);
  }
  set selectToRankEnabled(val) {
    this.setPropertyValue("selectToRankEnabled", val);
  }
  get selectToRankSwapAreas() {
    return this.getPropertyValue("selectToRankSwapAreas", false);
  }
  set selectToRankSwapAreas(val) {
    this.setPropertyValue("selectToRankSwapAreas", val);
  }
  /**
   * Specifies the layout of the ranked and unranked areas. Applies when [`selectToRankEnabled`](https://surveyjs.io/form-library/documentation/api-reference/ranking-question-model#selectToRankEnabled) is `true`.
   *
   * Possible values:
   *
   * - `"horizontal"` (default) - The ranked and unranked areas are positioned next to each other. Users drag and drop choices between them in the horizontal direction.
   * - `"vertical"`- The ranked area is positioned above the unranked area. Users drag and drop choices between them in the vertical direction.
   * @see selectToRankAreasLayout
  */
  get selectToRankAreasLayout() {
    return this.getPropertyValue("selectToRankAreasLayout");
  }
  set selectToRankAreasLayout(val) {
    this.setPropertyValue("selectToRankAreasLayout", val);
  }
  get renderedSelectToRankAreasLayout() {
    if (this.isMobileMode()) return "vertical";
    return this.selectToRankAreasLayout;
  }
  isMobileMode() {
    return IsMobile;
  }
  get useFullItemSizeForShortcut() {
    return this.getPropertyValue("useFullItemSizeForShortcut");
  }
  set useFullItemSizeForShortcut(val) {
    this.setPropertyValue("useFullItemSizeForShortcut", val);
  }
  get dragDropSvgIcon() {
    return this.cssClasses.dragDropSvgIconId || "#icon-drag-24x24";
  }
  get arrowsSvgIcon() {
    return this.cssClasses.arrowsSvgIconId || "#icon-reorder-24x24";
  }
  get dashSvgIcon() {
    return this.cssClasses.dashSvgIconId || "#icon-rankingundefined-16x16";
  }
  //a11y
  get isNewA11yStructure() {
    return false;
  }
};
__decorate([propertyArray({
  onSet: (val, target) => target.updateRenderedRankingChoices(),
  onRemove: (_, _i, target) => target.updateRenderedRankingChoices(),
  onPush: (_, _i, target) => target.updateRenderedRankingChoices()
})], QuestionRankingModel.prototype, "rankingChoices", void 0);
__decorate([propertyArray({
  onSet: (val, target) => target.updateRenderedUnRankingChoices(),
  onRemove: (_, _i, target) => target.updateRenderedUnRankingChoices(),
  onPush: (_, _i, target) => target.updateRenderedUnRankingChoices()
})], QuestionRankingModel.prototype, "unRankingChoices", void 0);
__decorate([propertyArray()], QuestionRankingModel.prototype, "_renderedRankingChoices", void 0);
__decorate([propertyArray()], QuestionRankingModel.prototype, "_renderedUnRankingChoices", void 0);
__decorate([property({
  defaultValue: null
})], QuestionRankingModel.prototype, "currentDropTarget", void 0);
__decorate([property({
  defaultValue: true
})], QuestionRankingModel.prototype, "carryForwardStartUnranked", void 0);
__decorate([property({
  localizable: {
    defaultStr: "selectToRankEmptyRankedAreaText"
  }
})], QuestionRankingModel.prototype, "selectToRankEmptyRankedAreaText", void 0);
__decorate([property({
  localizable: {
    defaultStr: "selectToRankEmptyUnrankedAreaText"
  }
})], QuestionRankingModel.prototype, "selectToRankEmptyUnrankedAreaText", void 0);
Serializer.addClass("ranking", [{
  name: "showOtherItem",
  visible: false,
  isSerializable: false
}, {
  name: "otherText",
  visible: false,
  isSerializable: false
}, {
  name: "otherErrorText",
  visible: false,
  isSerializable: false
}, {
  name: "storeOthersAsComment",
  visible: false,
  isSerializable: false
}, {
  name: "showNoneItem",
  visible: false,
  isSerializable: false
}, {
  name: "showRefuseItem",
  visible: false,
  isSerializable: false
}, {
  name: "showDontKnowItem",
  visible: false,
  isSerializable: false
}, {
  name: "noneText",
  visible: false,
  isSerializable: false
}, {
  name: "showSelectAllItem",
  visible: false,
  isSerializable: false
}, {
  name: "selectAllText",
  visible: false,
  isSerializable: false
}, {
  name: "colCount:number",
  visible: false,
  isSerializable: false
}, {
  name: "separateSpecialChoices",
  visible: false,
  isSerializable: false
}, {
  name: "longTap",
  default: true,
  visible: false,
  isSerializable: false
}, {
  name: "selectToRankEnabled:switch",
  default: false,
  visible: true,
  isSerializable: true
}, {
  name: "selectToRankSwapAreas:switch",
  default: false,
  visible: false,
  isSerializable: true,
  dependsOn: "selectToRankEnabled"
}, {
  name: "selectToRankAreasLayout",
  default: "horizontal",
  choices: ["horizontal", "vertical"],
  dependsOn: "selectToRankEnabled",
  visibleIf: (obj) => {
    return !!obj.selectToRankEnabled;
  },
  visible: true,
  isSerializable: true
}, {
  name: "selectToRankEmptyRankedAreaText:text",
  serializationProperty: "locSelectToRankEmptyRankedAreaText",
  category: "general",
  dependsOn: "selectToRankEnabled",
  visibleIf: (obj) => {
    return !!obj.selectToRankEnabled;
  }
}, {
  name: "selectToRankEmptyUnrankedAreaText:text",
  serializationProperty: "locSelectToRankEmptyUnrankedAreaText",
  category: "general",
  dependsOn: "selectToRankEnabled",
  visibleIf: (obj) => {
    return !!obj.selectToRankEnabled;
  }
}, {
  name: "maxSelectedChoices:number",
  visible: true,
  default: 0,
  dependsOn: "selectToRankEnabled",
  visibleIf: (obj) => {
    return !!obj.selectToRankEnabled;
  },
  isSerializable: true
}, {
  name: "minSelectedChoices:number",
  visible: true,
  default: 0,
  dependsOn: "selectToRankEnabled",
  visibleIf: (obj) => {
    return !!obj.selectToRankEnabled;
  },
  isSerializable: true
}, {
  name: "itemComponent",
  visible: false,
  default: "sv-ranking-item"
}], function() {
  return new QuestionRankingModel("");
}, "checkbox");
QuestionFactory.Instance.registerQuestion("ranking", (name) => {
  const q = new QuestionRankingModel(name);
  q.choices = QuestionFactory.DefaultChoices;
  return q;
});
var QuestionCommentModel = class extends QuestionTextBase {
  constructor(name) {
    super(name);
  }
  get textAreaModel() {
    if (!this.textAreaModelValue) {
      this.textAreaModelValue = new TextAreaModel(this.getTextAreaOptions());
    }
    return this.textAreaModelValue;
  }
  getTextAreaOptions() {
    const _this = this;
    const updateQuestionValue = (newValue) => {
      if (!Helpers.isTwoValueEquals(_this.value, newValue, false, true, false)) {
        _this.value = newValue;
      }
    };
    const options = {
      question: this,
      id: () => this.inputId,
      propertyName: "value",
      className: () => this.className,
      placeholder: () => this.renderedPlaceholder,
      isDisabledAttr: () => this.isDisabledAttr,
      isReadOnlyAttr: () => this.isReadOnlyAttr,
      autoGrow: () => this.renderedAutoGrow,
      maxLength: () => this.getMaxLength(),
      rows: () => this.rows,
      cols: () => this.cols,
      ariaRequired: () => this.a11y_input_ariaRequired,
      ariaLabel: () => this.a11y_input_ariaLabel,
      ariaLabelledBy: () => this.a11y_input_ariaLabelledBy,
      ariaDescribedBy: () => this.a11y_input_ariaDescribedBy,
      ariaInvalid: () => this.a11y_input_ariaInvalid,
      ariaErrormessage: () => this.a11y_input_ariaErrormessage,
      getTextValue: () => {
        return this.value;
      },
      onTextAreaChange: (e) => {
        updateQuestionValue(e.target.value);
      },
      onTextAreaInput: (event) => {
        this.onInput(event);
      },
      onTextAreaKeyDown: (event) => {
        this.onKeyDown(event);
      },
      onTextAreaFocus: (event) => {
        this.onFocus(event);
      },
      onTextAreaBlur: (event) => {
        this.onBlur(event);
      }
    };
    return options;
  }
  /**
   * Specifies the visible height of the comment area, measured in lines.
   *
   * The value of this property is passed on to the `rows` attribute of the underlying `<textarea>` element.
   */
  get rows() {
    return this.getPropertyValue("rows");
  }
  set rows(val) {
    this.setPropertyValue("rows", val);
  }
  get cols() {
    return this.getPropertyValue("cols");
  }
  set cols(val) {
    this.setPropertyValue("cols", val);
  }
  /**
   * Specifies whether the question allows line breaks.
   *
   * When this property is enabled, a user can press Enter to insert line breaks. They are saved as `\n` in survey results. The Comment question also recognizes and interprets the `\n` sequence as a line break when you set the question `value` in code.
   */
  get acceptCarriageReturn() {
    return this.getPropertyValue("acceptCarriageReturn");
  }
  set acceptCarriageReturn(val) {
    this.setPropertyValue("acceptCarriageReturn", val);
  }
  /**
   * Specifies whether the comment area automatically increases its height to accomodate multi-line content.
   *
   * Default value: `false` (inherited from `SurveyModel`'s [`autoGrowComment`](https://surveyjs.io/form-library/documentation/surveymodel#autoGrowComment) property)
   * @see allowResize
   */
  get autoGrow() {
    return this.getPropertyValue("autoGrow");
  }
  set autoGrow(val) {
    this.setPropertyValue("autoGrow", val);
  }
  get renderedAutoGrow() {
    const autoGrow = this.autoGrow;
    return autoGrow === void 0 && this.survey ? this.survey.autoGrowComment : !!autoGrow;
  }
  /**
   * Specifies whether to display a resize handle for the comment area.
   *
   * Default value: `true` (inherited from `SurveyModel`'s [`allowResizeComment`](https://surveyjs.io/form-library/documentation/surveymodel#allowResizeComment) property)
   * @see autoGrow
   */
  get allowResize() {
    return this.getPropertyValue("allowResize");
  }
  set allowResize(val) {
    this.setPropertyValue("allowResize", val);
  }
  get renderedAllowResize() {
    const res = this.allowResize;
    if (res === void 0 && this.survey) {
      return this.survey.allowResizeComment;
    } else {
      return !!res;
    }
  }
  get resizeStyle() {
    return this.renderedAllowResize ? "both" : "none";
  }
  getType() {
    return "comment";
  }
  afterRenderQuestionElement(el) {
    const {
      root
    } = settings.environment;
    this.element = root.getElementById(this.inputId) || el;
    super.afterRenderQuestionElement(el);
  }
  beforeDestroyQuestionElement(el) {
    super.beforeDestroyQuestionElement(el);
    this.element = void 0;
  }
  onInput(event) {
    if (this.isInputTextUpdate) this.value = event.target.value;
    this.updateRemainingCharacterCounter(event.target.value);
  }
  onBlurCore(event) {
    super.onBlurCore(event);
  }
  onKeyDown(event) {
    this.onKeyDownPreprocess && this.onKeyDownPreprocess(event);
    if (!this.acceptCarriageReturn && (event.key === "Enter" || event.keyCode === 13)) {
      event.preventDefault();
      event.stopPropagation();
    }
  }
  setNewValue(newValue) {
    if (!this.acceptCarriageReturn && !!newValue) {
      newValue = newValue.replace(new RegExp("(\r\n|\n|\r)", "gm"), "");
    }
    super.setNewValue(newValue);
  }
  getValueSeparator() {
    return "\n";
  }
  notifyStateChanged(prevState) {
    super.notifyStateChanged(prevState);
    if (!this.isCollapsed) {
      this.textAreaModel.updateElement();
    }
  }
  get className() {
    return (this.cssClasses ? this.getControlClass() : "panel-comment-root") || void 0;
  }
};
Serializer.addClass("comment", [{
  name: "maxLength:number",
  default: -1
}, {
  name: "cols:number",
  default: 50,
  visible: false,
  isSerializable: false
}, {
  name: "rows:number",
  default: 4
}, {
  name: "placeholder",
  alternativeName: "placeHolder",
  serializationProperty: "locPlaceholder"
}, {
  name: "textUpdateMode",
  default: "default",
  choices: ["default", "onBlur", "onTyping"]
}, {
  name: "autoGrow:boolean",
  defaultFunc: () => void 0
}, {
  name: "allowResize:boolean",
  defaultFunc: () => void 0
}, {
  name: "acceptCarriageReturn:boolean",
  default: true,
  visible: false
}], function() {
  return new QuestionCommentModel("");
}, "textbase");
QuestionFactory.Instance.registerQuestion("comment", (name) => {
  return new QuestionCommentModel(name);
});
var envStr = "environment";
var userStr = "user";
var Camera = class _Camera {
  constructor() {
    this.canFlipValue = void 0;
  }
  static clear() {
    _Camera.cameraList = void 0;
    _Camera.cameraIndex = -1;
  }
  static setCameraList(list) {
    const getDeviceType = function(device) {
      const lbl = device.label.toLocaleLowerCase();
      if (lbl.indexOf(userStr) > -1) return userStr;
      if (lbl.indexOf(envStr) > -1) return envStr;
      if (lbl.indexOf("front") > -1) return userStr;
      if (lbl.indexOf("back") > -1) return envStr;
      return "";
    };
    _Camera.clear();
    if (Array.isArray(list) && list.length > 0) {
      _Camera.cameraIndex = -1;
      list.sort((a, b) => {
        if (a === b) return 0;
        if (a.label !== b.label) {
          const lblA = getDeviceType(a);
          const lblB = getDeviceType(b);
          if (lblA !== lblB) {
            if (lblA === userStr) return -1;
            if (lblB === userStr) return 1;
            if (lblA === envStr) return -1;
            if (lblB === envStr) return 1;
          }
        }
        const iA = list.indexOf(a);
        const iB = list.indexOf(b);
        return iA < iB ? -1 : 1;
      });
    }
    _Camera.cameraList = list;
  }
  hasCamera(callback) {
    if (_Camera.cameraList !== void 0) {
      this.hasCameraCallback(callback);
      return;
    }
    if (_Camera.mediaDevicesCallback) {
      const devicesCallback = (devices) => {
        this.setVideoInputs(devices);
        this.hasCameraCallback(callback);
      };
      _Camera.mediaDevicesCallback(devicesCallback);
      return;
    }
    if (typeof navigator !== "undefined" && navigator.mediaDevices) {
      navigator.mediaDevices.enumerateDevices().then((devices) => {
        this.setVideoInputs(devices);
        this.hasCameraCallback(callback);
        this.updateCanFlipValue();
      }).catch((error) => {
        _Camera.cameraList = null;
        this.hasCameraCallback(callback);
      });
    } else {
      _Camera.cameraList = null;
      this.hasCameraCallback(callback);
    }
  }
  getMediaConstraints(videoSize) {
    const devices = _Camera.cameraList;
    if (!Array.isArray(devices) || devices.length < 1) return void 0;
    if (_Camera.cameraIndex < 0) _Camera.cameraIndex = 0;
    const selDevice = devices[_Camera.cameraIndex];
    const videoConstraints = {};
    if (selDevice && selDevice.deviceId) {
      videoConstraints.deviceId = {
        exact: selDevice.deviceId
      };
    } else {
      videoConstraints.facingMode = _Camera.cameraFacingMode;
    }
    if (videoSize) {
      if (videoSize === null || videoSize === void 0 ? void 0 : videoSize.height) {
        videoConstraints.height = {
          ideal: videoSize.height
        };
      }
      if (videoSize === null || videoSize === void 0 ? void 0 : videoSize.width) {
        videoConstraints.width = {
          ideal: videoSize.width
        };
      }
    }
    return {
      video: videoConstraints,
      audio: false
    };
  }
  startVideo(videoElement, callback, imageWidth, imageHeight) {
    if (!videoElement) {
      callback(void 0);
      return;
    }
    videoElement.style.width = "100%";
    videoElement.style.height = "auto";
    videoElement.style.height = "100%";
    videoElement.style.objectFit = "contain";
    const mediaConstraints = this.getMediaConstraints({
      width: imageWidth,
      height: imageHeight
    });
    navigator.mediaDevices.getUserMedia(mediaConstraints).then((stream) => {
      var _a;
      videoElement.srcObject = stream;
      if (!((_a = _Camera.cameraList[_Camera.cameraIndex]) === null || _a === void 0 ? void 0 : _a.deviceId) && !!stream.getTracks()[0].getCapabilities().facingMode) {
        _Camera.canSwitchFacingMode = true;
        this.updateCanFlipValue();
      }
      videoElement.play();
      callback(stream);
    }).catch((error) => {
      callback(void 0);
    });
  }
  getImageSize(videoEl) {
    return {
      width: videoEl.videoWidth,
      height: videoEl.videoHeight
    };
  }
  snap(videoElement, callback) {
    if (!videoElement) return false;
    if (!DomDocumentHelper.isAvailable()) return false;
    const root = DomDocumentHelper.getDocument();
    const canvasEl = root.createElement("canvas");
    const imageSize = this.getImageSize(videoElement);
    canvasEl.height = imageSize.height;
    canvasEl.width = imageSize.width;
    let context = canvasEl.getContext("2d");
    context.clearRect(0, 0, canvasEl.width, canvasEl.height);
    context.drawImage(videoElement, 0, 0, canvasEl.width, canvasEl.height);
    canvasEl.toBlob(callback, "image/png");
    return true;
  }
  updateCanFlipValue() {
    const list = _Camera.cameraList;
    this.canFlipValue = Array.isArray(list) && list.length > 1 || _Camera.canSwitchFacingMode;
    if (this.onCanFlipChangedCallback) this.onCanFlipChangedCallback(this.canFlipValue);
  }
  canFlip(onCanFlipChangedCallback) {
    if (this.canFlipValue === void 0) {
      this.updateCanFlipValue();
    }
    if (onCanFlipChangedCallback) {
      this.onCanFlipChangedCallback = onCanFlipChangedCallback;
    }
    return this.canFlipValue;
  }
  flip() {
    if (!this.canFlip()) return;
    if (_Camera.canSwitchFacingMode) {
      _Camera.cameraFacingMode = _Camera.cameraFacingMode === userStr ? "environment" : userStr;
    } else if (_Camera.cameraIndex >= _Camera.cameraList.length - 1) {
      _Camera.cameraIndex = 0;
    } else {
      _Camera.cameraIndex++;
    }
  }
  hasCameraCallback(callback) {
    callback(Array.isArray(_Camera.cameraList));
  }
  setVideoInputs(devices) {
    const list = [];
    devices.forEach((device) => {
      if (device.kind === "videoinput") {
        list.push(device);
      }
    });
    _Camera.setCameraList(list.length > 0 ? list : null);
  }
};
Camera.cameraIndex = -1;
Camera.cameraFacingMode = userStr;
Camera.canSwitchFacingMode = false;
function dataUrl2File(dataUrl, fileName, type) {
  const str = atob(dataUrl.split(",")[1]);
  const buffer = new Uint8Array(str.split("").map((c) => c.charCodeAt(0))).buffer;
  return new File([buffer], fileName, {
    type
  });
}
var QuestionFileModelBase = class extends Question {
  constructor() {
    super(...arguments);
    this.isUploading = false;
    this.onUploadStateChanged = this.addEvent();
    this.onStateChanged = this.addEvent();
  }
  stateChanged(state) {
    if (this.currentState == state) {
      return;
    }
    if (state === "loading") {
      this.isUploading = true;
    }
    if (state === "loaded") {
      this.isUploading = false;
    }
    if (state === "error") {
      this.isUploading = false;
    }
    this.currentState = state;
    this.onStateChanged.fire(this, {
      state
    });
    this.onUploadStateChanged.fire(this, {
      state
    });
  }
  get showLoadingIndicator() {
    return this.isUploading && this.isDefaultV2Theme;
  }
  /**
   * Specifies whether to store file or signature content as text in `SurveyModel`'s [`data`](https://surveyjs.io/form-library/documentation/surveymodel#data) property.
   *
   * If you disable this property, implement `SurveyModel`'s [`onUploadFiles`](https://surveyjs.io/form-library/documentation/surveymodel#onUploadFiles) event handler to specify how to store file content.
   */
  get storeDataAsText() {
    return this.getPropertyValue("storeDataAsText");
  }
  set storeDataAsText(val) {
    this.setPropertyValue("storeDataAsText", val);
  }
  /**
     * Enable this property if you want to wait until files are uploaded to complete the survey.
     *
     * Default value: `false`
     */
  get waitForUpload() {
    return this.getPropertyValue("waitForUpload");
  }
  set waitForUpload(val) {
    this.setPropertyValue("waitForUpload", val);
  }
  clearValue(keepComment) {
    this.clearOnDeletingContainer();
    super.clearValue(keepComment);
  }
  clearOnDeletingContainer() {
    if (!this.survey) return;
    this.survey.clearFiles(this, this.name, this.value, null, () => {
    });
  }
  onCheckForErrors(errors, isOnValueChanged, fireCallback) {
    super.onCheckForErrors(errors, isOnValueChanged, fireCallback);
    if (this.isUploading && this.waitForUpload) {
      errors.push(new UploadingFileError(this.getLocalizationString("uploadingFile"), this));
    }
  }
  uploadFiles(files) {
    if (this.survey) {
      this.stateChanged("loading");
      this.survey.uploadFiles(this, this.name, files, (arg1, arg2) => {
        if (Array.isArray(arg1)) {
          this.setValueFromResult(arg1);
          if (Array.isArray(arg2)) {
            arg2.forEach((error) => this.errors.push(new UploadingFileError(error, this)));
            this.stateChanged("error");
          }
        }
        if (arg1 === "success" && Array.isArray(arg2)) {
          this.setValueFromResult(arg2);
        }
        if (arg1 === "error") {
          if (typeof arg2 === "string") {
            this.errors.push(new UploadingFileError(arg2, this));
          }
          if (Array.isArray(arg2) && arg2.length > 0) {
            arg2.forEach((error) => this.errors.push(new UploadingFileError(error, this)));
          }
          this.stateChanged("error");
        }
        this.stateChanged("loaded");
      });
    }
  }
  loadPreview(newValue) {
  }
  onChangeQuestionValue(newValue) {
    super.onChangeQuestionValue(newValue);
    this.stateChanged(this.isEmpty() ? "empty" : "loaded");
  }
  getIsQuestionReady() {
    return super.getIsQuestionReady() && !this.isFileLoading;
  }
  get isFileLoading() {
    return this.isFileLoadingValue;
  }
  set isFileLoading(val) {
    this.isFileLoadingValue = val;
    this.updateIsReady();
  }
};
__decorate([property()], QuestionFileModelBase.prototype, "isUploading", void 0);
__decorate([property({
  defaultValue: "empty"
})], QuestionFileModelBase.prototype, "currentState", void 0);
var QuestionFilePage = class _QuestionFilePage extends Base {
  static getId() {
    return "sv_sfp_" + _QuestionFilePage.pageCounter++;
  }
  constructor(question, index) {
    super();
    this.question = question;
    this.index = index;
    this.id = _QuestionFilePage.getId();
  }
  get css() {
    return this.question.cssClasses.page;
  }
};
QuestionFilePage.pageCounter = 0;
__decorate([propertyArray({})], QuestionFilePage.prototype, "items", void 0);
var QuestionFileModel = class extends QuestionFileModelBase {
  get supportFileNavigator() {
    return this.isDefaultV2Theme;
  }
  get fileNavigatorVisible() {
    const isUploading = this.isUploading;
    const isPlayingVideo = this.isPlayingVideo;
    const containsMultipleFiles = this.containsMultiplyFiles;
    const needToShowFileNavigator = this.pageSize < this.previewValue.length;
    return !isUploading && !isPlayingVideo && containsMultipleFiles && needToShowFileNavigator && this.isDefaultV2Theme;
  }
  get pagesCount() {
    return Math.ceil(this.previewValue.length / this.pageSize);
  }
  get actionsContainerVisible() {
    const isUploading = this.isUploading;
    const isPlayingVideo = this.isPlayingVideo;
    const isDefaultV2Theme = this.isDefaultV2Theme;
    return !isUploading && !isPlayingVideo && isDefaultV2Theme;
  }
  constructor(name) {
    super(name);
    this.isDragging = false;
    this.fileNavigator = new ActionContainer();
    this.canFlipCameraValue = void 0;
    this.prevPreviewLength = 0;
    this._renderedPages = [];
    this.pagesAnimation = new AnimationTab(this.getPagesAnimationOptions(), (val) => {
      this._renderedPages = val;
    }, () => this.renderedPages);
    this.calcAvailableItemsCount = (availableWidth, itemWidth, gap) => {
      let itemsCount = Math.floor(availableWidth / (itemWidth + gap));
      if ((itemsCount + 1) * (itemWidth + gap) - gap <= availableWidth) itemsCount++;
      return itemsCount;
    };
    this.dragCounter = 0;
    this.onDragEnter = (event) => {
      if (this.canDragDrop()) {
        event.preventDefault();
        this.isDragging = true;
        this.dragCounter++;
      }
    };
    this.onDragOver = (event) => {
      if (!this.canDragDrop()) {
        event.returnValue = false;
        return false;
      }
      event.dataTransfer.dropEffect = "copy";
      event.preventDefault();
    };
    this.onDrop = (event) => {
      if (this.canDragDrop()) {
        this.isDragging = false;
        this.dragCounter = 0;
        event.preventDefault();
        let src = event.dataTransfer;
        this.onChange(src);
      }
    };
    this.onDragLeave = (event) => {
      if (this.canDragDrop()) {
        this.dragCounter--;
        if (this.dragCounter === 0) {
          this.isDragging = false;
        }
      }
    };
    this.doChange = (event) => {
      var src = event.target || event.srcElement;
      this.onChange(src);
    };
    this.doClean = () => {
      if (this.needConfirmRemoveFile) {
        confirmActionAsync({
          message: this.confirmRemoveAllMessage,
          funcOnYes: () => {
            this.clearFilesCore();
          },
          locale: this.getLocale(),
          rootElement: this.survey.rootElement,
          cssClass: this.cssClasses.confirmDialog
        });
        return;
      }
      this.clearFilesCore();
    };
    this.doDownloadFileFromContainer = (event) => {
      event.stopPropagation();
      const currentTarget = event.currentTarget;
      if (currentTarget && currentTarget.getElementsByTagName) {
        const link = currentTarget.getElementsByTagName("a")[0];
        link === null || link === void 0 ? void 0 : link.click();
      }
    };
    this.doDownloadFile = (event, data) => {
      event.stopPropagation();
      if (detectIEOrEdge()) {
        event.preventDefault();
        loadFileFromBase64(data.content, data.name);
      }
    };
    this.createLocalizableString("takePhotoCaption", this, false, true);
    this.createLocalizableString("clearCaption", this, false, true);
    this.actionsContainer = new ActionContainer();
    this.actionsContainer.locOwner = this;
    this.fileIndexAction = new Action({
      id: "fileIndex",
      title: this.getFileIndexCaption(),
      enabled: false
    });
    this.prevFileAction = new Action({
      id: "prevPage",
      iconSize: 16,
      action: () => {
        this.navigationDirection = "left";
        this.indexToShow = this.previewValue.length && (this.indexToShow - 1 + this.pagesCount) % this.pagesCount || 0;
        this.fileIndexAction.title = this.getFileIndexCaption();
      }
    });
    this.nextFileAction = new Action({
      id: "nextPage",
      iconSize: 16,
      action: () => {
        this.navigationDirection = "right";
        this.indexToShow = this.previewValue.length && (this.indexToShow + 1) % this.pagesCount || 0;
        this.fileIndexAction.title = this.getFileIndexCaption();
      }
    });
    this.takePictureAction = new Action({
      iconName: "icon-takepicture",
      id: "sv-file-take-picture",
      iconSize: "auto",
      innerCss: new ComputedUpdater(() => new CssClassBuilder().append(this.cssClasses.contextButton).append(this.cssClasses.takePictureButton).toString()),
      locTitle: this.locTakePhotoCaption,
      showTitle: false,
      action: () => {
        this.snapPicture();
      }
    });
    this.closeCameraAction = new Action({
      iconName: "icon-closecamera",
      id: "sv-file-close-camera",
      iconSize: "auto",
      innerCss: new ComputedUpdater(() => new CssClassBuilder().append(this.cssClasses.contextButton).append(this.cssClasses.closeCameraButton).toString()),
      action: () => {
        this.stopVideo();
      }
    });
    this.changeCameraAction = new Action({
      iconName: "icon-changecamera",
      id: "sv-file-change-camera",
      iconSize: "auto",
      innerCss: new ComputedUpdater(() => new CssClassBuilder().append(this.cssClasses.contextButton).append(this.cssClasses.changeCameraButton).toString()),
      visible: new ComputedUpdater(() => this.canFlipCamera()),
      action: () => {
        this.flipCamera();
      }
    });
    this.chooseFileAction = new Action({
      iconName: "icon-choosefile",
      id: "sv-file-choose-file",
      iconSize: "auto",
      data: {
        question: this
      },
      enabledIf: () => !this.isInputReadOnly,
      component: "sv-file-choose-btn"
    });
    this.startCameraAction = new Action({
      iconName: "icon-takepicture_24x24",
      id: "sv-file-start-camera",
      iconSize: "auto",
      locTitle: this.locTakePhotoCaption,
      showTitle: new ComputedUpdater(() => !this.isAnswered),
      enabledIf: () => !this.isInputReadOnly,
      action: () => {
        this.startVideo();
      }
    });
    this.cleanAction = new Action({
      iconName: "icon-clear",
      id: "sv-file-clean",
      iconSize: "auto",
      locTitle: this.locClearButtonCaption,
      showTitle: false,
      enabledIf: () => !this.isInputReadOnly,
      innerCss: new ComputedUpdater(() => this.cssClasses.removeButton),
      action: () => {
        this.doClean();
      }
    });
    [this.closeCameraAction, this.changeCameraAction, this.takePictureAction].forEach((action) => {
      action.cssClasses = {};
    });
    this.registerFunctionOnPropertiesValueChanged(["sourceType", "currentMode", "isAnswered"], () => {
      this.updateActionsVisibility();
    });
    this.actionsContainer.actions = [this.chooseFileAction, this.startCameraAction, this.cleanAction];
    this.fileNavigator.actions = [this.prevFileAction, this.fileIndexAction, this.nextFileAction];
  }
  get videoId() {
    return this.id + "_video";
  }
  get hasVideoUI() {
    return this.currentMode !== "file";
  }
  get hasFileUI() {
    return this.currentMode !== "camera";
  }
  startVideo() {
    if (this.currentMode === "file" || this.isDesignMode || this.isPlayingVideo) return;
    this.setIsPlayingVideo(true);
    setTimeout(() => {
      this.startVideoInCamera();
    }, 0);
  }
  get videoHtmlElement() {
    var _a;
    return (_a = this.rootElement) === null || _a === void 0 ? void 0 : _a.querySelector(`#${this.videoId}`);
  }
  startVideoInCamera() {
    this.camera.startVideo(this.videoHtmlElement, (stream) => {
      this.videoStream = stream;
      if (!stream) {
        this.stopVideo();
      }
    }, getRenderedSize(this.imageWidth), getRenderedSize(this.imageHeight));
  }
  stopVideo() {
    this.setIsPlayingVideo(false);
    this.closeVideoStream();
  }
  snapPicture() {
    if (!this.isPlayingVideo) return;
    const blobCallback = (blob) => {
      if (blob) {
        const file = new File([blob], "snap_picture.png", {
          type: "image/png"
        });
        this.loadFiles([file]);
      }
    };
    this.camera.snap(this.videoHtmlElement, blobCallback);
    this.stopVideo();
  }
  canFlipCamera() {
    if (this.canFlipCameraValue === void 0) {
      this.canFlipCameraValue = this.camera.canFlip((res) => {
        this.canFlipCameraValue = res;
      });
    }
    return this.canFlipCameraValue;
  }
  flipCamera() {
    if (!this.canFlipCamera()) return;
    this.closeVideoStream();
    this.camera.flip();
    this.startVideoInCamera();
  }
  closeVideoStream() {
    if (!!this.videoStream) {
      this.videoStream.getTracks().forEach((track) => {
        track.stop();
      });
      this.videoStream = void 0;
    }
  }
  onHidingContent() {
    super.onHidingContent();
    this.stopVideo();
  }
  updateElementCssCore(cssClasses) {
    super.updateElementCssCore(cssClasses);
    this.prevFileAction.iconName = this.cssClasses.leftIconId;
    this.nextFileAction.iconName = this.cssClasses.rightIconId;
    this.updateCurrentMode();
  }
  getFileIndexCaption() {
    return this.getLocalizationFormatString("indexText", this.indexToShow + 1, this.pagesCount);
  }
  updateFileNavigator() {
    this.updatePages();
    this.navigationDirection = void 0;
    this.indexToShow = this.previewValue.length && (this.indexToShow + this.pagesCount) % this.pagesCount || 0;
    this.fileIndexAction.title = this.getFileIndexCaption();
  }
  updateRenderedPages() {
    if (this.pages && this.pages[this.indexToShow]) {
      this.renderedPages = [this.pages[this.indexToShow]];
    }
  }
  updatePages() {
    this.blockAnimations();
    let currentPage;
    this.pages = [];
    this.renderedPages = [];
    this.previewValue.forEach((val, index) => {
      if (index % this.pageSize == 0) {
        currentPage = new QuestionFilePage(this, this.pages.length);
        this.pages.push(currentPage);
      }
      currentPage.items.push(val);
    });
    this.releaseAnimations();
    this.updateRenderedPages();
  }
  previewValueChanged() {
    this.navigationDirection = void 0;
    if (this.previewValue.length !== this.prevPreviewLength) {
      if (this.previewValue.length > 0) {
        if (this.prevPreviewLength > this.previewValue.length) {
          if (this.indexToShow >= this.pagesCount && this.indexToShow > 0) {
            this.indexToShow = this.pagesCount - 1;
            this.navigationDirection = "left-delete";
          }
        } else {
          this.indexToShow = Math.floor(this.prevPreviewLength / this.pageSize);
        }
      } else {
        this.indexToShow = 0;
      }
    }
    this.updatePages();
    this.fileIndexAction.title = this.getFileIndexCaption();
    this.containsMultiplyFiles = this.previewValue.length > 1;
    if (this.previewValue.length > 0 && !this.calculatedGapBetweenItems && !this.calculatedItemWidth) {
      setTimeout(() => {
        this.processResponsiveness(0, this._width);
      }, 1);
    }
    this.prevPreviewLength = this.previewValue.length;
  }
  getType() {
    return "file";
  }
  onChangeQuestionValue(newValue) {
    super.onChangeQuestionValue(newValue);
    if (!this.isLoadingFromJson) {
      this.loadPreview(newValue);
    }
  }
  /**
   * Disable this property only to implement a custom preview.
   *
   * [View Demo](https://surveyjs.io/form-library/examples/file-custom-preview/ (linkStyle))
   * @see allowImagesPreview
   */
  get showPreview() {
    return this.getPropertyValue("showPreview");
  }
  set showPreview(val) {
    this.setPropertyValue("showPreview", val);
  }
  /**
   * Specifies whether users can upload multiple files.
   *
   * Default value: `false`
   */
  get allowMultiple() {
    return this.getPropertyValue("allowMultiple");
  }
  set allowMultiple(val) {
    this.setPropertyValue("allowMultiple", val);
  }
  /**
   * The image height.
   */
  get imageHeight() {
    return this.getPropertyValue("imageHeight");
  }
  set imageHeight(val) {
    this.setPropertyValue("imageHeight", val);
  }
  /**
   * The image width.
   */
  get imageWidth() {
    return this.getPropertyValue("imageWidth");
  }
  set imageWidth(val) {
    this.setPropertyValue("imageWidth", val);
  }
  /**
   * An [accept](https://www.w3schools.com/tags/att_input_accept.asp) attribute value for the underlying `<input>` element.
   */
  get acceptedTypes() {
    return this.getPropertyValue("acceptedTypes");
  }
  set acceptedTypes(val) {
    this.setPropertyValue("acceptedTypes", val);
  }
  /**
   * Specifies whether to show a preview of image files.
   */
  get allowImagesPreview() {
    return this.getPropertyValue("allowImagesPreview");
  }
  set allowImagesPreview(val) {
    this.setPropertyValue("allowImagesPreview", val);
  }
  /**
   * Maximum allowed file size, measured in bytes.
   *
   * Default value: 0 (unlimited)
   */
  get maxSize() {
    return this.getPropertyValue("maxSize");
  }
  set maxSize(val) {
    this.setPropertyValue("maxSize", val);
  }
  chooseFile(event) {
    if (!this.rootElement) return;
    const inputElement = this.rootElement.querySelector(`#${this.inputId}`);
    if (!inputElement) return;
    event.preventDefault();
    event.stopImmediatePropagation();
    if (inputElement) {
      if (this.survey) {
        this.survey.chooseFiles(inputElement, (files) => this.loadFiles(files), {
          element: this,
          elementType: this.getType(),
          propertyName: this.name
        });
      } else {
        inputElement.click();
      }
    }
  }
  /**
   * Specifies whether users should confirm file deletion.
   *
   * Default value: `false`
   */
  get needConfirmRemoveFile() {
    return this.getPropertyValue("needConfirmRemoveFile");
  }
  set needConfirmRemoveFile(val) {
    this.setPropertyValue("needConfirmRemoveFile", val);
  }
  getConfirmRemoveMessage(fileName) {
    return this.confirmRemoveMessage.format(fileName);
  }
  get takePhotoCaption() {
    return this.getLocalizableStringText("takePhotoCaption");
  }
  set takePhotoCaption(val) {
    this.setLocalizableStringText("takePhotoCaption", val);
  }
  get locTakePhotoCaption() {
    return this.getLocalizableString("takePhotoCaption");
  }
  get clearButtonCaption() {
    return this.getLocalizableStringText("clearCaption");
  }
  set clearButtonCaption(value) {
    this.setLocalizableStringText("clearCaption", value);
  }
  get locClearButtonCaption() {
    return this.getLocalizableString("clearCaption");
  }
  get locRenderedPlaceholder() {
    if (this.locRenderedPlaceholderValue === void 0) {
      this.locRenderedPlaceholderValue = new ComputedUpdater(() => {
        const isReadOnly = this.isReadOnly;
        const hasFileUI = !this.isDesignMode && this.hasFileUI || this.isDesignMode && this.sourceType != "camera";
        const hasVideoUI = !this.isDesignMode && this.hasVideoUI || this.isDesignMode && this.sourceType != "file";
        let renderedPlaceholder;
        if (isReadOnly) {
          renderedPlaceholder = this.locNoFileChosenCaption;
        } else if (hasFileUI && hasVideoUI) {
          renderedPlaceholder = this.locFileOrPhotoPlaceholder;
        } else if (hasFileUI) {
          renderedPlaceholder = this.locFilePlaceholder;
        } else {
          renderedPlaceholder = this.locPhotoPlaceholder;
        }
        return renderedPlaceholder;
      });
    }
    return this.locRenderedPlaceholderValue;
  }
  get currentMode() {
    return this.getPropertyValue("currentMode", this.sourceType);
  }
  get isPlayingVideo() {
    return this.getPropertyValue("isPlayingVideo", false);
  }
  setIsPlayingVideo(show) {
    this.setPropertyValue("isPlayingVideo", show);
  }
  updateCurrentMode() {
    if (!this.isDesignMode && this.survey) {
      if (this.sourceType !== "file") {
        this.camera.hasCamera((res) => {
          this.setPropertyValue("currentMode", res && this.isDefaultV2Theme ? this.sourceType : "file");
        });
      } else {
        this.setPropertyValue("currentMode", this.sourceType);
      }
    }
  }
  updateActionsVisibility() {
    const isDesignMode = this.isDesignMode;
    this.chooseFileAction.visible = !isDesignMode && this.hasFileUI || isDesignMode && this.sourceType !== "camera";
    this.startCameraAction.visible = !isDesignMode && this.hasVideoUI || isDesignMode && this.sourceType !== "file";
    this.cleanAction.visible = !!this.isAnswered;
  }
  get inputTitle() {
    if (this.isUploading) return this.loadingFileTitle;
    if (this.isEmpty()) return this.chooseFileTitle;
    return " ";
  }
  get chooseButtonText() {
    return this.isEmpty() || this.allowMultiple ? this.chooseButtonCaption : this.replaceButtonCaption;
  }
  clear(doneCallback) {
    if (!this.survey) return;
    this.containsMultiplyFiles = false;
    this.survey.clearFiles(this, this.name, this.value, null, (status, data) => {
      if (status === "success") {
        this.value = void 0;
        this.errors = [];
        !!doneCallback && doneCallback();
        this.indexToShow = 0;
        this.fileIndexAction.title = this.getFileIndexCaption();
      }
    });
  }
  get renderCapture() {
    return this.allowCameraAccess ? "user" : void 0;
  }
  get multipleRendered() {
    return this.allowMultiple ? "multiple" : void 0;
  }
  //todo: remove it in V2
  get showChooseButton() {
    return !this.isReadOnly && !this.isDefaultV2Theme;
  }
  //
  get showFileDecorator() {
    const isPlayingVideo = this.isPlayingVideo;
    const showLoadingIndicator = this.showLoadingIndicator;
    return !isPlayingVideo && !showLoadingIndicator;
  }
  get allowShowPreview() {
    const isShowLoadingIndicator = this.showLoadingIndicator;
    const isPlayingVideo = this.isPlayingVideo;
    return !isShowLoadingIndicator && !isPlayingVideo;
  }
  get showPreviewContainer() {
    return this.previewValue && this.previewValue.length > 0;
  }
  //todo: remove in V2
  get showRemoveButtonCore() {
    const showLoadingIndicator = this.showLoadingIndicator;
    const isReadOnly = this.isReadOnly;
    const isEmpty = this.isEmpty();
    return !isReadOnly && !isEmpty && !showLoadingIndicator && !this.isDefaultV2Theme;
  }
  get showRemoveButton() {
    return this.showRemoveButtonCore && this.cssClasses.removeButton;
  }
  get showRemoveButtonBottom() {
    const cssClasses = new CssClassBuilder().append(this.cssClasses.removeButtonBottom).append(this.cssClasses.contextButton).toString();
    return this.showRemoveButtonCore && cssClasses;
  }
  //
  defaultImage(data) {
    return !this.canPreviewImage(data) && !!this.cssClasses.defaultImage;
  }
  /**
   * Removes a file with a specified name.
   */
  removeFile(name) {
    this.removeFileByContent(this.value.filter((f) => f.name === name)[0]);
  }
  removeFileByContent(content) {
    if (!this.survey) return;
    this.survey.clearFiles(this, this.name, this.value, content.name, (status, data) => {
      if (status === "success") {
        var oldValue = this.value;
        if (Array.isArray(oldValue)) {
          this.value = oldValue.filter((f) => !Helpers.isTwoValueEquals(f, content, true, false, false));
        } else {
          this.value = void 0;
        }
      }
    });
  }
  setValueFromResult(arg) {
    this.value = (this.value || []).concat(arg.map((r) => {
      return {
        name: r.file.name,
        type: r.file.type,
        content: r.content
      };
    }));
  }
  /**
   * Loads multiple files into the question.
   * @param files An array of [File](https://developer.mozilla.org/en-US/docs/Web/API/File) objects.
   */
  loadFiles(files) {
    if (!this.survey) {
      return;
    }
    this.errors = [];
    if (!this.allFilesOk(files)) {
      return;
    }
    var loadFilesProc = () => {
      this.stateChanged("loading");
      var content = [];
      if (this.storeDataAsText) {
        files.forEach((file) => {
          let fileReader = new FileReader();
          fileReader.onload = (e) => {
            content = content.concat([{
              name: file.name,
              type: file.type,
              content: fileReader.result
            }]);
            if (content.length === files.length) {
              this.value = (this.value || []).concat(content);
            }
          };
          fileReader.readAsDataURL(file);
        });
      } else {
        this.uploadFiles(files);
      }
    };
    if (this.allowMultiple) {
      loadFilesProc();
    } else {
      this.clear(loadFilesProc);
    }
  }
  get camera() {
    if (!this.cameraValue) {
      this.cameraValue = new Camera();
    }
    return this.cameraValue;
  }
  canPreviewImage(fileItem) {
    return this.allowImagesPreview && !!fileItem && this.isFileImage(fileItem);
  }
  loadPreview(newValue) {
    if (this.showPreview && this.prevLoadedPreviewValue === newValue) return;
    this.previewValue.splice(0, this.previewValue.length);
    if (!this.showPreview || !newValue) return;
    this.prevLoadedPreviewValue = newValue;
    var newValues = Array.isArray(newValue) ? newValue : !!newValue ? [newValue] : [];
    if (this.storeDataAsText) {
      newValues.forEach((value) => {
        var content = value.content || value;
        this.previewValue.push({
          name: value.name,
          type: value.type,
          content
        });
      });
      this.previewValueChanged();
    } else {
      if (!!this._previewLoader) {
        this._previewLoader.dispose();
      }
      this.isFileLoading = true;
      this._previewLoader = new FileLoader(this, (status, loaded) => {
        if (status !== "error") {
          loaded.forEach((val) => {
            this.previewValue.push(val);
          });
          this.previewValueChanged();
        }
        this.isFileLoading = false;
        this._previewLoader.dispose();
        this._previewLoader = void 0;
      });
      this._previewLoader.load(newValues);
    }
  }
  allFilesOk(files) {
    var errorLength = this.errors ? this.errors.length : 0;
    (files || []).forEach((file) => {
      if (this.maxSize > 0 && file.size > this.maxSize) {
        this.errors.push(new ExceedSizeError(this.maxSize, this));
      }
    });
    return errorLength === this.errors.length;
  }
  isFileImage(file) {
    if (!file || !file.content || !file.content.substring) return false;
    const imagePrefix = "data:image";
    var subStr = file.content && file.content.substring(0, imagePrefix.length);
    subStr = subStr && subStr.toLowerCase();
    var result = subStr === imagePrefix || !!file.type && file.type.toLowerCase().indexOf("image/") === 0;
    return result;
  }
  getPlainData(options = {
    includeEmpty: true
  }) {
    var questionPlainData = super.getPlainData(options);
    if (!!questionPlainData && !this.isEmpty()) {
      questionPlainData.isNode = false;
      var values = Array.isArray(this.value) ? this.value : [this.value];
      questionPlainData.data = values.map((dataValue, index) => {
        return {
          name: index,
          title: "File",
          value: dataValue.content && dataValue.content || dataValue,
          displayValue: dataValue.name && dataValue.name || dataValue,
          getString: (val) => typeof val === "object" ? JSON.stringify(val) : val,
          isNode: false
        };
      });
    }
    return questionPlainData;
  }
  getImageWrapperCss(data) {
    return new CssClassBuilder().append(this.cssClasses.imageWrapper).append(this.cssClasses.imageWrapperDefaultImage, this.defaultImage(data)).toString();
  }
  getActionsContainerCss(css) {
    return new CssClassBuilder().append(css.actionsContainer).append(css.actionsContainerAnswered, this.isAnswered).toString();
  }
  getRemoveButtonCss() {
    return new CssClassBuilder().append(this.cssClasses.removeFileButton).append(this.cssClasses.contextButton).toString();
  }
  getChooseFileCss() {
    const isAnswered = this.isAnswered;
    return new CssClassBuilder().append(this.cssClasses.chooseFile).append(this.cssClasses.controlDisabled, this.isReadOnly).append(this.cssClasses.chooseFileAsText, !isAnswered).append(this.cssClasses.chooseFileAsTextDisabled, !isAnswered && this.isInputReadOnly).append(this.cssClasses.contextButton, isAnswered).append(this.cssClasses.chooseFileAsIcon, isAnswered).toString();
  }
  getReadOnlyFileCss() {
    return new CssClassBuilder().append("form-control").append(this.cssClasses.placeholderInput).toString();
  }
  get fileRootCss() {
    return new CssClassBuilder().append(this.cssClasses.root).append(this.cssClasses.rootDisabled, this.isDisabledStyle).append(this.cssClasses.rootReadOnly, this.isReadOnlyStyle).append(this.cssClasses.rootPreview, this.isPreviewStyle).append(this.cssClasses.rootDragging, this.isDragging).append(this.cssClasses.rootAnswered, this.isAnswered).append(this.cssClasses.single, !this.allowMultiple).append(this.cssClasses.singleImage, !this.allowMultiple && this.isAnswered && this.canPreviewImage(this.value[0])).append(this.cssClasses.mobile, this.isMobile).toString();
  }
  getFileDecoratorCss() {
    return new CssClassBuilder().append(this.cssClasses.fileDecorator).append(this.cssClasses.onError, this.hasCssError()).append(this.cssClasses.fileDecoratorDrag, this.isDragging).toString();
  }
  onChange(src) {
    if (!DomWindowHelper.isFileReaderAvailable()) return;
    if (!src || !src.files || src.files.length < 1) return;
    let files = [];
    let allowCount = this.allowMultiple ? src.files.length : 1;
    for (let i = 0; i < allowCount; i++) {
      files.push(src.files[i]);
    }
    src.value = "";
    this.loadFiles(files);
  }
  calcCssClasses(css) {
    const classes = super.calcCssClasses(css);
    this.actionsContainer.cssClasses = css.actionBar;
    this.actionsContainer.cssClasses.itemWithTitle = this.actionsContainer.cssClasses.item;
    this.actionsContainer.cssClasses.item = "";
    this.actionsContainer.cssClasses.itemAsIcon = classes.contextButton;
    this.actionsContainer.containerCss = classes.actionsContainer;
    return classes;
  }
  onSurveyLoad() {
    super.onSurveyLoad();
    this.updateCurrentMode();
    this.updateActionsVisibility();
    this.loadPreview(this.value);
  }
  needResponsiveness() {
    return this.supportResponsiveness() && this.isDefaultV2Theme;
  }
  supportResponsiveness() {
    return true;
  }
  getObservedElementSelector() {
    return classesToSelector(this.cssClasses.dragArea);
  }
  getFileListSelector() {
    return classesToSelector(this.cssClasses.fileList);
  }
  get renderedPages() {
    return this._renderedPages;
  }
  set renderedPages(val) {
    this.pagesAnimation.sync(val);
  }
  getPagesAnimationOptions() {
    return {
      getEnterOptions: (page) => {
        const pageClass = this.cssClasses.page;
        return {
          cssClass: pageClass ? new CssClassBuilder().append(`${pageClass}--enter-from-left`, this.navigationDirection == "left" || this.navigationDirection == "left-delete").append(`${pageClass}--enter-from-right`, this.navigationDirection == "right").toString() : ""
        };
      },
      getLeaveOptions: (page) => {
        const pageClass = this.cssClasses.page;
        return {
          cssClass: pageClass ? new CssClassBuilder().append(`${pageClass}--leave-to-left`, this.navigationDirection == "right").append(`${pageClass}--leave-to-right`, this.navigationDirection == "left").toString() : ""
        };
      },
      getAnimatedElement: (page) => {
        var _a;
        return (_a = this.rootElement) === null || _a === void 0 ? void 0 : _a.querySelector(`#${page.id}`);
      },
      isAnimationEnabled: () => {
        return this.animationAllowed && !!this.rootElement;
      },
      getRerenderEvent: () => {
        return this.onElementRerendered;
      }
    };
  }
  triggerResponsiveness(hard) {
    if (hard) {
      this.calculatedGapBetweenItems = void 0;
      this.calculatedItemWidth = void 0;
    }
    super.triggerResponsiveness();
  }
  processResponsiveness(_, availableWidth) {
    this._width = availableWidth;
    if (this.rootElement) {
      if ((!this.calculatedGapBetweenItems || !this.calculatedItemWidth) && this.allowMultiple) {
        const fileListSelector = this.getFileListSelector();
        const fileListElement = fileListSelector ? this.rootElement.querySelector(this.getFileListSelector()) : void 0;
        if (fileListElement) {
          const visiblePage = fileListElement.querySelector(classesToSelector(this.cssClasses.page));
          if (visiblePage) {
            const firstVisibleItem = visiblePage.querySelector(classesToSelector(this.cssClasses.previewItem));
            this.calculatedGapBetweenItems = Math.ceil(Number.parseFloat(DomDocumentHelper.getComputedStyle(visiblePage).gap));
            if (firstVisibleItem) {
              this.calculatedItemWidth = Math.ceil(Number.parseFloat(DomDocumentHelper.getComputedStyle(firstVisibleItem).width));
            }
          }
        }
      }
    }
    if (this.calculatedGapBetweenItems && this.calculatedItemWidth) {
      this.pageSize = this.calcAvailableItemsCount(availableWidth, this.calculatedItemWidth, this.calculatedGapBetweenItems);
      return true;
    }
    return false;
  }
  canDragDrop() {
    return !this.isInputReadOnly && this.currentMode !== "camera" && !this.isPlayingVideo;
  }
  afterRenderQuestionElement(el) {
    this.rootElement = el;
  }
  beforeDestroyQuestionElement(el) {
    this.rootElement = void 0;
  }
  clearFilesCore() {
    if (this.rootElement) {
      const input = this.rootElement.querySelectorAll("input")[0];
      if (input) {
        input.value = "";
      }
    }
    this.clear();
  }
  doRemoveFile(data, event) {
    event.stopPropagation();
    if (this.needConfirmRemoveFile) {
      confirmActionAsync({
        message: this.getConfirmRemoveMessage(data.name),
        funcOnYes: () => {
          this.removeFileCore(data);
        },
        locale: this.getLocale(),
        rootElement: this.survey.rootElement,
        cssClass: this.cssClasses.confirmDialog
      });
      return;
    }
    this.removeFileCore(data);
  }
  removeFileCore(data) {
    const previewIndex = this.previewValue.indexOf(data);
    this.removeFileByContent(previewIndex === -1 ? data : this.value[previewIndex]);
  }
  //#endregion
  dispose() {
    this.cameraValue = void 0;
    this.closeVideoStream();
    super.dispose();
  }
};
__decorate([property()], QuestionFileModel.prototype, "isDragging", void 0);
__decorate([propertyArray({})], QuestionFileModel.prototype, "previewValue", void 0);
__decorate([propertyArray({})], QuestionFileModel.prototype, "pages", void 0);
__decorate([property({
  defaultValue: 0,
  onSet: (val, target) => {
    target.updateRenderedPages();
  }
})], QuestionFileModel.prototype, "indexToShow", void 0);
__decorate([property({
  defaultValue: 1,
  onSet: (_, target) => {
    target.updateFileNavigator();
  }
})], QuestionFileModel.prototype, "pageSize", void 0);
__decorate([property({
  defaultValue: false
})], QuestionFileModel.prototype, "containsMultiplyFiles", void 0);
__decorate([property()], QuestionFileModel.prototype, "allowCameraAccess", void 0);
__decorate([property({
  onSet: (val, obj) => {
    if (!obj.isLoadingFromJson) {
      obj.updateCurrentMode();
    }
  }
})], QuestionFileModel.prototype, "sourceType", void 0);
__decorate([property()], QuestionFileModel.prototype, "canFlipCameraValue", void 0);
__decorate([property({
  localizable: {
    defaultStr: "confirmRemoveFile"
  }
})], QuestionFileModel.prototype, "confirmRemoveMessage", void 0);
__decorate([property({
  localizable: {
    defaultStr: "confirmRemoveAllFiles"
  }
})], QuestionFileModel.prototype, "confirmRemoveAllMessage", void 0);
__decorate([property({
  localizable: {
    defaultStr: "noFileChosen"
  }
})], QuestionFileModel.prototype, "noFileChosenCaption", void 0);
__decorate([property({
  localizable: {
    defaultStr: "chooseFileCaption"
  }
})], QuestionFileModel.prototype, "chooseButtonCaption", void 0);
__decorate([property({
  localizable: {
    defaultStr: "replaceFileCaption"
  }
})], QuestionFileModel.prototype, "replaceButtonCaption", void 0);
__decorate([property({
  localizable: {
    defaultStr: "removeFileCaption"
  }
})], QuestionFileModel.prototype, "removeFileCaption", void 0);
__decorate([property({
  localizable: {
    defaultStr: "loadingFile"
  }
})], QuestionFileModel.prototype, "loadingFileTitle", void 0);
__decorate([property({
  localizable: {
    defaultStr: "chooseFile"
  }
})], QuestionFileModel.prototype, "chooseFileTitle", void 0);
__decorate([property({
  localizable: {
    defaultStr: "fileOrPhotoPlaceholder"
  }
})], QuestionFileModel.prototype, "fileOrPhotoPlaceholder", void 0);
__decorate([property({
  localizable: {
    defaultStr: "photoPlaceholder"
  }
})], QuestionFileModel.prototype, "photoPlaceholder", void 0);
__decorate([property({
  localizable: {
    defaultStr: "filePlaceholder"
  }
})], QuestionFileModel.prototype, "filePlaceholder", void 0);
__decorate([property()], QuestionFileModel.prototype, "locRenderedPlaceholderValue", void 0);
__decorate([propertyArray()], QuestionFileModel.prototype, "_renderedPages", void 0);
Serializer.addClass("file", [{
  name: "showCommentArea:switch",
  layout: "row",
  visible: true,
  category: "general"
}, {
  name: "showPreview:boolean",
  default: true,
  visible: false
}, "allowMultiple:boolean", {
  name: "allowImagesPreview:boolean",
  default: true,
  dependsOn: "showPreview",
  visibleIf: (obj) => {
    return !!obj.showPreview;
  }
}, "imageHeight", "imageWidth", "acceptedTypes", {
  name: "storeDataAsText:boolean",
  default: true
}, {
  name: "waitForUpload:boolean",
  default: false
}, {
  name: "maxSize:number",
  default: 0
}, {
  name: "defaultValue",
  visible: false
}, {
  name: "correctAnswer",
  visible: false
}, {
  name: "validators",
  visible: false
}, {
  name: "needConfirmRemoveFile:boolean"
}, {
  name: "sourceType",
  choices: ["file", "camera", "file-camera"],
  default: "file",
  category: "general",
  visible: true
}, {
  name: "fileOrPhotoPlaceholder:text",
  serializationProperty: "locFileOrPhotoPlaceholder",
  category: "general"
}, {
  name: "photoPlaceholder:text",
  serializationProperty: "locPhotoPlaceholder",
  category: "general"
}, {
  name: "filePlaceholder:text",
  serializationProperty: "locFilePlaceholder",
  category: "general"
}, {
  name: "allowCameraAccess:switch",
  category: "general",
  visible: false
}], function() {
  return new QuestionFileModel("");
}, "question");
QuestionFactory.Instance.registerQuestion("file", (name) => {
  return new QuestionFileModel(name);
});
var FileLoader = class {
  constructor(fileQuestion, callback) {
    this.fileQuestion = fileQuestion;
    this.callback = callback;
    this.loaded = [];
  }
  load(files) {
    let downloadedCount = 0;
    this.loaded = new Array(files.length);
    files.forEach((value, index) => {
      if (this.fileQuestion.survey) {
        this.fileQuestion.survey.downloadFile(this.fileQuestion, this.fileQuestion.name, value, (status, data) => {
          if (!this.fileQuestion || !this.callback) {
            return;
          }
          if (status !== "error") {
            this.loaded[index] = {
              content: data,
              name: value.name,
              type: value.type
            };
            downloadedCount++;
            if (downloadedCount === files.length) {
              this.callback(status, this.loaded);
            }
          } else {
            this.callback("error", this.loaded);
          }
        });
      }
    });
  }
  dispose() {
    this.fileQuestion = void 0;
    this.callback = void 0;
  }
};
var QuestionHtmlModel = class extends QuestionNonValue {
  constructor(name) {
    super(name);
    var locHtml = this.createLocalizableString("html", this);
    locHtml.onGetTextCallback = (str) => {
      return !!this.survey && !this.ignoreHtmlProgressing ? this.processHtml(str) : str;
    };
  }
  getType() {
    return "html";
  }
  get isCompositeQuestion() {
    return true;
  }
  getProcessedText(text) {
    if (this.ignoreHtmlProgressing) return text;
    return super.getProcessedText(text);
  }
  /**
   * HTML markup to display.
   *
   * > IMPORTANT: If you get the markup from a third party, ensure that it does not contain malicious code.
   */
  get html() {
    return this.getLocalizableStringText("html", "");
  }
  set html(val) {
    this.setLocalizableStringText("html", val);
  }
  get locHtml() {
    return this.getLocalizableString("html");
  }
  get processedHtml() {
    return this.processHtml(this.html);
  }
  processHtml(html) {
    return this.survey ? this.survey.processHtml(html, "html-question") : this.html;
  }
  get isNewA11yStructure() {
    return true;
  }
  get renderCssRoot() {
    return new CssClassBuilder().append(this.cssClasses.root).append(this.cssClasses.nested, this.getIsNested()).toString() || void 0;
  }
};
Serializer.addClass("html", [{
  name: "html:html",
  serializationProperty: "locHtml"
}, {
  name: "showNumber",
  visible: false
}, {
  name: "state",
  visible: false
}, {
  name: "titleLocation",
  visible: false
}, {
  name: "descriptionLocation",
  visible: false
}, {
  name: "errorLocation",
  visible: false
}, {
  name: "indent",
  visible: false
}, {
  name: "width",
  visible: false
}], function() {
  return new QuestionHtmlModel("");
}, "nonvalue");
QuestionFactory.Instance.registerQuestion("html", (name) => {
  return new QuestionHtmlModel(name);
});
var QuestionRadiogroupModel = class extends QuestionCheckboxBase {
  constructor(name) {
    super(name);
  }
  getDefaultItemComponent() {
    return "survey-radiogroup-item";
  }
  getType() {
    return "radiogroup";
  }
  getFirstInputElementId() {
    return this.inputId + "_0";
  }
  /**
   * Returns the selected choice item. If no item is selected, returns `null`.
   */
  get selectedItem() {
    return this.getSingleSelectedItem();
  }
  /**
   * Specifies whether to display a button that clears the question value.
   *
   * Default value: `false`
   */
  get allowClear() {
    return this.getPropertyValue("allowClear");
  }
  set allowClear(val) {
    this.setPropertyValue("allowClear", val);
  }
  /**
   * @deprecated Use the [`allowClear`](https://surveyjs.io/form-library/documentation/api-reference/radio-button-question-model#allowClear) property instead.
   */
  get showClearButton() {
    return this.allowClear;
  }
  set showClearButton(val) {
    this.allowClear = val;
  }
  get canShowClearButton() {
    return this.allowClear && !this.isReadOnly;
  }
  get clearButtonCaption() {
    return this.getLocalizationString("clearCaption");
  }
  supportAutoAdvance() {
    return this.isMouseDown === true && !this.isOtherSelected;
  }
  getConditionJson(operator = null, path = null) {
    const json2 = super.getConditionJson(operator, path);
    delete json2["allowClear"];
    delete json2["showClearButton"];
    return json2;
  }
  setNewComment(newValue) {
    this.isMouseDown = true;
    super.setNewComment(newValue);
    this.isMouseDown = false;
  }
  get showClearButtonInContent() {
    return !this.isDefaultV2Theme && this.canShowClearButton;
  }
  clickItemHandler(item) {
    if (this.isReadOnlyAttr) return;
    this.renderedValue = item.value;
  }
  getDefaultTitleActions() {
    const actions = [];
    if (this.isDefaultV2Theme && !this.isDesignMode) {
      const clearAction = new Action({
        locTitleName: "clearCaption",
        id: `sv-clr-btn-${this.id}`,
        action: () => {
          this.clearValue(true);
        },
        innerCss: this.cssClasses.clearButton,
        visible: new ComputedUpdater(() => this.canShowClearButton)
      });
      actions.push(clearAction);
    }
    return actions;
  }
  //a11y
  get isNewA11yStructure() {
    return true;
  }
  get a11y_input_ariaRole() {
    return "radiogroup";
  }
};
Serializer.addClass("radiogroup", [{
  name: "allowClear:boolean",
  alternativeName: "showClearButton"
}, {
  name: "separateSpecialChoices",
  visible: true
}, {
  name: "itemComponent",
  visible: false,
  default: "survey-radiogroup-item"
}], function() {
  return new QuestionRadiogroupModel("");
}, "checkboxbase");
QuestionFactory.Instance.registerQuestion("radiogroup", (name) => {
  var q = new QuestionRadiogroupModel(name);
  q.choices = QuestionFactory.DefaultChoices;
  return q;
});
var RenderedRatingItem = class extends Base {
  onStringChangedCallback() {
    this.text = this.itemValue.text;
  }
  get value() {
    return this.itemValue.getPropertyValue("value");
  }
  get locText() {
    return this.locString || this.itemValue.locText;
  }
  constructor(itemValue, locString = null) {
    super();
    this.itemValue = itemValue;
    this.locString = locString;
    this.locText.onStringChanged.add(this.onStringChangedCallback.bind(this));
    this.onStringChangedCallback();
  }
};
__decorate([property({
  defaultValue: ""
})], RenderedRatingItem.prototype, "highlight", void 0);
__decorate([property({
  defaultValue: ""
})], RenderedRatingItem.prototype, "text", void 0);
__decorate([property()], RenderedRatingItem.prototype, "style", void 0);
var RatingItemValue = class extends ItemValue {
  constructor(value, text, description) {
    super(value, text);
    this.description = description;
  }
};
var QuestionRatingModel = class _QuestionRatingModel extends Question {
  constructor(name) {
    super(name);
    this._syncPropertiesChanging = false;
    this.iCounter = 0;
    this.createItemValues("rateValues");
    this.createLocalizableString("ratingOptionsCaption", this, false, true);
    this.registerFunctionOnPropertiesValueChanged(["rateMin", "rateMax", "minRateDescription", "maxRateDescription", "rateStep", "displayRateDescriptionsAsExtremeItems"], () => this.resetRenderedItems());
    this.registerFunctionOnPropertiesValueChanged(["rateType"], () => {
      this.setIconsToRateValues();
      this.resetRenderedItems();
      this.updateRateCount();
    });
    this.registerFunctionOnPropertiesValueChanged(["rateValues"], () => {
      this.setIconsToRateValues();
      this.resetRenderedItems();
    });
    this.registerSychProperties(["rateValues"], () => {
      this.autoGenerate = this.rateValues.length == 0;
      this.setIconsToRateValues();
      this.resetRenderedItems();
    });
    this.registerFunctionOnPropertiesValueChanged(["rateColorMode", "scaleColorMode"], () => {
      this.updateColors(this.survey.themeVariables);
    });
    this.registerFunctionOnPropertiesValueChanged(["displayMode"], () => {
      this.updateRenderAsBasedOnDisplayMode(true);
    });
    this.registerSychProperties(["autoGenerate"], () => {
      if (!this.autoGenerate && this.rateValues.length === 0) {
        this.setPropertyValue("rateValues", this.visibleRateValues);
      }
      if (this.autoGenerate) {
        this.rateValues.splice(0, this.rateValues.length);
        this.updateRateMax();
      }
      this.resetRenderedItems();
    });
    this.createLocalizableString("minRateDescription", this, true).onStringChanged.add((sender, options) => {
      this.setPropertyValue("hasMinRateDescription", !sender.isEmpty);
    });
    this.createLocalizableString("maxRateDescription", this, true).onStringChanged.add((sender, options) => {
      this.setPropertyValue("hasMaxRateDescription", !sender.isEmpty);
    });
    this.initPropertyDependencies();
  }
  setIconsToRateValues() {
    if (this.rateType == "smileys") {
      this.rateValues.map((item) => item.icon = this.getItemSmiley(item));
    }
  }
  endLoadingFromJson() {
    super.endLoadingFromJson();
    if (this.jsonObj.rateMin !== void 0 && this.jsonObj.rateCount !== void 0 && this.jsonObj.rateMax === void 0) {
      this.updateRateMax();
    }
    if (this.jsonObj.rateMax !== void 0 && this.jsonObj.rateCount !== void 0 && this.jsonObj.rateMin === void 0) {
      this.updateRateMin();
    }
    if (this.jsonObj.autoGenerate === void 0 && this.jsonObj.rateValues !== void 0) this.autoGenerate = !this.jsonObj.rateValues.length;
    this.updateRateCount();
    this.setIconsToRateValues();
  }
  registerSychProperties(names, func) {
    this.registerFunctionOnPropertiesValueChanged(names, () => {
      if (!this._syncPropertiesChanging) {
        this._syncPropertiesChanging = true;
        func();
        this._syncPropertiesChanging = false;
      }
    });
  }
  useRateValues() {
    return !!this.rateValues.length && !this.autoGenerate;
  }
  updateRateMax() {
    this.rateMax = this.rateMin + this.rateStep * (this.rateCount - 1);
  }
  updateRateMin() {
    this.rateMin = this.rateMax - this.rateStep * (this.rateCount - 1);
  }
  updateRateCount() {
    let newCount = 0;
    if (this.useRateValues()) {
      newCount = this.rateValues.length;
    } else {
      newCount = Math.trunc((this.rateMax - this.rateMin) / (this.rateStep || 1)) + 1;
    }
    if (newCount > 10 && this.rateDisplayMode == "smileys") {
      newCount = 10;
    }
    this.rateCount = newCount;
    if (this.rateValues.length > newCount) this.rateValues.splice(newCount, this.rateValues.length - newCount);
  }
  initPropertyDependencies() {
    this.registerSychProperties(["rateCount"], () => {
      if (!this.useRateValues()) {
        this.rateMax = this.rateMin + this.rateStep * (this.rateCount - 1);
      } else {
        if (this.rateCount < this.rateValues.length) {
          if (this.rateCount >= 10 && this.rateDisplayMode == "smileys") return;
          this.rateValues.splice(this.rateCount, this.rateValues.length - this.rateCount);
        } else {
          for (let i = this.rateValues.length; i < this.rateCount; i++) {
            this.rateValues.push(new ItemValue(getLocaleString("choices_Item") + (i + 1)));
          }
        }
      }
    });
    this.registerSychProperties(["rateMin", "rateMax", "rateStep", "rateValues"], () => {
      this.updateRateCount();
    });
  }
  get showSelectedItemLocText() {
    return !this.readOnly && !this.inputHasValue && !!this.selectedItemLocText;
  }
  get selectedItemLocText() {
    var _a;
    return !this.readOnly && ((_a = this.visibleRateValues.filter((v) => v.value == this.value)[0]) === null || _a === void 0 ? void 0 : _a.locText);
  }
  /**
   * A list of rate values.
   *
   * This property accepts an array of objects with the following structure:
   *
   * ```js
   * {
   *   "value": any, // A value to be saved in survey results
   *   "text": String, // A display text. This property supports Markdown. When `text` is undefined, `value` is used.
   *   "customProperty": any // Any property that you find useful.
   * }
   * ```
   *
   * If you add custom properties, refer to the following help topic to learn how to serialize them into JSON: [Add Custom Properties to Property Grid](https://surveyjs.io/survey-creator/documentation/property-grid#add-custom-properties-to-the-property-grid).
   *
   * To enable Markdown support for the `text` property, implement Markdown-to-HTML conversion in the [onTextMarkdown](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#onTextMarkdown) event handler. For an example, refer to the following demo: [Convert Markdown to HTML with markdown-it](https://surveyjs.io/form-library/examples/edit-survey-questions-markdown/).
   *
   * If you need to specify only the `value` property, you can set the `rateValues` property to an array of numbers, for example, `[ 3, 6, 10 ]`. These values are both saved in survey results and used as display text.
   *
   * If you do not specify the `rateValues` property, rate values are generated automatically based upon the [`rateMin`](https://surveyjs.io/form-library/documentation/api-reference/rating-scale-question-model#rateMin), [`rateMax`](https://surveyjs.io/form-library/documentation/api-reference/rating-scale-question-model#rateMax), [`rateStep`](https://surveyjs.io/form-library/documentation/api-reference/rating-scale-question-model#rateStep), and [`rateCount`](https://surveyjs.io/form-library/documentation/api-reference/rating-scale-question-model#rateCount) property values.
   *
   * [View Demo](https://surveyjs.io/form-library/examples/rating-scale/ (linkStyle))
   */
  get rateValues() {
    return this.getPropertyValue("rateValues");
  }
  set rateValues(val) {
    this.setPropertyValue("rateValues", val);
  }
  /**
   * Specifies the first rate value in the generated sequence of rate values. Applies if the [`rateValues`](https://surveyjs.io/form-library/documentation/api-reference/rating-scale-question-model#rateValues) array is empty.
   *
   * Default value: 1
   *
   * [View Demo](https://surveyjs.io/form-library/examples/rating-scale/ (linkStyle))
   * @see rateMax
   * @see rateStep
   * @see rateCount
   */
  get rateMin() {
    return this.getPropertyValue("rateMin");
  }
  set rateMin(val) {
    this.setPropertyValue("rateMin", val);
  }
  /**
   * Specifies the last rate value in the generated sequence of rate values. Applies if the [`rateValues`](https://surveyjs.io/form-library/documentation/api-reference/rating-scale-question-model#rateValues) array is empty.
   *
   * Default value: 5
   *
   * [View Demo](https://surveyjs.io/form-library/examples/rating-scale/ (linkStyle))
   * @see rateMin
   * @see rateStep
   * @see rateCount
   */
  get rateMax() {
    return this.getPropertyValue("rateMax");
  }
  set rateMax(val) {
    this.setPropertyValue("rateMax", val);
  }
  /**
   * Specifies a step with which to generate rate values. Applies if the [`rateValues`](https://surveyjs.io/form-library/documentation/api-reference/rating-scale-question-model#rateValues) array is empty.
   *
   * Default value: 1
   *
   * [View Demo](https://surveyjs.io/form-library/examples/rating-scale/ (linkStyle))
   * @see rateMin
   * @see rateMax
   * @see rateCount
   */
  get rateStep() {
    return this.getPropertyValue("rateStep");
  }
  set rateStep(val) {
    this.setPropertyValue("rateStep", val);
  }
  updateColors(themeVariables) {
    if (this.colorMode === "monochrome") return;
    if (!DomDocumentHelper.isAvailable()) return;
    if (_QuestionRatingModel.colorsCalculated) return;
    function getColorFromProperty(varName) {
      const style = getComputedStyle(DomDocumentHelper.getDocumentElement());
      return style.getPropertyValue && style.getPropertyValue(varName);
    }
    function getRGBColor(colorName, varName) {
      let str = !!themeVariables && themeVariables[colorName];
      if (!str) str = getColorFromProperty(varName);
      if (!str) return null;
      const canvasElement = DomDocumentHelper.createElement("canvas");
      if (!canvasElement) return null;
      var ctx = canvasElement.getContext("2d");
      ctx.fillStyle = str;
      if (ctx.fillStyle == "#000000") {
        ctx.fillStyle = getColorFromProperty(varName);
      }
      const newStr = ctx.fillStyle;
      if (newStr.startsWith("rgba")) {
        return newStr.substring(5, newStr.length - 1).split(",").map((c) => +c.trim());
      }
      var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(newStr);
      return result ? [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16), 1] : null;
    }
    _QuestionRatingModel.badColor = getRGBColor("--sjs-special-red", "--sd-rating-bad-color");
    _QuestionRatingModel.normalColor = getRGBColor("--sjs-special-yellow", "--sd-rating-normal-color");
    _QuestionRatingModel.goodColor = getRGBColor("--sjs-special-green", "--sd-rating-good-color");
    _QuestionRatingModel.badColorLight = getRGBColor("--sjs-special-red-light", "--sd-rating-bad-color-light");
    _QuestionRatingModel.normalColorLight = getRGBColor("--sjs-special-yellow-light", "--sd-rating-normal-color-light");
    _QuestionRatingModel.goodColorLight = getRGBColor("--sjs-special-green-light", "--sd-rating-good-color-light");
    this.colorsCalculated = true;
    this.resetRenderedItems();
  }
  getDisplayValueCore(keysAsText, value) {
    if (!this.useRateValues) return super.getDisplayValueCore(keysAsText, value);
    var res = ItemValue.getTextOrHtmlByValue(this.visibleRateValues, value);
    return !!res ? res : value;
  }
  get visibleRateValues() {
    return this.renderedRateItems.map((i) => i.itemValue);
  }
  supportEmptyValidation() {
    return this.renderAs === "dropdown";
  }
  itemValuePropertyChanged(item, name, oldValue, newValue) {
    if (!this.useRateValues() && newValue !== void 0) this.autoGenerate = false;
    super.itemValuePropertyChanged(item, name, oldValue, newValue);
  }
  runConditionCore(values, properties) {
    super.runConditionCore(values, properties);
    this.runRateItesmCondition(values, properties);
  }
  runRateItesmCondition(values, properties) {
    var _a;
    if (!this.useRateValues()) return;
    let isChanged = false;
    if ((_a = this.survey) === null || _a === void 0 ? void 0 : _a.areInvisibleElementsShowing) {
      this.rateValues.forEach((item) => {
        isChanged = isChanged || !item.isVisible;
        item.setIsVisible(item, true);
      });
    } else {
      isChanged = ItemValue.runConditionsForItems(this.rateValues, void 0, void 0, values, properties, true);
    }
    if (isChanged) {
      this.resetRenderedItems();
      if (!this.isEmpty() && !this.isReadOnly) {
        const item = ItemValue.getItemByValue(this.rateValues, this.value);
        if (item && !item.isVisible) {
          this.clearValue();
        }
      }
    }
  }
  getRateValuesCore() {
    if (!this.useRateValues()) return this.createRateValues();
    const items = new Array();
    this.rateValues.forEach((item) => {
      if (item.isVisible) {
        items.push(item);
      }
    });
    return items;
  }
  calculateRateValues() {
    let rateValues = this.getRateValuesCore();
    if (this.rateType == "smileys" && rateValues.length > 10) rateValues = rateValues.slice(0, 10);
    return rateValues;
  }
  calculateRenderedRateItems() {
    const rateValues = this.calculateRateValues();
    return rateValues.map((v, i) => {
      let renderedItem = null;
      if (this.displayRateDescriptionsAsExtremeItems) {
        if (i == 0) renderedItem = new RenderedRatingItem(v, this.minRateDescription && this.locMinRateDescription || v.locText);
        if (i == rateValues.length - 1) renderedItem = new RenderedRatingItem(v, this.maxRateDescription && this.locMaxRateDescription || v.locText);
      }
      if (!renderedItem) renderedItem = new RenderedRatingItem(v);
      return renderedItem;
    });
  }
  calculateVisibleChoices() {
    const rateValues = this.calculateRateValues();
    return rateValues.map((i, idx) => this.getRatingItemValue(i, idx));
  }
  resetRenderedItems() {
    if (this.autoGenerate) {
      const rateValues = this.getRateValuesCore();
      this.rateMax = rateValues[rateValues.length - 1].value;
    }
    if (Array.isArray(this.getPropertyValueWithoutDefault("renderedRateItems"))) {
      this.setArrayPropertyDirectly("renderedRateItems", this.calculateRenderedRateItems());
    }
    if (Array.isArray(this.getPropertyValueWithoutDefault("visibleChoices"))) {
      this.setArrayPropertyDirectly("visibleChoices", this.calculateVisibleChoices);
    }
  }
  get renderedRateItems() {
    return this.getPropertyValue("renderedRateItems", void 0, () => this.calculateRenderedRateItems());
  }
  get visibleChoices() {
    return this.getPropertyValue("visibleChoices", void 0, () => this.calculateVisibleChoices());
  }
  createRateValues() {
    var res = [];
    var value = this.rateMin;
    var step = this.rateStep;
    while (value <= this.rateMax && res.length < settings.ratingMaximumRateValueCount) {
      let item = new ItemValue(value);
      item.locOwner = this;
      item.ownerPropertyName = "rateValues";
      res.push(item);
      value = this.correctValue(value + step, step);
    }
    return res;
  }
  getRatingItemValue(item, index) {
    if (!item) return null;
    const value = item.value;
    let description;
    if (value === this.rateMin) {
      description = this.minRateDescription && this.locMinRateDescription;
    }
    if (value === this.rateMax || index === settings.ratingMaximumRateValueCount) {
      description = this.maxRateDescription && this.locMaxRateDescription;
    }
    let newItem = new RatingItemValue(value, item.text, description);
    newItem.locOwner = item.locOwner;
    newItem.ownerPropertyName = item.ownerPropertyName;
    return newItem;
  }
  correctValue(value, step) {
    if (!value) return value;
    if (Math.round(value) == value) return value;
    var fr = 0;
    while (Math.round(step) != step) {
      step *= 10;
      fr++;
    }
    return parseFloat(value.toFixed(fr));
  }
  getType() {
    return "rating";
  }
  getFirstInputElementId() {
    return this.inputId + "_0";
  }
  getInputId(index) {
    return this.inputId + "_" + index;
  }
  get questionName() {
    return this.name + "_" + this.id;
  }
  supportAutoAdvance() {
    return this.isMouseDown === true || this.renderAs === "dropdown";
  }
  supportOther() {
    return false;
  }
  getPlainDataCalculatedValue(propName) {
    const res = super.getPlainDataCalculatedValue(propName);
    if (res !== void 0 || !this.useRateValues || this.isEmpty()) return res;
    const item = ItemValue.getItemByValue(this.visibleRateValues, this.value);
    return item ? item[propName] : void 0;
  }
  /**
   * Specifies a description for the minimum (first) rate value.
   * @see rateDescriptionLocation
   * @see displayRateDescriptionsAsExtremeItems
   * @see rateValues
   * @see rateMin
   */
  get minRateDescription() {
    return this.getLocalizableStringText("minRateDescription");
  }
  set minRateDescription(val) {
    this.setLocalizableStringText("minRateDescription", val);
  }
  get locMinRateDescription() {
    return this.getLocalizableString("minRateDescription");
  }
  /**
   * Specifies a description for the maximum (last) rate value.
   * @see rateDescriptionLocation
   * @see displayRateDescriptionsAsExtremeItems
   * @see rateValues
   * @see rateMax
   */
  get maxRateDescription() {
    return this.getLocalizableStringText("maxRateDescription");
  }
  set maxRateDescription(val) {
    this.setLocalizableStringText("maxRateDescription", val);
  }
  get locMaxRateDescription() {
    return this.getLocalizableString("maxRateDescription");
  }
  get hasMinRateDescription() {
    return this.getPropertyValue("hasMinRateDescription", void 0, () => !!this.minRateDescription);
  }
  get hasMaxRateDescription() {
    return this.getPropertyValue("hasMaxRateDescription", void 0, () => !!this.maxRateDescription);
  }
  get hasMinLabel() {
    return !this.displayRateDescriptionsAsExtremeItems && !!this.hasMinRateDescription;
  }
  get hasMaxLabel() {
    return !this.displayRateDescriptionsAsExtremeItems && !!this.hasMaxRateDescription;
  }
  updateRenderAsBasedOnDisplayMode(isOnChange) {
    if (this.isDesignMode) {
      if (isOnChange || this.renderAs === "dropdown") {
        this.renderAs = "default";
      }
    } else {
      if (isOnChange || this.displayMode !== "auto") {
        this.renderAs = this.displayMode === "dropdown" ? "dropdown" : "default";
      }
    }
  }
  onSurveyLoad() {
    super.onSurveyLoad();
    if (this.renderAs === "dropdown" && this.displayMode === "auto") {
      this.displayMode = this.renderAs;
    } else {
      this.updateRenderAsBasedOnDisplayMode();
    }
  }
  get rateDisplayMode() {
    return this.rateType;
  }
  set rateDisplayMode(val) {
    this.rateType = val;
  }
  get isStar() {
    return this.rateType == "stars";
  }
  get isSmiley() {
    return this.rateType == "smileys";
  }
  getDefaultItemComponent() {
    if (this.renderAs == "dropdown") return "sv-rating-dropdown-item";
    if (this.isStar) return "sv-rating-item-star";
    if (this.isSmiley) return "sv-rating-item-smiley";
    return "sv-rating-item";
  }
  /**
   * The name of a component used to render items.
   */
  get itemComponent() {
    return this.getPropertyValue("itemComponent", this.getDefaultItemComponent());
  }
  set itemComponent(value) {
    this.setPropertyValue("itemComponent", value);
  }
  valueToData(val) {
    if (this.useRateValues()) {
      var item = ItemValue.getItemByValue(this.rateValues, val);
      return !!item ? item.value : val;
    }
    return !isNaN(val) ? parseFloat(val) : val;
  }
  setValueFromClick(value) {
    if (this.isReadOnlyAttr) return;
    if (this.value === (typeof this.value === "string" ? value : parseFloat(value))) {
      this.clearValue(true);
    } else {
      this.value = value;
    }
    for (let i = 0; i < this.renderedRateItems.length; i++) {
      this.renderedRateItems[i].highlight = "none";
    }
  }
  onItemMouseIn(item) {
    if (IsTouch) return;
    if (this.isReadOnly || !item.itemValue.isEnabled || this.isDesignMode) return;
    let high = true;
    let selected = this.value != null;
    if (this.rateType !== "stars") {
      item.highlight = "highlighted";
      return;
    }
    for (let i = 0; i < this.renderedRateItems.length; i++) {
      this.renderedRateItems[i].highlight = high && !selected && "highlighted" || !high && selected && "unhighlighted" || "none";
      if (this.renderedRateItems[i] == item) high = false;
      if (this.renderedRateItems[i].itemValue.value == this.value) selected = false;
    }
  }
  onItemMouseOut(item) {
    if (IsTouch) return;
    this.renderedRateItems.forEach((item2) => item2.highlight = "none");
  }
  get itemSmallMode() {
    return this.inMatrixMode && settings.matrix.rateSize == "small";
  }
  get ratingRootCss() {
    const hasLabel = this.hasMaxLabel || this.hasMinLabel;
    return new CssClassBuilder().append(this.cssClasses.root).append(this.cssClasses.rootWrappable, this.displayMode == "buttons" || !!this.survey && this.survey.isDesignMode || this.displayMode == "auto" && !this.supportResponsiveness()).append(this.cssClasses.rootLabelsTop, hasLabel && this.rateDescriptionLocation == "top").append(this.cssClasses.rootLabelsBottom, hasLabel && this.rateDescriptionLocation == "bottom").append(this.cssClasses.rootLabelsDiagonal, hasLabel && this.rateDescriptionLocation == "topBottom").append(this.cssClasses.itemSmall, this.itemSmallMode && this.rateType != "labels").toString();
  }
  get itemStarIcon() {
    return this.itemSmallMode ? "icon-rating-star-small" : "icon-rating-star";
  }
  get itemStarIconAlt() {
    return this.itemStarIcon + "-2";
  }
  getItemSmiley(item) {
    const icons = ["terrible", "very-poor", "poor", "not-good", "average", "normal", "good", "very-good", "excellent", "perfect"];
    const priority = ["very-good", "not-good", "normal", "good", "average", "excellent", "poor", "perfect", "very-poor", "terrible"];
    const count2 = this.useRateValues() ? this.rateValues.length : this.rateMax - this.rateMin + 1;
    const selectedPriority = priority.slice(0, count2);
    const selectedIcons = icons.filter((i) => selectedPriority.indexOf(i) != -1);
    if (!this.useRateValues()) {
      return selectedIcons[item.value - this.rateMin];
    } else {
      return selectedIcons[this.rateValues.indexOf(item)];
    }
  }
  getItemSmileyIconName(item) {
    return "icon-" + this.getItemSmiley(item);
  }
  getItemClassByText(item, text) {
    return this.getItemClass(item);
  }
  getRenderedItemColor(index, light) {
    let startColor = light ? _QuestionRatingModel.badColorLight : _QuestionRatingModel.badColor;
    let endColor = light ? _QuestionRatingModel.goodColorLight : _QuestionRatingModel.goodColor;
    const normalIndex = (this.rateCount - 1) / 2;
    const middleColor = light ? _QuestionRatingModel.normalColorLight : _QuestionRatingModel.normalColor;
    if (index < normalIndex) {
      endColor = middleColor;
    } else {
      startColor = middleColor;
      index -= normalIndex;
    }
    if (!startColor || !endColor) return null;
    const curColor = [0, 0, 0, 0];
    for (let i = 0; i < 4; i++) {
      curColor[i] = startColor[i] + (endColor[i] - startColor[i]) * index / normalIndex;
      if (i < 3) curColor[i] = Math.trunc(curColor[i]);
    }
    return "rgba(" + curColor[0] + ", " + curColor[1] + ", " + curColor[2] + ", " + curColor[3] + ")";
  }
  getItemStyle(item, highlight = "none") {
    if (this.scaleColorMode === "monochrome" && this.rateColorMode == "default" || this.isPreviewStyle || this.isReadOnlyStyle) return {};
    const index = this.visibleRateValues.indexOf(item);
    const color = this.getRenderedItemColor(index, false);
    const colorLight = highlight == "highlighted" && this.scaleColorMode === "colored" && this.getRenderedItemColor(index, true);
    return colorLight ? {
      "--sd-rating-item-color": color,
      "--sd-rating-item-color-light": colorLight
    } : {
      "--sd-rating-item-color": color
    };
  }
  getItemClass(item, highlight = "none") {
    let isSelected = this.value == item.value;
    if (this.isStar) {
      if (!this.useRateValues()) {
        isSelected = this.value >= item.value;
      } else {
        isSelected = this.rateValues.indexOf(this.rateValues.filter((i) => i.value == this.value)[0]) >= this.rateValues.indexOf(item);
      }
    }
    const isDisabled = this.isReadOnly || !item.isEnabled;
    const allowHover = !isDisabled && this.value != item.value && !(!!this.survey && this.survey.isDesignMode);
    const renderedItem = this.renderedRateItems.filter((i) => i.itemValue == item)[0];
    const isHighlighted = this.isStar && (renderedItem === null || renderedItem === void 0 ? void 0 : renderedItem.highlight) == "highlighted";
    const isUnhighlighted = this.isStar && (renderedItem === null || renderedItem === void 0 ? void 0 : renderedItem.highlight) == "unhighlighted";
    let itemClass = this.cssClasses.item;
    let itemSelectedClass = this.cssClasses.selected;
    let itemDisabledClass = this.cssClasses.itemDisabled;
    let itemReadOnlyClass = this.cssClasses.itemReadOnly;
    let itemPreviewClass = this.cssClasses.itemPreview;
    let itemHoverClass = this.cssClasses.itemHover;
    let itemitemOnErrorClass = this.cssClasses.itemOnError;
    let itemHighlightedClass = null;
    let itemUnhighlightedClass = null;
    let itemScaleColoredClass = null;
    let itemRateColoredClass = null;
    let itemSmallClass = null;
    if (this.isStar) {
      itemClass = this.cssClasses.itemStar;
      itemSelectedClass = this.cssClasses.itemStarSelected;
      itemDisabledClass = this.cssClasses.itemStarDisabled;
      itemReadOnlyClass = this.cssClasses.itemStarReadOnly;
      itemPreviewClass = this.cssClasses.itemStarPreview;
      itemHoverClass = this.cssClasses.itemStarHover;
      itemitemOnErrorClass = this.cssClasses.itemStarOnError;
      itemHighlightedClass = this.cssClasses.itemStarHighlighted;
      itemUnhighlightedClass = this.cssClasses.itemStarUnhighlighted;
      itemSmallClass = this.cssClasses.itemStarSmall;
    }
    if (this.isSmiley) {
      itemClass = this.cssClasses.itemSmiley;
      itemSelectedClass = this.cssClasses.itemSmileySelected;
      itemDisabledClass = this.cssClasses.itemSmileyDisabled;
      itemReadOnlyClass = this.cssClasses.itemSmileyReadOnly;
      itemPreviewClass = this.cssClasses.itemSmileyPreview;
      itemHoverClass = this.cssClasses.itemSmileyHover;
      itemitemOnErrorClass = this.cssClasses.itemSmileyOnError;
      itemHighlightedClass = this.cssClasses.itemSmileyHighlighted;
      itemScaleColoredClass = this.cssClasses.itemSmileyScaleColored;
      itemRateColoredClass = this.cssClasses.itemSmileyRateColored;
      itemSmallClass = this.cssClasses.itemSmileySmall;
    }
    const hasFixedSize = !this.isStar && !this.isSmiley && (!this.displayRateDescriptionsAsExtremeItems || this.useRateValues() && item != this.rateValues[0] && item != this.rateValues[this.rateValues.length - 1] || !this.useRateValues() && item.value != this.rateMin && item.value != this.rateMax) && item.locText.calculatedText.length <= 2 && Number.isInteger(Number(item.locText.calculatedText));
    return new CssClassBuilder().append(itemClass).append(itemSelectedClass, isSelected).append(itemDisabledClass, this.isDisabledStyle).append(itemReadOnlyClass, this.isReadOnlyStyle).append(itemPreviewClass, this.isPreviewStyle).append(itemHoverClass, allowHover).append(itemHighlightedClass, isHighlighted).append(itemScaleColoredClass, this.scaleColorMode == "colored").append(itemRateColoredClass, this.rateColorMode == "scale" && isSelected).append(itemUnhighlightedClass, isUnhighlighted).append(itemitemOnErrorClass, this.hasCssError()).append(itemSmallClass, this.itemSmallMode).append(this.cssClasses.itemFixedSize, hasFixedSize).toString();
  }
  //methods for mobile view
  getControlClass() {
    this.isEmpty();
    return new CssClassBuilder().append(this.cssClasses.control).append(this.cssClasses.controlEmpty, this.isEmpty()).append(this.cssClasses.onError, this.hasCssError()).append(this.cssClasses.controlDisabled, this.isDisabledStyle).append(this.cssClasses.controlReadOnly, this.isReadOnlyStyle).append(this.cssClasses.controlPreview, this.isPreviewStyle).toString();
  }
  get placeholder() {
    return this.getLocalizableStringText("ratingOptionsCaption");
  }
  set placeholder(val) {
    this.setLocalizableStringText("ratingOptionsCaption", val);
  }
  get locPlaceholder() {
    return this.getLocalizableString("ratingOptionsCaption");
  }
  get allowClear() {
    return true;
  }
  get searchEnabled() {
    return false;
  }
  get renderedValue() {
    return this.value;
  }
  set renderedValue(val) {
    this.value = val;
  }
  isItemSelected(item) {
    return item.value == this.value;
  }
  get readOnlyText() {
    if (this.readOnly) return this.displayValue || this.placeholder;
    return this.isEmpty() ? this.placeholder : "";
  }
  needResponsiveWidth() {
    this.getPropertyValue("rateValues");
    const rateStep = this.getPropertyValue("rateStep");
    const rateMax = this.getPropertyValue("rateMax");
    const rateMin = this.getPropertyValue("rateMin");
    return this.displayMode != "dropdown" && !!(this.hasMinRateDescription || this.hasMaxRateDescription || rateStep && (rateMax - rateMin) / rateStep > 9);
  }
  // TODO: return responsiveness after design improvement
  supportResponsiveness() {
    return !this.inMatrixMode;
  }
  onBeforeSetCompactRenderer() {
    if (!this.dropdownListModelValue) {
      this.dropdownListModelValue = new DropdownListModel(this);
      this.ariaExpanded = "false";
    }
  }
  getCompactRenderAs() {
    return this.displayMode == "buttons" ? "default" : "dropdown";
  }
  getDesktopRenderAs() {
    return this.displayMode == "dropdown" ? "dropdown" : "default";
  }
  set dropdownListModel(val) {
    this.dropdownListModelValue = val;
    this.ariaExpanded = !!val ? "false" : void 0;
    this.updateElementCss();
  }
  get dropdownListModel() {
    if (this.renderAs === "dropdown") {
      this.onBeforeSetCompactRenderer();
    }
    return this.dropdownListModelValue;
  }
  onBlurCore(event) {
    var _a;
    (_a = this.dropdownListModel) === null || _a === void 0 ? void 0 : _a.onBlur(event);
    super.onBlurCore(event);
  }
  updateCssClasses(res, css) {
    super.updateCssClasses(res, css);
    updateListCssValues(res, css);
  }
  calcCssClasses(css) {
    const classes = super.calcCssClasses(css);
    if (this.dropdownListModelValue) {
      this.dropdownListModelValue.updateCssClasses(classes.popup, classes.list);
    }
    return classes;
  }
  themeChanged(theme) {
    this.colorsCalculated = false;
    this.updateColors(theme.cssVariables);
  }
  setSurveyImpl(value, isLight) {
    super.setSurveyImpl(value, isLight);
    if (!this.survey) return;
    this.updateColors(this.survey.themeVariables);
    this.updateRenderAsBasedOnDisplayMode();
  }
  dispose() {
    super.dispose();
    if (!!this.dropdownListModelValue) {
      this.dropdownListModelValue.dispose();
      this.dropdownListModelValue = void 0;
    }
  }
};
QuestionRatingModel.colorsCalculated = false;
__decorate([property({
  defaultValue: false
})], QuestionRatingModel.prototype, "inputHasValue", void 0);
__decorate([property()], QuestionRatingModel.prototype, "autoGenerate", void 0);
__decorate([property()], QuestionRatingModel.prototype, "rateCount", void 0);
__decorate([property()], QuestionRatingModel.prototype, "displayRateDescriptionsAsExtremeItems", void 0);
__decorate([property()], QuestionRatingModel.prototype, "displayMode", void 0);
__decorate([property()], QuestionRatingModel.prototype, "rateDescriptionLocation", void 0);
__decorate([property()], QuestionRatingModel.prototype, "rateType", void 0);
__decorate([property()], QuestionRatingModel.prototype, "scaleColorMode", void 0);
__decorate([property()], QuestionRatingModel.prototype, "rateColorMode", void 0);
Serializer.addClass("rating", [{
  name: "showCommentArea:switch",
  layout: "row",
  visible: true,
  category: "general"
}, {
  name: "rateType",
  alternativeName: "rateDisplayMode",
  default: "labels",
  category: "rateValues",
  choices: ["labels", "stars", "smileys"],
  visibleIndex: 1
}, {
  name: "scaleColorMode",
  category: "rateValues",
  default: "monochrome",
  choices: ["monochrome", "colored"],
  visibleIf: function(obj) {
    return obj.rateDisplayMode == "smileys";
  },
  visibleIndex: 2
}, {
  name: "rateColorMode",
  category: "rateValues",
  default: "scale",
  choices: ["default", "scale"],
  visibleIf: function(obj) {
    return obj.rateDisplayMode == "smileys" && obj.scaleColorMode == "monochrome";
  },
  visibleIndex: 3
}, {
  name: "autoGenerate",
  category: "rateValues",
  default: true,
  choices: [true, false],
  visibleIndex: 5
}, {
  name: "rateCount:number",
  default: 5,
  category: "rateValues",
  visibleIndex: 4,
  onSettingValue: (obj, val) => {
    if (val < 2) return 2;
    if (val > settings.ratingMaximumRateValueCount && val > obj.rateValues.length) return settings.ratingMaximumRateValueCount;
    if (val > 10 && obj.rateDisplayMode == "smileys") return 10;
    return val;
  }
}, {
  name: "rateValues:itemvalue[]",
  baseValue: function() {
    return getLocaleString("choices_Item");
  },
  category: "rateValues",
  visibleIf: function(obj) {
    return !obj.autoGenerate;
  },
  visibleIndex: 6
}, {
  name: "rateMin:number",
  default: 1,
  onSettingValue: (obj, val) => {
    return val > obj.rateMax - obj.rateStep ? obj.rateMax - obj.rateStep : val;
  },
  visibleIf: function(obj) {
    return !!obj.autoGenerate;
  },
  visibleIndex: 7
}, {
  name: "rateMax:number",
  default: 5,
  onSettingValue: (obj, val) => {
    return val < obj.rateMin + obj.rateStep ? obj.rateMin + obj.rateStep : val;
  },
  visibleIf: function(obj) {
    return !!obj.autoGenerate;
  },
  visibleIndex: 8
}, {
  name: "rateStep:number",
  default: 1,
  minValue: 0.1,
  onSettingValue: (obj, val) => {
    if (val <= 0) val = 1;
    if (val > obj.rateMax - obj.rateMin) val = obj.rateMax - obj.rateMin;
    return val;
  },
  visibleIf: function(obj) {
    return !!obj.autoGenerate;
  },
  visibleIndex: 9
}, {
  name: "minRateDescription",
  alternativeName: "mininumRateDescription",
  serializationProperty: "locMinRateDescription",
  visibleIndex: 18
}, {
  name: "maxRateDescription",
  alternativeName: "maximumRateDescription",
  serializationProperty: "locMaxRateDescription",
  visibleIndex: 19
}, {
  name: "displayRateDescriptionsAsExtremeItems:boolean",
  default: false,
  visibleIndex: 21,
  visibleIf: function(obj) {
    return obj.rateType == "labels";
  }
}, {
  name: "rateDescriptionLocation",
  default: "leftRight",
  choices: ["leftRight", "top", "bottom", "topBottom"],
  visibleIndex: 20
}, {
  name: "displayMode",
  default: "auto",
  choices: ["auto", "buttons", "dropdown"],
  visibleIndex: 0
}, {
  name: "itemComponent",
  visible: false,
  defaultFunc: (obj) => {
    if (!obj) return "sv-rating-item";
    if (!!obj.getOriginalObj) obj = obj.getOriginalObj();
    return obj.getDefaultItemComponent();
  }
}], function() {
  return new QuestionRatingModel("");
}, "question");
QuestionFactory.Instance.registerQuestion("rating", (name) => {
  return new QuestionRatingModel(name);
});
var QuestionBooleanModel = class extends Question {
  constructor(name) {
    super(name);
    this.createLocalizableString("labelFalse", this, true, "booleanUncheckedLabel");
    this.createLocalizableString("labelTrue", this, true, "booleanCheckedLabel");
  }
  getType() {
    return "boolean";
  }
  isLayoutTypeSupported(layoutType) {
    return true;
  }
  supportAutoAdvance() {
    return this.renderAs !== "checkbox";
  }
  get isIndeterminate() {
    return this.isEmpty();
  }
  get hasTitle() {
    return true;
  }
  /**
   * Gets or sets the question value as a Boolean value.
   *
   * If you set the `valueTrue` and `valueFalse` properties, the `value` property contains their values instead of Boolean values. This may be inconvenient when you operate the question value in code. To access the standard Boolean values, use the `booleanValue` property.
   * @see valueTrue
   * @see valueFalse
   */
  get booleanValue() {
    if (this.isEmpty()) return null;
    return this.value == this.getValueTrue();
  }
  set booleanValue(val) {
    if (this.isReadOnly || this.isDesignMode) {
      return;
    }
    this.setBooleanValue(val);
  }
  get checkedValue() {
    return this.booleanValue;
  }
  set checkedValue(val) {
    this.booleanValue = val;
  }
  setBooleanValue(val) {
    if (this.isValueEmpty(val)) {
      this.value = void 0;
      this.booleanValueRendered = void 0;
    } else {
      this.value = val == true ? this.getValueTrue() : this.getValueFalse();
      this.booleanValueRendered = val;
    }
  }
  get defaultValue() {
    return this.getPropertyValue("defaultValue");
  }
  set defaultValue(val) {
    if (val === true) val = "true";
    if (val === false) val = "false";
    this.setPropertyValue("defaultValue", val);
    this.updateValueWithDefaults();
  }
  getDefaultValue() {
    const val = this.defaultValue;
    if (val === "indeterminate" || val === void 0 || val === null) return void 0;
    return val == "true" ? this.getValueTrue() : this.getValueFalse();
  }
  get locTitle() {
    const original = this.getLocalizableString("title");
    if ((this.isLabelRendered && !this.showTitle || this.isValueEmpty(original.text)) && !this.isValueEmpty(this.locLabel.text)) return this.locLabel;
    return original;
  }
  get labelRenderedAriaID() {
    return this.isLabelRendered ? this.ariaTitleId : null;
  }
  beforeDestroyQuestionElement(el) {
    super.beforeDestroyQuestionElement(el);
    this.leftAnswerElement = void 0;
  }
  get isLabelRendered() {
    return this.titleLocation === "hidden" && this.useTitleAsLabel;
  }
  get canRenderLabelDescription() {
    return this.isLabelRendered && this.hasDescription && (this.hasDescriptionUnderTitle || this.hasDescriptionUnderInput);
  }
  /**
   * Gets or sets a text label that corresponds to a positive answer.
   *
   * Default value: "Yes"
   * @see valueTrue
   * @see valueFalse
   */
  get labelTrue() {
    return this.getLocalizableStringText("labelTrue");
  }
  set labelTrue(val) {
    this.setLocalizableStringText("labelTrue", val);
  }
  get locLabelTrue() {
    return this.getLocalizableString("labelTrue");
  }
  get isDeterminated() {
    return this.booleanValue !== null && this.booleanValue !== void 0;
  }
  get locLabelLeft() {
    return this.swapOrder ? this.getLocalizableString("labelTrue") : this.getLocalizableString("labelFalse");
  }
  get locLabelRight() {
    return this.swapOrder ? this.getLocalizableString("labelFalse") : this.getLocalizableString("labelTrue");
  }
  /**
   * Gets or sets a text label that corresponds to a negative answer.
   *
   * Default value: "No"
   * @see valueTrue
   * @see valueFalse
   */
  get labelFalse() {
    return this.getLocalizableStringText("labelFalse");
  }
  set labelFalse(val) {
    this.setLocalizableStringText("labelFalse", val);
  }
  get locLabelFalse() {
    return this.getLocalizableString("labelFalse");
  }
  getValueTrue() {
    return this.valueTrue !== void 0 ? this.valueTrue : true;
  }
  getValueFalse() {
    return this.valueFalse !== void 0 ? this.valueFalse : false;
  }
  setDefaultValue() {
    if (this.isDefaultValueSet("true", this.valueTrue)) this.setBooleanValue(true);
    if (this.isDefaultValueSet("false", this.valueFalse)) this.setBooleanValue(false);
    const val = this.defaultValue;
    if (val === "indeterminate" || val === null || val === void 0) this.setBooleanValue(void 0);
  }
  isDefaultValueSet(defaultValueCheck, valueTrueOrFalse) {
    return this.defaultValue == defaultValueCheck || valueTrueOrFalse !== void 0 && this.defaultValue === valueTrueOrFalse;
  }
  getDisplayValueCore(keysAsText, value) {
    if (value == this.getValueTrue()) return this.locLabelTrue.textOrHtml;
    return this.locLabelFalse.textOrHtml;
  }
  getItemCssValue(css) {
    return new CssClassBuilder().append(css.item).append(css.itemOnError, this.hasCssError()).append(css.itemDisabled, this.isDisabledStyle).append(css.itemReadOnly, this.isReadOnlyStyle).append(css.itemPreview, this.isPreviewStyle).append(css.itemHover, !this.isDesignMode).append(css.itemChecked, !!this.booleanValue).append(css.itemExchanged, !!this.swapOrder).append(css.itemIndeterminate, !this.isDeterminated).toString();
  }
  getItemCss() {
    return this.getItemCssValue(this.cssClasses);
  }
  getCheckboxItemCss() {
    return this.getItemCssValue({
      item: this.cssClasses.checkboxItem,
      itemOnError: this.cssClasses.checkboxItemOnError,
      itemDisabled: this.cssClasses.checkboxItemDisabled,
      itemDisable: this.cssClasses.checkboxItemDisabled,
      itemReadOnly: this.cssClasses.checkboxItemReadOnly,
      itemPreview: this.cssClasses.checkboxItemPreview,
      itemChecked: this.cssClasses.checkboxItemChecked,
      itemIndeterminate: this.cssClasses.checkboxItemIndeterminate
    });
  }
  getLabelCss(checked) {
    return new CssClassBuilder().append(this.cssClasses.label).append(this.cssClasses.disabledLabel, this.booleanValue === !checked || this.isDisabledStyle).append(this.cssClasses.labelReadOnly, this.isReadOnlyStyle).append(this.cssClasses.labelPreview, this.isPreviewStyle).append(this.cssClasses.labelTrue, !this.isIndeterminate && checked === !this.swapOrder).append(this.cssClasses.labelFalse, !this.isIndeterminate && checked === this.swapOrder).toString();
  }
  updateValueFromSurvey(newValue, clearData = false) {
    super.updateValueFromSurvey(newValue, clearData);
  }
  onValueChanged() {
    super.onValueChanged();
  }
  get svgIcon() {
    if (this.booleanValue && this.cssClasses.svgIconCheckedId) return this.cssClasses.svgIconCheckedId;
    if (!this.isDeterminated && this.cssClasses.svgIconIndId) return this.cssClasses.svgIconIndId;
    if (!this.booleanValue && this.cssClasses.svgIconUncheckedId) return this.cssClasses.svgIconUncheckedId;
    return this.cssClasses.svgIconId;
  }
  get itemSvgIcon() {
    if (this.isPreviewStyle && this.cssClasses.itemPreviewSvgIconId) {
      return this.cssClasses.itemPreviewSvgIconId;
    }
    return this.cssClasses.itemSvgIconId;
  }
  get allowClick() {
    return this.isIndeterminate && !this.isInputReadOnly;
  }
  getCheckedLabel() {
    if (this.booleanValue === true) {
      return this.locLabelTrue;
    } else if (this.booleanValue === false) {
      return this.locLabelFalse;
    }
  }
  setQuestionValue(newValue, updateIsAnswered = true) {
    if (newValue === "true" && this.valueTrue !== "true") newValue = true;
    if (newValue === "false" && this.valueFalse !== "false") newValue = false;
    if (newValue === "indeterminate" || newValue === null) newValue = void 0;
    super.setQuestionValue(newValue, updateIsAnswered);
  }
  /* #region web-based methods */
  onLabelClick(event, value) {
    if (this.allowClick) {
      preventDefaults(event);
      this.booleanValue = value;
    }
    return true;
  }
  calculateBooleanValueByEvent(event, isRightClick) {
    let isRtl = false;
    if (DomDocumentHelper.isAvailable()) {
      isRtl = DomDocumentHelper.getComputedStyle(event.target).direction == "rtl";
    }
    this.booleanValue = isRtl ? !isRightClick : isRightClick;
  }
  onSwitchClickModel(event) {
    if (this.allowClick) {
      preventDefaults(event);
      var isRightClick = event.offsetX / event.target.offsetWidth > 0.5;
      this.calculateBooleanValueByEvent(event, isRightClick);
      return;
    }
    return true;
  }
  onKeyDownCore(event) {
    if (event.key === "ArrowLeft" || event.key === "ArrowRight") {
      event.stopPropagation();
      this.calculateBooleanValueByEvent(event, event.key === "ArrowRight");
    }
    return true;
  }
  /* #endregion */
  getRadioItemClass(css, value) {
    let className = void 0;
    if (css.radioItem) {
      className = css.radioItem;
    }
    if (css.radioItemChecked && value === this.booleanValue) {
      className = (className ? className + " " : "") + css.radioItemChecked;
    }
    if (this.isDisabledStyle) {
      className += " " + css.radioItemDisabled;
    }
    if (this.isReadOnlyStyle) {
      className += " " + css.radioItemReadOnly;
    }
    if (this.isPreviewStyle) {
      className += " " + css.radioItemPreview;
    }
    return className;
  }
  supportResponsiveness() {
    return true;
  }
  getCompactRenderAs() {
    return "radio";
  }
  createActionContainer(allowAdaptiveActions) {
    return super.createActionContainer(this.renderAs !== "checkbox");
  }
  //a11y
  get isNewA11yStructure() {
    return true;
  }
  get a11y_input_ariaRole() {
    return "switch";
  }
};
__decorate([property()], QuestionBooleanModel.prototype, "booleanValueRendered", void 0);
__decorate([property()], QuestionBooleanModel.prototype, "showTitle", void 0);
__decorate([property({
  localizable: true
})], QuestionBooleanModel.prototype, "label", void 0);
__decorate([property({
  defaultValue: true
})], QuestionBooleanModel.prototype, "useTitleAsLabel", void 0);
__decorate([property({
  defaultValue: false
})], QuestionBooleanModel.prototype, "swapOrder", void 0);
__decorate([property()], QuestionBooleanModel.prototype, "valueTrue", void 0);
__decorate([property()], QuestionBooleanModel.prototype, "valueFalse", void 0);
Serializer.addClass("boolean", [{
  name: "showCommentArea:switch",
  layout: "row",
  visible: true,
  category: "general"
}, {
  name: "label:text",
  serializationProperty: "locLabel",
  isSerializable: false,
  visible: false
}, {
  name: "labelTrue:text",
  serializationProperty: "locLabelTrue"
}, {
  name: "labelFalse:text",
  serializationProperty: "locLabelFalse"
}, "valueTrue", "valueFalse", {
  name: "swapOrder:boolean",
  category: "general"
}, {
  name: "renderAs",
  default: "default",
  visible: false
}], function() {
  return new QuestionBooleanModel("");
}, "question");
QuestionFactory.Instance.registerQuestion("boolean", (name) => {
  return new QuestionBooleanModel(name);
});
var ImageItemValue = class extends ItemValue {
  constructor(value, text = null, typeName = "imageitemvalue") {
    super(value, text, typeName);
    this.typeName = typeName;
    this.createLocalizableString("imageLink", this, false);
  }
  getType() {
    return !!this.typeName ? this.typeName : "itemvalue";
  }
  /**
   * The image or video link property.
   */
  get imageLink() {
    return this.getLocalizableStringText("imageLink");
  }
  set imageLink(val) {
    this.setLocalizableStringText("imageLink", val);
    this.imageNotLoaded = false;
    this.videoNotLoaded = false;
  }
  get locImageLink() {
    return this.getLocalizableString("imageLink");
  }
  getLocale() {
    return !!this.locOwner ? this.locOwner.getLocale() : "";
  }
  getMarkdownHtml(text, name) {
    return !!this.locOwner ? this.locOwner.getMarkdownHtml(text, name) : void 0;
  }
  getRenderer(name) {
    return !!this.locOwner ? this.locOwner.getRenderer(name) : null;
  }
  getRendererContext(locStr) {
    return !!this.locOwner ? this.locOwner.getRendererContext(locStr) : locStr;
  }
  getProcessedText(text) {
    return !!this.locOwner ? this.locOwner.getProcessedText(text) : text;
  }
  onErrorHandler() {
    this.contentNotLoaded = true;
  }
  set contentNotLoaded(val) {
    if (this.locOwner instanceof QuestionImagePickerModel && this.locOwner.contentMode == "video") {
      this.videoNotLoaded = val;
    } else {
      this.imageNotLoaded = val;
    }
  }
  get contentNotLoaded() {
    return this.locOwner instanceof QuestionImagePickerModel && this.locOwner.contentMode == "video" ? this.videoNotLoaded : this.imageNotLoaded;
  }
};
__decorate([property({
  defaultValue: false
})], ImageItemValue.prototype, "videoNotLoaded", void 0);
__decorate([property({
  defaultValue: false
})], ImageItemValue.prototype, "imageNotLoaded", void 0);
var QuestionImagePickerModel = class extends QuestionCheckboxBase {
  constructor(name) {
    super(name);
    this.isResponsiveValue = false;
    this.onContentLoaded = (item, event) => {
      item.contentNotLoaded = false;
      const content = event.target;
      if (this.contentMode == "video") {
        item["aspectRatio"] = content.videoWidth / content.videoHeight;
      } else {
        item["aspectRatio"] = content.naturalWidth / content.naturalHeight;
      }
      this._width && this.processResponsiveness(0, this._width);
    };
    this.gridColCount = void 0;
    this.colCount = 0;
    this.registerPropertyChangedHandlers(["minImageWidth", "maxImageWidth", "minImageHeight", "maxImageHeight", "visibleChoices", "colCount", "isResponsiveValue"], () => {
      if (!!this._width) {
        this.processResponsiveness(0, this._width);
      }
    });
    this.registerPropertyChangedHandlers(["imageWidth", "imageHeight"], () => {
      this.calcIsResponsive();
    });
    this.calcIsResponsive();
  }
  getType() {
    return "imagepicker";
  }
  supportAutoAdvance() {
    return !this.multiSelect;
  }
  get hasSingleInput() {
    return false;
  }
  getItemValueType() {
    return "imageitemvalue";
  }
  get isCompositeQuestion() {
    return true;
  }
  get itemFlowDirection() {
    return "row";
  }
  supportOther() {
    return false;
  }
  supportNone() {
    return false;
  }
  supportRefuse() {
    return false;
  }
  supportDontKnow() {
    return false;
  }
  isAnswerCorrect() {
    if (!this.multiSelect) return super.isAnswerCorrect();
    return Helpers.isArrayContainsEqual(this.value, this.correctAnswer);
  }
  /**
   * Specifies whether users can select multiple images or videos.
   *
   * Default value: `false`
   */
  get multiSelect() {
    return this.getPropertyValue("multiSelect");
  }
  set multiSelect(newValue) {
    this.setPropertyValue("multiSelect", newValue);
  }
  isItemSelected(item) {
    var val = this.value;
    const imageItemValue = item;
    if (this.isValueEmpty(val)) return false;
    if (!imageItemValue.imageLink || imageItemValue.contentNotLoaded) return false;
    if (!this.multiSelect) return this.isTwoValueEquals(val, item.value);
    if (!Array.isArray(val)) return false;
    for (var i = 0; i < val.length; i++) {
      if (this.isTwoValueEquals(val[i], item.value)) return true;
    }
    return false;
  }
  getItemEnabled(item) {
    const imageItemValue = item;
    if (!imageItemValue.imageLink || imageItemValue.contentNotLoaded) return false;
    return super.getItemEnabled(item);
  }
  clearIncorrectValues() {
    if (this.multiSelect) {
      var val = this.value;
      if (!val) return;
      if (!Array.isArray(val) || val.length == 0) {
        this.clearValue(true);
        return;
      }
      var newValue = [];
      for (var i = 0; i < val.length; i++) {
        if (!this.hasUnknownValue(val[i], true)) {
          newValue.push(val[i]);
        }
      }
      if (newValue.length == val.length) return;
      if (newValue.length == 0) {
        this.clearValue(true);
      } else {
        this.value = newValue;
      }
    } else {
      super.clearIncorrectValues();
    }
  }
  getDisplayValueCore(keysAsText, value) {
    if (!this.multiSelect && !Array.isArray(value)) return super.getDisplayValueCore(keysAsText, value);
    return this.getDisplayArrayValue(keysAsText, value);
  }
  /**
   * Specifies whether to display labels under images or videos. Labels text are taken from the `text` property of each object in the `choices` array.
   * @see choices
   */
  get showLabel() {
    return this.getPropertyValue("showLabel");
  }
  set showLabel(newValue) {
    this.setPropertyValue("showLabel", newValue);
  }
  endLoadingFromJson() {
    super.endLoadingFromJson();
    if (!this.isDesignMode && this.multiSelect) {
      this.createNewArray("renderedValue");
      this.createNewArray("value");
    }
    this.calcIsResponsive();
  }
  getValueCore() {
    var value = super.getValueCore();
    if (value !== void 0) {
      return value;
    }
    if (this.multiSelect) {
      return [];
    }
    return value;
  }
  convertValToArrayForMultSelect(val) {
    if (!this.multiSelect) return val;
    if (this.isValueEmpty(val) || Array.isArray(val)) return val;
    return [val];
  }
  renderedValueFromDataCore(val) {
    return this.convertValToArrayForMultSelect(val);
  }
  rendredValueToDataCore(val) {
    return this.convertValToArrayForMultSelect(val);
  }
  /**
   * Specifies the height of containers for images or videos. Accepts positive numbers and CSS values.
   *
   * Default value: `auto`
   *
   * This property allows you to specify the exact image height. If you do not set it, the height will be calculated automatically based on the [`minImageHeight`](#minImageHeight) and [`maxImageHeight`](#maxImageHeight) values and available screen height.
   *
   * Use the [`imageFit`](#imageFit) property to specify how to fit the images or videos into their containers.
   * @see imageWidth
   */
  get imageHeight() {
    return this.getPropertyValue("imageHeight");
  }
  set imageHeight(val) {
    this.setPropertyValue("imageHeight", val);
  }
  get imageScale() {
    return this.survey ? this.survey["widthScale"] / 100 : 1;
  }
  get renderedImageHeight() {
    const height = this.isResponsive ? Math.floor(this.responsiveImageHeight) : this.imageHeight * this.imageScale;
    return height ? height : 150 * this.imageScale;
  }
  /**
   * Specifies the width of containers for images or videos. Accepts positive numbers and CSS values.
   *
   * Default value: `auto`
   *
   * This property allows you to specify the exact image width. If you do not set it, the width will be calculated automatically based on the [`minImageWidth`](#minImageWidth) and [`maxImageWidth`](#maxImageWidth) values and available screen width.
   *
   * Use the [`imageFit`](#imageFit) property to specify how to fit the images or videos into their containers.
   * @see imageHeight
   */
  get imageWidth() {
    return this.getPropertyValue("imageWidth");
  }
  set imageWidth(val) {
    this.setPropertyValue("imageWidth", val);
  }
  get renderedImageWidth() {
    const width = this.isResponsive ? Math.floor(this.responsiveImageWidth) : this.imageWidth * this.imageScale;
    return width ? width : 200 * this.imageScale;
  }
  /**
   * Specifies how to resize images or videos to fit them into their containers.
   *
   * Refer to the [`object-fit`](https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit) CSS property description for information on accepted values.
   * @see imageHeight
   * @see imageWidth
   */
  get imageFit() {
    return this.getPropertyValue("imageFit");
  }
  set imageFit(val) {
    this.setPropertyValue("imageFit", val);
  }
  /**
   * Specifies the type of content that choice items display.
   *
   * Possible values:
   *
   * - `"image"` (default) - Images in one of the following formats: JPEG, GIF, PNG, APNG, SVG, BMP, ICO.
   * - `"video"` - Videos in one of the following formats: MP4, MOV, WMV, FLV, AVI, MKV.
   */
  get contentMode() {
    return this.getPropertyValue("contentMode");
  }
  set contentMode(val) {
    this.setPropertyValue("contentMode", val);
    if (val === "video") {
      this.showLabel = true;
    }
  }
  convertDefaultValue(val) {
    return val;
  }
  get inputType() {
    return this.multiSelect ? "checkbox" : "radio";
  }
  isBuiltInChoice(item) {
    return false;
  }
  addToVisibleChoices(items, isAddAll) {
    this.addNewItemToVisibleChoices(items, isAddAll);
  }
  getSelectBaseRootCss() {
    const isResponsive = this.isResponsive;
    return new CssClassBuilder().append(super.getSelectBaseRootCss()).append(this.cssClasses.rootResponsive, isResponsive).append(this.cssClasses.rootStatic, !isResponsive).append(this.cssClasses.rootColumn, this.getCurrentColCount() == 1).toString();
  }
  get isResponsive() {
    return this.isResponsiveValue && this.isDefaultV2Theme;
  }
  get exactSizesAreEmpty() {
    return !["imageHeight", "imageWidth"].some((propName) => this[propName] !== void 0 && this[propName] !== null);
  }
  calcIsResponsive() {
    this.isResponsiveValue = this.exactSizesAreEmpty;
  }
  getObservedElementSelector() {
    return classesToSelector(this.cssClasses.root);
  }
  supportResponsiveness() {
    return true;
  }
  needResponsiveness() {
    return this.supportResponsiveness() && this.isDefaultV2Theme;
  }
  needResponsiveWidth() {
    return this.colCount > 2;
  }
  getCurrentColCount() {
    if (this.responsiveColCount === void 0 || this.colCount === 0) {
      return this.colCount;
    }
    return this.responsiveColCount;
  }
  getContainerStyle() {
    if (!this.isResponsive) return {};
    return {
      gridAutoFlow: !this.gridColCount ? "column" : null,
      gridTemplateColumns: this.gridColCount ? `repeat(${this.gridColCount}, 1fr)` : null
    };
  }
  processResponsiveness(_, availableWidth) {
    this._width = availableWidth = Math.floor(availableWidth);
    const calcAvailableColumnsCount = (availableWidth2, minWidth, gap) => {
      let itemsInRow = Math.floor(availableWidth2 / (minWidth + gap));
      if ((itemsInRow + 1) * (minWidth + gap) - gap <= availableWidth2) itemsInRow++;
      return itemsInRow;
    };
    if (this.isResponsive) {
      const itemsCount = this.choices.length + (this.isDesignMode ? 1 : 0);
      const gap = (this.gapBetweenItems || 0) * this.imageScale;
      const minWidth = this.minImageWidth * this.imageScale;
      const maxWidth = this.maxImageWidth * this.imageScale;
      const maxHeight = this.maxImageHeight * this.imageScale;
      const minHeight = this.minImageHeight * this.imageScale;
      let colCount = this.colCount;
      let width;
      const availableColumnsCount = calcAvailableColumnsCount(availableWidth, minWidth, gap);
      if (colCount === 0) {
        if ((gap + minWidth) * itemsCount - gap > availableWidth) {
          width = Math.floor((availableWidth - gap * (availableColumnsCount - 1)) / availableColumnsCount);
        } else {
          width = Math.floor((availableWidth - gap * (itemsCount - 1)) / itemsCount);
        }
        this.gridColCount = Math.max(Math.min(itemsCount, availableColumnsCount), 1);
      } else {
        if (availableColumnsCount < colCount) {
          this.responsiveColCount = Math.max(availableColumnsCount, 1);
          colCount = this.responsiveColCount;
        } else {
          this.responsiveColCount = colCount;
        }
        this.gridColCount = this.responsiveColCount;
        width = Math.floor((availableWidth - gap * (colCount - 1)) / colCount);
      }
      width = Math.max(minWidth, Math.min(width, maxWidth));
      let height = Number.MIN_VALUE;
      this.choices.forEach((item) => {
        const tempHeight = width / item["aspectRatio"];
        height = tempHeight > height ? tempHeight : height;
      });
      if (height > maxHeight) {
        height = maxHeight;
      } else if (height < minHeight) {
        height = minHeight;
      }
      const oldResponsiveImageWidth = this.responsiveImageWidth;
      const oldResponsiveImageHeight = this.responsiveImageHeight;
      this.responsiveImageWidth = width;
      this.responsiveImageHeight = height;
      return oldResponsiveImageWidth !== this.responsiveImageWidth || oldResponsiveImageHeight !== this.responsiveImageHeight;
    }
    return false;
  }
  triggerResponsiveness(hard = true) {
    if (hard && this.reCalcGapBetweenItemsCallback) {
      this.reCalcGapBetweenItemsCallback();
    }
    super.triggerResponsiveness(hard);
  }
  afterRender(el) {
    super.afterRender(el);
    const selector = this.getObservedElementSelector();
    const observedElement = el && selector ? el.querySelector(selector) : void 0;
    if (!!observedElement) {
      this.reCalcGapBetweenItemsCallback = () => {
        this.gapBetweenItems = Math.ceil(Number.parseFloat(DomDocumentHelper.getComputedStyle(observedElement).gap)) || 16;
      };
      this.reCalcGapBetweenItemsCallback();
    }
  }
};
__decorate([property({})], QuestionImagePickerModel.prototype, "responsiveImageHeight", void 0);
__decorate([property({})], QuestionImagePickerModel.prototype, "responsiveImageWidth", void 0);
__decorate([property({})], QuestionImagePickerModel.prototype, "isResponsiveValue", void 0);
__decorate([property({})], QuestionImagePickerModel.prototype, "maxImageWidth", void 0);
__decorate([property({})], QuestionImagePickerModel.prototype, "minImageWidth", void 0);
__decorate([property({})], QuestionImagePickerModel.prototype, "maxImageHeight", void 0);
__decorate([property({})], QuestionImagePickerModel.prototype, "minImageHeight", void 0);
__decorate([property({})], QuestionImagePickerModel.prototype, "responsiveColCount", void 0);
__decorate([property()], QuestionImagePickerModel.prototype, "gridColCount", void 0);
Serializer.addClass("imageitemvalue", [{
  name: "imageLink:file",
  serializationProperty: "locImageLink"
}], (value) => new ImageItemValue(value), "itemvalue");
Serializer.addClass("responsiveImageSize", [], void 0, "number");
Serializer.addClass("imagepicker", [{
  name: "showOtherItem",
  visible: false
}, {
  name: "otherText",
  visible: false
}, {
  name: "showNoneItem",
  visible: false
}, {
  name: "showRefuseItem",
  visible: false
}, {
  name: "showDontKnowItem",
  visible: false
}, {
  name: "noneText",
  visible: false
}, {
  name: "optionsCaption",
  visible: false
}, {
  name: "otherErrorText",
  visible: false
}, {
  name: "storeOthersAsComment",
  visible: false
}, {
  name: "contentMode",
  default: "image",
  choices: ["image", "video"]
}, {
  name: "imageFit",
  default: "contain",
  choices: ["none", "contain", "cover", "fill"]
}, {
  name: "imageHeight:number",
  minValue: 0
}, {
  name: "imageWidth:number",
  minValue: 0
}, {
  name: "minImageWidth:responsiveImageSize",
  default: 200,
  minValue: 0
}, {
  name: "minImageHeight:responsiveImageSize",
  default: 133,
  minValue: 0
}, {
  name: "maxImageWidth:responsiveImageSize",
  default: 3e3,
  minValue: 0
}, {
  name: "maxImageHeight:responsiveImageSize",
  default: 3e3,
  minValue: 0
}], function() {
  return new QuestionImagePickerModel("");
}, "checkboxbase");
Serializer.addProperty("imagepicker", {
  name: "showLabel:boolean",
  default: false
});
Serializer.addProperty("imagepicker", {
  name: "colCount:number",
  default: 0,
  choices: [0, 1, 2, 3, 4, 5]
});
Serializer.addProperty("imagepicker", {
  name: "multiSelect:boolean",
  default: false
});
Serializer.addProperty("imagepicker", {
  name: "choices:imageitemvalue[]"
});
QuestionFactory.Instance.registerQuestion("imagepicker", (name) => {
  var q = new QuestionImagePickerModel(name);
  return q;
});
var videoSuffics = [".mp4", ".mov", ".wmv", ".flv", ".avi", ".mkv"];
var youtubeUrl = "https://www.youtube.com/";
var youtubeEmbed = "embed";
var QuestionImageModel = class extends QuestionNonValue {
  constructor(name) {
    super(name);
    const locImageLink = this.createLocalizableString("imageLink", this, false);
    locImageLink.onGetTextCallback = (text) => {
      return getCorrectImageLink(text, this.contentMode == "youtube");
    };
    this.createLocalizableString("altText", this, false);
    this.registerPropertyChangedHandlers(["contentMode", "imageLink"], () => this.calculateRenderedMode());
  }
  getType() {
    return "image";
  }
  get isCompositeQuestion() {
    return false;
  }
  onSurveyLoad() {
    super.onSurveyLoad();
    this.calculateRenderedMode();
  }
  /**
   * Specifies an image or video URL.
   * @see contentMode
   */
  get imageLink() {
    return this.getLocalizableStringText("imageLink");
  }
  set imageLink(val) {
    this.setLocalizableStringText("imageLink", val);
  }
  get locImageLink() {
    return this.getLocalizableString("imageLink");
  }
  /**
   * Specifies a value for the `alt` attribute of the underlying `<img>` element.
   */
  get altText() {
    return this.getLocalizableStringText("altText");
  }
  set altText(val) {
    this.setLocalizableStringText("altText", val);
  }
  get locAltText() {
    return this.getLocalizableString("altText");
  }
  /**
   * Specifies the height of a container for the image or video. Accepts positive numbers and CSS values.
   *
   * Default value: 150
   *
   * Use the `imageFit` property to specify how to fit the image or video into the container.
   * @see imageWidth
   * @see imageFit
   */
  get imageHeight() {
    return this.getPropertyValue("imageHeight");
  }
  set imageHeight(val) {
    this.setPropertyValue("imageHeight", val);
  }
  get renderedStyleHeight() {
    return this.imageHeight ? getRenderedStyleSize(this.imageHeight) : void 0;
  }
  get renderedHeight() {
    return this.imageHeight ? getRenderedSize(this.imageHeight) : void 0;
  }
  /**
   * Specifies the width of a container for the image or video. Accepts positive numbers and CSS values.
   *
   * Default value: 200
   *
   * Use the `imageFit` property to specify how to fit the image or video into the container.
   * @see imageHeight
   * @see imageFit
   */
  get imageWidth() {
    return this.getPropertyValue("imageWidth");
  }
  set imageWidth(val) {
    this.setPropertyValue("imageWidth", val);
  }
  get renderedStyleWidth() {
    return this.imageWidth ? getRenderedStyleSize(this.imageWidth) : void 0;
  }
  get renderedWidth() {
    return this.imageWidth ? getRenderedSize(this.imageWidth) : void 0;
  }
  /**
   * Specifies how to resize the image or video to fit it into its container.
   *
   * Refer to the [`object-fit`](https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit) CSS property description for information on accepted values.
   * @see imageHeight
   * @see imageWidth
   */
  get imageFit() {
    return this.getPropertyValue("imageFit");
  }
  set imageFit(val) {
    this.setPropertyValue("imageFit", val);
  }
  /**
   * Specifies the type of content that the Image question displays.
   *
   * Possible values:
   *
   * - `"image"` - An image in one of the following formats: JPEG, GIF, PNG, APNG, SVG, BMP, ICO.
   * - `"video"` - A video in one of the following formats: MP4, MOV, WMV, FLV, AVI, MKV.
   * - `"youtube"` - A link to a YouTube video.
   * - `"auto"` (default) - Selects one of the above based on the [`imageLink`](https://surveyjs.io/form-library/documentation/questionimagemodel#imageLink) property.
   */
  get contentMode() {
    return this.getPropertyValue("contentMode");
  }
  set contentMode(val) {
    this.setPropertyValue("contentMode", val);
    if (val === "video") {
      this.showLabel = true;
    }
  }
  /**
   * Returns the type of content that the Image question displays: `"image"`, `"video"`, or `"youtube"`.
   * @see contentMode
   */
  get renderedMode() {
    return this.getPropertyValue("renderedMode", "image");
  }
  getImageCss() {
    const imageHeightProperty = this.getPropertyByName("imageHeight");
    const imageWidthProperty = this.getPropertyByName("imageWidth");
    const isDefaultSize = imageHeightProperty.isDefaultValue(this.imageHeight) && imageWidthProperty.isDefaultValue(this.imageWidth);
    return new CssClassBuilder().append(this.cssClasses.image).append(this.cssClasses.adaptive, isDefaultSize).toString();
  }
  onLoadHandler() {
    this.contentNotLoaded = false;
  }
  onErrorHandler() {
    this.contentNotLoaded = true;
  }
  setRenderedMode(val) {
    this.setPropertyValue("renderedMode", val);
  }
  calculateRenderedMode() {
    if (this.contentMode !== "auto") {
      this.setRenderedMode(this.contentMode);
    } else {
      if (this.isYoutubeVideo()) {
        this.setRenderedMode("youtube");
      } else if (this.isVideo()) {
        this.setRenderedMode("video");
      } else {
        this.setRenderedMode("image");
      }
    }
  }
  isYoutubeVideo() {
    return Helpers.isUrlYoutubeVideo(this.imageLink);
  }
  isVideo() {
    let link = this.imageLink;
    if (!link) return false;
    link = link.toLowerCase();
    for (let i = 0; i < videoSuffics.length; i++) {
      if (link.endsWith(videoSuffics[i])) return true;
    }
    return false;
  }
};
__decorate([property({
  defaultValue: false
})], QuestionImageModel.prototype, "contentNotLoaded", void 0);
function getCorrectImageLink(val, isYouTube) {
  if (!val || !Helpers.isUrlYoutubeVideo(val)) return isYouTube ? "" : val;
  let res = val.toLocaleLowerCase();
  if (res.indexOf(youtubeEmbed) > -1) return val;
  let id = "";
  for (var i = val.length - 1; i >= 0; i--) {
    if (val[i] === "=" || val[i] === "/") break;
    id = val[i] + id;
  }
  return youtubeUrl + youtubeEmbed + "/" + id;
}
Serializer.addClass("image", [{
  name: "imageLink:file",
  serializationProperty: "locImageLink"
}, {
  name: "altText",
  serializationProperty: "locAltText",
  alternativeName: "text",
  category: "general"
}, {
  name: "contentMode",
  default: "auto",
  choices: ["auto", "image", "video", "youtube"]
}, {
  name: "imageFit",
  default: "contain",
  choices: ["none", "contain", "cover", "fill"]
}, {
  name: "imageHeight",
  default: "150"
}, {
  name: "imageWidth",
  default: "200"
}], function() {
  return new QuestionImageModel("");
}, "nonvalue");
QuestionFactory.Instance.registerQuestion("image", (name) => {
  return new QuestionImageModel(name);
});
var Point = class {
  constructor(x, y, pressure, time) {
    if (isNaN(x) || isNaN(y)) {
      throw new Error(`Point is invalid: (${x}, ${y})`);
    }
    this.x = +x;
    this.y = +y;
    this.pressure = pressure || 0;
    this.time = time || Date.now();
  }
  distanceTo(start) {
    return Math.sqrt(Math.pow(this.x - start.x, 2) + Math.pow(this.y - start.y, 2));
  }
  equals(other) {
    return this.x === other.x && this.y === other.y && this.pressure === other.pressure && this.time === other.time;
  }
  velocityFrom(start) {
    return this.time !== start.time ? this.distanceTo(start) / (this.time - start.time) : 0;
  }
};
var Bezier = class _Bezier {
  static fromPoints(points, widths) {
    const c2 = this.calculateControlPoints(points[0], points[1], points[2]).c2;
    const c3 = this.calculateControlPoints(points[1], points[2], points[3]).c1;
    return new _Bezier(points[1], c2, c3, points[2], widths.start, widths.end);
  }
  static calculateControlPoints(s1, s2, s3) {
    const dx1 = s1.x - s2.x;
    const dy1 = s1.y - s2.y;
    const dx2 = s2.x - s3.x;
    const dy2 = s2.y - s3.y;
    const m1 = {
      x: (s1.x + s2.x) / 2,
      y: (s1.y + s2.y) / 2
    };
    const m2 = {
      x: (s2.x + s3.x) / 2,
      y: (s2.y + s3.y) / 2
    };
    const l1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
    const l2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
    const dxm = m1.x - m2.x;
    const dym = m1.y - m2.y;
    const k = l2 / (l1 + l2);
    const cm = {
      x: m2.x + dxm * k,
      y: m2.y + dym * k
    };
    const tx = s2.x - cm.x;
    const ty = s2.y - cm.y;
    return {
      c1: new Point(m1.x + tx, m1.y + ty),
      c2: new Point(m2.x + tx, m2.y + ty)
    };
  }
  constructor(startPoint, control2, control1, endPoint, startWidth, endWidth) {
    this.startPoint = startPoint;
    this.control2 = control2;
    this.control1 = control1;
    this.endPoint = endPoint;
    this.startWidth = startWidth;
    this.endWidth = endWidth;
  }
  length() {
    const steps = 10;
    let length = 0;
    let px;
    let py;
    for (let i = 0; i <= steps; i += 1) {
      const t = i / steps;
      const cx = this.point(t, this.startPoint.x, this.control1.x, this.control2.x, this.endPoint.x);
      const cy = this.point(t, this.startPoint.y, this.control1.y, this.control2.y, this.endPoint.y);
      if (i > 0) {
        const xdiff = cx - px;
        const ydiff = cy - py;
        length += Math.sqrt(xdiff * xdiff + ydiff * ydiff);
      }
      px = cx;
      py = cy;
    }
    return length;
  }
  point(t, start, c1, c2, end) {
    return start * (1 - t) * (1 - t) * (1 - t) + 3 * c1 * (1 - t) * (1 - t) * t + 3 * c2 * (1 - t) * t * t + end * t * t * t;
  }
};
var SignatureEventTarget = class {
  constructor() {
    try {
      this._et = new EventTarget();
    } catch (error) {
      this._et = document;
    }
  }
  addEventListener(type, listener, options) {
    this._et.addEventListener(type, listener, options);
  }
  dispatchEvent(event) {
    return this._et.dispatchEvent(event);
  }
  removeEventListener(type, callback, options) {
    this._et.removeEventListener(type, callback, options);
  }
};
function throttle(fn, wait = 250) {
  let previous = 0;
  let timeout = null;
  let result;
  let storedContext;
  let storedArgs;
  const later = () => {
    previous = Date.now();
    timeout = null;
    result = fn.apply(storedContext, storedArgs);
    if (!timeout) {
      storedContext = null;
      storedArgs = [];
    }
  };
  return function wrapper(...args) {
    const now = Date.now();
    const remaining = wait - (now - previous);
    storedContext = this;
    storedArgs = args;
    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      previous = now;
      result = fn.apply(storedContext, storedArgs);
      if (!timeout) {
        storedContext = null;
        storedArgs = [];
      }
    } else if (!timeout) {
      timeout = window.setTimeout(later, remaining);
    }
    return result;
  };
}
var SignaturePad = class _SignaturePad extends SignatureEventTarget {
  constructor(canvas, options = {}) {
    super();
    this.canvas = canvas;
    this._drawingStroke = false;
    this._isEmpty = true;
    this._lastPoints = [];
    this._data = [];
    this._lastVelocity = 0;
    this._lastWidth = 0;
    this._handleMouseDown = (event) => {
      if (event.buttons === 1) {
        this._strokeBegin(event);
      }
    };
    this._handleMouseMove = (event) => {
      this._strokeMoveUpdate(event);
    };
    this._handleMouseUp = (event) => {
      if (event.buttons === 1) {
        this._strokeEnd(event);
      }
    };
    this._handleTouchStart = (event) => {
      if (event.cancelable) {
        event.preventDefault();
      }
      if (event.targetTouches.length === 1) {
        const touch = event.changedTouches[0];
        this._strokeBegin(touch);
      }
    };
    this._handleTouchMove = (event) => {
      if (event.cancelable) {
        event.preventDefault();
      }
      const touch = event.targetTouches[0];
      this._strokeMoveUpdate(touch);
    };
    this._handleTouchEnd = (event) => {
      const wasCanvasTouched = event.target === this.canvas;
      if (wasCanvasTouched) {
        if (event.cancelable) {
          event.preventDefault();
        }
        const touch = event.changedTouches[0];
        this._strokeEnd(touch);
      }
    };
    this._handlePointerStart = (event) => {
      event.preventDefault();
      this._strokeBegin(event);
    };
    this._handlePointerMove = (event) => {
      this._strokeMoveUpdate(event);
    };
    this._handlePointerEnd = (event) => {
      if (this._drawingStroke) {
        event.preventDefault();
        this._strokeEnd(event);
      }
    };
    this.velocityFilterWeight = options.velocityFilterWeight || 0.7;
    this.minWidth = options.minWidth || 0.5;
    this.maxWidth = options.maxWidth || 2.5;
    this.throttle = "throttle" in options ? options.throttle : 16;
    this.minDistance = "minDistance" in options ? options.minDistance : 5;
    this.dotSize = options.dotSize || 0;
    this.penColor = options.penColor || "black";
    this.backgroundColor = options.backgroundColor || "rgba(0,0,0,0)";
    this.compositeOperation = options.compositeOperation || "source-over";
    this.canvasContextOptions = "canvasContextOptions" in options ? options.canvasContextOptions : {};
    this._strokeMoveUpdate = this.throttle ? throttle(_SignaturePad.prototype._strokeUpdate, this.throttle) : _SignaturePad.prototype._strokeUpdate;
    this._ctx = canvas.getContext("2d", this.canvasContextOptions);
    this.clear();
    this.on();
  }
  clear() {
    const {
      _ctx: ctx,
      canvas
    } = this;
    ctx.fillStyle = this.backgroundColor;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    this._data = [];
    this._reset(this._getPointGroupOptions());
    this._isEmpty = true;
  }
  fromDataURL(dataUrl, options = {}) {
    return new Promise((resolve, reject) => {
      const image = new Image();
      const ratio = options.ratio || window.devicePixelRatio || 1;
      const width = options.width || this.canvas.width / ratio;
      const height = options.height || this.canvas.height / ratio;
      const xOffset = options.xOffset || 0;
      const yOffset = options.yOffset || 0;
      this._reset(this._getPointGroupOptions());
      image.onload = () => {
        this._ctx.drawImage(image, xOffset, yOffset, width, height);
        resolve();
      };
      image.onerror = (error) => {
        reject(error);
      };
      image.crossOrigin = "anonymous";
      image.src = dataUrl;
      this._isEmpty = false;
    });
  }
  toDataURL(type = "image/png", encoderOptions) {
    switch (type) {
      case "image/svg+xml":
        if (typeof encoderOptions !== "object") {
          encoderOptions = void 0;
        }
        return `data:image/svg+xml;base64,${btoa(this.toSVG(encoderOptions))}`;
      default:
        if (typeof encoderOptions !== "number") {
          encoderOptions = void 0;
        }
        return this.canvas.toDataURL(type, encoderOptions);
    }
  }
  on() {
    this.canvas.style.touchAction = "none";
    this.canvas.style.msTouchAction = "none";
    this.canvas.style.userSelect = "none";
    const isIOS = /Macintosh/.test(navigator.userAgent) && "ontouchstart" in document;
    if (window.PointerEvent && !isIOS) {
      this._handlePointerEvents();
    } else {
      this._handleMouseEvents();
      if ("ontouchstart" in window) {
        this._handleTouchEvents();
      }
    }
  }
  off() {
    this.canvas.style.touchAction = "auto";
    this.canvas.style.msTouchAction = "auto";
    this.canvas.style.userSelect = "auto";
    this.canvas.removeEventListener("pointerdown", this._handlePointerStart);
    this.canvas.removeEventListener("pointermove", this._handlePointerMove);
    this.canvas.ownerDocument.removeEventListener("pointerup", this._handlePointerEnd);
    this.canvas.removeEventListener("mousedown", this._handleMouseDown);
    this.canvas.removeEventListener("mousemove", this._handleMouseMove);
    this.canvas.ownerDocument.removeEventListener("mouseup", this._handleMouseUp);
    this.canvas.removeEventListener("touchstart", this._handleTouchStart);
    this.canvas.removeEventListener("touchmove", this._handleTouchMove);
    this.canvas.removeEventListener("touchend", this._handleTouchEnd);
  }
  isEmpty() {
    return this._isEmpty;
  }
  fromData(pointGroups, {
    clear = true
  } = {}) {
    if (clear) {
      this.clear();
    }
    this._fromData(pointGroups, this._drawCurve.bind(this), this._drawDot.bind(this));
    this._data = this._data.concat(pointGroups);
  }
  toData() {
    return this._data;
  }
  _getPointGroupOptions(group) {
    return {
      penColor: group && "penColor" in group ? group.penColor : this.penColor,
      dotSize: group && "dotSize" in group ? group.dotSize : this.dotSize,
      minWidth: group && "minWidth" in group ? group.minWidth : this.minWidth,
      maxWidth: group && "maxWidth" in group ? group.maxWidth : this.maxWidth,
      velocityFilterWeight: group && "velocityFilterWeight" in group ? group.velocityFilterWeight : this.velocityFilterWeight,
      compositeOperation: group && "compositeOperation" in group ? group.compositeOperation : this.compositeOperation
    };
  }
  _strokeBegin(event) {
    const cancelled = !this.dispatchEvent(new CustomEvent("beginStroke", {
      detail: event,
      cancelable: true
    }));
    if (cancelled) {
      return;
    }
    this._drawingStroke = true;
    const pointGroupOptions = this._getPointGroupOptions();
    const newPointGroup = Object.assign(Object.assign({}, pointGroupOptions), {
      points: []
    });
    this._data.push(newPointGroup);
    this._reset(pointGroupOptions);
    this._strokeUpdate(event);
  }
  _strokeUpdate(event) {
    if (!this._drawingStroke) {
      return;
    }
    if (this._data.length === 0) {
      this._strokeBegin(event);
      return;
    }
    this.dispatchEvent(new CustomEvent("beforeUpdateStroke", {
      detail: event
    }));
    const x = event.clientX;
    const y = event.clientY;
    const pressure = event.pressure !== void 0 ? event.pressure : event.force !== void 0 ? event.force : 0;
    const point = this._createPoint(x, y, pressure);
    const lastPointGroup = this._data[this._data.length - 1];
    const lastPoints = lastPointGroup.points;
    const lastPoint = lastPoints.length > 0 && lastPoints[lastPoints.length - 1];
    const isLastPointTooClose = lastPoint ? point.distanceTo(lastPoint) <= this.minDistance : false;
    const pointGroupOptions = this._getPointGroupOptions(lastPointGroup);
    if (!lastPoint || !(lastPoint && isLastPointTooClose)) {
      const curve = this._addPoint(point, pointGroupOptions);
      if (!lastPoint) {
        this._drawDot(point, pointGroupOptions);
      } else if (curve) {
        this._drawCurve(curve, pointGroupOptions);
      }
      lastPoints.push({
        time: point.time,
        x: point.x,
        y: point.y,
        pressure: point.pressure
      });
    }
    this.dispatchEvent(new CustomEvent("afterUpdateStroke", {
      detail: event
    }));
  }
  _strokeEnd(event) {
    if (!this._drawingStroke) {
      return;
    }
    this._strokeUpdate(event);
    this._drawingStroke = false;
    this.dispatchEvent(new CustomEvent("endStroke", {
      detail: event
    }));
  }
  _handlePointerEvents() {
    this._drawingStroke = false;
    this.canvas.addEventListener("pointerdown", this._handlePointerStart);
    this.canvas.addEventListener("pointermove", this._handlePointerMove);
    this.canvas.ownerDocument.addEventListener("pointerup", this._handlePointerEnd);
  }
  _handleMouseEvents() {
    this._drawingStroke = false;
    this.canvas.addEventListener("mousedown", this._handleMouseDown);
    this.canvas.addEventListener("mousemove", this._handleMouseMove);
    this.canvas.ownerDocument.addEventListener("mouseup", this._handleMouseUp);
  }
  _handleTouchEvents() {
    this.canvas.addEventListener("touchstart", this._handleTouchStart);
    this.canvas.addEventListener("touchmove", this._handleTouchMove);
    this.canvas.addEventListener("touchend", this._handleTouchEnd);
  }
  _reset(options) {
    this._lastPoints = [];
    this._lastVelocity = 0;
    this._lastWidth = (options.minWidth + options.maxWidth) / 2;
    this._ctx.fillStyle = options.penColor;
    this._ctx.globalCompositeOperation = options.compositeOperation;
  }
  _createPoint(x, y, pressure) {
    const rect = this.canvas.getBoundingClientRect();
    return new Point(x - rect.left, y - rect.top, pressure, (/* @__PURE__ */ new Date()).getTime());
  }
  _addPoint(point, options) {
    const {
      _lastPoints
    } = this;
    _lastPoints.push(point);
    if (_lastPoints.length > 2) {
      if (_lastPoints.length === 3) {
        _lastPoints.unshift(_lastPoints[0]);
      }
      const widths = this._calculateCurveWidths(_lastPoints[1], _lastPoints[2], options);
      const curve = Bezier.fromPoints(_lastPoints, widths);
      _lastPoints.shift();
      return curve;
    }
    return null;
  }
  _calculateCurveWidths(startPoint, endPoint, options) {
    const velocity = options.velocityFilterWeight * endPoint.velocityFrom(startPoint) + (1 - options.velocityFilterWeight) * this._lastVelocity;
    const newWidth = this._strokeWidth(velocity, options);
    const widths = {
      end: newWidth,
      start: this._lastWidth
    };
    this._lastVelocity = velocity;
    this._lastWidth = newWidth;
    return widths;
  }
  _strokeWidth(velocity, options) {
    return Math.max(options.maxWidth / (velocity + 1), options.minWidth);
  }
  _drawCurveSegment(x, y, width) {
    const ctx = this._ctx;
    ctx.moveTo(x, y);
    ctx.arc(x, y, width, 0, 2 * Math.PI, false);
    this._isEmpty = false;
  }
  _drawCurve(curve, options) {
    const ctx = this._ctx;
    const widthDelta = curve.endWidth - curve.startWidth;
    const drawSteps = Math.ceil(curve.length()) * 2;
    ctx.beginPath();
    ctx.fillStyle = options.penColor;
    for (let i = 0; i < drawSteps; i += 1) {
      const t = i / drawSteps;
      const tt = t * t;
      const ttt = tt * t;
      const u = 1 - t;
      const uu = u * u;
      const uuu = uu * u;
      let x = uuu * curve.startPoint.x;
      x += 3 * uu * t * curve.control1.x;
      x += 3 * u * tt * curve.control2.x;
      x += ttt * curve.endPoint.x;
      let y = uuu * curve.startPoint.y;
      y += 3 * uu * t * curve.control1.y;
      y += 3 * u * tt * curve.control2.y;
      y += ttt * curve.endPoint.y;
      const width = Math.min(curve.startWidth + ttt * widthDelta, options.maxWidth);
      this._drawCurveSegment(x, y, width);
    }
    ctx.closePath();
    ctx.fill();
  }
  _drawDot(point, options) {
    const ctx = this._ctx;
    const width = options.dotSize > 0 ? options.dotSize : (options.minWidth + options.maxWidth) / 2;
    ctx.beginPath();
    this._drawCurveSegment(point.x, point.y, width);
    ctx.closePath();
    ctx.fillStyle = options.penColor;
    ctx.fill();
  }
  _fromData(pointGroups, drawCurve, drawDot) {
    for (const group of pointGroups) {
      const {
        points
      } = group;
      const pointGroupOptions = this._getPointGroupOptions(group);
      if (points.length > 1) {
        for (let j = 0; j < points.length; j += 1) {
          const basicPoint = points[j];
          const point = new Point(basicPoint.x, basicPoint.y, basicPoint.pressure, basicPoint.time);
          if (j === 0) {
            this._reset(pointGroupOptions);
          }
          const curve = this._addPoint(point, pointGroupOptions);
          if (curve) {
            drawCurve(curve, pointGroupOptions);
          }
        }
      } else {
        this._reset(pointGroupOptions);
        drawDot(points[0], pointGroupOptions);
      }
    }
  }
  toSVG({
    includeBackgroundColor = false
  } = {}) {
    const pointGroups = this._data;
    const ratio = Math.max(window.devicePixelRatio || 1, 1);
    const minX = 0;
    const minY = 0;
    const maxX = this.canvas.width / ratio;
    const maxY = this.canvas.height / ratio;
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("xmlns", "http://www.w3.org/2000/svg");
    svg.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink");
    svg.setAttribute("viewBox", `${minX} ${minY} ${maxX} ${maxY}`);
    svg.setAttribute("width", maxX.toString());
    svg.setAttribute("height", maxY.toString());
    if (includeBackgroundColor && this.backgroundColor) {
      const rect = document.createElement("rect");
      rect.setAttribute("width", "100%");
      rect.setAttribute("height", "100%");
      rect.setAttribute("fill", this.backgroundColor);
      svg.appendChild(rect);
    }
    this._fromData(pointGroups, (curve, {
      penColor
    }) => {
      const path = document.createElement("path");
      if (!isNaN(curve.control1.x) && !isNaN(curve.control1.y) && !isNaN(curve.control2.x) && !isNaN(curve.control2.y)) {
        const attr = `M ${curve.startPoint.x.toFixed(3)},${curve.startPoint.y.toFixed(3)} C ${curve.control1.x.toFixed(3)},${curve.control1.y.toFixed(3)} ${curve.control2.x.toFixed(3)},${curve.control2.y.toFixed(3)} ${curve.endPoint.x.toFixed(3)},${curve.endPoint.y.toFixed(3)}`;
        path.setAttribute("d", attr);
        path.setAttribute("stroke-width", (curve.endWidth * 2.25).toFixed(3));
        path.setAttribute("stroke", penColor);
        path.setAttribute("fill", "none");
        path.setAttribute("stroke-linecap", "round");
        svg.appendChild(path);
      }
    }, (point, {
      penColor,
      dotSize,
      minWidth,
      maxWidth
    }) => {
      const circle = document.createElement("circle");
      const size = dotSize > 0 ? dotSize : (minWidth + maxWidth) / 2;
      circle.setAttribute("r", size.toString());
      circle.setAttribute("cx", point.x.toString());
      circle.setAttribute("cy", point.y.toString());
      circle.setAttribute("fill", penColor);
      svg.appendChild(circle);
    });
    return svg.outerHTML;
  }
};
var defaultWidth = 300;
var defaultHeight = 200;
var QuestionSignaturePadModel = class extends QuestionFileModelBase {
  getPenColorFromTheme() {
    const _survey = this.survey;
    return !!_survey && !!_survey.themeVariables && _survey.themeVariables["--sjs-primary-backcolor"];
  }
  updateColors(signaturePad) {
    const penColorFromTheme = this.getPenColorFromTheme();
    const penColorProperty = this.getPropertyByName("penColor");
    signaturePad.penColor = this.penColor || penColorFromTheme || penColorProperty.defaultValue || "#1ab394";
    const backgroundColorProperty = this.getPropertyByName("backgroundColor");
    const backgroundColorFromTheme = penColorFromTheme ? "transparent" : void 0;
    const background = !!this.backgroundImage ? "transparent" : this.backgroundColor;
    signaturePad.backgroundColor = background || backgroundColorFromTheme || backgroundColorProperty.defaultValue || "#ffffff";
  }
  getCssRoot(cssClasses) {
    return new CssClassBuilder().append(super.getCssRoot(cssClasses)).append(cssClasses.small, this.signatureWidth.toString() === "300").toString();
  }
  getFormat() {
    return this.dataFormat === "jpeg" ? "image/jpeg" : this.dataFormat === "svg" ? "image/svg+xml" : "";
  }
  updateValue() {
    if (this.signaturePad) {
      var data = this.signaturePad.toDataURL(this.getFormat());
      this.valueIsUpdatingInternally = true;
      this.value = data;
      this.valueIsUpdatingInternally = false;
    }
  }
  constructor(name) {
    super(name);
    this.valueIsUpdatingInternally = false;
    this._loadedData = void 0;
    this.updateValueHandler = () => {
      this._loadedData = void 0;
      this.scaleCanvas(false, true);
      this.loadPreview(this.value);
    };
  }
  getType() {
    return "signaturepad";
  }
  afterRenderQuestionElement(el) {
    if (!!el) {
      if (!this.isDesignMode) this.initSignaturePad(el);
      this.element = el;
    }
    super.afterRenderQuestionElement(el);
  }
  beforeDestroyQuestionElement(el) {
    if (!!el) {
      this.destroySignaturePad(el);
    }
  }
  themeChanged(theme) {
    if (!!this.signaturePad) {
      this.updateColors(this.signaturePad);
    }
  }
  resizeCanvas() {
    this.canvas.width = this.containerWidth;
    this.canvas.height = this.containerHeight;
  }
  scaleCanvas(refresh = true, resize = false) {
    const canvas = this.canvas;
    const scale = canvas.offsetWidth / this.containerWidth;
    if (this.scale != scale || resize) {
      this.scale = scale;
      canvas.style.width = this.renderedCanvasWidth;
      this.resizeCanvas();
      this.signaturePad.minWidth = this.penMinWidth * scale;
      this.signaturePad.maxWidth = this.penMaxWidth * scale;
      canvas.getContext("2d").scale(1 / scale, 1 / scale);
      if (refresh) {
        this.loadPreview(this.value);
      }
    }
  }
  fromUrl(url) {
    this.isFileLoading = true;
    if (isBase64URL(url)) {
      this.fromDataUrl(url);
      this.isFileLoading = false;
    } else {
      const img = new Image();
      img.crossOrigin = "anonymous";
      img.src = url;
      img.onload = () => {
        if (!!this.canvas) {
          const canvas = DomDocumentHelper.createElement("canvas");
          canvas.width = this.containerWidth;
          canvas.height = this.containerHeight;
          const ctx = canvas.getContext("2d");
          ctx.drawImage(img, 0, 0);
          var dataURL = canvas.toDataURL(this.getFormat());
          this.fromDataUrl(dataURL);
        }
        this.isFileLoading = false;
      };
      img.onerror = () => {
        this.isFileLoading = false;
      };
    }
  }
  fromDataUrl(data) {
    this._loadedData = data;
    if (this.signaturePad) {
      this.signaturePad.fromDataURL(data, {
        width: this.canvas.width * this.scale,
        height: this.canvas.height * this.scale
      });
    }
  }
  get loadedData() {
    return this._loadedData;
  }
  loadPreview(newValue) {
    if (!newValue) {
      if (this.signaturePad && this.canvas) {
        this.canvas.getContext("2d").clearRect(0, 0, this.canvas.width * this.scale, this.canvas.height * this.scale);
        this.signaturePad.clear();
      }
      this.valueWasChangedFromLastUpload = false;
      return;
    }
    if (this.storeDataAsText) {
      this.fromDataUrl(newValue);
    } else {
      if (this.loadedData) {
        this.fromDataUrl(this.loadedData);
      } else {
        var newValues = !!newValue ? [newValue] : [];
        if (!!this._previewLoader) {
          this._previewLoader.dispose();
        }
        this.isFileLoading = true;
        this._previewLoader = new FileLoader(this, (status, loaded) => {
          if (status === "success" && loaded && loaded.length > 0 && loaded[0].content) {
            this.fromDataUrl(loaded[0].content);
            this.isFileLoading = false;
          } else if (status === "skipped") {
            this.fromUrl(newValue);
          }
          this._previewLoader.dispose();
          this._previewLoader = void 0;
        });
        this._previewLoader.load(newValues);
      }
    }
  }
  onChangeQuestionValue(newValue) {
    super.onChangeQuestionValue(newValue);
    if (!this.isLoadingFromJson) {
      this._loadedData = void 0;
      this.loadPreview(newValue);
    }
  }
  onSurveyLoad() {
    super.onSurveyLoad();
    this.loadPreview(this.value);
  }
  initSignaturePad(el) {
    var canvas = el.getElementsByTagName("canvas")[0];
    this.canvas = canvas;
    this.resizeCanvas();
    var signaturePad = new SignaturePad(canvas, {
      backgroundColor: "#ffffff"
    });
    this.signaturePad = signaturePad;
    if (this.isInputReadOnly) {
      signaturePad.off();
    }
    this.readOnlyChangedCallback = () => {
      if (this.isInputReadOnly) {
        signaturePad.off();
      } else {
        signaturePad.on();
      }
    };
    this.updateColors(signaturePad);
    signaturePad.addEventListener("beginStroke", () => {
      this.scaleCanvas();
      this.isDrawingValue = true;
      canvas.focus();
    }, {
      once: false
    });
    signaturePad.addEventListener("endStroke", () => {
      this.isDrawingValue = false;
      if (this.storeDataAsText) {
        this.updateValue();
      } else {
        this.valueWasChangedFromLastUpload = true;
      }
    }, {
      once: false
    });
    this.updateValueHandler();
    this.readOnlyChangedCallback();
    var propertyChangedHandler = (sender, options) => {
      if (options.name === "signatureWidth" || options.name === "signatureHeight") {
        if (!this.valueIsUpdatingInternally) this.updateValueHandler();
      }
    };
    this.onPropertyChanged.add(propertyChangedHandler);
    this.signaturePad.propertyChangedHandler = propertyChangedHandler;
  }
  destroySignaturePad(el) {
    if (this.signaturePad) {
      this.onPropertyChanged.remove(this.signaturePad.propertyChangedHandler);
      this.signaturePad.off();
    }
    this.readOnlyChangedCallback = null;
    this.signaturePad = null;
  }
  /**
   * Specifies the format in which to store the signature image.
   *
   * Possible values:
   *
   * - `"png"` (default)
   * - `"jpeg"`
   * - `"svg"`
   */
  get dataFormat() {
    return this.getPropertyValue("dataFormat");
  }
  set dataFormat(val) {
    this.setPropertyValue("dataFormat", correctFormatData(val));
  }
  /**
   * Specifies the width of the signature area. Accepts positive integer numbers.
   */
  get signatureWidth() {
    return this.getPropertyValue("signatureWidth");
  }
  set signatureWidth(val) {
    this.setPropertyValue("signatureWidth", val);
  }
  /**
   * Specifies the height of the signature area. Accepts positive integer numbers.
   */
  get signatureHeight() {
    return this.getPropertyValue("signatureHeight");
  }
  set signatureHeight(val) {
    this.setPropertyValue("signatureHeight", val);
  }
  get containerHeight() {
    return this.signatureHeight || defaultHeight;
  }
  get containerWidth() {
    return this.signatureWidth || defaultWidth;
  }
  get renderedCanvasWidth() {
    return this.signatureAutoScaleEnabled ? "100%" : this.containerWidth + "px";
  }
  //todo: need to remove this property
  get height() {
    return this.getPropertyValue("height");
  }
  set height(val) {
    this.setPropertyValue("height", val);
  }
  /**
   * Specifies whether to display a button that clears the signature area.
   *
   * Default value: `true`
   */
  get allowClear() {
    return this.getPropertyValue("allowClear");
  }
  set allowClear(val) {
    this.setPropertyValue("allowClear", val);
  }
  get canShowClearButton() {
    const hasSignature = !this.nothingIsDrawn();
    const isUploading = this.isUploading;
    return !this.isInputReadOnly && this.allowClear && hasSignature && !isUploading;
  }
  /**
   * Specifies a color for the pen.
   *
   * This property accepts color values in the following formats:
   *
   * - Hexadecimal colors (`"#FF0000"`)
   * - RGB colors (`"rgb(255,0,0)"`)
   * - Color names (`"red"`)
   * @see backgroundColor
   */
  get penColor() {
    return this.getPropertyValue("penColor");
  }
  set penColor(val) {
    this.setPropertyValue("penColor", val);
    !!this.signaturePad && this.updateColors(this.signaturePad);
  }
  /**
   * Specifies a color for the signature area background. Ignored if [`backgroundImage`](#backgroundImage) is set.
   *
   * This property accepts color values in the following formats:
   *
   * - Hexadecimal colors (`"#FF0000"`)
   * - RGB colors (`"rgb(255,0,0)"`)
   * - Color names (`"red"`)
   * @see penColor
   */
  get backgroundColor() {
    return this.getPropertyValue("backgroundColor");
  }
  set backgroundColor(val) {
    this.setPropertyValue("backgroundColor", val);
    !!this.signaturePad && this.updateColors(this.signaturePad);
  }
  /**
   * An image to display in the background of the signature area. Accepts a base64 or URL string value.
   * @see backgroundColor
   */
  get backgroundImage() {
    return this.getPropertyValue("backgroundImage");
  }
  set backgroundImage(val) {
    this.setPropertyValue("backgroundImage", val);
    !!this.signaturePad && this.updateColors(this.signaturePad);
  }
  get clearButtonCaption() {
    return this.getLocalizationString("clearCaption");
  }
  get locRenderedPlaceholder() {
    return this.isReadOnly ? this.locPlaceholderReadOnly : this.locPlaceholder;
  }
  nothingIsDrawn() {
    const isDrawing = this.isDrawingValue;
    const isEmpty = this.isEmpty();
    const isUploading = this.isUploading;
    const valueWasChangedFromLastUpload = this.valueWasChangedFromLastUpload;
    return !isDrawing && isEmpty && !isUploading && !valueWasChangedFromLastUpload;
  }
  needShowPlaceholder() {
    return this.showPlaceholder && this.nothingIsDrawn();
  }
  onBlurCore(event) {
    super.onBlurCore(event);
    if (!this.storeDataAsText) {
      if (!this.element.contains(event.relatedTarget)) {
        if (!this.valueWasChangedFromLastUpload) return;
        this.uploadFiles([dataUrl2File(this.signaturePad.toDataURL(this.getFormat()), this.name + "." + correctFormatData(this.dataFormat), this.getFormat())]);
        this.valueWasChangedFromLastUpload = false;
      }
    }
  }
  uploadResultItemToValue(r) {
    return r.content;
  }
  setValueFromResult(arg) {
    this.valueIsUpdatingInternally = true;
    this.value = (arg === null || arg === void 0 ? void 0 : arg.length) ? arg.map((r) => r.content)[0] : void 0;
    this.valueIsUpdatingInternally = false;
  }
  clearValue(keepComment) {
    this.valueWasChangedFromLastUpload = false;
    super.clearValue(keepComment);
    this._loadedData = void 0;
    this.loadPreview(this.value);
  }
  endLoadingFromJson() {
    super.endLoadingFromJson();
    if (this.signatureWidth === 300 && !!this.width && typeof this.width === "number" && this.width) {
      ConsoleWarnings.warn("Use signatureWidth property to set width for the signature pad");
      this.signatureWidth = this.width;
      this.width = void 0;
    }
    if (this.signatureHeight === 200 && !!this.height) {
      ConsoleWarnings.warn("Use signatureHeight property to set width for the signature pad");
      this.signatureHeight = this.height;
      this.height = void 0;
    }
  }
};
__decorate([property({
  defaultValue: false
})], QuestionSignaturePadModel.prototype, "isDrawingValue", void 0);
__decorate([property({
  defaultValue: false
})], QuestionSignaturePadModel.prototype, "isReadyForUpload", void 0);
__decorate([property({
  defaultValue: false
})], QuestionSignaturePadModel.prototype, "valueWasChangedFromLastUpload", void 0);
__decorate([property()], QuestionSignaturePadModel.prototype, "signatureAutoScaleEnabled", void 0);
__decorate([property()], QuestionSignaturePadModel.prototype, "penMinWidth", void 0);
__decorate([property()], QuestionSignaturePadModel.prototype, "penMaxWidth", void 0);
__decorate([property({})], QuestionSignaturePadModel.prototype, "showPlaceholder", void 0);
__decorate([property({
  localizable: {
    defaultStr: "signaturePlaceHolder"
  }
})], QuestionSignaturePadModel.prototype, "placeholder", void 0);
__decorate([property({
  localizable: {
    defaultStr: "signaturePlaceHolderReadOnly"
  }
})], QuestionSignaturePadModel.prototype, "placeholderReadOnly", void 0);
function correctFormatData(val) {
  if (!val) val = "png";
  val = val.replace("image/", "").replace("+xml", "");
  if (val !== "jpeg" && val !== "svg") val = "png";
  return val;
}
Serializer.addClass("signaturepad", [
  {
    name: "signatureWidth:number",
    category: "general",
    default: 300
  },
  {
    name: "signatureHeight:number",
    category: "general",
    default: 200
  },
  {
    name: "signatureAutoScaleEnabled:boolean",
    category: "general",
    default: false
  },
  {
    name: "penMinWidth:number",
    category: "general",
    default: 0.5
  },
  {
    name: "penMaxWidth:number",
    category: "general",
    default: 2.5
  },
  //need to remove this property
  {
    name: "height:number",
    category: "general",
    visible: false
  },
  {
    name: "allowClear:boolean",
    category: "general",
    default: true
  },
  {
    name: "showPlaceholder:boolean",
    category: "general",
    default: true
  },
  {
    name: "placeholder:text",
    serializationProperty: "locPlaceholder",
    category: "general",
    dependsOn: "showPlaceholder",
    visibleIf: (obj) => obj.showPlaceholder
  },
  {
    name: "placeholderReadOnly:text",
    serializationProperty: "locPlaceholderReadOnly",
    category: "general",
    dependsOn: "showPlaceholder",
    visibleIf: (obj) => obj.showPlaceholder
  },
  {
    name: "backgroundImage:file",
    category: "general"
  },
  {
    name: "penColor:color",
    category: "general"
  },
  {
    name: "backgroundColor:color",
    category: "general"
  },
  {
    name: "dataFormat",
    category: "general",
    default: "png",
    choices: [{
      value: "png",
      text: "PNG"
    }, {
      value: "jpeg",
      text: "JPEG"
    }, {
      value: "svg",
      text: "SVG"
    }],
    onSettingValue: (obj, val) => {
      return correctFormatData(val);
    }
  },
  {
    name: "defaultValue",
    visible: false
  },
  {
    name: "correctAnswer",
    visible: false
  },
  {
    name: "storeDataAsText:boolean",
    default: true
  },
  {
    name: "waitForUpload:boolean",
    default: false
  }
], function() {
  return new QuestionSignaturePadModel("");
}, "question");
QuestionFactory.Instance.registerQuestion("signaturepad", (name) => {
  return new QuestionSignaturePadModel(name);
});
var QuestionPanelDynamicItemTextProcessor = class _QuestionPanelDynamicItemTextProcessor extends QuestionTextProcessor {
  constructor(data, panelItem, variableName) {
    super(variableName);
    this.data = data;
    this.panelItem = panelItem;
    this.variableName = variableName;
    this.sharedQuestions = {};
  }
  get survey() {
    return this.panelItem.getSurvey();
  }
  get panel() {
    return this.panelItem.panel;
  }
  get panelIndex() {
    return !!this.data ? this.data.getItemIndex(this.panelItem) : -1;
  }
  get visiblePanelIndex() {
    return !!this.data ? this.data.getVisibleItemIndex(this.panelItem) : -1;
  }
  getValues() {
    return this.panelItem.getAllValues();
  }
  getQuestionByName(name) {
    var res = super.getQuestionByName(name);
    if (!!res) return res;
    var index = this.panelIndex;
    res = index > -1 ? this.data.getSharedQuestionFromArray(name, index) : void 0;
    const qName = !!res ? res.name : name;
    this.sharedQuestions[qName] = name;
    return res;
  }
  getQuestionDisplayText(question) {
    const name = this.sharedQuestions[question.name];
    if (!name) return super.getQuestionDisplayText(question);
    const val = this.panelItem.getValue(name);
    return question.getDisplayValue(true, val);
  }
  onCustomProcessText(textValue) {
    if (textValue.name == QuestionPanelDynamicItem.IndexVariableName) {
      var index = this.panelIndex;
      if (index > -1) {
        textValue.isExists = true;
        textValue.value = index + 1;
        return true;
      }
    }
    if (textValue.name == QuestionPanelDynamicItem.VisibleIndexVariableName) {
      var index = this.visiblePanelIndex;
      if (index > -1) {
        textValue.isExists = true;
        textValue.value = index + 1;
        return true;
      }
    }
    if (textValue.name.toLowerCase().indexOf(QuestionPanelDynamicItem.ParentItemVariableName + ".") == 0) {
      var q = this.data;
      if (!!q && !!q.parentQuestion && !!q.parent && !!q.parent.data) {
        var processor = new _QuestionPanelDynamicItemTextProcessor(q.parentQuestion, q.parent.data, QuestionPanelDynamicItem.ItemVariableName);
        var text = QuestionPanelDynamicItem.ItemVariableName + textValue.name.substring(QuestionPanelDynamicItem.ParentItemVariableName.length);
        var res = processor.processValue(text, textValue.returnDisplayValue);
        textValue.isExists = res.isExists;
        textValue.value = res.value;
      }
      return true;
    }
    return false;
  }
};
var PanelDynamicTabbedMenuItem = class extends Action {
  constructor(innerItem) {
    super(innerItem);
  }
};
var QuestionPanelDynamicItem = class _QuestionPanelDynamicItem {
  constructor(data, panel) {
    this.data = data;
    this.panelValue = panel;
    this.textPreProcessor = new QuestionPanelDynamicItemTextProcessor(data, this, _QuestionPanelDynamicItem.ItemVariableName);
    this.setSurveyImpl();
  }
  get panel() {
    return this.panelValue;
  }
  setSurveyImpl() {
    this.panel.setSurveyImpl(this);
  }
  getValue(name) {
    var values = this.getAllValues();
    return values[name];
  }
  setValue(name, newValue) {
    const oldItemData = this.data.getPanelItemData(this);
    const oldValue = !!oldItemData ? oldItemData[name] : void 0;
    if (Helpers.isTwoValueEquals(newValue, oldValue, false, true, false)) return;
    this.data.setPanelItemData(this, name, Helpers.getUnbindValue(newValue));
    const questions = this.panel.questions;
    const triggerName = _QuestionPanelDynamicItem.ItemVariableName + "." + name;
    for (var i = 0; i < questions.length; i++) {
      const q = questions[i];
      if (q.getValueName() !== name) {
        q.checkBindings(name, newValue);
      }
      q.runTriggers(triggerName, newValue);
    }
  }
  getVariable(name) {
    return void 0;
  }
  setVariable(name, newValue) {
  }
  getComment(name) {
    var result = this.getValue(name + settings.commentSuffix);
    return result ? result : "";
  }
  setComment(name, newValue, locNotification) {
    this.setValue(name + settings.commentSuffix, newValue);
  }
  findQuestionByName(name) {
    if (!name) return void 0;
    const prefix = _QuestionPanelDynamicItem.ItemVariableName + ".";
    if (name.indexOf(prefix) === 0) {
      return this.panel.getQuestionByName(name.substring(prefix.length));
    }
    const survey = this.getSurvey();
    return !!survey ? survey.getQuestionByName(name) : null;
  }
  getEditingSurveyElement() {
    return void 0;
  }
  getAllValues() {
    return this.data.getPanelItemData(this);
  }
  getFilteredValues() {
    var values = {};
    var surveyValues = !!this.data && !!this.data.getRootData() ? this.data.getRootData().getFilteredValues() : {};
    for (var key in surveyValues) {
      values[key] = surveyValues[key];
    }
    values[_QuestionPanelDynamicItem.ItemVariableName] = this.getAllValues();
    if (!!this.data) {
      const indexStr = _QuestionPanelDynamicItem.IndexVariableName;
      const visibleIndexStr = _QuestionPanelDynamicItem.VisibleIndexVariableName;
      delete values[indexStr];
      delete values[visibleIndexStr];
      values[indexStr.toLowerCase()] = this.data.getItemIndex(this);
      values[visibleIndexStr.toLowerCase()] = this.data.getVisibleItemIndex(this);
      const q = this.data;
      if (!!q && !!q.parentQuestion && !!q.parent) {
        values[_QuestionPanelDynamicItem.ParentItemVariableName] = q.parent.getValue();
      }
    }
    return values;
  }
  getFilteredProperties() {
    if (!!this.data && !!this.data.getRootData()) return this.data.getRootData().getFilteredProperties();
    return {
      survey: this.getSurvey()
    };
  }
  getSurveyData() {
    return this;
  }
  getSurvey() {
    return this.data ? this.data.getSurvey() : null;
  }
  getTextProcessor() {
    return this.textPreProcessor;
  }
};
QuestionPanelDynamicItem.ItemVariableName = "panel";
QuestionPanelDynamicItem.ParentItemVariableName = "parentpanel";
QuestionPanelDynamicItem.IndexVariableName = "panelIndex";
QuestionPanelDynamicItem.VisibleIndexVariableName = "visiblePanelIndex";
var QuestionPanelDynamicTemplateSurveyImpl = class {
  constructor(data) {
    this.data = data;
  }
  getSurveyData() {
    return null;
  }
  getSurvey() {
    return this.data.getSurvey();
  }
  getTextProcessor() {
    return null;
  }
};
var QuestionPanelDynamicModel = class extends Question {
  constructor(name) {
    super(name);
    this._renderedPanels = [];
    this.isPanelsAnimationRunning = false;
    this.isAddingNewPanels = false;
    this.isSetPanelItemData = {};
    this.createNewArray("panels", (panel) => {
      this.onPanelAdded(panel);
    }, (panel) => {
      this.onPanelRemoved(panel);
    });
    this.createNewArray("visiblePanels");
    this.templateValue = this.createAndSetupNewPanelObject();
    this.template.renderWidth = "100%";
    this.template.selectedElementInDesign = this;
    this.template.addElementCallback = (element) => {
      this.addOnPropertyChangedCallback(element);
      this.rebuildPanels();
    };
    this.template.removeElementCallback = () => {
      this.rebuildPanels();
    };
    this.createLocalizableString("confirmDeleteText", this, false, "confirmDelete");
    this.createLocalizableString("keyDuplicationError", this, false, true);
    this.createLocalizableString("addPanelText", this, false, "addPanel");
    this.createLocalizableString("removePanelText", this, false, "removePanel");
    this.createLocalizableString("prevPanelText", this, false, "pagePrevText");
    this.createLocalizableString("nextPanelText", this, false, "pageNextText");
    this.createLocalizableString("noEntriesText", this, false, "noEntriesText");
    this.createLocalizableString("templateTabTitle", this, true, "panelDynamicTabTextFormat");
    this.createLocalizableString("tabTitlePlaceholder", this, true, "tabTitlePlaceholder");
    this.registerPropertyChangedHandlers(["panelsState"], () => {
      this.setPanelsState();
    });
    this.registerPropertyChangedHandlers(["newPanelPosition", "displayMode", "showProgressBar"], () => {
      this.updateFooterActions();
    });
    this.registerPropertyChangedHandlers(["allowAddPanel"], () => {
      this.updateNoEntriesTextDefaultLoc();
    });
    this.registerPropertyChangedHandlers(["minPanelCount"], () => {
      this.onMinPanelCountChanged();
    });
    this.registerPropertyChangedHandlers(["maxPanelCount"], () => {
      this.onMaxPanelCountChanged();
    });
  }
  get isCompositeQuestion() {
    return true;
  }
  get hasSingleInput() {
    return false;
  }
  get isContainer() {
    return true;
  }
  getFirstQuestionToFocus(withError) {
    for (var i = 0; i < this.visiblePanelsCore.length; i++) {
      const res = this.visiblePanelsCore[i].getFirstQuestionToFocus(withError);
      if (!!res) return res;
    }
    if (this.showAddPanelButton && (!withError || this.currentErrorCount > 0)) return this;
    return null;
  }
  getFirstInputElementId() {
    if (this.showAddPanelButton) return this.addButtonId;
    return super.getFirstInputElementId();
  }
  setSurveyImpl(value, isLight) {
    super.setSurveyImpl(value, isLight);
    this.setTemplatePanelSurveyImpl();
    this.setPanelsSurveyImpl();
  }
  assignOnPropertyChangedToTemplate() {
    var elements = this.template.elements;
    for (var i = 0; i < elements.length; i++) {
      this.addOnPropertyChangedCallback(elements[i]);
    }
  }
  addOnPropertyChangedCallback(element) {
    if (element.isQuestion) {
      element.setParentQuestion(this);
    }
    element.onPropertyChanged.add((element2, options) => {
      this.onTemplateElementPropertyChanged(element2, options);
    });
    if (element.isPanel) {
      element.addElementCallback = (element2) => {
        this.addOnPropertyChangedCallback(element2);
      };
    }
  }
  onTemplateElementPropertyChanged(element, options) {
    if (this.isLoadingFromJson || this.useTemplatePanel || this.panelsCore.length == 0) return;
    var property2 = Serializer.findProperty(element.getType(), options.name);
    if (!property2) return;
    var panels = this.panelsCore;
    for (var i = 0; i < panels.length; i++) {
      var question = panels[i].getQuestionByName(element.name);
      if (!!question && question[options.name] !== options.newValue) {
        question[options.name] = options.newValue;
      }
    }
  }
  get useTemplatePanel() {
    return this.isDesignMode && !this.isContentElement;
  }
  getType() {
    return "paneldynamic";
  }
  clearOnDeletingContainer() {
    this.panelsCore.forEach((panel) => {
      panel.clearOnDeletingContainer();
    });
  }
  get isAllowTitleLeft() {
    return false;
  }
  removeElement(element) {
    return this.template.removeElement(element);
  }
  /**
   * A `PanelModel` object used as a template to create dynamic panels.
   * @see PanelModel
   * @see templateElements
   * @see templateTitle
   * @see panels
   * @see panelCount
   */
  get template() {
    return this.templateValue;
  }
  getPanel() {
    return this.template;
  }
  /**
   * An array of questions and panels included in a panel template.
   * @see template
   * @see panels
   * @see panelCount
   */
  get templateElements() {
    return this.template.elements;
  }
  /**
   * A template for panel titles.
   *
   * The template can contain the following placeholders:
   *
   * - `{panelIndex}` - A panel index within the collection of all panels. Starts with 1.
   * - `{visiblePanelIndex}` - A panel index within the collection of visible panels. Starts with 1.
   * @see template
   * @see templateDescription
   * @see templateElements
   * @see panels
   * @see panelCount
   */
  get templateTitle() {
    return this.template.title;
  }
  set templateTitle(newValue) {
    this.template.title = newValue;
  }
  get locTemplateTitle() {
    return this.template.locTitle;
  }
  /**
   * A template for tab titles. Applies when [`displayMode`](https://surveyjs.io/form-library/documentation/api-reference/dynamic-panel-model#displayMode) is `"tab"`.
   *
   * The template can contain the following placeholders:
   *
   * - `{panelIndex}` - A panel index within the collection of all panels. Starts with 1.
   * - `{visiblePanelIndex}` - A panel index within the collection of visible panels. Starts with 1.
   *
   * If you want to customize individual tab titles, handle `SurveyModel`'s [`onGetDynamicPanelTabTitle`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#onGetDynamicPanelTabTitle) event.
   *
   * [View Demo](https://surveyjs.io/form-library/examples/tabbed-interface-for-duplicate-group-option/ (linkStyle))
   * @see templateTitle
   * @see tabTitlePlaceholder
   * @see displayMode
   */
  get templateTabTitle() {
    return this.locTemplateTabTitle.text;
  }
  set templateTabTitle(newValue) {
    this.locTemplateTabTitle.text = newValue;
  }
  get locTemplateTabTitle() {
    return this.getLocalizableString("templateTabTitle");
  }
  /**
   * A placeholder for tab titles that applies when the [`templateTabTitle`](https://surveyjs.io/form-library/documentation/api-reference/dynamic-panel-model#templateTabTitle) expression doesn't produce a meaningful value.
   *
   * Default value: `"New Panel"` (taken from a [localization dictionary](https://github.com/surveyjs/survey-library/tree/01bd8abd0c574719956d4d579d48c8010cd389d4/packages/survey-core/src/localization))
   */
  get tabTitlePlaceholder() {
    return this.locTabTitlePlaceholder.text;
  }
  set tabTitlePlaceholder(newValue) {
    this.locTabTitlePlaceholder.text = newValue;
  }
  get locTabTitlePlaceholder() {
    return this.getLocalizableString("tabTitlePlaceholder");
  }
  /**
   * A template for panel descriptions.
   * @see template
   * @see templateTitle
   * @see templateElements
   * @see panels
   * @see panelCount
   */
  get templateDescription() {
    return this.template.description;
  }
  set templateDescription(newValue) {
    this.template.description = newValue;
  }
  get locTemplateDescription() {
    return this.template.locDescription;
  }
  /**
   * A Boolean expression that is evaluated against each panel. If the expression evaluates to `false`, the panel becomes hidden.
   *
   * A survey parses and runs all expressions on startup. If any values used in the expression change, the survey re-evaluates it.
   *
   * Use the `{panel}` placeholder to reference the current panel in the expression.
   *
   * Refer to the following help topic for more information: [Conditional Visibility](https://surveyjs.io/form-library/documentation/design-survey/conditional-logic#conditional-visibility).
   * @see visibleIf
   * @see visiblePanels
   */
  get templateVisibleIf() {
    return this.getPropertyValue("templateVisibleIf");
  }
  set templateVisibleIf(val) {
    this.setPropertyValue("templateVisibleIf", val);
    this.template.visibleIf = val;
  }
  get items() {
    var res = [];
    for (var i = 0; i < this.panelsCore.length; i++) {
      res.push(this.panelsCore[i].data);
    }
    return res;
  }
  /**
   * An array of `PanelModel` objects created based on a panel template.
   * @see PanelModel
   * @see template
   * @see panelCount
   */
  get panels() {
    this.buildPanelsFirstTime(this.canBuildPanels);
    return this.panelsCore;
  }
  /**
   * An array of currently visible panels ([`PanelModel`](https://surveyjs.io/form-library/documentation/api-reference/panel-model) objects).
   * @see templateVisibleIf
   */
  get visiblePanels() {
    this.buildPanelsFirstTime(this.canBuildPanels);
    return this.visiblePanelsCore;
  }
  get panelsCore() {
    return this.getPropertyValue("panels");
  }
  get visiblePanelsCore() {
    return this.getPropertyValue("visiblePanels");
  }
  onPanelAdded(panel) {
    this.onPanelRemovedCore(panel);
    if (!panel.visible) return;
    let index = 0;
    const panels = this.panelsCore;
    for (var i = 0; i < panels.length; i++) {
      if (panels[i] === panel) break;
      if (panels[i].visible) index++;
    }
    this.visiblePanelsCore.splice(index, 0, panel);
    this.addTabFromToolbar(panel, index);
    if (!this.currentPanel) {
      this.currentPanel = panel;
    }
    this.updateRenderedPanels();
  }
  onPanelRemoved(panel) {
    let index = this.onPanelRemovedCore(panel);
    if (this.currentPanel === panel) {
      const visPanels = this.visiblePanelsCore;
      if (index >= visPanels.length) index = visPanels.length - 1;
      this.currentPanel = index >= 0 ? visPanels[index] : null;
    }
    this.updateRenderedPanels();
  }
  onPanelRemovedCore(panel) {
    const visPanels = this.visiblePanelsCore;
    let index = visPanels.indexOf(panel);
    if (index > -1) {
      visPanels.splice(index, 1);
      this.removeTabFromToolbar(panel);
    }
    return index;
  }
  /**
   * A zero-based index of the currently displayed panel.
   *
   * When `displayMode` is `"list"` or Dynamic Panel is empty (`panelCount` is 0), this property contains -1.
   * @see currentPanel
   * @see panels
   * @see panelCount
   * @see displayMode
   */
  get currentIndex() {
    if (this.isRenderModeList) return -1;
    if (this.useTemplatePanel) return 0;
    return this.visiblePanelsCore.indexOf(this.currentPanel);
  }
  set currentIndex(val) {
    if (val < 0 || this.visiblePanelCount < 1) return;
    if (val >= this.visiblePanelCount) val = this.visiblePanelCount - 1;
    this.currentPanel = this.visiblePanelsCore[val];
  }
  /**
   * A `PanelModel` object that is the currently displayed panel.
   *
   * When `displayMode` is `"list"` or Dynamic Panel is empty (`panelCount` is 0), this property contains `null`.
   * @see currentIndex
   * @see panels
   * @see panelCount
   * @see displayMode
   */
  get currentPanel() {
    if (this.isDesignMode) return this.template;
    if (this.isRenderModeList || this.useTemplatePanel) return null;
    let res = this.getPropertyValue("currentPanel", null);
    if (!res && this.visiblePanelCount > 0) {
      res = this.visiblePanelsCore[0];
      this.currentPanel = res;
    }
    return res;
  }
  set currentPanel(val) {
    if (this.isRenderModeList || this.useTemplatePanel) return;
    const curPanel = this.getPropertyValue("currentPanel");
    const index = !!val ? this.visiblePanelsCore.indexOf(val) : -1;
    if (!!val && index < 0 || val === curPanel) return;
    if (curPanel) {
      curPanel.onHidingContent();
    }
    this.setPropertyValue("currentPanel", val);
    this.updateRenderedPanels();
    this.updateFooterActions();
    this.updateTabToolbarItemsPressedState();
    this.fireCallback(this.currentIndexChangedCallback);
    if (index > -1 && this.survey) {
      const options = {
        panel: val,
        visiblePanelIndex: index
      };
      this.survey.dynamicPanelCurrentIndexChanged(this, options);
    }
  }
  updateRenderedPanels() {
    if (this.isRenderModeList) {
      this.renderedPanels = [].concat(this.visiblePanels);
    } else if (this.currentPanel) {
      this.renderedPanels = [this.currentPanel];
    } else {
      this.renderedPanels = [];
    }
  }
  set renderedPanels(val) {
    if (this.renderedPanels.length == 0 || val.length == 0) {
      this.blockAnimations();
      this.panelsAnimation.sync(val);
      this.releaseAnimations();
    } else {
      this.isPanelsAnimationRunning = true;
      this.panelsAnimation.sync(val);
    }
  }
  get renderedPanels() {
    return this._renderedPanels;
  }
  getPanelsAnimationOptions() {
    const getDirectionCssClass = () => {
      if (this.isRenderModeList) return "";
      let cssClass = new CssClassBuilder();
      let isRemoving = false;
      const leavingPanel = this.renderedPanels.filter((el) => el !== this.currentPanel)[0];
      let leavingPanelIndex = this.visiblePanels.indexOf(leavingPanel);
      if (leavingPanelIndex < 0) {
        isRemoving = true;
        leavingPanelIndex = this.removedPanelIndex;
      }
      return cssClass.append("sv-pd-animation-adding", !!this.focusNewPanelCallback).append("sv-pd-animation-removing", isRemoving).append("sv-pd-animation-left", leavingPanelIndex <= this.currentIndex).append("sv-pd-animation-right", leavingPanelIndex > this.currentIndex).toString();
    };
    return {
      getRerenderEvent: () => this.onElementRerendered,
      getAnimatedElement: (panel) => {
        var _a, _b;
        if (panel && this.cssContent) {
          const contentSelector = classesToSelector(this.cssContent);
          return (_b = (_a = this.getWrapperElement()) === null || _a === void 0 ? void 0 : _a.querySelector(`:scope ${contentSelector} #${panel.id}`)) === null || _b === void 0 ? void 0 : _b.parentElement;
        }
      },
      getEnterOptions: () => {
        const cssClass = new CssClassBuilder().append(this.cssClasses.panelWrapperEnter).append(getDirectionCssClass()).toString();
        return {
          onBeforeRunAnimation: (el) => {
            if (this.focusNewPanelCallback) {
              const scolledElement = this.isRenderModeList ? el : el.parentElement;
              SurveyElement.ScrollElementToViewCore(scolledElement, false, false, {
                behavior: "smooth"
              });
            }
            if (!this.isRenderModeList && el.parentElement) {
              setPropertiesOnElementForAnimation(el.parentElement, {
                heightTo: el.offsetHeight + "px"
              });
            } else {
              prepareElementForVerticalAnimation(el);
            }
          },
          onAfterRunAnimation: (el) => {
            cleanHtmlElementAfterAnimation(el);
            if (el.parentElement) {
              cleanHtmlElementAfterAnimation(el.parentElement);
            }
          },
          cssClass
        };
      },
      getLeaveOptions: () => {
        const cssClass = new CssClassBuilder().append(this.cssClasses.panelWrapperLeave).append(getDirectionCssClass()).toString();
        return {
          onBeforeRunAnimation: (el) => {
            if (!this.isRenderModeList && el.parentElement) {
              setPropertiesOnElementForAnimation(el.parentElement, {
                heightFrom: el.offsetHeight + "px"
              });
            } else {
              prepareElementForVerticalAnimation(el);
            }
          },
          onAfterRunAnimation: (el) => {
            cleanHtmlElementAfterAnimation(el);
            if (el.parentElement) {
              cleanHtmlElementAfterAnimation(el.parentElement);
            }
          },
          cssClass
        };
      },
      isAnimationEnabled: () => {
        return this.animationAllowed && !!this.getWrapperElement();
      }
    };
  }
  disablePanelsAnimations() {
    this.panelsCore.forEach((panel) => {
      panel.blockAnimations();
    });
  }
  enablePanelsAnimations() {
    this.panelsCore.forEach((panel) => {
      panel.releaseAnimations();
    });
  }
  updatePanelsAnimation() {
    this._panelsAnimations = new (this.isRenderModeList ? AnimationGroup : AnimationTab)(this.getPanelsAnimationOptions(), (val, isTempUpdate) => {
      this._renderedPanels = val;
      if (!isTempUpdate) {
        this.isPanelsAnimationRunning = false;
        this.focusNewPanel();
      }
    }, () => this._renderedPanels);
  }
  get panelsAnimation() {
    if (!this._panelsAnimations) {
      this.updatePanelsAnimation();
    }
    return this._panelsAnimations;
  }
  onHidingContent() {
    super.onHidingContent();
    if (this.currentPanel) {
      this.currentPanel.onHidingContent();
    } else {
      this.visiblePanelsCore.forEach((panel) => panel.onHidingContent());
    }
  }
  /**
   * Specifies whether to display a confirmation dialog when a respondent wants to delete a panel.
   * @see confirmDeleteText
   */
  get confirmDelete() {
    return this.getPropertyValue("confirmDelete");
  }
  set confirmDelete(val) {
    this.setPropertyValue("confirmDelete", val);
  }
  /**
   * Specifies a key question. Set this property to the name of a question used in the template, and Dynamic Panel will display `keyDuplicationError` if a user tries to enter a duplicate value in this question.
   * @see keyDuplicationError
   */
  get keyName() {
    return this.getPropertyValue("keyName", "");
  }
  set keyName(val) {
    this.setPropertyValue("keyName", val);
  }
  /**
   * A message displayed in a confirmation dialog that appears when a respondent wants to delete a panel.
   * @see confirmDelete
   */
  get confirmDeleteText() {
    return this.getLocalizableStringText("confirmDeleteText");
  }
  set confirmDeleteText(val) {
    this.setLocalizableStringText("confirmDeleteText", val);
  }
  get locConfirmDeleteText() {
    return this.getLocalizableString("confirmDeleteText");
  }
  /**
   * An error message displayed when users enter a duplicate value into a question that accepts only unique values (`isUnique` is set to `true` or `keyName` is specified).
   *
   * A default value for this property is taken from a [localization dictionary](https://github.com/surveyjs/survey-library/tree/01bd8abd0c574719956d4d579d48c8010cd389d4/packages/survey-core/src/localization). Refer to the following help topic for more information: [Localization & Globalization](https://surveyjs.io/form-library/documentation/localization).
   * @see keyName
   */
  get keyDuplicationError() {
    return this.getLocalizableStringText("keyDuplicationError");
  }
  set keyDuplicationError(val) {
    this.setLocalizableStringText("keyDuplicationError", val);
  }
  get locKeyDuplicationError() {
    return this.getLocalizableString("keyDuplicationError");
  }
  /**
   * A caption for the Previous button. Applies only if `displayMode` is different from `"list"`.
   * @see displayMode
   * @see isPrevButtonVisible
   */
  get prevPanelText() {
    return this.getLocalizableStringText("prevPanelText");
  }
  set prevPanelText(val) {
    this.setLocalizableStringText("prevPanelText", val);
  }
  get locPrevPanelText() {
    return this.getLocalizableString("prevPanelText");
  }
  /**
   * @deprecated Use the [`prevPanelText`](https://surveyjs.io/form-library/documentation/api-reference/dynamic-panel-model#prevPanelText) property instead.
   */
  get panelPrevText() {
    return this.prevPanelText;
  }
  set panelPrevText(val) {
    this.prevPanelText = val;
  }
  get locPanelPrevText() {
    return this.locPrevPanelText;
  }
  /**
   * A caption for the Next button. Applies only if `displayMode` is different from `"list"`.
   * @see displayMode
   * @see isNextButtonVisible
   */
  get nextPanelText() {
    return this.getLocalizableStringText("nextPanelText");
  }
  set nextPanelText(val) {
    this.setLocalizableStringText("nextPanelText", val);
  }
  get locNextPanelText() {
    return this.getLocalizableString("nextPanelText");
  }
  /**
   * @deprecated Use the [`nextPanelText`](https://surveyjs.io/form-library/documentation/api-reference/dynamic-panel-model#nextPanelText) property instead.
   */
  get panelNextText() {
    return this.nextPanelText;
  }
  set panelNextText(val) {
    this.nextPanelText = val;
  }
  get locPanelNextText() {
    return this.locNextPanelText;
  }
  /**
   * A caption for the Add Panel button.
   */
  get addPanelText() {
    return this.getLocalizableStringText("addPanelText");
  }
  set addPanelText(value) {
    this.setLocalizableStringText("addPanelText", value);
  }
  get locAddPanelText() {
    return this.getLocalizableString("addPanelText");
  }
  /**
   * @deprecated Use the [`addPanelText`](https://surveyjs.io/form-library/documentation/api-reference/dynamic-panel-model#addPanelText) property instead.
   */
  get panelAddText() {
    return this.addPanelText;
  }
  set panelAddText(value) {
    this.addPanelText = value;
  }
  get locPanelAddText() {
    return this.locAddPanelText;
  }
  /**
   * A caption for the Remove Panel button.
   * @see removePanelButtonLocation
   */
  get removePanelText() {
    return this.getLocalizableStringText("removePanelText");
  }
  set removePanelText(val) {
    this.setLocalizableStringText("removePanelText", val);
  }
  get locRemovePanelText() {
    return this.getLocalizableString("removePanelText");
  }
  /**
   * @deprecated Use the [`removePanelText`](https://surveyjs.io/form-library/documentation/api-reference/dynamic-panel-model#removePanelText) property instead.
   */
  get panelRemoveText() {
    return this.removePanelText;
  }
  set panelRemoveText(val) {
    this.removePanelText = val;
  }
  get locPanelRemoveText() {
    return this.locRemovePanelText;
  }
  get isProgressTopShowing() {
    return this.displayMode == "carousel" && (this.progressBarLocation === "top" || this.progressBarLocation === "topBottom");
  }
  get isProgressBottomShowing() {
    return this.displayMode == "carousel" && (this.progressBarLocation === "bottom" || this.progressBarLocation === "topBottom");
  }
  /**
   * Indicates whether the Previous button is visible.
   * @see currentIndex
   * @see currentPanel
   * @see prevPanelText
   */
  get isPrevButtonVisible() {
    return this.currentIndex > 0;
  }
  get isPrevButtonShowing() {
    return this.isPrevButtonVisible;
  }
  /**
   * Indicates whether the Next button is visible.
   * @see currentIndex
   * @see currentPanel
   * @see nextPanelText
   */
  get isNextButtonVisible() {
    return this.currentIndex >= 0 && this.currentIndex < this.visiblePanelCount - 1;
  }
  get isNextButtonShowing() {
    return this.isNextButtonVisible;
  }
  get isRangeShowing() {
    return this.showProgressBar && this.currentIndex >= 0 && this.visiblePanelCount > 1;
  }
  getElementsInDesign(includeHidden = false) {
    return includeHidden ? [this.template] : this.templateElements;
  }
  prepareValueForPanelCreating() {
    this.addingNewPanelsValue = this.value;
    this.isAddingNewPanels = true;
    this.isNewPanelsValueChanged = false;
  }
  setValueAfterPanelsCreating() {
    this.isAddingNewPanels = false;
    if (this.isNewPanelsValueChanged) {
      this.isValueChangingInternally = true;
      this.value = this.addingNewPanelsValue;
      this.isValueChangingInternally = false;
    }
  }
  getValueCore() {
    return this.isAddingNewPanels ? this.addingNewPanelsValue : super.getValueCore();
  }
  setValueCore(newValue) {
    if (this.isAddingNewPanels) {
      this.isNewPanelsValueChanged = true;
      this.addingNewPanelsValue = newValue;
    } else {
      super.setValueCore(newValue);
    }
  }
  setIsMobile(val) {
    super.setIsMobile(val);
    (this.panelsCore || []).forEach((panel) => panel.getQuestions(true).forEach((question) => {
      question.setIsMobile(val);
    }));
  }
  themeChanged(theme) {
    super.themeChanged(theme);
    (this.panelsCore || []).forEach((panel) => panel.getQuestions(true).forEach((question) => {
      question.themeChanged(theme);
    }));
  }
  /**
   * The number of panels in Dynamic Panel.
   * @see minPanelCount
   * @see maxPanelCount
   */
  get panelCount() {
    return !this.canBuildPanels || this.wasNotRenderedInSurvey ? this.getPropertyValue("panelCount") : this.panelsCore.length;
  }
  set panelCount(val) {
    if (val < 0) return;
    if (!this.canBuildPanels || this.wasNotRenderedInSurvey) {
      this.setPropertyValue("panelCount", val);
      return;
    }
    if (val == this.panelsCore.length || this.useTemplatePanel) return;
    this.updateBindings("panelCount", val);
    this.prepareValueForPanelCreating();
    for (let i = this.panelCount; i < val; i++) {
      const panel = this.createNewPanel();
      this.panelsCore.push(panel);
      if (this.displayMode == "list" && this.panelsState != "default") {
        if (this.panelsState === "expanded") {
          panel.expand();
        } else {
          if (!!panel.title) {
            panel.collapse();
          }
        }
      }
    }
    if (val < this.panelCount) {
      this.panelsCore.splice(val, this.panelCount - val);
    }
    this.disablePanelsAnimations();
    this.setValueAfterPanelsCreating();
    this.setValueBasedOnPanelCount();
    this.reRunCondition();
    this.updateFooterActions();
    this.fireCallback(this.panelCountChangedCallback);
    this.enablePanelsAnimations();
  }
  /**
   * Returns the number of visible panels in Dynamic Panel.
   * @see templateVisibleIf
   */
  get visiblePanelCount() {
    return this.visiblePanels.length;
  }
  /**
   * Specifies whether users can expand and collapse panels. Applies if `displayMode` is `"list"` and the `templateTitle` property is specified.
   *
   * Possible values:
   *
   * - `"default"` (default) - All panels are displayed in full and cannot be collapsed.
   * - `"expanded"` - All panels are displayed in full and can be collapsed in the UI.
   * - `"collapsed"` - All panels display only their titles and descriptions and can be expanded in the UI.
   * - `"firstExpanded"` - Only the first panel is displayed in full; other panels are collapsed and can be expanded in the UI.
   * @see displayMode
   * @see templateTitle
   */
  get panelsState() {
    return this.getPropertyValue("panelsState");
  }
  set panelsState(val) {
    this.setPropertyValue("panelsState", val);
  }
  setTemplatePanelSurveyImpl() {
    this.template.setSurveyImpl(this.useTemplatePanel ? this.surveyImpl : new QuestionPanelDynamicTemplateSurveyImpl(this));
  }
  setPanelsSurveyImpl() {
    for (var i = 0; i < this.panelsCore.length; i++) {
      var panel = this.panelsCore[i];
      if (panel == this.template) continue;
      panel.setSurveyImpl(panel.data);
    }
  }
  setPanelsState() {
    if (this.useTemplatePanel || this.displayMode != "list" || !this.templateTitle) return;
    for (var i = 0; i < this.panelsCore.length; i++) {
      var state = this.panelsState;
      if (state === "firstExpanded") {
        state = i === 0 ? "expanded" : "collapsed";
      }
      this.panelsCore[i].state = state;
    }
  }
  setValueBasedOnPanelCount() {
    var value = this.value;
    if (!value || !Array.isArray(value)) value = [];
    if (value.length == this.panelCount) return;
    for (var i = value.length; i < this.panelCount; i++) {
      const panelValue = this.panels[i].getValue();
      const val = !Helpers.isValueEmpty(panelValue) ? panelValue : {};
      value.push(val);
    }
    if (value.length > this.panelCount) {
      value.splice(this.panelCount, value.length - this.panelCount);
    }
    this.isValueChangingInternally = true;
    this.value = value;
    this.isValueChangingInternally = false;
  }
  /**
   * A minimum number of panels in Dynamic Panel. Users cannot delete panels if `panelCount` equals `minPanelCount`.
   *
   * Default value: 0
   * @see panelCount
   * @see maxPanelCount
   * @see allowRemovePanel
   */
  get minPanelCount() {
    return this.getPropertyValue("minPanelCount");
  }
  set minPanelCount(val) {
    if (val < 0) val = 0;
    this.setPropertyValue("minPanelCount", val);
  }
  onMinPanelCountChanged() {
    const val = this.minPanelCount;
    if (val > this.maxPanelCount) this.maxPanelCount = val;
    if (this.panelCount < val) this.panelCount = val;
  }
  /**
   * A maximum number of panels in Dynamic Panel. Users cannot add new panels if `panelCount` equals `maxPanelCount`.
   *
   * Default value: 100 (inherited from [`settings.panel.maxPanelCount`](https://surveyjs.io/form-library/documentation/settings#panelMaximumPanelCount))
   * @see panelCount
   * @see minPanelCount
   * @see allowAddPanel
   */
  get maxPanelCount() {
    return this.getPropertyValue("maxPanelCount");
  }
  set maxPanelCount(val) {
    if (val <= 0) return;
    if (val > settings.panel.maxPanelCount) val = settings.panel.maxPanelCount;
    this.setPropertyValue("maxPanelCount", val);
    this.updateFooterActions();
  }
  onMaxPanelCountChanged() {
    const val = this.maxPanelCount;
    if (val < this.minPanelCount) this.minPanelCount = val;
    if (this.panelCount > val) this.panelCount = val;
    this.updateFooterActions();
  }
  /**
   * Specifies whether users are allowed to add new panels.
   *
   * Default value: `true`
   *
   * By default, users add new panels to the end. If you want to let users insert a new panel after the current panel, set the [`newPanelPosition`](https://surveyjs.io/form-library/documentation/api-reference/dynamic-panel-model#newPanelPosition) property to `"next"`.
   * @see canAddPanel
   * @see allowRemovePanel
   */
  get allowAddPanel() {
    return this.getPropertyValue("allowAddPanel");
  }
  set allowAddPanel(val) {
    this.setPropertyValue("allowAddPanel", val);
  }
  get addButtonId() {
    return this.id + "addPanel";
  }
  /**
   * Specifies the position of newly added panels.
   *
   * Possible values:
   *
   * - `"last"` (default) - New panels are added to the end.
   * - `"next"` - New panels are inserted after the current panel.
   * @see allowAddPanel
   * @see addPanel
   */
  get newPanelPosition() {
    return this.getPropertyValue("newPanelPosition");
  }
  set newPanelPosition(val) {
    this.setPropertyValue("newPanelPosition", val);
  }
  /**
   * Specifies whether users are allowed to delete panels.
   *
   * Default value: `true`
   * @see canRemovePanel
   * @see allowAddPanel
   */
  get allowRemovePanel() {
    return this.getPropertyValue("allowRemovePanel");
  }
  set allowRemovePanel(val) {
    this.setPropertyValue("allowRemovePanel", val);
  }
  /**
   * Gets or sets the location of question titles relative to their input fields.
   *
   * - `"default"` (default) - Inherits the setting from the Dynamic Panel's `titleLocation` property, which in turn inherits the [`questionTitleLocation`](https://surveyjs.io/form-library/documentation/surveymodel#questionTitleLocation) property value specified for the Dynamic Panel's container (page or survey).
   * - `"top"` - Displays question titles above input fields.
   * - `"bottom"` - Displays question titles below input fields.
   * - `"left"` - Displays question titles to the left of input fields.
   * - `"hidden"` - Hides question titles.
   * @see titleLocation
   */
  get templateQuestionTitleLocation() {
    return this.getPropertyValue("templateQuestionTitleLocation");
  }
  set templateQuestionTitleLocation(val) {
    this.setPropertyValue("templateQuestionTitleLocation", val);
  }
  /**
   * @deprecated Use the [`templateQuestionTitleLocation`](https://surveyjs.io/form-library/documentation/api-reference/dynamic-panel-model#templateQuestionTitleLocation) property instead.
   */
  get templateTitleLocation() {
    return this.templateQuestionTitleLocation;
  }
  set templateTitleLocation(val) {
    this.templateQuestionTitleLocation = val;
  }
  /**
   * Specifies the error message position.
   *
   * Possible values:
   *
   * - `"default"` (default) - Inherits the setting from the [`errorLocation`](#errorLocation) property.
   * - `"top"` - Displays error messages above questions.
   * - `"bottom"` - Displays error messages below questions.
   */
  get templateErrorLocation() {
    return this.getPropertyValue("templateErrorLocation");
  }
  set templateErrorLocation(value) {
    this.setPropertyValue("templateErrorLocation", value.toLowerCase());
  }
  /**
   * Use this property to show/hide the numbers in titles in questions inside a dynamic panel.
   * By default the value is "off". You may set it to "onPanel" and the first question inside a dynamic panel will start with 1 or "onSurvey" to include nested questions in dymamic panels into global survey question numbering.
   */
  get showQuestionNumbers() {
    return this.getPropertyValue("showQuestionNumbers");
  }
  set showQuestionNumbers(val) {
    this.setPropertyValue("showQuestionNumbers", val);
    if (!this.isLoadingFromJson && this.survey) {
      this.survey.questionVisibilityChanged(this, this.visible, true);
    }
  }
  notifySurveyOnChildrenVisibilityChanged() {
    return this.showQuestionNumbers === "onSurvey";
  }
  /**
   * Specifies the location of the Remove Panel button relative to panel content.
   *
   * Possible values:
   *
   * - `"bottom"` (default) - Displays the Remove Panel button below panel content.
   * - `"right"` - Displays the Remove Panel button to the right of panel content.
   * @see removePanelText
   */
  get removePanelButtonLocation() {
    return this.getPropertyValue("removePanelButtonLocation");
  }
  set removePanelButtonLocation(val) {
    this.setPropertyValue("removePanelButtonLocation", val);
  }
  /**
   * @deprecated Use the [`removePanelButtonLocation`](https://surveyjs.io/form-library/documentation/api-reference/dynamic-panel-model#removePanelButtonLocation) property instead.
   */
  get panelRemoveButtonLocation() {
    return this.removePanelButtonLocation;
  }
  set panelRemoveButtonLocation(val) {
    this.removePanelButtonLocation = val;
  }
  /**
   * @deprecated Use the [`showProgressBar`](https://surveyjs.io/form-library/documentation/api-reference/dynamic-panel-model#showProgressBar) property instead.
   */
  get showRangeInProgress() {
    return this.showProgressBar;
  }
  set showRangeInProgress(val) {
    this.showProgressBar = val;
  }
  /**
   * @deprecated Use the [`displayMode`](https://surveyjs.io/form-library/documentation/api-reference/dynamic-panel-model#displayMode) property instead.
   */
  get renderMode() {
    let displayMode = this.displayMode;
    if (displayMode == "carousel") {
      const progressBarLocation = this.progressBarLocation;
      if (progressBarLocation == "top") {
        return "progressTop";
      } else if (progressBarLocation == "bottom") {
        return "progressBottom";
      } else if (progressBarLocation == "topBottom") {
        return "progressTopBottom";
      }
    }
    return displayMode;
  }
  set renderMode(val) {
    if ((val || "").startsWith("progress")) {
      if (val == "progressTop") {
        this.progressBarLocation = "top";
      } else if (val == "progressBottom") {
        this.progressBarLocation = "bottom";
      } else if (val == "progressTopBottom") {
        this.progressBarLocation = "topBottom";
      }
      this.displayMode = "carousel";
    } else {
      this.displayMode = val;
    }
  }
  updatePanelView() {
    this.blockAnimations();
    this.updateRenderedPanels();
    this.releaseAnimations();
    this.updatePanelsAnimation();
  }
  get tabAlign() {
    return this.getPropertyValue("tabAlign");
  }
  set tabAlign(val) {
    this.setPropertyValue("tabAlign", val);
    if (this.isRenderModeTab) {
      this.tabbedMenu.containerCss = this.getTabbedMenuCss();
    }
  }
  get isRenderModeList() {
    return this.displayMode === "list";
  }
  get isRenderModeTab() {
    return this.displayMode === "tab";
  }
  setVisibleIndex(value) {
    if (!this.isVisible) return 0;
    const onSurveyNumbering = this.showQuestionNumbers === "onSurvey";
    let startIndex = onSurveyNumbering ? value : 0;
    const panels = this.isDesignMode ? [this.template] : this.visiblePanelsCore;
    for (let i = 0; i < panels.length; i++) {
      let counter = this.setPanelVisibleIndex(panels[i], startIndex, this.showQuestionNumbers != "off");
      if (onSurveyNumbering) {
        startIndex += counter;
      }
    }
    super.setVisibleIndex(!onSurveyNumbering ? value : -1);
    return !onSurveyNumbering ? 1 : startIndex - value;
  }
  setPanelVisibleIndex(panel, index, showIndex) {
    if (!showIndex) {
      panel.setVisibleIndex(-1);
      return 0;
    }
    return panel.setVisibleIndex(index);
  }
  /**
   * Indicates whether it is possible to add a new panel.
   *
   * This property returns `true` when all of the following conditions apply:
   *
   * - Users are allowed to add new panels (`allowAddPanel` is `true`).
   * - Dynamic Panel or its parent survey is not in read-only state.
   * - `panelCount` is less than `maxPanelCount`.
   * @see allowAddPanel
   * @see isReadOnly
   * @see panelCount
   * @see maxPanelCount
   * @see canRemovePanel
   */
  get canAddPanel() {
    if (this.isDesignMode) return false;
    if (this.isDefaultV2Theme && !this.legacyNavigation && !this.isRenderModeList && this.currentIndex < this.visiblePanelCount - 1 && this.newPanelPosition !== "next") {
      return false;
    }
    return this.allowAddPanel && !this.isReadOnly && this.panelCount < this.maxPanelCount;
  }
  /**
   * Indicates whether it is possible to delete panels.
   *
   * This property returns `true` when all of the following conditions apply:
   *
   * - Users are allowed to delete panels (`allowRemovePanel` is `true`).
   * - Dynamic Panel or its parent survey is not in read-only state.
   * - `panelCount` exceeds `minPanelCount`.
   * @see allowRemovePanel
   * @see isReadOnly
   * @see panelCount
   * @see minPanelCount
   * @see canAddPanel
   */
  get canRemovePanel() {
    if (this.isDesignMode) return false;
    return this.allowRemovePanel && !this.isReadOnly && this.panelCount > this.minPanelCount;
  }
  rebuildPanels() {
    if (this.isLoadingFromJson) return;
    this.prepareValueForPanelCreating();
    var panels = [];
    if (this.useTemplatePanel) {
      new QuestionPanelDynamicItem(this, this.template);
      panels.push(this.template);
    } else {
      for (var i = 0; i < this.panelCount; i++) {
        this.createNewPanel();
        panels.push(this.createNewPanel());
      }
    }
    this.panelsCore.splice(0, this.panelsCore.length, ...panels);
    this.setValueAfterPanelsCreating();
    this.setPanelsState();
    this.reRunCondition();
    this.updateFooterActions();
    this.fireCallback(this.panelCountChangedCallback);
    this.updateTabToolbar();
  }
  /**
   * If it is not empty, then this value is set to every new panel, including panels created initially, unless the defaultValue is not empty
   * @see defaultValue
   * @see copyDefaultValueFromLastEntry
   */
  get defaultPanelValue() {
    return this.getPropertyValue("defaultPanelValue");
  }
  set defaultPanelValue(val) {
    this.setPropertyValue("defaultPanelValue", val);
  }
  /**
   * Specifies whether default values for a new panel should be copied from the last panel.
   *
   * If you also specify `defaultValue`, it will be merged with the copied values.
   * @see defaultValue
   */
  get copyDefaultValueFromLastEntry() {
    return this.getPropertyValue("copyDefaultValueFromLastEntry");
  }
  set copyDefaultValueFromLastEntry(val) {
    this.setPropertyValue("copyDefaultValueFromLastEntry", val);
  }
  /**
   * @deprecated Use the [`copyDefaultValueFromLastEntry`](https://surveyjs.io/form-library/documentation/api-reference/dynamic-panel-model#copyDefaultValueFromLastEntry) property instead.
   */
  get defaultValueFromLastPanel() {
    return this.copyDefaultValueFromLastEntry;
  }
  set defaultValueFromLastPanel(val) {
    this.copyDefaultValueFromLastEntry = val;
  }
  isDefaultValueEmpty() {
    return super.isDefaultValueEmpty() && this.isValueEmpty(this.defaultPanelValue);
  }
  setDefaultValue() {
    if (this.isValueEmpty(this.defaultPanelValue) || !this.isValueEmpty(this.defaultValue)) {
      super.setDefaultValue();
      return;
    }
    if (!this.isEmpty() || this.panelCount == 0) return;
    var newValue = [];
    for (var i = 0; i < this.panelCount; i++) {
      newValue.push(this.defaultPanelValue);
    }
    this.value = newValue;
  }
  get isValueArray() {
    return true;
  }
  isEmpty() {
    var val = this.value;
    if (!val || !Array.isArray(val)) return true;
    for (var i = 0; i < val.length; i++) {
      if (!this.isRowEmpty(val[i])) return false;
    }
    return true;
  }
  getProgressInfo() {
    return SurveyElement.getProgressInfoByElements(this.visiblePanelsCore, this.isRequired);
  }
  isRowEmpty(val) {
    for (var prop in val) {
      if (val.hasOwnProperty(prop)) return false;
    }
    return true;
  }
  /**
   * @deprecated Call the [`addPanel(undefined, true)`](https://surveyjs.io/form-library/documentation/api-reference/dynamic-panel-model#addPanel) method instead.
   */
  addPanelUI() {
    return this.addPanel(void 0, true);
  }
  /**
   * Adds a new panel based on the [template](https://surveyjs.io/form-library/documentation/api-reference/dynamic-panel-model#template).
   * @param index *(Optional)* An index at which to insert the new panel. `undefined` adds the panel to the end or inserts it after the current panel if [`displayMode`](https://surveyjs.io/form-library/documentation/api-reference/dynamic-panel-model#renderMode) is `"tab"`. A negative index (for instance, -1) adds the panel to the end in all cases, regardless of the `displayMode` value.
   * @param runAdditionalActions *(Optional)* Pass `true` if you want to perform additional actions: check whether a new panel [can be added](https://surveyjs.io/form-library/documentation/api-reference/dynamic-panel-model#canAddPanel), expand and focus the new panel, and run animated effects. Default value: `false` (the listed actions are skipped).
   * @see panelCount
   * @see panels
   * @see allowAddPanel
   * @see newPanelPosition
   */
  addPanel(index, runAdditionalActions) {
    const isUI = runAdditionalActions === true;
    if (isUI) {
      if (!this.canAddPanel) return null;
      if (!this.canLeaveCurrentPanel()) return null;
    }
    const newPanel = this.addPanelCore(index);
    if (isUI) {
      if (this.displayMode === "list" && this.panelsState !== "default") {
        newPanel.expand();
      }
      this.focusNewPanelCallback = () => {
        newPanel.focusFirstQuestion();
      };
      if (!this.isPanelsAnimationRunning) {
        this.focusNewPanel();
      }
    }
    return newPanel;
  }
  addPanelCore(index) {
    const curIndex = this.currentIndex;
    if (index === void 0) {
      index = curIndex < 0 ? this.panelCount : curIndex + 1;
    }
    if (index < 0 || index > this.panelCount) {
      index = this.panelCount;
    }
    this.updateValueOnAddingPanel(curIndex < 0 ? this.panelCount - 1 : curIndex, index);
    if (!this.isRenderModeList) {
      this.currentIndex = index;
    }
    if (this.survey) this.survey.dynamicPanelAdded(this);
    return this.panelsCore[index];
  }
  focusNewPanel() {
    if (this.focusNewPanelCallback) {
      this.focusNewPanelCallback();
      this.focusNewPanelCallback = void 0;
    }
  }
  updateValueOnAddingPanel(prevIndex, index) {
    this.panelCount++;
    let newValue = this.value;
    if (!Array.isArray(newValue) || newValue.length !== this.panelCount) return;
    let hasModified = false;
    const lastIndex = this.panelCount - 1;
    if (index < lastIndex) {
      hasModified = true;
      const rec = newValue[lastIndex];
      newValue.splice(lastIndex, 1);
      newValue.splice(index, 0, rec);
    }
    if (!this.isValueEmpty(this.defaultPanelValue)) {
      hasModified = true;
      this.copyValue(newValue[index], this.defaultPanelValue);
    }
    if (this.copyDefaultValueFromLastEntry && newValue.length > 1) {
      const fromIndex = prevIndex > -1 && prevIndex <= lastIndex ? prevIndex : lastIndex;
      hasModified = true;
      this.copyValue(newValue[index], newValue[fromIndex]);
    }
    if (hasModified) {
      this.value = newValue;
    }
  }
  canLeaveCurrentPanel() {
    return !(this.displayMode !== "list" && this.currentPanel && this.currentPanel.hasErrors(true, true));
  }
  copyValue(dest, src) {
    for (var key in src) {
      dest[key] = src[key];
    }
  }
  getPanelRemoveButtonId(panel) {
    return panel.id + "_remove_button";
  }
  isRequireConfirmOnDelete(val) {
    if (!this.confirmDelete) return false;
    const index = this.getVisualPanelIndex(val);
    if (index < 0 || index >= this.visiblePanelCount) return false;
    const panelValue = this.visiblePanelsCore[index].getValue();
    return !this.isValueEmpty(panelValue) && (this.isValueEmpty(this.defaultPanelValue) || !this.isTwoValueEquals(panelValue, this.defaultPanelValue));
  }
  /**
   * Switches Dynamic Panel to the next panel. Returns `true` in case of success, or `false` if `displayMode` is `"list"` or the current panel contains validation errors.
   * @see displayMode
   */
  goToNextPanel() {
    if (this.currentIndex < 0) return false;
    if (!this.canLeaveCurrentPanel()) return false;
    this.currentIndex++;
    return true;
  }
  /**
   * Switches Dynamic Panel to the previous panel.
   */
  goToPrevPanel() {
    if (this.currentIndex < 0) return;
    this.currentIndex--;
  }
  /**
   * @deprecated Call the [`removePanel(value, true)`](https://surveyjs.io/form-library/documentation/api-reference/dynamic-panel-model#removePanel) method instead.
   */
  removePanelUI(value) {
    this.removePanel(value, this.isRequireConfirmOnDelete(value));
  }
  /**
   * Deletes a panel from the [`panels`](https://surveyjs.io/form-library/documentation/api-reference/dynamic-panel-model#panels) array.
   * @param value A `PanelModel` instance or zero-based panel index.
   * @param confirmDelete *(Optional)* Pass `true` if you want to perform additional actions: check whether the panel [can be removed](https://surveyjs.io/form-library/documentation/api-reference/dynamic-panel-model#canRemovePanel) and display a confirmation dialog.
   * @see addPanel
   */
  removePanel(value, confirmDelete) {
    const visIndex = this.getVisualPanelIndex(value);
    if (visIndex < 0 || visIndex >= this.visiblePanelCount) return;
    const isUI = confirmDelete !== void 0;
    if (isUI) {
      if (!this.canRemovePanel) return;
      const removePanel = () => {
        var _a;
        this.removePanelCore(visIndex);
        const pnlCount = this.visiblePanelCount;
        const nextIndex = visIndex >= pnlCount ? pnlCount - 1 : visIndex;
        let id = pnlCount === 0 ? this.addButtonId : nextIndex > -1 ? this.getPanelRemoveButtonId(this.visiblePanels[nextIndex]) : "";
        if (!!id) {
          SurveyElement.FocusElement(id, true, (_a = this.survey) === null || _a === void 0 ? void 0 : _a.rootElement);
        }
      };
      if (confirmDelete) {
        confirmActionAsync({
          message: this.confirmDeleteText,
          funcOnYes: () => {
            removePanel();
          },
          locale: this.getLocale(),
          rootElement: this.survey.rootElement,
          cssClass: this.cssClasses.confirmDialog
        });
      } else {
        removePanel();
      }
    } else {
      this.removePanelCore(visIndex);
    }
  }
  removePanelCore(visIndex) {
    this.removedPanelIndex = visIndex;
    const panel = this.visiblePanelsCore[visIndex];
    const index = this.panelsCore.indexOf(panel);
    if (index < 0) return;
    if (this.survey && !this.survey.dynamicPanelRemoving(this, index, panel)) return;
    this.panelsCore.splice(index, 1);
    this.updateBindings("panelCount", this.panelCount);
    var value = this.value;
    if (!value || !Array.isArray(value) || index >= value.length) return;
    this.isValueChangingInternally = true;
    value.splice(index, 1);
    this.value = value;
    this.updateFooterActions();
    this.fireCallback(this.panelCountChangedCallback);
    if (this.survey) this.survey.dynamicPanelRemoved(this, index, panel);
    this.isValueChangingInternally = false;
  }
  getVisualPanelIndex(val) {
    if (Helpers.isNumber(val)) return val;
    const visPanels = this.visiblePanelsCore;
    for (var i = 0; i < visPanels.length; i++) {
      if (visPanels[i] === val || visPanels[i].data === val) return i;
    }
    return -1;
  }
  getPanelVisibleIndexById(id) {
    const visPanels = this.visiblePanelsCore;
    for (var i = 0; i < visPanels.length; i++) {
      if (visPanels[i].id === id) return i;
    }
    return -1;
  }
  locStrsChanged() {
    super.locStrsChanged();
    var panels = this.panelsCore;
    for (var i = 0; i < panels.length; i++) {
      panels[i].locStrsChanged();
    }
    if (this.tabbedMenu) {
      this.tabbedMenu.locStrsChanged();
    }
  }
  clearIncorrectValues() {
    for (var i = 0; i < this.panelsCore.length; i++) {
      this.clearIncorrectValuesInPanel(i);
    }
  }
  clearErrors() {
    super.clearErrors();
    for (var i = 0; i < this.panelsCore.length; i++) {
      this.panelsCore[i].clearErrors();
    }
  }
  getQuestionFromArray(name, index) {
    if (index < 0 || index >= this.panelsCore.length) return null;
    return this.panelsCore[index].getQuestionByName(name);
  }
  clearIncorrectValuesInPanel(index) {
    var panel = this.panelsCore[index];
    panel.clearIncorrectValues();
    var val = this.value;
    var values = !!val && index < val.length ? val[index] : null;
    if (!values) return;
    var isChanged = false;
    for (var key in values) {
      if (this.getSharedQuestionFromArray(key, index)) continue;
      var q = panel.getQuestionByName(key);
      if (!!q) continue;
      if (this.iscorrectValueWithPostPrefix(panel, key, settings.commentSuffix) || this.iscorrectValueWithPostPrefix(panel, key, settings.matrix.totalsSuffix)) continue;
      delete values[key];
      isChanged = true;
    }
    if (isChanged) {
      val[index] = values;
      this.value = val;
    }
  }
  iscorrectValueWithPostPrefix(panel, key, postPrefix) {
    if (key.indexOf(postPrefix) !== key.length - postPrefix.length) return false;
    return !!panel.getQuestionByName(key.substring(0, key.indexOf(postPrefix)));
  }
  getSharedQuestionFromArray(name, panelIndex) {
    return !!this.survey && !!this.valueName ? this.survey.getQuestionByValueNameFromArray(this.valueName, name, panelIndex) : null;
  }
  addConditionObjectsByContext(objects, context) {
    const contextQ = !!(context === null || context === void 0 ? void 0 : context.isValidator) ? context.errorOwner : context;
    const hasContext = !!context && (context === true || this.template.questions.indexOf(contextQ) > -1);
    const panelObjs = new Array();
    const questions = this.template.questions;
    for (var i = 0; i < questions.length; i++) {
      questions[i].addConditionObjectsByContext(panelObjs, context);
    }
    for (var index = 0; index < settings.panel.maxPanelCountInCondition; index++) {
      const indexStr = "[" + index + "].";
      const prefixName = this.getValueName() + indexStr;
      const prefixText = this.processedTitle + indexStr;
      for (var i = 0; i < panelObjs.length; i++) {
        if (!!panelObjs[i].context) {
          objects.push(panelObjs[i]);
        } else {
          objects.push({
            name: prefixName + panelObjs[i].name,
            text: prefixText + panelObjs[i].text,
            question: panelObjs[i].question
          });
        }
      }
    }
    if (hasContext) {
      const prefixName = context === true ? this.getValueName() + "." : "";
      const prefixText = context === true ? this.processedTitle + "." : "";
      for (var i = 0; i < panelObjs.length; i++) {
        if (panelObjs[i].question == context) continue;
        const obj = {
          name: prefixName + QuestionPanelDynamicItem.ItemVariableName + "." + panelObjs[i].name,
          text: prefixText + QuestionPanelDynamicItem.ItemVariableName + "." + panelObjs[i].text,
          question: panelObjs[i].question
        };
        obj.context = this;
        objects.push(obj);
      }
    }
  }
  collectNestedQuestionsCore(questions, visibleOnly) {
    const panels = visibleOnly ? this.visiblePanelsCore : this.panelsCore;
    if (!Array.isArray(panels)) return;
    panels.forEach((panel) => {
      panel.questions.forEach((q) => q.collectNestedQuestions(questions, visibleOnly));
    });
  }
  getConditionJson(operator = null, path = null) {
    if (!path) return super.getConditionJson(operator);
    var questionName = path;
    var pos = path.indexOf(".");
    if (pos > -1) {
      questionName = path.substring(0, pos);
      path = path.substring(pos + 1);
    }
    var question = this.template.getQuestionByName(questionName);
    if (!question) return null;
    return question.getConditionJson(operator, path);
  }
  onReadOnlyChanged() {
    var readOnly = this.isReadOnly;
    this.template.readOnly = readOnly;
    for (var i = 0; i < this.panelsCore.length; i++) {
      this.panelsCore[i].readOnly = readOnly;
    }
    this.updateNoEntriesTextDefaultLoc();
    this.updateFooterActions();
    super.onReadOnlyChanged();
  }
  updateNoEntriesTextDefaultLoc() {
    const loc = this.getLocalizableString("noEntriesText");
    if (!loc) return;
    loc.localizationName = this.isReadOnly || !this.allowAddPanel ? "noEntriesReadonlyText" : "noEntriesText";
  }
  onSurveyLoad() {
    this.template.readOnly = this.isReadOnly;
    this.template.onSurveyLoad();
    if (this.panelCount < this.minPanelCount) {
      this.panelCount = this.minPanelCount;
    }
    if (this.panelCount > this.maxPanelCount) {
      this.panelCount = this.maxPanelCount;
    }
    this.buildPanelsFirstTime();
    super.onSurveyLoad();
  }
  buildPanelsFirstTime(force = false) {
    if (this.hasPanelBuildFirstTime) return;
    if (!force && this.wasNotRenderedInSurvey) return;
    this.blockAnimations();
    this.hasPanelBuildFirstTime = true;
    this.isBuildingPanelsFirstTime = true;
    if (this.getPropertyValue("panelCount") > 0) {
      this.panelCount = this.getPropertyValue("panelCount");
    }
    if (this.useTemplatePanel) {
      this.rebuildPanels();
    }
    this.setPanelsSurveyImpl();
    this.setPanelsState();
    this.assignOnPropertyChangedToTemplate();
    if (!!this.survey) {
      for (var i = 0; i < this.panelCount; i++) {
        this.survey.dynamicPanelAdded(this);
      }
    }
    this.updateIsReady();
    if (!this.showAddPanelButton) {
      this.updateNoEntriesTextDefaultLoc();
    }
    this.updateFooterActions();
    this.isBuildingPanelsFirstTime = false;
    this.releaseAnimations();
  }
  get showAddPanelButton() {
    return this.allowAddPanel && !this.isReadOnly;
  }
  get wasNotRenderedInSurvey() {
    return !this.hasPanelBuildFirstTime && !this.wasRendered && !!this.survey;
  }
  get canBuildPanels() {
    return !this.isLoadingFromJson && !this.useTemplatePanel;
  }
  onFirstRenderingCore() {
    super.onFirstRenderingCore();
    this.buildPanelsFirstTime();
    this.template.onFirstRendering();
    for (var i = 0; i < this.panelsCore.length; i++) {
      this.panelsCore[i].onFirstRendering();
    }
  }
  localeChanged() {
    super.localeChanged();
    for (var i = 0; i < this.panelsCore.length; i++) {
      this.panelsCore[i].localeChanged();
    }
  }
  runConditionCore(values, properties) {
    super.runConditionCore(values, properties);
    this.runPanelsCondition(this.panelsCore, values, properties);
  }
  runTriggers(name, value, keys) {
    super.runTriggers(name, value, keys);
    this.visiblePanelsCore.forEach((p) => {
      p.questions.forEach((q) => q.runTriggers(name, value, keys));
    });
  }
  reRunCondition() {
    if (!this.data) return;
    this.runCondition(this.getDataFilteredValues(), this.getDataFilteredProperties());
  }
  runPanelsCondition(panels, values, properties) {
    var cachedValues = {};
    if (values && values instanceof Object) {
      cachedValues = JSON.parse(JSON.stringify(values));
    }
    if (!!this.parentQuestion && !!this.parent) {
      cachedValues[QuestionPanelDynamicItem.ParentItemVariableName] = this.parent.getValue();
    }
    this.isValueChangingInternally = true;
    for (var i = 0; i < panels.length; i++) {
      const panel = panels[i];
      var panelValues = this.getPanelItemData(panel.data);
      const newValues = Helpers.createCopy(cachedValues);
      const panelName = QuestionPanelDynamicItem.ItemVariableName;
      newValues[panelName] = panelValues;
      newValues[QuestionPanelDynamicItem.IndexVariableName.toLowerCase()] = i;
      const newProps = Helpers.createCopy(properties);
      newProps[panelName] = panel;
      panel.runCondition(newValues, newProps);
    }
    this.isValueChangingInternally = false;
  }
  onAnyValueChanged(name, questionName) {
    super.onAnyValueChanged(name, questionName);
    for (var i = 0; i < this.panelsCore.length; i++) {
      this.panelsCore[i].onAnyValueChanged(name, questionName);
      this.panelsCore[i].onAnyValueChanged(QuestionPanelDynamicItem.ItemVariableName, "");
    }
  }
  hasKeysDuplicated(fireCallback, rec = null) {
    var keyValues = [];
    var res;
    for (var i = 0; i < this.panelsCore.length; i++) {
      res = this.isValueDuplicated(this.panelsCore[i], keyValues, rec, fireCallback) || res;
    }
    return res;
  }
  updatePanelsContainsErrors() {
    var question = this.changingValueQuestion;
    var parent = question.parent;
    while (!!parent) {
      parent.updateContainsErrors();
      parent = parent.parent;
    }
    this.updateContainsErrors();
  }
  hasErrors(fireCallback = true, rec = null) {
    if (this.isValueChangingInternally || this.isBuildingPanelsFirstTime) return false;
    var res = false;
    if (!!this.changingValueQuestion) {
      var res = this.changingValueQuestion.hasErrors(fireCallback, rec);
      res = this.hasKeysDuplicated(fireCallback, rec) || res;
      this.updatePanelsContainsErrors();
    } else {
      res = this.hasErrorInPanels(fireCallback, rec);
    }
    return super.hasErrors(fireCallback, rec) || res;
  }
  getContainsErrors() {
    var res = super.getContainsErrors();
    if (res) return res;
    var panels = this.panelsCore;
    for (var i = 0; i < panels.length; i++) {
      if (panels[i].containsErrors) return true;
    }
    return false;
  }
  getIsAnswered() {
    if (!super.getIsAnswered()) return false;
    var panels = this.visiblePanelsCore;
    for (var i = 0; i < panels.length; i++) {
      var visibleQuestions = [];
      panels[i].addQuestionsToList(visibleQuestions, true);
      for (var j = 0; j < visibleQuestions.length; j++) {
        if (!visibleQuestions[j].isAnswered) return false;
      }
    }
    return true;
  }
  clearValueOnHidding(isClearOnHidden) {
    if (!isClearOnHidden) {
      if (!!this.survey && this.survey.getQuestionClearIfInvisible("onHidden") === "none") return;
      this.clearValueInPanelsIfInvisible("onHiddenContainer");
    }
    super.clearValueOnHidding(isClearOnHidden);
  }
  clearValueIfInvisible(reason = "onHidden") {
    const panelReason = reason === "onHidden" ? "onHiddenContainer" : reason;
    this.clearValueInPanelsIfInvisible(panelReason);
    super.clearValueIfInvisible(reason);
  }
  clearValueInPanelsIfInvisible(reason) {
    for (var i = 0; i < this.panelsCore.length; i++) {
      const panel = this.panelsCore[i];
      var questions = panel.questions;
      this.isSetPanelItemData = {};
      for (var j = 0; j < questions.length; j++) {
        const q = questions[j];
        if (q.visible && !panel.isVisible) continue;
        q.clearValueIfInvisible(reason);
        this.isSetPanelItemData[q.getValueName()] = this.maxCheckCount + 1;
      }
    }
    this.isSetPanelItemData = {};
  }
  getIsRunningValidators() {
    if (super.getIsRunningValidators()) return true;
    for (var i = 0; i < this.panelsCore.length; i++) {
      var questions = this.panelsCore[i].questions;
      for (var j = 0; j < questions.length; j++) {
        if (questions[j].isRunningValidators) return true;
      }
    }
    return false;
  }
  getAllErrors() {
    var result = super.getAllErrors();
    const panels = this.visiblePanelsCore;
    for (var i = 0; i < panels.length; i++) {
      var questions = panels[i].questions;
      for (var j = 0; j < questions.length; j++) {
        var errors = questions[j].getAllErrors();
        if (errors && errors.length > 0) {
          result = result.concat(errors);
        }
      }
    }
    return result;
  }
  getDisplayValueCore(keysAsText, value) {
    var values = this.getUnbindValue(value);
    if (!values || !Array.isArray(values)) return values;
    for (var i = 0; i < this.panelsCore.length && i < values.length; i++) {
      var val = values[i];
      if (!val) continue;
      values[i] = this.getPanelDisplayValue(i, val, keysAsText);
    }
    return values;
  }
  getPanelDisplayValue(panelIndex, val, keysAsText) {
    if (!val) return val;
    var panel = this.panelsCore[panelIndex];
    var keys = Object.keys(val);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var question = panel.getQuestionByValueName(key);
      if (!question) {
        question = this.getSharedQuestionFromArray(key, panelIndex);
      }
      if (!!question) {
        var qValue = question.getDisplayValue(keysAsText, val[key]);
        val[key] = qValue;
        if (keysAsText && !!question.title && question.title !== key) {
          val[question.title] = qValue;
          delete val[key];
        }
      }
    }
    return val;
  }
  hasErrorInPanels(fireCallback, rec) {
    var res = false;
    var panels = this.visiblePanels;
    var keyValues = [];
    for (var i = 0; i < panels.length; i++) {
      this.setOnCompleteAsyncInPanel(panels[i]);
    }
    const focusOnError = !!rec && rec.focusOnFirstError;
    for (let i2 = 0; i2 < panels.length; i2++) {
      let pnlError = panels[i2].hasErrors(fireCallback, focusOnError, rec);
      pnlError = this.isValueDuplicated(panels[i2], keyValues, rec, fireCallback) || pnlError;
      if (!this.isRenderModeList && pnlError && !res && focusOnError) {
        this.currentIndex = i2;
      }
      res = pnlError || res;
    }
    return res;
  }
  setOnCompleteAsyncInPanel(panel) {
    var questions = panel.questions;
    for (var i = 0; i < questions.length; i++) {
      questions[i].onCompletedAsyncValidators = (hasErrors) => {
        this.raiseOnCompletedAsyncValidators();
      };
    }
  }
  isValueDuplicated(panel, keyValues, rec, fireCallback) {
    if (!this.keyName) return false;
    var question = panel.getQuestionByValueName(this.keyName);
    if (!question || question.isEmpty()) return false;
    var value = question.value;
    if (!!this.changingValueQuestion && question != this.changingValueQuestion) {
      question.hasErrors(fireCallback, rec);
    }
    for (var i = 0; i < keyValues.length; i++) {
      if (value == keyValues[i]) {
        if (fireCallback) {
          question.addError(new KeyDuplicationError(this.keyDuplicationError, this));
        }
        if (!!rec && !rec.firstErrorQuestion) {
          rec.firstErrorQuestion = question;
        }
        return true;
      }
    }
    keyValues.push(value);
    return false;
  }
  getPanelActions(panel) {
    let actions = panel.footerActions;
    if (this.removePanelButtonLocation !== "right") {
      actions.push(new Action({
        id: `remove-panel-${panel.id}`,
        component: "sv-paneldynamic-remove-btn",
        visible: new ComputedUpdater(() => [this.canRenderRemovePanel(panel, "bottom")].every((val) => val === true)),
        data: {
          question: this,
          panel
        }
      }));
    }
    if (!!this.survey) {
      actions = this.survey.getUpdatedPanelFooterActions(panel, actions, this);
    }
    return actions;
  }
  canRenderRemovePanelOnRight(panel) {
    return this.canRenderRemovePanel(panel, "right");
  }
  canRenderRemovePanel(panel, side) {
    const canRemove = this.canRemovePanel;
    const notCollpased = panel.state !== "collapsed";
    return this.removePanelButtonLocation === side && canRemove && notCollpased;
  }
  createNewPanel() {
    var panel = this.createAndSetupNewPanelObject();
    var json2 = this.template.toJSON();
    new JsonObject().toObject(json2, panel);
    panel.renderWidth = "100%";
    panel.updateCustomWidgets();
    new QuestionPanelDynamicItem(this, panel);
    if (!this.isDesignMode && !this.isReadOnly && !this.isValueEmpty(panel.getValue())) {
      this.runPanelsCondition([panel], this.getDataFilteredValues(), this.getDataFilteredProperties());
    }
    var questions = panel.questions;
    for (var i = 0; i < questions.length; i++) {
      questions[i].setParentQuestion(this);
    }
    if (this.wasRendered) {
      panel.onFirstRendering();
      panel.locStrsChanged();
    }
    panel.onGetFooterActionsCallback = () => {
      return this.getPanelActions(panel);
    };
    panel.onGetFooterToolbarCssCallback = () => {
      return this.cssClasses.panelFooter;
    };
    panel.registerPropertyChangedHandlers(["visible"], () => {
      if (panel.visible) this.onPanelAdded(panel);
      else this.onPanelRemoved(panel);
      this.updateFooterActions();
    });
    return panel;
  }
  createAndSetupNewPanelObject() {
    var panel = this.createNewPanelObject();
    panel.isInteractiveDesignElement = false;
    panel.setParentQuestion(this);
    panel.onGetQuestionTitleLocation = () => this.getTemplateQuestionTitleLocation();
    return panel;
  }
  getTemplateQuestionTitleLocation() {
    return this.templateQuestionTitleLocation != "default" ? this.templateQuestionTitleLocation : this.getTitleLocationCore();
  }
  getChildErrorLocation(child) {
    if (this.templateErrorLocation !== "default") return this.templateErrorLocation;
    return super.getChildErrorLocation(child);
  }
  createNewPanelObject() {
    return Serializer.createClass("panel");
  }
  setPanelCountBasedOnValue() {
    if (this.isValueChangingInternally || this.useTemplatePanel) return;
    var val = this.value;
    var newPanelCount = val && Array.isArray(val) ? val.length : 0;
    if (newPanelCount == 0 && this.getPropertyValue("panelCount") > 0) {
      newPanelCount = this.getPropertyValue("panelCount");
    }
    this.settingPanelCountBasedOnValue = true;
    this.panelCount = newPanelCount;
    this.settingPanelCountBasedOnValue = false;
  }
  setQuestionValue(newValue) {
    if (this.settingPanelCountBasedOnValue) return;
    super.setQuestionValue(newValue, false);
    this.setPanelCountBasedOnValue();
    for (var i = 0; i < this.panelsCore.length; i++) {
      this.panelUpdateValueFromSurvey(this.panelsCore[i]);
    }
    this.updateIsAnswered();
  }
  onSurveyValueChanged(newValue) {
    if (newValue === void 0 && this.isAllPanelsEmpty()) return;
    super.onSurveyValueChanged(newValue);
    for (var i = 0; i < this.panelsCore.length; i++) {
      this.panelSurveyValueChanged(this.panelsCore[i]);
    }
    if (newValue === void 0) {
      this.setValueBasedOnPanelCount();
    }
    this.updateIsReady();
  }
  isAllPanelsEmpty() {
    for (var i = 0; i < this.panelsCore.length; i++) {
      if (!Helpers.isValueEmpty(this.panelsCore[i].getValue())) return false;
    }
    return true;
  }
  panelUpdateValueFromSurvey(panel) {
    const questions = panel.questions;
    var values = this.getPanelItemData(panel.data);
    for (var i = 0; i < questions.length; i++) {
      const q = questions[i];
      q.updateValueFromSurvey(values[q.getValueName()]);
      q.updateCommentFromSurvey(values[q.getValueName() + settings.commentSuffix]);
      q.initDataUI();
    }
  }
  panelSurveyValueChanged(panel) {
    var questions = panel.questions;
    var values = this.getPanelItemData(panel.data);
    for (var i = 0; i < questions.length; i++) {
      var q = questions[i];
      q.onSurveyValueChanged(values[q.getValueName()]);
    }
  }
  onSetData() {
    super.onSetData();
    if (!this.isLoadingFromJson && this.useTemplatePanel) {
      this.setTemplatePanelSurveyImpl();
      this.rebuildPanels();
    }
  }
  isNewValueCorrect(val) {
    return Array.isArray(val);
  }
  //IQuestionPanelDynamicData
  getItemIndex(item) {
    var res = this.items.indexOf(item);
    return res > -1 ? res : this.items.length;
  }
  getVisibleItemIndex(item) {
    const visPanels = this.visiblePanelsCore;
    for (var i = 0; i < visPanels.length; i++) {
      if (visPanels[i].data === item) return i;
    }
    return visPanels.length;
  }
  getPanelItemData(item) {
    var items = this.items;
    var index = items.indexOf(item);
    var qValue = this.value;
    if (index < 0 && Array.isArray(qValue) && qValue.length > items.length) {
      index = items.length;
    }
    if (index < 0) return {};
    if (!qValue || !Array.isArray(qValue) || qValue.length <= index) return {};
    return qValue[index];
  }
  setPanelItemData(item, name, val) {
    if (this.isSetPanelItemData[name] > this.maxCheckCount) return;
    if (!this.isSetPanelItemData[name]) {
      this.isSetPanelItemData[name] = 0;
    }
    this.isSetPanelItemData[name]++;
    var items = this.items;
    var index = items.indexOf(item);
    if (index < 0) index = items.length;
    var qValue = this.getUnbindValue(this.value);
    if (!qValue || !Array.isArray(qValue)) {
      qValue = [];
    }
    if (qValue.length <= index) {
      for (var i = qValue.length; i <= index; i++) {
        qValue.push({});
      }
    }
    if (!qValue[index]) qValue[index] = {};
    const oldVal = qValue[index][name];
    if (!this.isValueEmpty(val)) {
      qValue[index][name] = val;
    } else {
      delete qValue[index][name];
    }
    if (index >= 0 && index < this.panelsCore.length) {
      this.changingValueQuestion = this.panelsCore[index].getQuestionByValueName(name);
    }
    const options = {
      panel: item.panel,
      name,
      panelIndex: index,
      panelData: qValue[index],
      value: val,
      oldValue: oldVal
    };
    if (this.survey) {
      this.survey.dynamicPanelItemValueChanging(this, options);
    }
    this.value = qValue;
    this.changingValueQuestion = null;
    if (this.survey) {
      this.survey.dynamicPanelItemValueChanged(this, options);
    }
    this.isSetPanelItemData[name]--;
    if (this.isSetPanelItemData[name] - 1) {
      delete this.isSetPanelItemData[name];
    }
  }
  getRootData() {
    return this.data;
  }
  getPlainData(options = {
    includeEmpty: true
  }) {
    var questionPlainData = super.getPlainData(options);
    if (!!questionPlainData) {
      questionPlainData.isNode = true;
      const prevData = Array.isArray(questionPlainData.data) ? [].concat(questionPlainData.data) : [];
      questionPlainData.data = this.panels.map((panel, index) => {
        var panelDataItem = {
          name: panel.name || index,
          title: panel.title || "Panel",
          value: panel.getValue(),
          displayValue: panel.getValue(),
          getString: (val) => typeof val === "object" ? JSON.stringify(val) : val,
          isNode: true,
          data: panel.questions.map((question) => question.getPlainData(options)).filter((d) => !!d)
        };
        (options.calculations || []).forEach((calculation) => {
          panelDataItem[calculation.propertyName] = panel[calculation.propertyName];
        });
        return panelDataItem;
      });
      questionPlainData.data = questionPlainData.data.concat(prevData);
    }
    return questionPlainData;
  }
  updateElementCss(reNew) {
    super.updateElementCss(reNew);
    for (var i = 0; i < this.panelsCore.length; i++) {
      var el = this.panelsCore[i];
      el.updateElementCss(reNew);
    }
  }
  get progressText() {
    var rangeMax = this.visiblePanelCount;
    return this.getLocalizationFormatString("panelDynamicProgressText", this.currentIndex + 1, rangeMax);
  }
  get progress() {
    return (this.currentIndex + 1) / this.visiblePanelCount * 100 + "%";
  }
  getRootCss() {
    return new CssClassBuilder().append(super.getRootCss()).append(this.cssClasses.empty, this.getShowNoEntriesPlaceholder()).toString();
  }
  get cssHeader() {
    const showTab = this.isRenderModeTab && !!this.visiblePanelCount;
    return new CssClassBuilder().append(super.getCssHeader(this.cssClasses)).append(this.cssClasses.headerTab, this.hasTitleOnTop && showTab).toString();
  }
  getTabsContainerCss() {
    return new CssClassBuilder().append(this.cssClasses.tabsContainer).append(this.cssClasses.tabsContainerWithHeader, this.hasTitleOnTop).toString();
  }
  getPanelWrapperCss(panel) {
    return new CssClassBuilder().append(this.cssClasses.panelWrapper, !panel || panel.visible).append(this.cssClasses.panelWrapperList, this.isRenderModeList).append(this.cssClasses.panelWrapperInRow, this.removePanelButtonLocation === "right").toString();
  }
  getPanelRemoveButtonCss() {
    return new CssClassBuilder().append(this.cssClasses.button).append(this.cssClasses.buttonRemove).append(this.cssClasses.buttonRemoveRight, this.removePanelButtonLocation === "right").toString();
  }
  getAddButtonCss() {
    return new CssClassBuilder().append(this.cssClasses.button).append(this.cssClasses.buttonAdd).append(this.cssClasses.buttonAdd + "--list-mode", this.displayMode === "list").toString();
  }
  getPrevButtonCss() {
    return new CssClassBuilder().append(this.cssClasses.buttonPrev).append(this.cssClasses.buttonPrevDisabled, !this.isPrevButtonVisible).toString();
  }
  getNextButtonCss() {
    return new CssClassBuilder().append(this.cssClasses.buttonNext).append(this.cssClasses.buttonNextDisabled, !this.isNextButtonVisible).toString();
  }
  /**
   * A text displayed when Dynamic Panel contains no entries.
   */
  get noEntriesText() {
    return this.getLocalizableStringText("noEntriesText");
  }
  set noEntriesText(val) {
    this.setLocalizableStringText("noEntriesText", val);
  }
  get locNoEntriesText() {
    return this.getLocalizableString("noEntriesText");
  }
  getShowNoEntriesPlaceholder() {
    return !!this.cssClasses.noEntriesPlaceholder && !this.isDesignMode && this.visiblePanelCount === 0;
  }
  needResponsiveWidth() {
    const panel = this.getPanel();
    if (!!panel && panel.needResponsiveWidth()) return true;
    return false;
  }
  get hasTabbedMenu() {
    return this.isRenderModeTab && this.visiblePanels.length > 0;
  }
  get tabbedMenu() {
    if (!this.isRenderModeTab) return null;
    if (!this.tabbedMenuValue) {
      this.tabbedMenuValue = new AdaptiveActionContainer();
      this.tabbedMenuValue.dotsItem.popupModel.showPointer = false;
      this.tabbedMenuValue.dotsItem.popupModel.verticalPosition = "bottom";
      this.tabbedMenuValue.dotsItem.popupModel.horizontalPosition = "center";
      this.updateElementCss(false);
    }
    return this.tabbedMenuValue;
  }
  get footerToolbar() {
    if (!this.footerToolbarValue) {
      this.initFooterToolbar();
    }
    return this.footerToolbarValue;
  }
  updateFooterActions() {
    if (!!this.updateFooterActionsCallback) {
      this.updateFooterActionsCallback();
    }
  }
  initFooterToolbar() {
    this.footerToolbarValue = this.createActionContainer();
    const items = [];
    const prevTextBtn = new Action({
      id: "sv-pd-prev-btn",
      title: this.prevPanelText,
      action: () => {
        this.goToPrevPanel();
      }
    });
    const nextTextBtn = new Action({
      id: "sv-pd-next-btn",
      title: this.nextPanelText,
      action: () => {
        this.goToNextPanel();
      }
    });
    const addBtn = new Action({
      id: "sv-pd-add-btn",
      component: "sv-paneldynamic-add-btn",
      data: {
        question: this
      }
    });
    const prevBtnIcon = new Action({
      id: "sv-prev-btn-icon",
      component: "sv-paneldynamic-prev-btn",
      data: {
        question: this
      }
    });
    const progressText = new Action({
      id: "sv-pd-progress-text",
      component: "sv-paneldynamic-progress-text",
      data: {
        question: this
      }
    });
    const nextBtnIcon = new Action({
      id: "sv-pd-next-btn-icon",
      component: "sv-paneldynamic-next-btn",
      data: {
        question: this
      }
    });
    items.push(prevTextBtn, nextTextBtn, addBtn, prevBtnIcon, progressText, nextBtnIcon);
    this.updateFooterActionsCallback = () => {
      const isLegacyNavigation = this.legacyNavigation;
      const isRenderModeList = this.isRenderModeList;
      const isMobile = this.isMobile;
      const showNavigation = !isLegacyNavigation && !isRenderModeList;
      prevTextBtn.visible = showNavigation && this.currentIndex > 0;
      nextTextBtn.visible = showNavigation && this.currentIndex < this.visiblePanelCount - 1;
      nextTextBtn.needSpace = isMobile && nextTextBtn.visible && prevTextBtn.visible;
      addBtn.visible = this.canAddPanel;
      addBtn.needSpace = this.isMobile && !nextTextBtn.visible && prevTextBtn.visible;
      progressText.visible = !this.isRenderModeList && !isMobile;
      progressText.needSpace = !isLegacyNavigation && !this.isMobile;
      const showLegacyNavigation = isLegacyNavigation && !isRenderModeList;
      prevBtnIcon.visible = showLegacyNavigation;
      nextBtnIcon.visible = showLegacyNavigation;
      prevBtnIcon.needSpace = showLegacyNavigation;
    };
    this.updateFooterActionsCallback();
    this.footerToolbarValue.setItems(items);
  }
  createTabByPanel(panel, visPanelIndex) {
    if (!this.isRenderModeTab) return;
    const locTitle = new LocalizableString(panel, true);
    locTitle.onGetTextCallback = (str) => {
      if (!str) {
        str = this.locTabTitlePlaceholder.renderedHtml;
      }
      if (!this.survey) return str;
      const options = {
        title: str,
        panel,
        visiblePanelIndex: visPanelIndex
      };
      this.survey.dynamicPanelGetTabTitle(this, options);
      return options.title;
    };
    locTitle.sharedData = this.locTemplateTabTitle;
    const panelId = panel.id;
    const isActive = this.getPanelVisibleIndexById(panelId) === this.currentIndex;
    const newItem = new PanelDynamicTabbedMenuItem({
      id: `${this.id}_tab_${panelId}`,
      panelId,
      pressed: isActive,
      locTitle,
      disableHide: isActive,
      action: () => {
        this.currentIndex = this.getPanelVisibleIndexById(panelId);
      }
    });
    return newItem;
  }
  getTabbedMenuCss(cssClasses) {
    const css = cssClasses !== null && cssClasses !== void 0 ? cssClasses : this.cssClasses;
    return new CssClassBuilder().append(css.tabsRoot).append(css.tabsLeft, this.tabAlign === "left").append(css.tabsRight, this.tabAlign === "right").append(css.tabsCenter, this.tabAlign === "center").toString();
  }
  updateTabToolbarItemsPressedState() {
    if (!this.isRenderModeTab) return;
    if (this.currentIndex < 0 || this.currentIndex >= this.visiblePanelCount) return;
    const panel = this.visiblePanelsCore[this.currentIndex];
    this.tabbedMenu.renderedActions.forEach((action) => {
      const isActive = action.panelId === panel.id;
      action.pressed = isActive;
      action.disableHide = isActive;
      if (action.mode === "popup" && action.disableHide) {
        action["raiseUpdate"]();
      }
    });
  }
  updateTabToolbar() {
    if (!this.isRenderModeTab) return;
    const items = [];
    const visPanels = this.visiblePanelsCore;
    for (let i = 0; i < visPanels.length; i++) {
      this.visiblePanelsCore.forEach((panel) => items.push(this.createTabByPanel(visPanels[i], i)));
    }
    this.tabbedMenu.setItems(items);
  }
  addTabFromToolbar(panel, index) {
    if (!this.isRenderModeTab) return;
    const newItem = this.createTabByPanel(panel, index);
    this.tabbedMenu.actions.splice(index, 0, newItem);
    this.updateTabToolbarItemsPressedState();
  }
  removeTabFromToolbar(panel) {
    if (!this.isRenderModeTab) return;
    const removedItem = this.tabbedMenu.actions.find((a) => a.panelId == panel.id);
    if (!removedItem) return;
    this.tabbedMenu.actions.splice(this.tabbedMenu.actions.indexOf(removedItem), 1);
    this.updateTabToolbarItemsPressedState();
  }
  get showLegacyNavigation() {
    return !this.isDefaultV2Theme;
  }
  get showNavigation() {
    if (this.isReadOnly && this.visiblePanelCount == 1) return false;
    return this.visiblePanelCount > 0 && !this.showLegacyNavigation && !!this.cssClasses.footer;
  }
  showSeparator(index) {
    return this.isRenderModeList && index < this.renderedPanels.length - 1;
  }
  calcCssClasses(css) {
    const classes = super.calcCssClasses(css);
    const tabbedMenu = this.tabbedMenu;
    if (!!tabbedMenu) {
      tabbedMenu.containerCss = this.getTabbedMenuCss(classes);
      tabbedMenu.cssClasses = classes.tabs;
      tabbedMenu.dotsItem.cssClasses = classes.tabs;
      tabbedMenu.dotsItem.popupModel.contentComponentData.model.cssClasses = css.list;
    }
    return classes;
  }
  onMobileChanged() {
    super.onMobileChanged();
    this.updateFooterActions();
  }
};
QuestionPanelDynamicModel.maxCheckCount = 3;
__decorate([propertyArray({})], QuestionPanelDynamicModel.prototype, "_renderedPanels", void 0);
__decorate([property({
  onSet: (val, target) => {
    target.fireCallback(target.renderModeChangedCallback);
    target.updatePanelView();
  }
})], QuestionPanelDynamicModel.prototype, "displayMode", void 0);
__decorate([property({
  onSet: (val, target) => {
    target.fireCallback(target.currentIndexChangedCallback);
  }
})], QuestionPanelDynamicModel.prototype, "showProgressBar", void 0);
__decorate([property({
  onSet: (val, target) => {
  }
})], QuestionPanelDynamicModel.prototype, "progressBarLocation", void 0);
__decorate([property({
  defaultValue: false,
  onSet: (_, target) => {
    target.updateFooterActions();
  }
})], QuestionPanelDynamicModel.prototype, "legacyNavigation", void 0);
Serializer.addClass("paneldynamic", [{
  name: "showCommentArea:switch",
  layout: "row",
  visible: true,
  category: "general"
}, {
  name: "templateElements",
  alternativeName: "questions",
  baseClassName: "question",
  visible: false,
  isLightSerializable: false
}, {
  name: "templateTitle:text",
  serializationProperty: "locTemplateTitle"
}, {
  name: "templateTabTitle",
  serializationProperty: "locTemplateTabTitle",
  visibleIf: (obj) => {
    return obj.displayMode === "tab";
  }
}, {
  name: "tabTitlePlaceholder",
  serializationProperty: "locTabTitlePlaceholder",
  visibleIf: (obj) => {
    return obj.displayMode === "tab";
  }
}, {
  name: "templateDescription:text",
  serializationProperty: "locTemplateDescription"
}, {
  name: "minWidth",
  defaultFunc: () => "auto"
}, {
  name: "noEntriesText:text",
  serializationProperty: "locNoEntriesText"
}, {
  name: "allowAddPanel:boolean",
  default: true
}, {
  name: "allowRemovePanel:boolean",
  default: true
}, {
  name: "newPanelPosition",
  choices: ["next", "last"],
  default: "last",
  category: "layout"
}, {
  name: "panelCount:number",
  isBindable: true,
  default: 0,
  choices: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
}, {
  name: "minPanelCount:number",
  default: 0,
  minValue: 0
}, {
  name: "maxPanelCount:number",
  defaultFunc: () => settings.panel.maxPanelCount
}, "defaultPanelValue:panelvalue", {
  name: "copyDefaultValueFromLastEntry:boolean",
  alternativeName: "defaultValueFromLastPanel"
}, {
  name: "panelsState",
  default: "default",
  choices: ["default", "collapsed", "expanded", "firstExpanded"],
  visibleIf: (obj) => {
    return obj.displayMode === "list";
  }
}, {
  name: "keyName"
}, {
  name: "keyDuplicationError",
  serializationProperty: "locKeyDuplicationError"
}, {
  name: "confirmDelete:boolean"
}, {
  name: "confirmDeleteText",
  serializationProperty: "locConfirmDeleteText",
  visibleIf: (obj) => {
    return obj.confirmDelete;
  }
}, {
  name: "addPanelText",
  alternativeName: "panelAddText",
  serializationProperty: "locAddPanelText",
  visibleIf: (obj) => {
    return obj.allowAddPanel;
  }
}, {
  name: "removePanelText",
  alternativeName: "panelRemoveText",
  serializationProperty: "locRemovePanelText",
  visibleIf: (obj) => {
    return obj.allowRemovePanel;
  }
}, {
  name: "prevPanelText",
  alternativeName: "panelPrevText",
  serializationProperty: "locPrevPanelText",
  visibleIf: (obj) => {
    return obj.displayMode !== "list";
  }
}, {
  name: "nextPanelText",
  alternativeName: "panelNextText",
  serializationProperty: "locNextPanelText",
  visibleIf: (obj) => {
    return obj.displayMode !== "list";
  }
}, {
  name: "showQuestionNumbers",
  default: "off",
  choices: ["off", "onPanel", "onSurvey"]
}, {
  name: "renderMode",
  visible: false,
  isSerializable: false
}, {
  name: "displayMode",
  default: "list",
  choices: ["list", "carousel", "tab"]
}, {
  name: "showProgressBar:boolean",
  alternativeName: "showRangeInProgress",
  default: true,
  visibleIf: (obj) => {
    return obj.displayMode === "carousel";
  }
}, {
  name: "progressBarLocation",
  default: "top",
  choices: ["top", "bottom", "topBottom"],
  visibleIf: (obj) => {
    return obj.showProgressBar && obj.displayMode === "carousel";
  }
}, {
  name: "tabAlign",
  default: "center",
  choices: ["left", "center", "right"],
  visibleIf: (obj) => {
    return obj.displayMode === "tab";
  }
}, {
  name: "templateQuestionTitleLocation",
  alternativeName: "questionTitleLocation",
  default: "default",
  choices: ["default", "top", "bottom", "left"]
}, {
  name: "templateErrorLocation",
  default: "default",
  choices: ["default", "top", "bottom"]
}, {
  name: "templateVisibleIf:expression",
  category: "logic"
}, {
  name: "removePanelButtonLocation",
  alternativeName: "panelRemoveButtonLocation",
  default: "bottom",
  choices: ["bottom", "right"],
  visibleIf: (obj) => {
    return obj.allowRemovePanel;
  }
}], function() {
  return new QuestionPanelDynamicModel("");
}, "question");
QuestionFactory.Instance.registerQuestion("paneldynamic", (name) => {
  return new QuestionPanelDynamicModel(name);
});
var SurveyProgressModel = class {
  static getProgressTextInBarCss(css) {
    return new CssClassBuilder().append(css.progressText).append(css.progressTextInBar).toString();
  }
  static getProgressTextUnderBarCss(css) {
    return new CssClassBuilder().append(css.progressText).append(css.progressTextUnderBar).toString();
  }
};
var Trigger = class _Trigger extends Base {
  static get operators() {
    if (_Trigger.operatorsValue != null) return _Trigger.operatorsValue;
    _Trigger.operatorsValue = {
      empty: function(value, expectedValue) {
        return !value;
      },
      notempty: function(value, expectedValue) {
        return !!value;
      },
      equal: function(value, expectedValue) {
        return value == expectedValue;
      },
      notequal: function(value, expectedValue) {
        return value != expectedValue;
      },
      contains: function(value, expectedValue) {
        return value && value["indexOf"] && value.indexOf(expectedValue) > -1;
      },
      notcontains: function(value, expectedValue) {
        return !value || !value["indexOf"] || value.indexOf(expectedValue) == -1;
      },
      greater: function(value, expectedValue) {
        return value > expectedValue;
      },
      less: function(value, expectedValue) {
        return value < expectedValue;
      },
      greaterorequal: function(value, expectedValue) {
        return value >= expectedValue;
      },
      lessorequal: function(value, expectedValue) {
        return value <= expectedValue;
      }
    };
    return _Trigger.operatorsValue;
  }
  constructor() {
    super();
    this.idValue = _Trigger.idCounter++;
    this.registerPropertyChangedHandlers(["operator", "value", "name"], () => {
      this.oldPropertiesChanged();
    });
    this.registerPropertyChangedHandlers(["expression"], () => {
      this.onExpressionChanged();
    });
  }
  get id() {
    return this.idValue;
  }
  getType() {
    return "triggerbase";
  }
  toString() {
    var res = this.getType().replace("trigger", "");
    var exp = !!this.expression ? this.expression : this.buildExpression();
    if (exp) {
      res += ", " + exp;
    }
    return res;
  }
  get isInternal() {
    return this.isGhost === true;
  }
  get operator() {
    return this.getPropertyValue("operator", "equal");
  }
  set operator(value) {
    if (!value) return;
    value = value.toLowerCase();
    if (!_Trigger.operators[value]) return;
    this.setPropertyValue("operator", value);
  }
  get value() {
    return this.getPropertyValue("value", null);
  }
  set value(val) {
    this.setPropertyValue("value", val);
  }
  get name() {
    return this.getPropertyValue("name", "");
  }
  set name(val) {
    this.setPropertyValue("name", val);
  }
  get expression() {
    return this.getPropertyValue("expression", "");
  }
  set expression(val) {
    this.setPropertyValue("expression", val);
  }
  canBeExecuted(isOnNextPage) {
    return true;
  }
  canBeExecutedOnComplete() {
    return false;
  }
  checkExpression(options) {
    this.isExecutingOnNextPage = options.isOnNextPage;
    this.isExecutingOnNavigation = options.isOnNavigation || options.isOnNextPage;
    if (!this.canBeExecuted(options.isOnNextPage)) return;
    if (options.isOnComplete && !this.canBeExecutedOnComplete()) return;
    if (!this.isCheckRequired(options.keys)) return;
    if (!!this.conditionRunner) {
      this.perform(options.values, options.properties || null);
    } else {
      if (this.canSuccessOnEmptyExpression()) {
        this.triggerResult(true, options.values, options.properties || null);
      }
    }
  }
  canSuccessOnEmptyExpression() {
    return false;
  }
  check(value) {
    var triggerResult = _Trigger.operators[this.operator](value, this.value);
    if (triggerResult) {
      this.onSuccess({}, null);
    } else {
      this.onFailure();
    }
  }
  get requireValidQuestion() {
    return false;
  }
  perform(values, properties) {
    this.conditionRunner.onRunComplete = (res) => {
      this.triggerResult(res, values, properties);
    };
    this.conditionRunner.run(values, properties);
  }
  triggerResult(res, values, properties) {
    if (res) {
      this.onSuccess(values, properties);
      this.onSuccessExecuted();
    } else {
      this.onFailure();
    }
  }
  onSuccess(values, properties) {
  }
  onFailure() {
  }
  onSuccessExecuted() {
  }
  endLoadingFromJson() {
    super.endLoadingFromJson();
    this.oldPropertiesChanged();
  }
  oldPropertiesChanged() {
    this.onExpressionChanged();
  }
  onExpressionChanged() {
    this.conditionRunner = null;
  }
  buildExpression() {
    if (!this.name) return "";
    if (this.isValueEmpty(this.value) && this.isRequireValue) return "";
    return "{" + this.name + "} " + this.operator + " " + OperandMaker.toOperandString(this.value);
  }
  isCheckRequired(keys) {
    if (!keys) return false;
    this.createConditionRunner();
    if (this.conditionRunner && this.conditionRunner.hasFunction() === true) return true;
    return new ProcessValue().isAnyKeyChanged(keys, this.getUsedVariables());
  }
  getUsedVariables() {
    if (!this.conditionRunner) return [];
    const res = this.conditionRunner.getVariables();
    if (Array.isArray(res)) {
      const unw = "-unwrapped";
      for (let i = res.length - 1; i >= 0; i--) {
        const s = res[i];
        if (s.endsWith(unw)) {
          res.push(s.substring(0, s.length - unw.length));
        }
      }
    }
    return res;
  }
  createConditionRunner() {
    if (!!this.conditionRunner) return;
    var expression = this.expression;
    if (!expression) {
      expression = this.buildExpression();
    }
    if (!expression) return;
    this.conditionRunner = new ConditionRunner(expression);
  }
  get isRequireValue() {
    return this.operator !== "empty" && this.operator != "notempty";
  }
};
Trigger.idCounter = 1;
Trigger.operatorsValue = null;
var SurveyTrigger = class extends Trigger {
  constructor() {
    super();
    this.ownerValue = null;
  }
  get owner() {
    return this.ownerValue;
  }
  setOwner(owner) {
    this.ownerValue = owner;
  }
  getSurvey(live = false) {
    return !!this.owner && !!this.owner["getSurvey"] ? this.owner.getSurvey() : null;
  }
  isRealExecution() {
    return true;
  }
  onSuccessExecuted() {
    if (!!this.owner && this.isRealExecution()) {
      this.owner.triggerExecuted(this);
    }
  }
};
var SurveyTriggerVisible = class extends SurveyTrigger {
  constructor() {
    super();
    this.pages = [];
    this.questions = [];
  }
  getType() {
    return "visibletrigger";
  }
  onSuccess(values, properties) {
    this.onTrigger(this.onItemSuccess);
  }
  onFailure() {
    this.onTrigger(this.onItemFailure);
  }
  onTrigger(func) {
    if (!this.owner) return;
    var objects = this.owner.getObjects(this.pages, this.questions);
    for (var i = 0; i < objects.length; i++) {
      func(objects[i]);
    }
  }
  onItemSuccess(item) {
    item.visible = true;
  }
  onItemFailure(item) {
    item.visible = false;
  }
};
var SurveyTriggerComplete = class extends SurveyTrigger {
  constructor() {
    super();
  }
  getType() {
    return "completetrigger";
  }
  get requireValidQuestion() {
    return true;
  }
  isRealExecution() {
    return !settings.triggers.executeCompleteOnValueChanged === this.isExecutingOnNavigation;
  }
  onSuccess(values, properties) {
    if (!this.owner) return;
    if (this.isRealExecution()) {
      this.owner.setCompleted(this);
    } else {
      this.owner.canBeCompleted(this, true);
    }
  }
  onFailure() {
    this.owner.canBeCompleted(this, false);
  }
};
var SurveyTriggerSetValue = class extends SurveyTrigger {
  constructor() {
    super();
  }
  getType() {
    return "setvaluetrigger";
  }
  canBeExecuted(isOnNextPage) {
    return !isOnNextPage && !!this.setToName;
  }
  onPropertyValueChanged(name, oldValue, newValue) {
    super.onPropertyValueChanged(name, oldValue, newValue);
    if (name !== "setToName") return;
    var survey = this.getSurvey();
    if (survey && !survey.isLoadingFromJson && survey.isDesignMode) {
      this.setValue = void 0;
    }
  }
  get setToName() {
    return this.getPropertyValue("setToName", "");
  }
  set setToName(val) {
    this.setPropertyValue("setToName", val);
  }
  get setValue() {
    return this.getPropertyValue("setValue");
  }
  set setValue(val) {
    this.setPropertyValue("setValue", val);
  }
  get isVariable() {
    return this.getPropertyValue("isVariable");
  }
  set isVariable(val) {
    this.setPropertyValue("isVariable", val);
  }
  onSuccess(values, properties) {
    if (!this.setToName || !this.owner) return;
    this.owner.setTriggerValue(this.setToName, this.setValue, this.isVariable);
  }
};
var SurveyTriggerSkip = class extends SurveyTrigger {
  constructor() {
    super();
  }
  getType() {
    return "skiptrigger";
  }
  get requireValidQuestion() {
    return this.canBeExecuted(false);
  }
  get gotoName() {
    return this.getPropertyValue("gotoName", "");
  }
  set gotoName(val) {
    this.setPropertyValue("gotoName", val);
  }
  canBeExecuted(isOnNextPage) {
    return isOnNextPage === !settings.triggers.executeSkipOnValueChanged;
  }
  onSuccess(values, properties) {
    if (!this.gotoName || !this.owner) return;
    this.owner.focusQuestion(this.gotoName);
  }
};
var SurveyTriggerRunExpression = class extends SurveyTrigger {
  constructor() {
    super();
  }
  getType() {
    return "runexpressiontrigger";
  }
  get setToName() {
    return this.getPropertyValue("setToName", "");
  }
  set setToName(val) {
    this.setPropertyValue("setToName", val);
  }
  get runExpression() {
    return this.getPropertyValue("runExpression", "");
  }
  set runExpression(val) {
    this.setPropertyValue("runExpression", val);
  }
  canBeExecuted(isOnNextPage) {
    return !isOnNextPage;
  }
  onSuccess(values, properties) {
    if (!this.owner || !this.runExpression) return;
    var expression = new ExpressionRunner(this.runExpression);
    if (expression.canRun) {
      expression.onRunComplete = (res) => {
        this.onCompleteRunExpression(res);
      };
      expression.run(values, properties);
    }
  }
  onCompleteRunExpression(newValue) {
    if (!!this.setToName && newValue !== void 0) {
      this.owner.setTriggerValue(this.setToName, Helpers.convertValToQuestionVal(newValue), false);
    }
  }
};
var SurveyTriggerCopyValue = class extends SurveyTrigger {
  constructor() {
    super();
  }
  canBeExecuted(isOnNextPage) {
    return !isOnNextPage && !!this.setToName && !!this.fromName;
  }
  get setToName() {
    return this.getPropertyValue("setToName", "");
  }
  set setToName(val) {
    this.setPropertyValue("setToName", val);
  }
  get fromName() {
    return this.getPropertyValue("fromName", "");
  }
  set fromName(val) {
    this.setPropertyValue("fromName", val);
  }
  get copyDisplayValue() {
    return this.getPropertyValue("copyDisplayValue");
  }
  set copyDisplayValue(val) {
    this.setPropertyValue("copyDisplayValue", val);
  }
  getType() {
    return "copyvaluetrigger";
  }
  onSuccess(values, properties) {
    if (!this.setToName || !this.owner) return;
    this.owner.copyTriggerValue(this.setToName, this.fromName, this.copyDisplayValue);
  }
  canSuccessOnEmptyExpression() {
    return true;
  }
  getUsedVariables() {
    const res = super.getUsedVariables();
    if (res.length === 0 && !!this.fromName) {
      res.push(this.fromName);
    }
    return res;
  }
};
Serializer.addClass("trigger", [{
  name: "operator",
  default: "equal",
  visible: false
}, {
  name: "value",
  visible: false
}, "expression:condition"]);
Serializer.addClass("surveytrigger", [{
  name: "name",
  visible: false
}], null, "trigger");
Serializer.addClass("visibletrigger", ["pages:pages", "questions:questions"], function() {
  return new SurveyTriggerVisible();
}, "surveytrigger");
Serializer.addClass("completetrigger", [], function() {
  return new SurveyTriggerComplete();
}, "surveytrigger");
Serializer.addClass("setvaluetrigger", [{
  name: "!setToName:questionvalue"
}, {
  name: "setValue:triggervalue",
  dependsOn: "setToName",
  visibleIf: function(obj) {
    return !!obj && !!obj["setToName"];
  }
}, {
  name: "isVariable:boolean",
  visible: false
}], function() {
  return new SurveyTriggerSetValue();
}, "surveytrigger");
Serializer.addClass("copyvaluetrigger", [{
  name: "!fromName:questionvalue"
}, {
  name: "!setToName:questionvalue"
}, {
  name: "copyDisplayValue:boolean",
  visible: false
}], function() {
  return new SurveyTriggerCopyValue();
}, "surveytrigger");
Serializer.addClass("skiptrigger", [{
  name: "!gotoName:question"
}], function() {
  return new SurveyTriggerSkip();
}, "surveytrigger");
Serializer.addClass("runexpressiontrigger", [{
  name: "setToName:questionvalue"
}, "runExpression:expression"], function() {
  return new SurveyTriggerRunExpression();
}, "surveytrigger");
var PopupSurveyModel = class extends Base {
  constructor(jsonObj, initialModel = null) {
    super();
    this.closeOnCompleteTimeout = 0;
    if (initialModel) {
      this.surveyValue = initialModel;
    } else {
      this.surveyValue = this.createSurvey(jsonObj);
    }
    this.surveyValue.fitToContainer = true;
    this.windowElement = DomDocumentHelper.createElement("div");
    this.survey.onComplete.add((survey, options) => {
      this.onSurveyComplete();
    });
    this.registerPropertyChangedHandlers(["isShowing"], () => {
      if (!!this.showingChangedCallback) this.showingChangedCallback();
    });
    this.registerPropertyChangedHandlers(["isExpanded"], () => {
      this.onExpandedChanged();
    });
    this.width = new ComputedUpdater(() => this.survey.width);
    this.width = this.survey.width;
    this.updateCss();
    this.onCreating();
  }
  onCreating() {
  }
  getType() {
    return "popupsurvey";
  }
  /**
   * A [`SurveyModel`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model) instance rendered in the pop-up window.
   */
  get survey() {
    return this.surveyValue;
  }
  /**
   * Indicates whether the pop-up survey appears on the page, regardless of its [expand state](#isExpanded).
   *
   * You can set this property to `true` or `false` to control visibility of the pop-up survey. Alternatively, you can use the [`show()`](#show) and [`hide()`](#hide) methods.
   */
  get isShowing() {
    return this.getPropertyValue("isShowing", false);
  }
  set isShowing(val) {
    this.setPropertyValue("isShowing", val);
  }
  get isFullScreen() {
    return this.getPropertyValue("isFullScreen", false);
  }
  set isFullScreen(val) {
    if (!this.isExpanded && !!val) {
      this.isExpanded = true;
    }
    this.setPropertyValue("isFullScreen", val);
    this.setCssRoot();
  }
  /**
   * Shows the pop-up survey. The survey may appear [expanded or collapsed](#isExpanded).
   *
   * As an alternative to this method, you can set the [`isShowing`](#isShowing) property to `true`.
   * @see hide
   */
  show() {
    this.isShowing = true;
  }
  /**
   * Hides the pop-up survey.
   *
   * As an alternative to this method, you can set the [`isShowing`](#isShowing) property to `false`.
   * @see show
   * @see expand
   * @see collapse
   */
  hide() {
    this.isShowing = false;
  }
  toggleFullScreen() {
    this.isFullScreen = !this.isFullScreen;
  }
  /**
   * Indicates whether the pop-up window is expanded or collapsed.
   *
   * You can set this property to `true` or `false` to control the expand state of the pop-up survey. Alternatively, you can use the [`expand()`](#expand) and [`collapse()`](#collapse) methods.
   */
  get isExpanded() {
    return this.getPropertyValue("isExpanded", false);
  }
  set isExpanded(val) {
    if (!!this.isFullScreen && !val) {
      this.isFullScreen = false;
    }
    this.setPropertyValue("isExpanded", val);
  }
  get isCollapsed() {
    return !this.isExpanded;
  }
  onExpandedChanged() {
    if (!!this.expandedChangedCallback) {
      this.expandedChangedCallback();
    }
    this.updateCssButton();
  }
  /**
   * A title for the pop-up window. If this property is undefined, the title is taken from [`SurveyModel`](#survey)'s [`title`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#title) property.
   */
  get title() {
    return this.survey.title;
  }
  set title(value) {
    this.survey.title = value;
  }
  get locTitle() {
    if (this.survey.locTitle.isEmpty) return null;
    return this.survey.locTitle;
  }
  get locDescription() {
    if (this.survey.locTitle.isEmpty) return null;
    return this.survey.locDescription;
  }
  /**
   * Expands the pop-up window.
   *
   * As an alternative to this method, you can set the [`isExpanded`](#isExpanded) property to `true`.
   * @see collapse
   */
  expand() {
    this.isExpanded = true;
  }
  /**
   * Collapses the pop-up window, leaving only the survey title visible.
   *
   * As an alternative to this method, you can set the [`isExpanded`](#isExpanded) property to `false`.
   * @see expand
   */
  collapse() {
    this.isExpanded = false;
  }
  changeExpandCollapse() {
    this.isExpanded = !this.isExpanded;
  }
  /**
   * Specifies whether to display a button that closes the pop-up window.
   *
   * Default value: `false`
   *
   * If you allow users to close the pop-up window, make sure to implement a UI element that opens it. This element should call the [`show()`](#show) method or enable the [`isShowing`](#isShowing) property.
   * @see expand
   * @see collapse
   * @see hide
   */
  get allowClose() {
    return this.getPropertyValue("allowClose", false);
  }
  set allowClose(val) {
    this.setPropertyValue("allowClose", val);
  }
  /**
   * Specifies whether to display a button that allows respondents to show the pop-up survey in full screen mode.
   *
   * Default value: `false`
   */
  get allowFullScreen() {
    return this.getPropertyValue("allowFullScreen", false);
  }
  set allowFullScreen(val) {
    this.setPropertyValue("allowFullScreen", val);
  }
  get css() {
    return this.survey.css;
  }
  get cssButton() {
    return this.getPropertyValue("cssButton", "");
  }
  get cssRoot() {
    let result = this.getPropertyValue("cssRoot", "");
    if (this.isCollapsed) result += " " + this.getPropertyValue("cssRootCollapsedMod", "");
    return result;
  }
  get cssRootCollapsedMod() {
    return this.getPropertyValue("cssRootCollapsedMod");
  }
  get cssRootContent() {
    return this.getPropertyValue("cssRootContent");
  }
  get cssBody() {
    return this.getPropertyValue("cssBody", "");
  }
  get cssHeaderRoot() {
    return this.getPropertyValue("cssHeaderRoot", "");
  }
  get cssHeaderTitleCollapsed() {
    return this.getPropertyValue("cssHeaderTitleCollapsed", "");
  }
  get cssHeaderButtonsContainer() {
    return this.getPropertyValue("cssHeaderButtonsContainer", "");
  }
  get cssHeaderCollapseButton() {
    return this.getPropertyValue("cssHeaderCollapseButton", "");
  }
  get cssHeaderCloseButton() {
    return this.getPropertyValue("cssHeaderCloseButton", "");
  }
  get cssHeaderFullScreenButton() {
    return this.getPropertyValue("cssHeaderFullScreenButton", "");
  }
  get renderedWidth() {
    let width = this.getPropertyValue("width", "60%");
    if (width && !isNaN(width)) width = width + "px";
    return width;
  }
  updateCss() {
    if (!this.css || !this.css.window) return;
    const cssWindow = this.css.window;
    this.setCssRoot();
    this.setPropertyValue("cssRootCollapsedMod", cssWindow.rootCollapsedMod);
    this.setPropertyValue("cssRootContent", cssWindow.rootContent);
    this.setPropertyValue("cssBody", cssWindow.body);
    const cssHeader = cssWindow.header;
    if (!cssHeader) return;
    this.setPropertyValue("cssHeaderRoot", cssHeader.root);
    this.setPropertyValue("cssHeaderTitleCollapsed", cssHeader.titleCollapsed);
    this.setPropertyValue("cssHeaderButtonsContainer", cssHeader.buttonsContainer);
    this.setPropertyValue("cssHeaderCollapseButton", cssHeader.collapseButton);
    this.setPropertyValue("cssHeaderCloseButton", cssHeader.closeButton);
    this.setPropertyValue("cssHeaderFullScreenButton", cssHeader.fullScreenButton);
    this.updateCssButton();
  }
  setCssRoot() {
    const cssWindow = this.css.window;
    if (this.isFullScreen) {
      this.setPropertyValue("cssRoot", cssWindow.root + " " + cssWindow.rootFullScreenMode);
    } else {
      this.setPropertyValue("cssRoot", cssWindow.root);
    }
  }
  updateCssButton() {
    const cssHeader = !!this.css.window ? this.css.window.header : null;
    if (!cssHeader) return;
    this.setCssButton(this.isExpanded ? cssHeader.buttonExpanded : cssHeader.buttonCollapsed);
  }
  setCssButton(val) {
    if (!val) return;
    this.setPropertyValue("cssButton", val);
  }
  createSurvey(jsonObj) {
    return new SurveyModel(jsonObj);
  }
  onSurveyComplete() {
    if (this.closeOnCompleteTimeout < 0) return;
    if (this.closeOnCompleteTimeout == 0) {
      this.hide();
    } else {
      var self2 = this;
      var timerId = null;
      var func = function() {
        self2.hide();
        clearInterval(timerId);
      };
      timerId = setInterval(func, this.closeOnCompleteTimeout * 1e3);
    }
  }
  onScroll() {
    this.survey.onScroll();
  }
};
__decorate([property()], PopupSurveyModel.prototype, "width", void 0);
var PopupModalViewModel = class extends PopupBaseViewModel {
  getStyleClass() {
    return super.getStyleClass().append("sv-popup--modal", !this.isOverlay);
  }
  getShowFooter() {
    return true;
  }
  createFooterActionBar() {
    super.createFooterActionBar();
    this.footerToolbar.containerCss = "sv-footer-action-bar";
    this.footerToolbarValue.addAction({
      id: "apply",
      visibleIndex: 20,
      title: this.applyButtonText,
      innerCss: "sv-popup__body-footer-item sv-popup__button sv-popup__button--apply sd-btn sd-btn--action",
      action: () => {
        this.apply();
      }
    });
  }
  constructor(model) {
    super(model);
    this.onScrollOutsideCallback = (event) => {
      this.preventScrollOuside(event, event.deltaY);
    };
  }
  get applyButtonText() {
    return this.getLocalizationString("modalApplyButtonText");
  }
  apply() {
    if (!!this.model.onApply && !this.model.onApply()) return;
    this.hidePopup();
  }
  clickOutside() {
    return;
  }
  onKeyDown(event) {
    if (event.key === "Escape" || event.keyCode === 27) {
      this.model.onCancel();
    }
    super.onKeyDown(event);
  }
  updateOnShowing() {
    if (this.container) {
      this.container.addEventListener("wheel", this.onScrollOutsideCallback, {
        passive: false
      });
    }
    super.updateOnShowing();
  }
  updateOnHiding() {
    if (this.container) {
      this.container.removeEventListener("wheel", this.onScrollOutsideCallback);
    }
    super.updateOnHiding();
  }
};
function createPopupModalViewModel(options, rootElement) {
  var _a;
  const popupOptions = Object.assign({}, options);
  popupOptions.verticalPosition = "top";
  popupOptions.horizontalPosition = "left";
  popupOptions.showPointer = false;
  popupOptions.isModal = true;
  popupOptions.displayMode = options.displayMode || "popup";
  const popupModel = new PopupModel(options.componentName, options.data, popupOptions);
  popupModel.isFocusedContent = (_a = options.isFocusedContent) !== null && _a !== void 0 ? _a : true;
  const popupViewModel = new PopupModalViewModel(popupModel);
  if (!!rootElement && !!rootElement.appendChild) {
    var container = DomDocumentHelper.createElement("div");
    rootElement.appendChild(container);
    popupViewModel.setComponentElement(container);
  }
  if (!popupViewModel.container) {
    popupViewModel.initializePopupContainer();
  }
  const onVisibilityChangedCallback = (sender, options2) => {
    if (!options2.isVisible) {
      if (!!container) {
        popupViewModel.resetComponentElement();
      }
    }
    popupViewModel.onVisibilityChanged.remove(onVisibilityChangedCallback);
  };
  popupViewModel.onVisibilityChanged.add(onVisibilityChangedCallback);
  return popupViewModel;
}
function createPopupViewModel(model) {
  if (model.isModal) {
    return new PopupModalViewModel(model);
  } else {
    return new PopupDropdownViewModel(model);
  }
}
var ButtonGroupItemValue = class extends ItemValue {
  constructor(value, text = null, typeName = "buttongroupitemvalue") {
    super(value, text, typeName);
    this.typeName = typeName;
  }
  getType() {
    return !!this.typeName ? this.typeName : "buttongroupitemvalue";
  }
};
__decorate([property()], ButtonGroupItemValue.prototype, "iconName", void 0);
__decorate([property()], ButtonGroupItemValue.prototype, "iconSize", void 0);
__decorate([property()], ButtonGroupItemValue.prototype, "showCaption", void 0);
var QuestionButtonGroupModel = class extends QuestionCheckboxBase {
  constructor(name) {
    super(name);
  }
  getType() {
    return "buttongroup";
  }
  getItemValueType() {
    return "buttongroupitemvalue";
  }
  supportOther() {
    return false;
  }
};
Serializer.addClass("buttongroup", [{
  name: "choices:buttongroupitemvalue[]"
}], function() {
  return new QuestionButtonGroupModel("");
}, "checkboxbase");
Serializer.addClass("buttongroupitemvalue", [{
  name: "showCaption:boolean",
  default: true
}, {
  name: "iconName:text"
}, {
  name: "iconSize:number"
}], (value) => new ButtonGroupItemValue(value), "itemvalue");
var ButtonGroupItemModel = class {
  constructor(question, item, index) {
    this.question = question;
    this.item = item;
    this.index = index;
  }
  get value() {
    return this.item.value;
  }
  get iconName() {
    return this.item.iconName;
  }
  get iconSize() {
    return this.item.iconSize || 24;
  }
  get caption() {
    return this.item.locText;
  }
  get showCaption() {
    return this.item.showCaption || this.item.showCaption === void 0;
  }
  get isRequired() {
    return this.question.isRequired;
  }
  get selected() {
    return this.question.isItemSelected(this.item);
  }
  get readOnly() {
    return this.question.isInputReadOnly || !this.item.isEnabled;
  }
  get name() {
    return this.question.name + "_" + this.question.id;
  }
  get id() {
    return this.question.inputId + "_" + this.index;
  }
  get hasErrors() {
    return this.question.errors.length > 0;
  }
  get describedBy() {
    return this.question.errors.length > 0 ? this.question.id + "_errors" : null;
  }
  get labelClass() {
    return new CssClassBuilder().append(this.question.cssClasses.item).append(this.question.cssClasses.itemSelected, this.selected).append(this.question.cssClasses.itemHover, !this.readOnly && !this.selected).append(this.question.cssClasses.itemDisabled, this.question.isReadOnly || !this.item.isEnabled).toString();
  }
  get css() {
    return {
      label: this.labelClass,
      icon: this.question.cssClasses.itemIcon,
      control: this.question.cssClasses.itemControl,
      caption: this.question.cssClasses.itemCaption,
      decorator: this.question.cssClasses.itemDecorator
    };
  }
  onChange() {
    this.question.renderedValue = this.item.value;
  }
};
var InputMaskBase = class extends Base {
  getSurvey(live = false) {
    return this.owner;
  }
  getType() {
    return "masksettings";
  }
  setData(json2) {
    const properties = Serializer.getProperties(this.getType());
    properties.forEach((property2) => {
      const currentValue = json2[property2.name];
      this[property2.name] = currentValue !== void 0 ? currentValue : property2.getDefaultValue(this);
    });
  }
  getData() {
    const res = {};
    const properties = Serializer.getProperties(this.getType());
    properties.forEach((property2) => {
      const currentValue = this[property2.name];
      if (!property2.isDefaultValue(currentValue)) {
        res[property2.name] = currentValue;
      }
    });
    return res;
  }
  processInput(args) {
    return {
      value: args.prevValue,
      caretPosition: args.selectionEnd,
      cancelPreventDefault: false
    };
  }
  getUnmaskedValue(src) {
    return src;
  }
  getMaskedValue(src) {
    return src;
  }
  getTextAlignment() {
    return "auto";
  }
  getTypeForExpressions() {
    return "text";
  }
};
__decorate([property()], InputMaskBase.prototype, "saveMaskedValue", void 0);
Serializer.addClass("masksettings", [{
  name: "saveMaskedValue:boolean",
  visibleIf: function(obj) {
    if (!obj) return false;
    return obj.getType() !== "masksettings";
  }
}], function() {
  return new InputMaskBase();
});
function getLiterals(pattern) {
  const result = [];
  let prevCharIsEscaped = false;
  const definitionsKeys = Object.keys(settings.maskSettings.patternDefinitions);
  for (let index = 0; index < pattern.length; index++) {
    const currentChar = pattern[index];
    if (currentChar === settings.maskSettings.patternEscapeChar) {
      prevCharIsEscaped = true;
    } else if (prevCharIsEscaped) {
      prevCharIsEscaped = false;
      result.push({
        type: "fixed",
        value: currentChar
      });
    } else {
      result.push({
        type: definitionsKeys.indexOf(currentChar) !== -1 ? "regex" : "const",
        value: currentChar
      });
    }
  }
  return result;
}
function getFirstMatch(str, strIndex, literal) {
  const currentDefinition = settings.maskSettings.patternDefinitions[literal.value];
  while (strIndex < str.length) {
    if (str[strIndex].match(currentDefinition)) {
      return strIndex;
    }
    strIndex++;
  }
  return strIndex;
}
function getMaskedValueByPattern(src, pattern, matchWholeMask) {
  const input = src === void 0 || src === null ? "" : src;
  let result = "";
  let strIndex = 0;
  const literals = typeof pattern === "string" ? getLiterals(pattern) : pattern;
  for (let maskIndex = 0; maskIndex < literals.length; maskIndex++) {
    switch (literals[maskIndex].type) {
      case "regex":
        if (strIndex < input.length) {
          strIndex = getFirstMatch(input, strIndex, literals[maskIndex]);
        }
        if (strIndex < input.length) {
          result += input[strIndex];
        } else if (matchWholeMask) {
          result += settings.maskSettings.patternPlaceholderChar;
        } else {
          return result;
        }
        strIndex++;
        break;
      case "const":
      case "fixed":
        result += literals[maskIndex].value;
        if (literals[maskIndex].value === input[strIndex]) {
          strIndex++;
        }
        break;
    }
  }
  return result;
}
function getUnmaskedValueByPattern(str, pattern, matchWholeMask, skipFixedChar = false) {
  let result = "";
  if (!str) return result;
  let literals = typeof pattern === "string" ? getLiterals(pattern) : pattern;
  for (let index = 0; index < literals.length; index++) {
    if (literals[index].type === "fixed" && !skipFixedChar) {
      result += literals[index].value;
    }
    if (literals[index].type === "regex") {
      const currentDefinition = settings.maskSettings.patternDefinitions[literals[index].value];
      if (!!str[index] && str[index].match(currentDefinition)) {
        result += str[index];
      } else if (matchWholeMask) {
        result = "";
        break;
      } else {
        break;
      }
    }
  }
  return result;
}
var InputMaskPattern = class extends InputMaskBase {
  constructor() {
    super(...arguments);
    this.literals = [];
  }
  updateLiterals() {
    this.literals = getLiterals(this.pattern || "");
  }
  onPropertyValueChanged(name, oldValue, newValue) {
    if (name === "pattern") {
      this.updateLiterals();
    }
  }
  getType() {
    return "patternmask";
  }
  fromJSON(json2, options) {
    super.fromJSON(json2, options);
    this.updateLiterals();
  }
  _getMaskedValue(src, matchWholeMask = false) {
    const input = src === void 0 || src === null ? "" : src;
    return getMaskedValueByPattern(input, this.literals, matchWholeMask);
  }
  _getUnmaskedValue(src, matchWholeMask = false) {
    const input = src === void 0 || src === null ? "" : src;
    return getUnmaskedValueByPattern(input, this.literals, matchWholeMask);
  }
  processInput(args) {
    const result = {
      value: args.prevValue,
      caretPosition: args.selectionEnd,
      cancelPreventDefault: false
    };
    if (!args.insertedChars && args.selectionStart === args.selectionEnd) {
      return result;
    }
    const leftPart = args.prevValue.slice(0, args.selectionStart) + (args.insertedChars || "");
    const leftPartUnmasked = getUnmaskedValueByPattern(args.prevValue.slice(0, args.selectionStart), this.literals.slice(0, args.selectionStart), false);
    const rightPartUnmasked = getUnmaskedValueByPattern(args.prevValue.slice(args.selectionEnd), this.literals.slice(args.selectionEnd), false, true);
    result.value = this._getMaskedValue(leftPartUnmasked + (args.insertedChars || "") + rightPartUnmasked, true);
    if (!args.insertedChars && args.inputDirection === "backward") {
      result.caretPosition = args.selectionStart;
    } else {
      result.caretPosition = this._getMaskedValue(leftPart).length;
    }
    return result;
  }
  getMaskedValue(src) {
    return this._getMaskedValue(src, true);
  }
  getUnmaskedValue(src) {
    return this._getUnmaskedValue(src, true);
  }
};
__decorate([property()], InputMaskPattern.prototype, "pattern", void 0);
Serializer.addClass("patternmask", [{
  name: "pattern"
}], function() {
  return new InputMaskPattern();
}, "masksettings");
function splitString(str, reverse = true, n = 3) {
  let arr = [];
  if (reverse) {
    for (let i = str.length - n; i > -n; i -= n) {
      arr.push(str.substring(i, i + n));
    }
    arr = arr.reverse();
  } else {
    for (let i = 0; i < str.length; i += n) {
      arr.push(str.substring(i, i + n));
    }
  }
  return arr;
}
var InputMaskNumeric = class extends InputMaskBase {
  calccaretPosition(leftPart, args, maskedValue) {
    const leftPartMaskedLength = !!leftPart ? this.displayNumber(this.parseNumber(leftPart), false).length : 0;
    let validCharIndex = 0;
    let result = args.selectionStart;
    const isDeleteKeyOperation = !args.insertedChars && args.inputDirection === "forward";
    for (let index = 0; index < maskedValue.length; index++) {
      const currentChar = maskedValue[index];
      if (currentChar !== this.thousandsSeparator) {
        validCharIndex++;
      }
      if (validCharIndex === leftPartMaskedLength + (isDeleteKeyOperation ? 1 : 0)) {
        if (isDeleteKeyOperation) {
          result = index;
        } else {
          result = index + 1;
        }
        break;
      }
    }
    return result;
  }
  numericalCompositionIsEmpty(number) {
    return !number.integralPart && !number.fractionalPart;
  }
  displayNumber(parsedNumber, insertThousandsSeparator = true, matchWholeMask = false) {
    let displayIntegralPart = parsedNumber.integralPart;
    if (insertThousandsSeparator && !!displayIntegralPart) {
      displayIntegralPart = splitString(displayIntegralPart).join(this.thousandsSeparator);
    }
    let displayFractionalPart = parsedNumber.fractionalPart;
    const minusSign = parsedNumber.isNegative ? "-" : "";
    if (displayFractionalPart === "") {
      if (matchWholeMask) {
        return !displayIntegralPart || displayIntegralPart === "0" ? displayIntegralPart : minusSign + displayIntegralPart;
      } else {
        const displayDecimalSeparator = parsedNumber.hasDecimalSeparator && !matchWholeMask ? this.decimalSeparator : "";
        const src = displayIntegralPart + displayDecimalSeparator;
        return src === "0" ? src : minusSign + src;
      }
    } else {
      displayIntegralPart = displayIntegralPart || "0";
      displayFractionalPart = displayFractionalPart.substring(0, this.precision);
      return [minusSign + displayIntegralPart, displayFractionalPart].join(this.decimalSeparator);
    }
  }
  convertNumber(parsedNumber) {
    let value;
    const minusSign = parsedNumber.isNegative ? "-" : "";
    if (!!parsedNumber.fractionalPart) {
      value = parseFloat(minusSign + (parsedNumber.integralPart || "0") + "." + parsedNumber.fractionalPart.substring(0, this.precision));
    } else {
      value = parseInt(minusSign + parsedNumber.integralPart || "0");
    }
    return value;
  }
  validateNumber(number, matchWholeMask) {
    const min2 = this.min || Number.MIN_SAFE_INTEGER;
    const max2 = this.max || Number.MAX_SAFE_INTEGER;
    if (this.numericalCompositionIsEmpty(number)) return true;
    if (this.min !== void 0 || this.max !== void 0) {
      let value = this.convertNumber(number);
      if (Number.isNaN(value)) {
        return true;
      }
      if (value >= min2 && value <= max2) return true;
      if (!matchWholeMask) {
        if (!number.hasDecimalSeparator && value != 0) {
          let test_high = value;
          let test_low = value;
          if (value > 0) {
            if (value + 1 > min2 && value <= max2) return true;
            while (true) {
              test_high = test_high * 10 + 9;
              test_low = test_low * 10;
              if (test_low > max2) {
                break;
              }
              if (test_high > min2) {
                return true;
              }
            }
            return false;
          }
          if (value < 0) {
            if (value >= min2 && value - 1 < max2) return true;
            while (true) {
              test_high = test_high * 10;
              test_low = test_low * 10 - 9;
              if (test_high < min2) {
                break;
              }
              if (test_low < max2) {
                return true;
              }
            }
            return false;
          }
        } else {
          const delta = Math.pow(0.1, (number.fractionalPart || "").length);
          if (value >= 0) return value + delta > min2 && value <= max2;
          if (value < 0) return value >= min2 && value - delta < max2;
        }
        return value >= 0 && value <= max2 || value < 0 && value >= min2;
      }
      return false;
    }
    return true;
  }
  parseNumber(src) {
    const result = {
      integralPart: "",
      fractionalPart: "",
      hasDecimalSeparator: false,
      isNegative: false
    };
    const input = src === void 0 || src === null ? "" : src.toString();
    let minusCharCount = 0;
    for (let inputIndex = 0; inputIndex < input.length; inputIndex++) {
      const currentChar = input[inputIndex];
      switch (currentChar) {
        case "-": {
          if (this.allowNegativeValues && (this.min === void 0 || this.min < 0)) {
            minusCharCount++;
          }
          break;
        }
        case this.decimalSeparator: {
          if (this.precision > 0) {
            result.hasDecimalSeparator = true;
          }
          break;
        }
        case this.thousandsSeparator: {
          break;
        }
        default: {
          if (currentChar.match(numberDefinition)) {
            if (result.hasDecimalSeparator) {
              result.fractionalPart += currentChar;
            } else {
              result.integralPart += currentChar;
            }
          }
        }
      }
    }
    result.isNegative = minusCharCount % 2 !== 0;
    if (result.integralPart.length > 1 && result.integralPart[0] === "0") {
      result.integralPart = result.integralPart.slice(1);
    }
    return result;
  }
  getNumberMaskedValue(src, matchWholeMask = false) {
    const parsedNumber = this.parseNumber(src);
    if (!this.validateNumber(parsedNumber, matchWholeMask)) {
      return null;
    }
    const displayText = this.displayNumber(parsedNumber, true, matchWholeMask);
    return displayText;
  }
  getNumberUnmaskedValue(str) {
    const parsedNumber = this.parseNumber(str);
    if (this.numericalCompositionIsEmpty(parsedNumber)) return void 0;
    return this.convertNumber(parsedNumber);
  }
  getTextAlignment() {
    return "right";
  }
  getMaskedValue(src) {
    let input = src === void 0 || src === null ? "" : src.toString();
    input = input.replace(".", this.decimalSeparator);
    return this.getNumberMaskedValue(input, true);
  }
  getUnmaskedValue(src) {
    return this.getNumberUnmaskedValue(src);
  }
  processInput(args) {
    const result = {
      value: args.prevValue,
      caretPosition: args.selectionEnd,
      cancelPreventDefault: false
    };
    const leftPart = args.prevValue.slice(0, args.selectionStart) + (args.insertedChars || "");
    const rightPart = args.prevValue.slice(args.selectionEnd);
    const src = leftPart + rightPart;
    const parsedNumber = this.parseNumber(src);
    if (!this.validateNumber(parsedNumber, false)) {
      return result;
    }
    const maskedValue = this.getNumberMaskedValue(src);
    const caretPosition = this.calccaretPosition(leftPart, args, maskedValue);
    result.value = maskedValue;
    result.caretPosition = caretPosition;
    return result;
  }
  getType() {
    return "numericmask";
  }
  isValueUndefined(value) {
    return value === "" || super.isValueUndefined(value);
  }
};
__decorate([property()], InputMaskNumeric.prototype, "allowNegativeValues", void 0);
__decorate([property()], InputMaskNumeric.prototype, "decimalSeparator", void 0);
__decorate([property()], InputMaskNumeric.prototype, "precision", void 0);
__decorate([property()], InputMaskNumeric.prototype, "thousandsSeparator", void 0);
__decorate([property()], InputMaskNumeric.prototype, "min", void 0);
__decorate([property()], InputMaskNumeric.prototype, "max", void 0);
Serializer.addClass("numericmask", [{
  name: "allowNegativeValues:boolean",
  default: true
}, {
  name: "decimalSeparator",
  default: ".",
  maxLength: 1
}, {
  name: "thousandsSeparator",
  default: ",",
  maxLength: 1
}, {
  name: "precision:number",
  default: 2,
  minValue: 0
}, {
  name: "min:number"
}, {
  name: "max:number"
}], function() {
  return new InputMaskNumeric();
}, "masksettings");
function getMaxCountLexem(currentLexemType, count2) {
  switch (currentLexemType) {
    case "hour":
    case "minute":
    case "second":
    case "day":
    case "month": {
      return 2;
    }
    case "timeMarker":
    case "year": {
      return count2;
    }
    default: {
      return 1;
    }
  }
}
function trimDatePart(lexem, data) {
  let result = data;
  if (lexem.count < lexem.maxCount && (lexem.type === "day" && parseInt(data[0]) === 0 || lexem.type === "month" && parseInt(data[0]) === 0)) {
    result = data.slice(1, data.length);
  }
  return result;
}
function getDateTimeLexems(pattern) {
  const result = [];
  let prevLexemType;
  const createOrUpdateLexem = (currentLexemType, currentChar, upperCase = false) => {
    if (!!prevLexemType && prevLexemType === currentLexemType) {
      result[result.length - 1].count++;
      const maxCount = getMaxCountLexem(currentLexemType, result[result.length - 1].count);
      result[result.length - 1].maxCount = maxCount;
    } else {
      const maxCount = getMaxCountLexem(currentLexemType, 1);
      result.push({
        type: currentLexemType,
        value: currentChar,
        count: 1,
        maxCount,
        upperCase
      });
    }
  };
  for (let index = 0; index < pattern.length; index++) {
    const currentChar = pattern[index];
    switch (currentChar) {
      case "m":
        createOrUpdateLexem("month", currentChar);
        break;
      case "d":
        createOrUpdateLexem("day", currentChar);
        break;
      case "y":
        createOrUpdateLexem("year", currentChar);
        break;
      case "h":
        createOrUpdateLexem("hour", currentChar, false);
        break;
      case "H":
        createOrUpdateLexem("hour", currentChar, true);
        break;
      case "M":
        createOrUpdateLexem("minute", currentChar);
        break;
      case "s":
        createOrUpdateLexem("second", currentChar);
        break;
      case "t":
        createOrUpdateLexem("timeMarker", currentChar);
        break;
      case "T":
        createOrUpdateLexem("timeMarker", currentChar, true);
        break;
      default:
        result.push({
          type: "separator",
          value: currentChar,
          count: 1,
          maxCount: 1,
          upperCase: false
        });
        break;
    }
    prevLexemType = result[result.length - 1].type;
  }
  return result;
}
var InputMaskDateTime = class extends InputMaskPattern {
  constructor() {
    super(...arguments);
    this.defaultDate = "1970-01-01T";
    this.turnOfTheCentury = 68;
    this.twelve = 12;
    this.lexems = [];
    this.inputDateTimeData = [];
    this.validBeginningOfNumbers = {
      hour: 1,
      hourU: 2,
      minute: 5,
      second: 5,
      day: 3,
      month: 1
    };
  }
  get hasDatePart() {
    return this.lexems.some((l) => l.type === "day" || l.type === "month" || l.type === "year");
  }
  get hasTimePart() {
    return this.lexems.some((l) => l.type === "hour" || l.type === "minute" || l.type === "second");
  }
  get is12Hours() {
    return this.lexems.filter((l) => l.type === "hour" && !l.upperCase).length > 0;
  }
  getType() {
    return "datetimemask";
  }
  getTypeForExpressions() {
    return this.hasTimePart ? "datetime-local" : "datetime";
  }
  updateLiterals() {
    this.lexems = getDateTimeLexems(this.pattern || "");
  }
  leaveOnlyNumbers(input) {
    let result = "";
    for (let index = 0; index < input.length; index++) {
      if (input[index].match(numberDefinition)) {
        result += input[index];
      }
    }
    return result;
  }
  getMaskedStrFromISO(str) {
    let date = new Date(str);
    this.initInputDateTimeData();
    if (!this.hasTimePart) {
      date = /* @__PURE__ */ new Date(str + "T00:00:00");
    }
    if (!this.hasDatePart) {
      date = new Date(this.defaultDate + str);
    }
    if (!isNaN(date)) {
      this.lexems.forEach((lexem, index) => {
        let inputData = this.inputDateTimeData[index];
        inputData.isCompleted = true;
        switch (lexem.type) {
          case "hour": {
            if (!this.is12Hours) {
              inputData.value = date.getHours().toString();
            } else {
              inputData.value = ((date.getHours() - 1) % this.twelve + 1).toString();
            }
            break;
          }
          case "minute": {
            inputData.value = date.getMinutes().toString();
            break;
          }
          case "second": {
            inputData.value = date.getSeconds().toString();
            break;
          }
          case "timeMarker": {
            const marker = date.getHours() >= this.twelve ? "pm" : "am";
            inputData.value = lexem.upperCase ? marker.toUpperCase() : marker;
            break;
          }
          case "day": {
            inputData.value = date.getDate().toString();
            break;
          }
          case "month": {
            inputData.value = (date.getMonth() + 1).toString();
            break;
          }
          case "year": {
            let year2 = date.getFullYear();
            if (lexem.count == 2) year2 = year2 % 100;
            inputData.value = year2.toString();
            break;
          }
        }
      });
    }
    return this.getFormatedString(true);
  }
  initInputDateTimeData() {
    this.inputDateTimeData = [];
    this.lexems.forEach((lexem) => {
      this.inputDateTimeData.push({
        lexem,
        isCompleted: false,
        value: void 0
      });
    });
  }
  getISO_8601Format(dateTime) {
    const date = [];
    const time = [];
    if (dateTime.year !== void 0) {
      const year2 = this.getPlaceholder(4, dateTime.year.toString(), "0") + dateTime.year;
      date.push(year2);
    }
    if (dateTime.month !== void 0 && dateTime.year !== void 0) {
      const month2 = this.getPlaceholder(2, dateTime.month.toString(), "0") + dateTime.month;
      date.push(month2);
    }
    if (dateTime.day !== void 0 && dateTime.month !== void 0 && dateTime.year !== void 0) {
      const day2 = this.getPlaceholder(2, dateTime.day.toString(), "0") + dateTime.day;
      date.push(day2);
    }
    if (dateTime.hour !== void 0) {
      const hour = this.getPlaceholder(2, dateTime.hour.toString(), "0") + dateTime.hour;
      time.push(hour);
    }
    if (dateTime.minute !== void 0 && dateTime.hour !== void 0) {
      const minute = this.getPlaceholder(2, dateTime.minute.toString(), "0") + dateTime.minute;
      time.push(minute);
    }
    if (dateTime.second !== void 0 && dateTime.minute !== void 0 && dateTime.hour !== void 0) {
      const second = this.getPlaceholder(2, dateTime.second.toString(), "0") + dateTime.second;
      time.push(second);
    }
    const result = [];
    if (date.length > 0) {
      result.push(date.join("-"));
    }
    if (time.length > 1) {
      result.push(time.join(":"));
    }
    return result.join("T");
  }
  isYearValid(dateTime) {
    if (dateTime.min === void 0 && dateTime.max === void 0) return false;
    const data = dateTime.year.toString();
    const minYearPart = dateTime.min.toISOString().slice(0, data.length);
    const maxYearPart = dateTime.max.toISOString().slice(0, data.length);
    return dateTime.year >= parseInt(minYearPart) && dateTime.year <= parseInt(maxYearPart);
  }
  createIDateTimeCompositionWithDefaults(dateTime, isUpperLimit) {
    const checkOnlyLeapYears = dateTime.day == 29 && dateTime.month == 2;
    let minYear = dateTime.min.getFullYear();
    let maxYear = dateTime.max.getFullYear();
    if (checkOnlyLeapYears) {
      minYear = Math.ceil(minYear / 4) * 4;
      maxYear = Math.floor(minYear / 4) * 4;
      if (minYear > maxYear) {
        minYear = void 0;
        maxYear = void 0;
      }
    }
    const year2 = dateTime.year !== void 0 ? dateTime.year : isUpperLimit ? maxYear : minYear;
    const month2 = dateTime.month !== void 0 ? dateTime.month : isUpperLimit && this.hasDatePart ? 12 : 1;
    const day2 = dateTime.day !== void 0 ? dateTime.day : isUpperLimit && this.hasDatePart ? this.getMaxDateForMonth(year2, month2) : 1;
    const hour = dateTime.hour !== void 0 ? dateTime.hour : isUpperLimit ? 23 : 0;
    const minute = dateTime.minute !== void 0 ? dateTime.minute : isUpperLimit ? 59 : 0;
    const second = dateTime.second !== void 0 ? dateTime.second : isUpperLimit ? 59 : 0;
    return {
      year: year2,
      month: month2,
      day: day2,
      hour,
      minute,
      second
    };
  }
  getMaxDateForMonth(year2, month2) {
    if (month2 == 2) return year2 % 4 == 0 && year2 % 100 != 0 || year2 % 400 ? 29 : 28;
    return [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month2 - 1];
  }
  isDateValid(dateTime) {
    const date = new Date(this.getISO_8601Format(this.createIDateTimeCompositionWithDefaults(dateTime, false)));
    const dateH = new Date(this.getISO_8601Format(this.createIDateTimeCompositionWithDefaults(dateTime, true)));
    return !isNaN(date) && (date.getDate() === dateTime.day || dateTime.day === void 0) && (date.getMonth() === dateTime.month - 1 || dateTime.month === void 0) && (date.getFullYear() === dateTime.year || dateTime.year === void 0) && dateH >= dateTime.min && date <= dateTime.max;
  }
  getPlaceholder(lexemLength, str, char) {
    const paddingsLength = lexemLength - (str || "").length;
    const paddings = paddingsLength > 0 ? char.repeat(paddingsLength) : "";
    return paddings;
  }
  isDateValid12(dateTime12) {
    if (!this.is12Hours) return this.isDateValid(dateTime12);
    if (this.is12Hours && dateTime12.hour > this.twelve) {
      return false;
    }
    if (!dateTime12.timeMarker) {
      if (this.isDateValid(dateTime12)) return true;
      dateTime12.hour += this.twelve;
      return this.isDateValid(dateTime12);
    } else if (dateTime12.timeMarker[0].toLowerCase() === "p") {
      if (dateTime12.hour !== this.twelve) {
        dateTime12.hour += this.twelve;
      }
      return this.isDateValid(dateTime12);
    } else {
      if (dateTime12.hour === this.twelve) {
        dateTime12.hour = 0;
      }
      return this.isDateValid(dateTime12);
    }
  }
  updateTimeMarkerInputDateTimeData(newItem, dateTime) {
    let data = newItem.value;
    if (!data) return;
    const propertyName = "timeMarker";
    const tempDateTime = Object.assign({}, dateTime);
    tempDateTime[propertyName] = data;
    if (this.isDateValid12(tempDateTime)) {
      newItem.isCompleted = true;
    } else {
      data = data.slice(0, data.length - 1);
    }
    newItem.value = data || void 0;
    dateTime[propertyName] = data || void 0;
    return;
  }
  updateInputDateTimeData(newItem, dateTime) {
    let data = newItem.value;
    if (!data) return;
    const propertyName = newItem.lexem.type;
    const tempDateTime = Object.assign({}, dateTime);
    tempDateTime[propertyName] = parseInt(this.parseTwoDigitYear(newItem));
    if (data.length === newItem.lexem.maxCount) {
      if (this.isDateValid12(tempDateTime)) {
        newItem.isCompleted = true;
        newItem.value = data || void 0;
        dateTime[propertyName] = parseInt(data) > 0 ? parseInt(data) : void 0;
        return;
      } else {
        data = data.slice(0, data.length - 1);
      }
    }
    tempDateTime[propertyName] = parseInt(data);
    const firstDigit = parseInt(data[0]);
    const validBeginningOfNumber = this.validBeginningOfNumbers[propertyName + (newItem.lexem.upperCase ? "U" : "")];
    if (propertyName === "year" && !this.isYearValid(tempDateTime)) {
      data = data.slice(0, data.length - 1);
      newItem.isCompleted = false;
    } else if (validBeginningOfNumber !== void 0 && firstDigit > validBeginningOfNumber) {
      if (this.isDateValid12(tempDateTime)) {
        newItem.isCompleted = true;
      } else {
        data = data.slice(0, data.length - 1);
      }
    } else if (validBeginningOfNumber !== void 0 && firstDigit !== 0 && firstDigit <= validBeginningOfNumber) {
      this.checkValidationDateTimePart(tempDateTime, propertyName, newItem);
      if (newItem.isCompleted && !this.isDateValid12(tempDateTime)) {
        data = data.slice(0, data.length - 1);
      }
    }
    newItem.value = data || void 0;
    dateTime[propertyName] = parseInt(data) > 0 ? parseInt(data) : void 0;
  }
  checkValidationDateTimePart(dateTime, propertyName, newItem) {
    const prevValue = dateTime[propertyName];
    let tempValue = prevValue * 10;
    let maxValue = 10;
    if (propertyName === "month") maxValue = 3;
    if (propertyName === "hour") maxValue = this.is12Hours ? 3 : 5;
    newItem.isCompleted = true;
    for (let index = 0; index < maxValue; index++) {
      dateTime[propertyName] = tempValue + index;
      if (this.isDateValid12(dateTime)) {
        newItem.isCompleted = false;
        break;
      }
    }
    dateTime[propertyName] = prevValue;
  }
  getCorrectDatePartFormat(inputData, matchWholeMask) {
    const lexem = inputData.lexem;
    let dataStr = inputData.value || "";
    if (!!dataStr && lexem.type === "timeMarker") {
      if (matchWholeMask) {
        dataStr = dataStr + this.getPlaceholder(lexem.count, dataStr, lexem.value);
      }
      return dataStr;
    }
    if (!!dataStr && inputData.isCompleted) {
      dataStr = parseInt(dataStr).toString();
    }
    if (!!dataStr && inputData.isCompleted) {
      const zeroPaddings = this.getPlaceholder(lexem.count, dataStr, "0");
      dataStr = zeroPaddings + dataStr;
    } else {
      dataStr = trimDatePart(lexem, dataStr);
      if (matchWholeMask) {
        dataStr += this.getPlaceholder(lexem.count, dataStr, lexem.value);
      }
    }
    return dataStr;
  }
  createIDateTimeComposition() {
    let isoMin, isoMax;
    if (this.hasDatePart) {
      isoMin = this.min || "0001-01-01";
      isoMax = this.max || "9999-12-31";
    } else {
      isoMin = this.defaultDate + (this.min || "00:00:00");
      isoMax = this.defaultDate + (this.max || "23:59:59");
    }
    const tempDateTime = {
      hour: void 0,
      minute: void 0,
      second: void 0,
      day: void 0,
      month: void 0,
      year: void 0,
      min: new Date(isoMin),
      max: new Date(isoMax)
    };
    return tempDateTime;
  }
  parseTwoDigitYear(data) {
    const inputData = data.value;
    if (data.lexem.type !== "year" || data.lexem.count > 2) return inputData;
    if (!!this.max && this.max.length >= 4) {
      this.turnOfTheCentury = parseInt(this.max.slice(2, 4));
    }
    const year2 = parseInt(inputData);
    const result = (year2 > this.turnOfTheCentury ? "19" : "20") + inputData;
    return result;
  }
  getFormatedString(matchWholeMask) {
    let result = "";
    let prevSeparator = "";
    let prevIsCompleted = false;
    let lastItemWithDataIndex = this.inputDateTimeData.length - 1;
    if (!matchWholeMask) {
      const arr = this.inputDateTimeData.filter((item) => !!item.value);
      lastItemWithDataIndex = this.inputDateTimeData.indexOf(arr[arr.length - 1]);
    }
    for (let index = 0; index < this.inputDateTimeData.length; index++) {
      const inputData = this.inputDateTimeData[index];
      switch (inputData.lexem.type) {
        case "timeMarker":
        case "hour":
        case "minute":
        case "second":
        case "day":
        case "month":
        case "year":
          if (inputData.value === void 0 && !matchWholeMask) {
            result += prevIsCompleted ? prevSeparator : "";
            return result;
          } else {
            const _matchWholeMask = matchWholeMask || lastItemWithDataIndex > index;
            const data = this.getCorrectDatePartFormat(inputData, _matchWholeMask);
            result += prevSeparator + data;
            prevIsCompleted = inputData.isCompleted;
          }
          break;
        case "separator":
          prevSeparator = inputData.lexem.value;
          break;
      }
    }
    return result;
  }
  cleanTimeMarker(str, upperCase) {
    let result = "";
    str = str.toUpperCase();
    for (let i = 0; i < str.length; i++) {
      if (!result && (str[i] == "P" || str[i] == "A") || result && str[i] == "M") result += str[i];
    }
    if (upperCase) {
      result = result.toUpperCase();
    } else {
      result = result.toLowerCase();
    }
    return result;
  }
  setInputDateTimeData(numberParts) {
    let numberPartsArrayIndex = 0;
    this.initInputDateTimeData();
    this.lexems.forEach((lexem, index) => {
      if (numberParts.length > 0 && numberPartsArrayIndex < numberParts.length) {
        if (lexem.type === "separator") return;
        const inputData = this.inputDateTimeData[index];
        const currentPart = numberParts[numberPartsArrayIndex];
        let _data;
        if (lexem.type === "timeMarker") {
          _data = this.cleanTimeMarker(currentPart, lexem.upperCase);
        } else {
          _data = this.leaveOnlyNumbers(currentPart);
        }
        inputData.value = _data.slice(0, lexem.maxCount);
        numberPartsArrayIndex++;
      }
    });
  }
  _getMaskedValue(src, matchWholeMask = true) {
    let input = src === void 0 || src === null ? "" : src.toString();
    const inputParts = this.getParts(input);
    this.setInputDateTimeData(inputParts);
    const tempDateTime = this.createIDateTimeComposition();
    this.inputDateTimeData.forEach((itemData) => {
      if (itemData.lexem.type === "timeMarker") {
        this.updateTimeMarkerInputDateTimeData(itemData, tempDateTime);
      } else {
        this.updateInputDateTimeData(itemData, tempDateTime);
      }
    });
    const result = this.getFormatedString(matchWholeMask);
    return result;
  }
  getParts(input) {
    const inputParts = [];
    const lexemsWithValue = this.lexems.filter((l) => l.type !== "separator");
    const separators = this.lexems.filter((l) => l.type === "separator").map((s) => s.value);
    let curPart = "";
    let foundSeparator = false;
    let foundPseudoSeparator = false;
    for (let i = 0; i < input.length; i++) {
      const inputChar = input[i];
      if (inputChar.match(numberDefinition) || inputChar === lexemsWithValue[inputParts.length].value) {
        foundSeparator = false;
        foundPseudoSeparator = false;
        curPart += inputChar;
      } else if (lexemsWithValue[inputParts.length].type === "timeMarker") {
        foundSeparator = false;
        foundPseudoSeparator = false;
        curPart += inputChar;
      } else {
        if (separators.indexOf(inputChar) !== -1) {
          if (!foundPseudoSeparator) {
            foundSeparator = true;
            inputParts.push(curPart);
            curPart = "";
          }
        } else {
          if (!foundSeparator) {
            foundPseudoSeparator = true;
            inputParts.push(curPart);
            curPart = "";
          }
        }
      }
      if (inputParts.length >= lexemsWithValue.length) {
        foundSeparator = false;
        break;
      }
    }
    if (curPart != "" || foundSeparator) {
      inputParts.push(curPart);
    }
    return inputParts;
  }
  getUnmaskedValue(src) {
    var _a;
    let input = src === void 0 || src === null ? "" : src.toString();
    const inputParts = this.getParts(input);
    this.setInputDateTimeData(inputParts);
    const timeMarker = (_a = this.inputDateTimeData.filter((idtd) => idtd.lexem.type === "timeMarker")[0]) === null || _a === void 0 ? void 0 : _a.value.toLowerCase()[0];
    const tempDateTime = this.createIDateTimeComposition();
    let uncompleted = false;
    this.inputDateTimeData.forEach((inputData) => {
      let str = inputData.value;
      if (inputData.lexem.type == "timeMarker" || inputData.lexem.type == "separator") return;
      if (!str || str.length < inputData.lexem.count) {
        uncompleted = true;
        return;
      }
      let value = parseInt(this.parseTwoDigitYear(inputData));
      if (inputData.lexem.type == "hour" && timeMarker === "p" && value != this.twelve) value += this.twelve;
      tempDateTime[inputData.lexem.type] = value;
    });
    return uncompleted ? "" : this.getISO_8601Format(tempDateTime);
  }
  getMaskedValue(src) {
    return this.getMaskedStrFromISO(src);
  }
  processInput(args) {
    const result = {
      value: args.prevValue,
      caretPosition: args.selectionEnd,
      cancelPreventDefault: false
    };
    const leftPart = args.prevValue.slice(0, args.selectionStart);
    const rightPart = args.prevValue.slice(args.selectionEnd);
    result.value = this._getMaskedValue(leftPart + (args.insertedChars || "") + rightPart);
    if (!args.insertedChars && args.inputDirection === "backward") {
      result.caretPosition = args.selectionStart;
    } else {
      result.caretPosition = this._getMaskedValue(leftPart + (args.insertedChars || ""), false).length;
    }
    return result;
  }
};
__decorate([property()], InputMaskDateTime.prototype, "min", void 0);
__decorate([property()], InputMaskDateTime.prototype, "max", void 0);
Serializer.addClass("datetimemask", [{
  name: "min",
  type: "datetime",
  enableIf: (obj) => {
    return !!obj.pattern;
  }
}, {
  name: "max",
  type: "datetime",
  enableIf: (obj) => {
    return !!obj.pattern;
  }
}], function() {
  return new InputMaskDateTime();
}, "patternmask");
var InputMaskCurrency = class extends InputMaskNumeric {
  getType() {
    return "currencymask";
  }
  wrapText(str) {
    const prefixValue = this.prefix || "";
    const suffixValue = this.suffix || "";
    let result = str;
    if (!result) return result;
    if (result.indexOf(prefixValue) === -1) {
      result = prefixValue + result;
    }
    if (result.indexOf(suffixValue) === -1) {
      result += suffixValue;
    }
    return result;
  }
  unwrapInputArgs(args) {
    let result = args.prevValue;
    if (!result) return;
    if (this.prefix && result.indexOf(this.prefix) !== -1) {
      result = result.slice(result.indexOf(this.prefix) + this.prefix.length);
      const preffixPadding = (this.prefix || "").length;
      args.selectionStart = Math.max(args.selectionStart - preffixPadding, 0);
      args.selectionEnd -= preffixPadding;
    }
    if (this.suffix && result.indexOf(this.suffix) !== -1) {
      result = result.slice(0, result.indexOf(this.suffix));
    }
    args.prevValue = result;
  }
  processInput(args) {
    this.unwrapInputArgs(args);
    const result = super.processInput(args);
    const preffixPadding = (this.prefix || "").length;
    if (!!result.value) {
      result.caretPosition += preffixPadding;
    }
    result.value = this.wrapText(result.value);
    return result;
  }
  getMaskedValue(src) {
    const result = super.getMaskedValue(src);
    return this.wrapText(result);
  }
};
__decorate([property()], InputMaskCurrency.prototype, "prefix", void 0);
__decorate([property()], InputMaskCurrency.prototype, "suffix", void 0);
Serializer.addClass("currencymask", [{
  name: "prefix"
}, {
  name: "suffix"
}], () => {
  return new InputMaskCurrency();
}, "numericmask");
var Version;
var ReleaseDate;
Version = `${"2.0.0"}`;
settings.version = Version;
ReleaseDate = `${"2025-03-07"}`;
function checkLibraryVersion(ver, libraryName) {
  if (Version != ver) {
    const str = "survey-core has version '" + Version + "' and " + libraryName + " has version '" + ver + "'. SurveyJS libraries should have the same versions to work correctly.";
    console.error(str);
  }
}
function slk(key) {
  _slk(key, lic, ReleaseDate);
}
function hasLicense(index) {
  return lic[index.toString()] === true;
}
var lic = {};
function _slk(k, lh, rd) {
  if (!k) return;
  const en = (s) => {
    var e = {}, i, b = 0, x, l = 0, a, r = "", w = String.fromCharCode, L = s.length;
    var A = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0; i < 64; i++) {
      e[A.charAt(i)] = i;
    }
    for (x = 0; x < L; x++) {
      let c = e[s.charAt(x)];
      b = (b << 6) + c;
      l += 6;
      while (l >= 8) {
        ((a = b >>> (l -= 8) & 255) || x < L - 2) && (r += w(a));
      }
    }
    return r;
  };
  let v = en(k);
  if (!v) return;
  let index = v.indexOf(";");
  if (index < 0) return;
  if (!checkPrefix(v.substring(0, index))) return;
  v = v.substring(index + 1);
  v.split(",").forEach((s) => {
    let i = s.indexOf("=");
    if (i > 0) {
      lh[s.substring(0, i)] = new Date(rd) <= new Date(s.substring(i + 1));
    }
  });
}
function checkPrefix(prefix) {
  if (!prefix) return true;
  const s = "domains:";
  const index = prefix.indexOf(s);
  if (index < 0) return true;
  const ds = prefix.substring(index + s.length).toLowerCase().split(",");
  if (!Array.isArray(ds) || ds.length === 0) return true;
  const location = DomWindowHelper.getLocation();
  if (!!location && !!location.hostname) {
    const hn = location.hostname.toLowerCase();
    ds.push("localhost");
    for (let i = 0; i < ds.length; i++) {
      if (hn.indexOf(ds[i]) > -1) return true;
    }
    return false;
  }
  return true;
}
var SvgIconRegistry = class {
  constructor() {
    this.icons = {};
    this.iconPrefix = "icon-";
    this.onIconsChanged = new EventBase();
  }
  processId(iconId, iconPrefix) {
    if (iconId.indexOf(iconPrefix) == 0) {
      iconId = iconId.substring(iconPrefix.length);
    }
    iconId = renamedIcons[iconId] || iconId;
    return iconId;
  }
  registerIconFromSymbol(iconId, iconSymbolSvg) {
    this.icons[iconId] = iconSymbolSvg;
  }
  registerIconFromSvgViaElement(iconId, iconSvg, iconPrefix = this.iconPrefix) {
    if (!DomDocumentHelper.isAvailable()) return;
    iconId = this.processId(iconId, iconPrefix);
    let divSvg = DomDocumentHelper.createElement("div");
    divSvg.innerHTML = iconSvg;
    let symbol = DomDocumentHelper.createElement("symbol");
    let svg = divSvg.querySelector("svg");
    symbol.innerHTML = svg.innerHTML;
    for (var i = 0; i < svg.attributes.length; i++) {
      symbol.setAttributeNS("http://www.w3.org/2000/svg", svg.attributes[i].name, svg.attributes[i].value);
    }
    symbol.id = iconPrefix + iconId;
    this.registerIconFromSymbol(iconId, symbol.outerHTML);
  }
  registerIconFromSvg(iconId, iconSvg, iconPrefix = this.iconPrefix) {
    iconId = this.processId(iconId, iconPrefix);
    const startStr = "<svg ";
    const endStr = "</svg>";
    iconSvg = iconSvg.trim();
    const str = iconSvg.toLowerCase();
    if (str.substring(0, startStr.length) === startStr && str.substring(str.length - endStr.length, str.length) === endStr) {
      this.registerIconFromSymbol(iconId, '<symbol id="' + iconPrefix + iconId + '" ' + iconSvg.substring(startStr.length, str.length - endStr.length) + "</symbol>");
      return true;
    } else {
      return false;
    }
  }
  // TODO: remove in V2
  registerIconsFromFolder(r) {
    r.keys().forEach((key) => {
      this.registerIconFromSvg(key.substring(2, key.length - 4).toLowerCase(), r(key));
    });
  }
  registerIcons(icons) {
    for (const iconId in icons) {
      this.registerIconFromSvg(iconId, icons[iconId]);
    }
    this.updateMarkup();
  }
  registerIcon(id, svg, iconSetVersion = "v2") {
    this.registerIconFromSvg(id, svg);
    addIconsToThemeSet(iconSetVersion, {
      [id]: svg
    });
  }
  iconsRenderedHtml() {
    return Object.keys(this.icons).map((icon) => this.icons[icon]).join("");
  }
  updateMarkup() {
    this.onIconsChanged.fire(this, {});
  }
};
var SvgRegistry = new SvgIconRegistry();
var SvgThemeSets = {};
function addIconsToThemeSet(name, iconsData) {
  if (!SvgThemeSets[name]) {
    SvgThemeSets[name] = {};
  }
  const set = SvgThemeSets[name];
  for (const iconId in iconsData) {
    set[iconId] = iconsData[iconId];
  }
}

// node_modules/survey-creator-core/fesm/survey-creator-core.js
var enStrings = {
  // survey templates
  survey: {
    edit: "Edit",
    externalHelpLink: "Watch and learn how to create surveys",
    externalHelpLinkUrl: "https://www.youtube.com/channel/UCH2ru9okIcooNZfpIbyq4qQ?view_as=subscriber",
    dropQuestion: "Please drop a question here from the Toolbox.",
    addLogicItem: "Create a rule to customize the flow of the survey.",
    copy: "Copy",
    duplicate: "Duplicate",
    addToToolbox: "Add to toolbox",
    deletePanel: "Delete Panel",
    deleteQuestion: "Delete Question",
    convertTo: "Convert to",
    drag: "Drag element",
    license: "To use our library, a <a href='https://surveyjs.io/licensing'>developer license</a> is required. If you have an active license, <a href='https://surveyjs.io/remove-alert-banner'>set up your license key</a> and ensure you're using the latest version."
  },
  // Creator tabs
  tabs: {
    preview: "Preview",
    theme: "Themes",
    translation: "Translations",
    designer: "Designer",
    json: "JSON Editor",
    logic: "Logic"
  },
  // Question types
  qt: {
    default: "Default",
    checkbox: "Checkboxes",
    comment: "Long Text",
    imagepicker: "Image Picker",
    ranking: "Ranking",
    image: "Image",
    dropdown: "Dropdown",
    tagbox: "Multi-Select Dropdown",
    file: "File Upload",
    html: "HTML",
    matrix: "Single-Select Matrix",
    matrixdropdown: "Multi-Select Matrix",
    matrixdynamic: "Dynamic Matrix",
    multipletext: "Multiple Textboxes",
    panel: "Panel",
    paneldynamic: "Dynamic Panel",
    radiogroup: "Radio Button Group",
    rating: "Rating Scale",
    text: "Single-Line Input",
    boolean: "Yes/No (Boolean)",
    expression: "Expression (read-only)",
    signaturepad: "Signature",
    buttongroup: "Button Group"
  },
  toolboxCategories: {
    general: "General",
    choice: "Choice Questions",
    text: "Text Input Questions",
    containers: "Containers",
    matrix: "Matrix Questions",
    misc: "Misc"
  },
  // Strings in SurveyJS Creator
  ed: {
    defaultLocale: "Default ({0})",
    survey: "Survey",
    settings: "Settings",
    settingsTooltip: "Open settings",
    surveySettings: "Survey Settings",
    surveySettingsTooltip: "Survey settings",
    themeSettings: "Theme Settings",
    themeSettingsTooltip: "Theme settings",
    creatorSettingTitle: "Creator Settings",
    showPanel: "Show Panel",
    hidePanel: "Hide Panel",
    prevSelected: "Select previous",
    nextSelected: "Select next",
    prevFocus: "Focus previous",
    nextFocus: "Focus next",
    surveyTypeName: "Survey",
    pageTypeName: "Page",
    panelTypeName: "Panel",
    questionTypeName: "Question",
    columnTypeName: "Column",
    addNewPage: "Add New Page",
    moveRight: "Scroll to the Right",
    moveLeft: "Scroll to the Left",
    deletePage: "Delete Page",
    editPage: "Edit Page",
    edit: "Edit",
    newPageName: "page",
    newQuestionName: "question",
    newPanelName: "panel",
    newTextItemName: "text",
    defaultV2Theme: "Default",
    modernTheme: "Modern",
    defaultTheme: "Default (legacy)",
    testSurveyAgain: "Preview Survey Again",
    testSurveyWidth: "Survey width: ",
    navigateToMsg: "You had to navigate to",
    saveSurvey: "Save Survey",
    saveSurveyTooltip: "Save Survey",
    saveTheme: "Save Theme",
    saveThemeTooltip: "Save Theme",
    jsonHideErrors: "Hide errors",
    jsonShowErrors: "Show errors",
    undo: "Undo",
    redo: "Redo",
    undoTooltip: "Undo last change",
    redoTooltip: "Redo the change",
    expandTooltip: "Expand",
    collapseTooltip: "Collapse",
    expandAllTooltip: "Expand All",
    collapseAllTooltip: "Collapse All",
    zoomInTooltip: "Zoom In",
    zoom100Tooltip: "Zoom to 100%",
    zoomOutTooltip: "Zoom Out",
    lockQuestionsTooltip: "Lock expand/collapse state for questions",
    showMoreChoices: "Show more",
    showLessChoices: "Show less",
    copy: "Copy",
    cut: "Cut",
    paste: "Paste",
    copyTooltip: "Copy selection to clipboard",
    cutTooltip: "Cut selection to clipboard",
    pasteTooltip: "Paste from clipboard",
    options: "Options",
    generateValidJSON: "Generate Valid JSON",
    generateReadableJSON: "Generate Readable JSON",
    toolbox: "Toolbox",
    "property-grid": "Properties",
    toolboxFilteredTextPlaceholder: "Type to search...",
    toolboxNoResultsFound: "No results found",
    propertyGridFilteredTextPlaceholder: "Type to search...",
    propertyGridNoResultsFound: "No results found",
    propertyGridPlaceholderTitle: "Start configuring your form",
    propertyGridPlaceholderDescription: "Click any category icon to explore survey settings. Additional settings will become available once you add a survey element to the design surface.",
    correctJSON: "Please correct JSON.",
    surveyResults: "Survey Results ",
    surveyResultsTable: "As Table",
    surveyResultsJson: "As JSON",
    resultsTitle: "Question Title",
    resultsName: "Question Name",
    resultsValue: "Answer Value",
    resultsDisplayValue: "Display Value",
    modified: "Modified",
    saving: "Saving",
    saved: "Saved",
    propertyEditorError: "Error",
    saveError: "Error! Editor content is not saved.",
    translationPropertyGridTitle: "Language Settings",
    themePropertyGridTitle: "Theme Settings",
    addLanguageTooltip: "Add Language",
    translationLanguages: "Languages",
    translationDeleteLanguage: "Are you certain you wish to delete all strings for this language?",
    translationAddLanguage: "Select language to translate",
    translationShowAllStrings: "All Strings",
    translationShowUsedStringsOnly: "Used Strings Only",
    translationShowAllPages: "All Pages",
    translationNoStrings: "No strings to translate. Please change the filter.",
    translationExportToSCVButton: "Export to CSV",
    translationImportFromSCVButton: "Import from CSV",
    translateUsigAI: "Auto-translate All",
    translateUsigAIFrom: "Translate from: ",
    translationDialogTitle: "Untranslated strings",
    translationMergeLocaleWithDefault: "Merge {0} with default locale",
    translationPlaceHolder: "Translation...",
    translationSource: "Source: ",
    translationTarget: "Target: ",
    translationYouTubeNotSupported: "YouTube links are not supported.",
    themeExportButton: "Export",
    themeImportButton: "Import",
    surveyJsonExportButton: "Export",
    surveyJsonImportButton: "Import",
    surveyJsonCopyButton: "Copy to clipboard",
    themeResetButton: "Reset theme settings to default",
    themeResetConfirmation: "Do you really want to reset the theme? All your customizations will be lost.",
    themeResetConfirmationOk: "Yes, reset the theme",
    bold: "Bold",
    italic: "Italic",
    underline: "Underline",
    addNewQuestion: "Add Question",
    selectPage: "Select page...",
    carryForwardChoicesCopied: "Choices are copied from",
    choicesLoadedFromWebText: "Choices are loaded from a web service.",
    choicesLoadedFromWebLinkText: "Go to settings",
    choicesLoadedFromWebPreviewTitle: "Preview of loaded choice options",
    htmlPlaceHolder: "HTML content will be here.",
    panelPlaceHolder: "Drop a question from the toolbox here.",
    surveyPlaceHolder: "The survey is empty. Drag an element from the toolbox or click the button below.",
    pagePlaceHolder: "The page is empty. Drag an element from the toolbox or click the button below.",
    imagePlaceHolder: "Drag and drop an image here or click the button below and choose an image to upload",
    surveyPlaceHolderMobile: 'Click the "Add Question" button below to start creating your form.',
    surveyPlaceholderTitle: "Your form is empty",
    surveyPlaceholderTitleMobile: "Your form is empty",
    surveyPlaceholderDescription: "Drag an element from the toolbox or click the button below.",
    surveyPlaceholderDescriptionMobile: "Drag an element from the toolbox or click the button below.",
    previewPlaceholderTitle: "No preview",
    previewPlaceholderTitleMobile: "No preview",
    previewPlaceholderDescription: "The survey doesn't contain any visible elements.",
    previewPlaceholderDescriptionMobile: "The survey doesn't contain any visible elements.",
    translationsPlaceholderTitle: "No strings to translate",
    translationsPlaceholderTitleMobile: "No strings to translate",
    translationsPlaceholderDescription: "Add elements to your form or change the strings filter in the toolbar.",
    translationsPlaceholderDescriptionMobile: "Add elements to your form or change the strings filter in the toolbar.",
    pagePlaceHolderMobile: 'Click the "Add Question" button below to add a new element to the page.',
    panelPlaceHolderMobile: 'Click the "Add Question" button below to add a new element to the panel.',
    imagePlaceHolderMobile: "Click the button below and choose an image to upload",
    imageChooseImage: "Choose Image",
    addNewTypeQuestion: "Add {0}",
    //{0} is localizable question type
    chooseLogoPlaceholder: "[LOGO]",
    choices_Item: "Item ",
    selectFile: "Select a file",
    removeFile: "Remove the file",
    lg: {
      addNewItem: "Add New Rule",
      empty_tab: "Create a rule to customize the flow of the survey.",
      logicPlaceholderTitle: "No logical rules",
      logicPlaceholderTitleMobile: "No logical rules",
      logicPlaceholderDescription: "Create a rule to customize the flow of the survey.",
      logicPlaceholderDescriptionMobile: "Create a rule to customize the flow of the survey.",
      page_visibilityName: "Show/hide page",
      page_enableName: "Enable/disable page",
      page_requireName: "Make page required",
      panel_visibilityName: "Show/hide panel",
      panel_enableName: "Enable/disable panel",
      panel_requireName: "Make panel required",
      question_visibilityName: "Show/hide question",
      question_enableName: "Enable/disable question",
      question_requireName: "Make question required",
      question_resetValueName: "Reset question value",
      question_setValueName: "Set question value",
      column_visibilityName: "Show/hide column",
      column_enableName: "Enable/disable column",
      column_requireName: "Make column required",
      column_resetValueName: "Reset column value",
      column_setValueName: "Set column value",
      trigger_completeName: "Complete survey",
      trigger_setvalueName: "Set answer",
      trigger_copyvalueName: "Copy answer",
      trigger_skipName: "Skip to question",
      trigger_runExpressionName: "Run expression",
      completedHtmlOnConditionName: 'Set "Thank You" page markup',
      page_visibilityDescription: "Make the page visible when the logical expression evaluates to true. Otherwise, keep the page invisible.",
      panel_visibilityDescription: "Make the page visible when the logical expression evaluates to true. Otherwise, keep the panel invisible.",
      panel_enableDescription: "Make the panel and all elements inside it enabled when the logical expression evaluates to true. Otherwise, keep them disabled.",
      question_visibilityDescription: "Make the question visible when the logical expression evaluates to true. Otherwise, keep the question invisible.",
      question_enableDescription: "Make the question enabled when the logical expression evaluates to true. Otherwise, keep the question disabled.",
      question_requireDescription: "Question becomes required when the logical expression evaluates to true.",
      trigger_completeDescription: 'When the logical expression evaluates to true, the survey ends, and the respondent sees the "Thank you" page.',
      trigger_setvalueDescription: "When question values used in the logical expression are changed, and the expression evaluates to true, the specified value is assigned to the selected question.",
      trigger_copyvalueDescription: "When question values used in the logical expression are changed, and the expression evaluates to true, the value of the selected question is copied to another question.",
      trigger_skipDescription: "When the logical expression evaluates to true, the survey focuses/jumps to the selected question.",
      trigger_runExpressionDescription: "When the logical expression evaluates to true, the survey evaluates another expression. Optionally, the result of the latter expression can be assigned as a value to the selected question",
      completedHtmlOnConditionDescription: 'If the logical expression evaluates to true, the "Thank You" page displays the specified content.',
      itemExpressionText: "When expression: '{0}' returns true",
      //{0} - the expression
      itemEmptyExpressionText: "New rule",
      page_visibilityText: "make page {0} visible",
      //{0} page name
      panel_visibilityText: "make panel {0} visible",
      //{0} panel name
      panel_enableText: "make panel {0} enable",
      //{0} panel name
      question_visibilityText: "make question {0} visible",
      //{0} question name
      question_enableText: "make question {0} enable",
      //{0} question name
      question_requireText: "make question {0} required",
      //{0} question name
      question_resetValueText: "reset value for question: {0}",
      //{0} question name.
      question_setValueText: "assign value: {1} to question: {0}",
      //{0} question name and {1} setValueExpression
      column_visibilityText: "make column {0} of question {1} visible",
      //{0} column name, {1} question name
      column_enableText: "make column {0} of question {1} enable",
      //{0} column name, {1} question name
      column_requireText: "make column {0} of question {1} required",
      //{0} column name, {1} question name
      column_resetValueText: "reset cell value for column: {0}",
      //{0} column name
      column_setValueText: "assign cell value: {1} to column: {0}",
      //{0} column name and {1} setValueExpression
      setValueExpressionPlaceholder: "An expression whose result will be assigned to the target question.",
      trigger_completeText: "survey becomes completed",
      trigger_setvalueText: "set into question: {0} value {1}",
      //{0} question name, {1} setValue
      trigger_setvalueEmptyText: "clear question value: {0}",
      //{0} question name
      trigger_copyvalueText: "copy into question: {0} value from question {1}",
      //{0} and {1} question names
      trigger_skipText: "survey skip to the question {0}",
      //{0} question name
      trigger_runExpressionText1: "run expression: '{0}'",
      //{0} the expression
      trigger_runExpressionText2: " and set its result into question: {0}",
      //{0} question name
      completedHtmlOnConditionText: 'show custom text for the "Thank You" page.',
      showAllQuestions: "All Questions",
      showAllActionTypes: "All Action Types",
      conditions: "Condition(s)",
      actions: "Action(s)",
      expressionEditorTitle: "Define condition(s)",
      actionsEditorTitle: "Define action(s)",
      deleteAction: "Delete Action",
      addNewAction: "Add Action",
      selectedActionCaption: "Select action...",
      expressionInvalid: "The logic expression is empty or invalid. Please correct it.",
      noActionError: "Please add at least one action.",
      actionInvalid: "Please fix issues in your action(s).",
      uncompletedRule_title: "Logical rules are incomplete",
      uncompletedRule_text: "You have not completed some of the logical rules. If you leave the tab now, the changes will be lost. Do you still want to leave the tab without completing the changes?",
      uncompletedRule_apply: "Yes",
      uncompletedRule_cancel: "No, I want to complete the rules"
    }
  },
  // Property Editors
  pe: {
    panel: {
      name: "Panel name",
      title: "Panel title",
      description: "Panel description",
      visibleIf: "Make the panel visible if",
      requiredIf: "Make the panel required if",
      questionOrder: "Question order within the panel",
      page: "Move the panel to page",
      startWithNewLine: "Display the panel on a new line",
      state: "Panel collapse state",
      width: "Inline panel width",
      minWidth: "Minimum panel width",
      maxWidth: "Maximum panel width",
      showNumber: "Number this panel"
    },
    panellayoutcolumn: {
      effectiveWidth: "Effective width, %",
      questionTitleWidth: "Question title width, px"
    },
    paneldynamic: {
      name: "Panel name",
      title: "Panel title",
      description: "Panel description",
      visibleIf: "Make the panel visible if",
      requiredIf: "Make the panel required if",
      page: "Move the panel to page",
      startWithNewLine: "Display the panel on a new line",
      state: "Panel collapse state",
      width: "Inline panel width",
      minWidth: "Minimum panel width",
      maxWidth: "Maximum panel width",
      confirmDelete: "Confirm panel deletion",
      templateDescription: "Panel description pattern",
      templateTitle: "Panel title pattern",
      noEntriesText: "Empty panel text",
      templateTabTitle: "Tab title pattern",
      tabTitlePlaceholder: "Tab title placeholder",
      templateVisibleIf: "Make an individual panel visible if",
      showNumber: "Number the panel",
      titleLocation: "Panel title alignment",
      descriptionLocation: "Panel description alignment",
      templateQuestionTitleLocation: "Question title alignment",
      templateErrorLocation: "Error message alignment",
      newPanelPosition: "New panel location",
      showRangeInProgress: "Show the progress bar",
      keyName: "Prevent duplicate responses in the following question"
    },
    question: {
      name: "Question name",
      title: "Question title",
      description: "Question description",
      visibleIf: "Make the question visible if",
      requiredIf: "Make the question required if",
      page: "Move the question to page",
      state: "Question box collapse state",
      showNumber: "Number this question",
      titleLocation: "Question title alignment",
      descriptionLocation: "Question description alignment",
      errorLocation: "Error message alignment",
      indent: "Increase the inner indent",
      width: "Inline question width",
      minWidth: "Minimum question width",
      maxWidth: "Maximum question width",
      textUpdateMode: "Update input field value"
    },
    signaturepad: {
      signatureWidth: "Signature area width",
      signatureHeight: "Signature area height",
      signatureAutoScaleEnabled: "Auto-scale the signature area",
      showPlaceholder: "Show a placeholder within signature area",
      placeholder: "Placeholder text",
      placeholderReadOnly: "Placeholder text in read-only or preview mode",
      allowClear: "Show the Clear button within signature area",
      penMinWidth: "Minimum stroke width",
      penMaxWidth: "Maximum stroke width",
      penColor: "Stroke color"
    },
    comment: {
      rows: "Input field height (in lines)"
    },
    showQuestionNumbers: "Question numbering",
    questionStartIndex: "Question indexing type",
    expression: {
      name: "Expression name",
      title: "Expression title",
      description: "Expression description",
      expression: "Expression"
    },
    trigger: {
      expression: "Expression"
    },
    calculatedvalue: {
      expression: "Expression"
    },
    // survey templates
    survey: {
      title: "Survey title",
      description: "Survey description",
      readOnly: "Make the survey read-only"
    },
    page: {
      name: "Page name",
      title: "Page title",
      description: "Page description",
      visibleIf: "Make the page visible if",
      requiredIf: "Make the page required if",
      timeLimit: "Time limit to complete the page",
      questionOrder: "Question order on the page"
    },
    matrixdropdowncolumn: {
      name: "Column name",
      title: "Column title",
      isUnique: "Prevent duplicate responses",
      width: "Column width",
      minWidth: "Minimum column width",
      rows: "Input field height (in lines)",
      visibleIf: "Make the column visible if",
      requiredIf: "Make the column required if",
      showInMultipleColumns: "Each option in a separate column"
    },
    multipletextitem: {
      name: "Name",
      title: "Title"
    },
    masksettings: {
      saveMaskedValue: "Save masked value in survey results"
    },
    patternmask: {
      pattern: "Value pattern"
    },
    datetimemask: {
      min: "Minimum value",
      max: "Maximum value"
    },
    numericmask: {
      allowNegativeValues: "Allow negative values",
      thousandsSeparator: "Thousands separator",
      decimalSeparator: "Decimal separator",
      precision: "Value precision",
      min: "Minimum value",
      max: "Maximum value"
    },
    currencymask: {
      prefix: "Currency prefix",
      suffix: "Currency suffix"
    },
    imageHeight: "Display area height",
    imageWidth: "Display area width",
    valueName: "Join identifier",
    defaultDisplayValue: "Default display value for dynamic texts",
    rateDescriptionLocation: "Label alignment",
    size: "Input field width (in characters)",
    cellErrorLocation: "Cell error message alignment",
    enabled: "Enabled",
    disabled: "Disabled",
    inherit: "Inherit",
    apply: "Apply",
    ok: "OK",
    save: "Save",
    clear: "Clear",
    saveTooltip: "Save",
    cancel: "Cancel",
    set: "Set",
    reset: "Reset",
    change: "Change",
    refresh: "Refresh",
    close: "Close",
    delete: "Delete",
    add: "Add",
    addNew: "Add New",
    addItem: "Click to add an item...",
    removeItem: "Click to remove the item...",
    dragItem: "Drag the item",
    addOther: "Other",
    addSelectAll: "Select All",
    addNone: "None",
    removeAll: "Remove All",
    edit: "Edit",
    back: "Return without saving",
    backTooltip: "Return without saving",
    saveAndBack: "Save and return",
    saveAndBackTooltip: "Save and return",
    doneEditing: "Done",
    editChoices: "Edit Choices",
    showChoices: "Show Choices",
    move: "Move",
    empty: "<empty>",
    emptyValue: "Value is empty",
    fastEntry: "Manual Entry",
    fastEntryNonUniqueError: "Value '{0}' is not unique",
    fastEntryChoicesCountError: "Please limit the number of items from {0} to {1}",
    fastEntryChoicesMinCountError: "Please enter at least {0} items",
    fastEntryPlaceholder: "Enter the list of choice options and their IDs in the following format:\n\nid|option\n\nA choice option ID is not visible to respondents and can be used in conditional rules.",
    formEntry: "Form Entry",
    testService: "Test the service",
    itemSelectorEmpty: "Please select the element",
    conditionActionEmpty: "Please select the action",
    conditionSelectQuestion: "Select a question...",
    conditionSelectPage: "Select a page...",
    conditionSelectPanel: "Select a panel...",
    conditionValueQuestionTitle: "Please enter/select the value",
    aceEditorHelp: "Press ctrl+space to get expression completion hint",
    aceEditorRowTitle: "Current row",
    aceEditorPanelTitle: "Current panel",
    showMore: "For more details please check the documentation",
    assistantTitle: "Available questions",
    cellsEmptyRowsColumns: "There is should be at least one column or row",
    showPreviewBeforeComplete: "Review before submit",
    overridingPropertyPrefix: "Enabled by a condition",
    resetToDefaultCaption: "Reset",
    propertyIsEmpty: "Please enter a value",
    propertyIsNoUnique: "Please enter a unique value",
    propertyNameIsNotUnique: "Please enter a unique name",
    propertyNameIsIncorrect: 'Do not use reserved words: "item", "choice", "panel", "row".',
    listIsEmpty: "You don't have any items yet",
    "listIsEmpty@choices": "You don't have any choices yet",
    "listIsEmpty@columns": "You don't have any columns yet",
    "listIsEmpty@gridLayoutColumns": "You don't have layout columns yet",
    "listIsEmpty@rows": "You don't have any rows yet",
    "listIsEmpty@validators": "You don't have any validation rules yet",
    "listIsEmpty@calculatedValues": "You don't have any custom variables yet",
    "listIsEmpty@triggers": "You don't have any triggers yet",
    "listIsEmpty@navigateToUrlOnCondition": "You don't have any links yet",
    "listIsEmpty@pages": "You don't have any pages yet",
    "addNew@choices": "Add new choice",
    "addNew@columns": "Add new column",
    "addNew@rows": "Add new row",
    "addNew@validators": "Add new rule",
    "addNew@calculatedValues": "Add new variable",
    "addNew@triggers": "Add new trigger",
    "addNew@navigateToUrlOnCondition": "Add new URL",
    "addNew@pages": "Add new page",
    expressionIsEmpty: "Expression is empty",
    value: "Value",
    text: "Text",
    rowid: "Row ID",
    imageLink: "Image or video file URL",
    columnEdit: "Edit column: {0}",
    itemEdit: "Edit item: {0}",
    url: "URL",
    path: "Path to data",
    choicesbyurl: {
      url: "Web service URL",
      valueName: "Get value to store from the following property"
    },
    titleName: "Get value to display from the following property",
    imageLinkName: "Get file URLs from the following property",
    allowEmptyResponse: "Accept empty response",
    titlePlaceholder: "Title",
    surveyTitlePlaceholder: "Survey Title",
    pageTitlePlaceholder: "Page {num}",
    startPageTitlePlaceholder: "Start Page",
    descriptionPlaceholder: "Description",
    surveyDescriptionPlaceholder: "Description",
    pageDescriptionPlaceholder: "Description",
    textWrapEnabled: "Wrap choices",
    showOtherItem: 'Enable the "Other" option',
    otherText: 'Rename the "Other" option',
    showNoneItem: 'Enable the "None" option',
    showRefuseItem: 'Enable the "Refuse to Answer" option',
    showDontKnowItem: `Enable the "Don't Know" option`,
    noneText: 'Rename the "None" option',
    showSelectAllItem: 'Enable the "Select All" option',
    selectAllText: 'Rename the "Select All" option',
    choicesMin: "Minimum value for auto-generated items",
    choicesMax: "Maximum value for auto-generated items",
    choicesStep: "Step value for auto-generated items",
    name: "Name",
    title: "Title",
    cellType: "Cell input type",
    colCount: "Column count",
    choicesOrder: "Choice order",
    visible: "Visible",
    isRequired: "Required",
    markRequired: "Mark as required",
    removeRequiredMark: "Remove the required mark",
    eachRowRequired: "Require an answer in each row",
    eachRowUnique: "Prevent duplicate responses in rows",
    requiredErrorText: "Error message for required questions",
    startWithNewLine: "Display the question on a new line",
    rows: "Rows",
    cols: "Columns",
    placeholder: "Placeholder text within input field",
    showPreview: "Show preview area",
    storeDataAsText: "Store file content in JSON result as text",
    maxSize: "Maximum file size (in bytes)",
    rowCount: "Row count",
    columnLayout: "Columns layout",
    addRowButtonLocation: '"Add Row" button alignment',
    transposeData: "Transpose rows to columns",
    addRowText: '"Add Row" button text',
    removeRowText: '"Remove Row" button text',
    rateMin: "Minimum rating value",
    rateMax: "Maximum rating value",
    rateStep: "Step value",
    minRateDescription: "Minimum value label",
    maxRateDescription: "Maximum value label",
    inputType: "Input type",
    optionsCaption: "Option placeholder",
    defaultValue: "Default Answer",
    cellsDefaultRow: "Default texts",
    surveyEditorTitle: "Edit survey settings",
    qEditorTitle: "Edit: {0}",
    maxLength: "Maximum character limit",
    buildExpression: "Build",
    editExpression: "Edit",
    and: "and",
    or: "or",
    remove: "Remove",
    addCondition: "Add Condition",
    emptyLogicPopupMessage: "Select a question to start configuring conditions.",
    if: "If",
    then: "then",
    setToName: "Target question",
    fromName: "Question to copy answer from",
    gotoName: "Question to skip to",
    ruleIsNotSet: "Rule is incorrect",
    includeIntoResult: "Add to the survey results",
    showTitle: "Make the title and description visible",
    expandCollapseTitle: "Expand/collapse title",
    locale: "Select a survey language",
    simulator: "Select device type",
    landscapeOrientation: "Switch to landscape orientation",
    portraitOrientation: "Switch to portrait orientation",
    clearInvisibleValues: "Clear hidden question values",
    cookieName: "Limit to one response",
    partialSendEnabled: "Auto-save survey progress on page change",
    storeOthersAsComment: 'Save the "Other" option value as a separate property',
    showPageTitles: "Show page titles",
    showPageNumbers: "Show page numbers",
    pagePrevText: '"Previous Page" button text',
    pageNextText: '"Next Page" button text',
    completeText: '"Complete Survey" button text',
    previewText: '"Review Answers" button text',
    editText: '"Edit Answer" button text',
    startSurveyText: '"Start Survey" button text',
    showNavigationButtons: "Show navigation buttons",
    navigationButtonsLocation: "Navigation buttons alignment",
    showPrevButton: 'Show the "Previous Page" button',
    firstPageIsStartPage: "First page is a start page",
    showCompletePage: 'Show the "Thank You" page',
    autoAdvanceEnabled: "Auto-advance to the next page",
    autoAdvanceAllowComplete: "Complete the survey automatically",
    showProgressBar: "Show the progress bar",
    progressBarLocation: "Progress bar alignment",
    questionTitleLocation: "Question title alignment",
    questionTitleWidth: "Question title width",
    requiredMark: "Required symbol(s)",
    questionTitleTemplate: "Question title template, default is: '{no}. {require} {title}'",
    questionErrorLocation: "Error message alignment",
    autoFocusFirstQuestion: "Focus first question on a new page",
    questionOrder: "Question order",
    timeLimit: "Time limit to complete the survey",
    timeLimitPerPage: "Time limit to complete one page",
    showTimer: "Use a timer",
    timerLocation: "Timer alignment",
    timerInfoMode: "Timer mode",
    renderMode: "Panel display mode",
    allowAddPanel: "Enable panel addition",
    allowRemovePanel: "Enable panel removal",
    addPanelText: '"Add Panel" button text',
    removePanelText: '"Remove Panel" button text',
    isSinglePage: "Show all elements on one page",
    html: "HTML markup",
    setValue: "Answer",
    dataFormat: "Storage format",
    allowAddRows: "Enable row addition",
    allowRemoveRows: "Enable row removal",
    allowRowReorder: "Enable row reordering",
    responsiveImageSizeHelp: "Does not apply if you specify the exact display area width or height.",
    minImageWidth: "Minimum display area width",
    maxImageWidth: "Maximum display area width",
    minImageHeight: "Minimum display area height",
    maxImageHeight: "Maximum display area height",
    minValue: "Minimum value",
    maxValue: "Maximum value",
    caseInsensitive: "Case insensitive",
    minLength: "Minimum length (in characters)",
    allowDigits: "Allow digits",
    minCount: "Minimum count",
    maxCount: "Maximum count",
    regex: "Regular expression",
    surveyvalidator: {
      text: "Error message",
      expression: "Validation expression"
    },
    totalText: "Total row header",
    totalType: "Aggregation method",
    totalExpression: "Total value expression",
    totalDisplayStyle: "Total value display format",
    totalCurrency: "Currency",
    totalFormat: "Formatted string",
    logo: "Survey logo",
    questionsOnPageMode: "Survey layout",
    maxTextLength: "Restrict answer length",
    maxCommentLength: "Restrict comment length",
    commentAreaRows: "Comment area height (in lines)",
    autoGrowComment: "Auto-expand text areas",
    allowResizeComment: "Allow users to resize text areas",
    textUpdateMode: "Update input field values",
    maskType: "Input mask type",
    autoFocusFirstError: "Set focus on the first invalid answer",
    checkErrorsMode: "Run validation",
    validateVisitedEmptyFields: "Validate empty fields on lost focus",
    navigateToUrl: "Redirect to an external link after submission",
    navigateToUrlOnCondition: "Dynamic external link",
    completedBeforeHtml: "Markup to show if the user already filled out this survey",
    completedHtml: '"Thank You" page markup',
    completedHtmlOnCondition: 'Dynamic "Thank You" page markup',
    loadingHtml: "Markup to show while survey model is loading",
    commentText: "Comment area text",
    autocomplete: "Autocomplete type",
    labelTrue: 'Label for "True"',
    labelFalse: 'Label for "False"',
    allowClear: "Show the Clear button",
    searchMode: "Search Mode",
    displayStyle: "Display format",
    format: "Formatted string",
    maximumFractionDigits: "Maximum fractional digits",
    minimumFractionDigits: "Minimum fractional digits",
    useGrouping: "Display grouping separators",
    allowMultiple: "Enable multiple file upload",
    allowImagesPreview: "Preview uploaded images",
    acceptedTypes: "Accepted file types",
    waitForUpload: "Wait for upload to complete",
    needConfirmRemoveFile: "Confirm file deletion",
    detailPanelMode: "Row expansion alignment",
    minRowCount: "Minimum row count",
    maxRowCount: "Maximum row count",
    confirmDelete: "Confirm row deletion",
    confirmDeleteText: "Confirmation message",
    panelCount: "Initial panel count",
    minPanelCount: "Minimum panel count",
    maxPanelCount: "Maximum panel count",
    panelsState: "Inner panel collapse state",
    prevPanelText: '"Previous Panel" button text',
    nextPanelText: '"Next Panel" button text',
    removePanelButtonLocation: '"Remove Panel" button alignment',
    hideIfRowsEmpty: "Hide the question if it has no rows",
    hideColumnsIfEmpty: "Hide columns if there are no rows",
    rateValues: "Custom rating values",
    rateCount: "Rating count",
    autoGenerate: "Rating configuration",
    hideIfChoicesEmpty: "Hide the question if it has no choices",
    minWidth: "Minimum width",
    maxWidth: "Maximum width",
    width: "Width",
    showHeader: "Show column headers",
    horizontalScroll: "Show horizontal scrollbar",
    columnMinWidth: "Minimum column width",
    rowTitleWidth: "Row header width",
    valueTrue: 'Value to store when "True" is selected',
    valueFalse: 'Value to store when "False" is selected',
    minErrorText: '"Value is below minimum" error message',
    maxErrorText: '"Value exceeds maximum" error message',
    otherErrorText: '"Empty comment" error message',
    keyDuplicationError: "Error message for duplicate responses",
    minSelectedChoices: "Minimum choices to select",
    maxSelectedChoices: "Maximum choices to select",
    logoWidth: "Logo width",
    logoHeight: "Logo height",
    readOnly: "Read-only",
    enableIf: "Disable the read-only mode if",
    noRowsText: '"No rows" message',
    separateSpecialChoices: "Separate special choices",
    choicesFromQuestion: "Copy choices from the following question",
    choicesFromQuestionMode: "Which choice options to copy",
    choiceValuesFromQuestion: "Use values from the following matrix column or panel question as choice IDs",
    choiceTextsFromQuestion: "Use values from the following matrix column or panel question as choice texts",
    progressBarShowPageTitles: "Display page titles in the progress bar",
    progressBarShowPageNumbers: "Display page numbers in the progress bar",
    showCommentArea: "Add a comment box",
    commentPlaceholder: "Placeholder text for the comment box",
    displayRateDescriptionsAsExtremeItems: "Show the labels as extreme values",
    rowOrder: "Row order",
    columnsLayout: "Column layout",
    columnColCount: "Nested column count",
    correctAnswer: "Correct Answer",
    defaultPanelValue: "Default Values",
    cells: "Cell Texts",
    fileInputPlaceholder: "Select a file or paste a file link...",
    keyName: "Prevent duplicate responses in the following column",
    itemvalue: {
      visibleIf: "Make the option visible if",
      enableIf: "Make the option selectable if"
    },
    "itemvalue@rows": {
      visibleIf: "Make the row visible if",
      enableIf: "Make the row editable if"
    },
    imageitemvalue: {
      text: "Alt text"
    },
    logoPosition: "Logo alignment",
    addLogo: "Add logo...",
    changeLogo: "Change logo...",
    logoPositions: {
      none: "Remove logo",
      left: "Left",
      right: "Right",
      top: "On the top",
      bottom: "In the bottom"
    },
    previewMode: "Preview mode",
    gridLayoutEnabled: "Enable grid layout",
    gridLayoutColumns: "Grid columns",
    maskSettings: "Mask settings",
    detailErrorLocation: "Row expansion error message alignment",
    // Creator tabs
    tabs: {
      panel: {
        layout: "Panel Layout"
      },
      general: "General",
      fileOptions: "Options",
      html: "HTML Editor",
      columns: "Columns",
      rows: "Rows",
      choices: "Choice Options",
      items: "Items",
      visibleIf: "Visible If",
      enableIf: "Editable If",
      requiredIf: "Required If",
      rateValues: "Rating Values",
      choicesByUrl: "Choices from a Web Service",
      matrixChoices: "Default Choices",
      multipleTextItems: "Text Inputs",
      numbering: "Numbering",
      validators: "Validators",
      navigation: "Navigation",
      question: "Question Settings",
      pages: "Pages",
      timer: "Quiz Mode",
      calculatedValues: "Calculated Values",
      triggers: "Triggers",
      templateTitle: "Title template",
      totals: "Totals",
      logic: "Conditions",
      mask: "Input Mask Settings",
      layout: {
        panel: "Panel Layout",
        question: "Layout",
        base: "Layout"
      },
      data: "Data",
      validation: "Validation",
      cells: "Individual Cell Texts",
      showOnCompleted: '"Thank You" Page',
      logo: "Logo in the Survey Header",
      slider: "Slider",
      expression: "Expression",
      questionSettings: "Question Settings",
      header: "Header",
      background: "Background",
      appearance: "Appearance",
      accentColors: "Accent colors",
      surfaceBackground: "Surface background",
      scaling: "Scaling",
      others: "Others"
    },
    editProperty: "Edit property '{0}'",
    items: "Items",
    choicesVisibleIf: "Make choices visible if",
    choicesEnableIf: "Make choices selectable if",
    columnsEnableIf: "Make columns visible if",
    rowsEnableIf: "Make rows visible if",
    innerIndent: "Increase the inner indent",
    copyDefaultValueFromLastEntry: "Use answers from the last entry as default",
    enterNewValue: "Please enter a value.",
    noquestions: "There are no questions in the survey.",
    createtrigger: "Please create a trigger",
    titleKeyboardAdornerTip: "Press enter button to edit",
    keyboardAdornerTip: "Press enter button to edit item, press delete button to delete item, press alt plus arrow up or arrow down to move item",
    triggerOn: "On ",
    triggerMakePagesVisible: "Make pages visible",
    triggerMakeQuestionsVisible: "Make elements visible",
    triggerCompleteText: "Complete the survey if successful.",
    triggerNotSet: "The trigger is not set",
    triggerRunIf: "Run if",
    triggerSetToName: "Change value of: ",
    triggerFromName: "Copy value from: ",
    triggerRunExpression: "Run this Expression",
    triggerSetValue: "to: ",
    triggerGotoName: "Go to the question",
    triggerIsVariable: "Do not put the variable into the survey result.",
    triggerRunExpressionEmpty: "Please enter a valid expression",
    emptyExpressionPlaceHolder: "Type expression here...",
    noFile: "No file chosen",
    clearIfInvisible: "Clear hidden question values",
    valuePropertyName: "Store values in the following property",
    searchEnabled: "Enable search-as-you-type",
    hideSelectedItems: "Hide selected items",
    closeOnSelect: "Collapse the dropdown upon selection",
    verticalAlign: "Vertical alignment within cells",
    alternateRows: "Alternate row colors",
    columnsVisibleIf: "Make columns visible if",
    rowsVisibleIf: "Make rows visible if",
    otherPlaceholder: "Placeholder text for the comment box",
    filePlaceholder: "Placeholder text for Local file",
    photoPlaceholder: "Placeholder text for Camera",
    fileOrPhotoPlaceholder: "Placeholder text for Local file or Camera",
    rateType: "Rating icon",
    url_placeholder: "Ex.: https://api.example.com/books",
    path_placeholder: "Ex.: categories.fiction",
    questionStartIndex_placeholder: "Ex.: a)",
    width_placeholder: "Ex.: 6in",
    minWidth_placeholder: "Ex.: 600px",
    maxWidth_placeholder: "Ex.: 50%",
    imageHeight_placeholder: "auto",
    imageWidth_placeholder: "auto",
    itemTitleWidth_placeholder: "Ex.: 100px",
    theme: {
      themeName: "Theme",
      isPanelless: "Question appearance",
      editorPanel: "Background and corner radius",
      questionPanel: "Background and corner radius",
      primaryColor: "Accent color",
      panelBackgroundTransparency: "Panel and question box opacity",
      questionBackgroundTransparency: "Input element opacity",
      fontSize: "Survey font size",
      scale: "Survey scale factor",
      cornerRadius: "Corner radius",
      advancedMode: "Advanced mode",
      pageTitle: "Title font",
      pageDescription: "Description font",
      questionTitle: "Title font",
      questionDescription: "Description font",
      editorFont: "Font",
      backgroundOpacity: "Opacity",
      // Auto-generated string
      "--sjs-font-family": "Survey font family",
      "--sjs-general-backcolor-dim": "Background color",
      "--sjs-primary-backcolor": "Accent background colors",
      "--sjs-primary-forecolor": "Accent foreground colors",
      "--sjs-special-red": "Error message colors",
      "--sjs-shadow-small": "Shadow effects",
      "--sjs-shadow-inner": "Shadow effects",
      "--sjs-border-default": "Colors"
    },
    "header@header": {
      headerView: "View",
      logoPosition: "Logo alignment",
      surveyTitle: "Survey title font",
      surveyDescription: "Survey description font",
      headerTitle: "Survey title font",
      headerDescription: "Survey description font",
      inheritWidthFrom: "Content area width",
      textAreaWidth: "Text width",
      backgroundColorSwitch: "Background color",
      backgroundImage: "Background image",
      backgroundImageOpacity: "Opacity",
      overlapEnabled: "Overlap",
      logoPositionX: "Logo alignment",
      titlePositionX: "Survey title alignment",
      descriptionPositionX: "Survey description alignment"
    }
  },
  // Property values
  pv: {
    "true": "true",
    "false": "false",
    file: "Local file",
    camera: "Camera",
    "file-camera": "Local file or Camera",
    inherit: "Inherit",
    show: "Visible",
    hide: "Hidden",
    default: "Inherit",
    initial: "Initial",
    random: "Random",
    collapsed: "Collapsed",
    expanded: "Expanded",
    none: "None",
    asc: "Ascending",
    desc: "Descending",
    indeterminate: "Indeterminate",
    selected: "Selected",
    unselected: "Unselected",
    decimal: "decimal",
    currency: "currency",
    percent: "percent",
    firstExpanded: "First panel is expanded",
    off: "Hide question numbers",
    list: "List",
    carousel: "Carousel",
    tab: "Tabs",
    progressTop: "Panel navigator + Progress bar at the top",
    progressBottom: "Panel navigator + Progress bar at the bottom",
    progressTopBottom: "Panel navigator + Progress bar at the top and bottom",
    horizontal: "Horizontal",
    vertical: "Vertical",
    top: "Top",
    bottom: "Bottom",
    topBottom: "Top and bottom",
    both: "Both",
    left: "Left",
    right: "Right",
    center: "Center",
    leftRight: "Left and right",
    middle: "Middle",
    color: "color",
    date: "date",
    datetime: "datetime",
    "datetime-local": "datetime-local",
    email: "email",
    month: "month",
    number: "number",
    password: "password",
    range: "range",
    tel: "tel",
    text: "text",
    time: "time",
    url: "url",
    week: "week",
    hidden: "Hidden",
    edit: "Editable",
    display: "Read-only",
    contain: "Contain",
    cover: "Cover",
    fill: "Fill",
    next: "Next",
    last: "Last",
    onComplete: "Upon survey completion",
    onHidden: "When question gets hidden",
    onHiddenContainer: "When question or its panel/page gets hidden",
    clearInvisibleValues: {
      none: "Never"
    },
    clearIfInvisible: {
      none: "Never"
    },
    inputType: {
      color: "Color",
      date: "Date",
      "datetime-local": "Date and Time",
      email: "Email",
      month: "Month",
      number: "Number",
      password: "Password",
      range: "Range",
      tel: "Phone Number",
      text: "Text",
      time: "Time",
      url: "URL",
      week: "Week"
    },
    autocomplete: {
      "name": "Full Name",
      "honorific-prefix": "Prefix",
      "given-name": "First Name",
      "additional-name": "Middle Name",
      "family-name": "Last Name",
      "honorific-suffix": "Suffix",
      "nickname": "Nickname",
      "organization-title": "Job Title",
      "username": "User Name",
      "new-password": "New Password",
      "current-password": "Current Password",
      "organization": "Organization Name",
      "street-address": "Full Street Address",
      "address-line1": "Address Line 1",
      "address-line2": "Address Line 2",
      "address-line3": "Address Line 3",
      "address-level4": "Level 4 Address",
      "address-level3": "Level 3 Address",
      "address-level2": "Level 2 Address",
      "address-level1": "Level 1 Address",
      "country": "Country Code",
      "country-name": "Country Name",
      "postal-code": "Postal Code",
      "cc-name": "Cardholder Name",
      "cc-given-name": "Cardholder First Name",
      "cc-additional-name": "Cardholder Middle Name",
      "cc-family-name": "Cardholder Last Name",
      "cc-number": "Credit Card Number",
      "cc-exp": "Expiration Date",
      "cc-exp-month": "Expiration Month",
      "cc-exp-year": "Expiration Year",
      "cc-csc": "Card Security Code",
      "cc-type": "Credit Card Type",
      "transaction-currency": "Transaction Currency",
      "transaction-amount": "Transaction Amount",
      "language": "Preferred Language",
      "bday": "Birthday",
      "bday-day": "Birthday Day",
      "bday-month": "Birthday Month",
      "bday-year": "Birthday Year",
      "sex": "Gender",
      "url": "Website URL",
      "photo": "Profile Photo",
      "tel": "Telephone Number",
      "tel-country-code": "Country Code for Phone",
      "tel-national": "National Telephone Number",
      "tel-area-code": "Area Code",
      "tel-local": "Local Phone Number",
      "tel-local-prefix": "Local Phone Prefix",
      "tel-local-suffix": "Local Phone Suffix",
      "tel-extension": "Phone Extension",
      "email": "Email Address",
      "impp": "Instant Messaging Protocol"
    },
    maskType: {
      none: "None",
      pattern: "Pattern",
      numeric: "Numeric",
      datetime: "Date and Time",
      currency: "Currency"
    },
    inputTextAlignment: {
      auto: "Auto",
      left: "Left",
      right: "Right"
    },
    all: "All",
    page: "Page",
    survey: "Survey",
    onNextPage: "When switching to the next page",
    onValueChanged: "After an answer is changed",
    onValueChanging: "Before an answer is changed",
    questionsOnPageMode: {
      standard: "Original structure",
      singlePage: "Show all questions on one page",
      questionPerPage: "Show single question per page"
    },
    noPreview: "No preview",
    showAllQuestions: "Show all questions",
    showAnsweredQuestions: "Show answered questions only",
    allQuestions: "Show all questions",
    answeredQuestions: "Show answered questions only",
    pages: "Completed pages",
    questions: "Answered questions",
    requiredQuestions: "Answered required questions",
    correctQuestions: "Valid answers",
    buttons: "Completed pages (button UI)",
    underInput: "Under the input field",
    underTitle: "Under the question title",
    onBlur: "On lost focus",
    onTyping: "While typing",
    underRow: "Under the row",
    underRowSingle: "Under the row, display one row expansion only",
    auto: "Auto",
    showNavigationButtons: {
      none: "Hidden"
    },
    timerInfoMode: {
      combined: "Both"
    },
    addRowButtonLocation: {
      default: "Based on matrix layout"
    },
    panelsState: {
      default: "Locked",
      collapsed: "Collapse all",
      expanded: "Expand all",
      firstExpanded: "First expanded"
    },
    widthMode: {
      static: "Static",
      responsive: "Responsive"
    },
    contentMode: {
      image: "Image",
      video: "Video",
      youtube: "YouTube"
    },
    displayMode: {
      buttons: "Buttons",
      dropdown: "Dropdown"
    },
    rateColorMode: {
      default: "Default",
      scale: "Scale"
    },
    scaleColorMode: {
      monochrome: "Monochrome",
      colored: "Colored"
    },
    autoGenerate: {
      "true": "Auto-generate",
      "false": "Manual"
    },
    rateType: {
      labels: "Labels",
      stars: "Stars",
      smileys: "Smileys"
    },
    state: {
      default: "Locked"
    },
    showQuestionNumbers: {
      default: "Auto-numbering",
      on: "Auto-numbering",
      onPage: "Reset on each page",
      onpanel: "Reset on each panel",
      onPanel: "Reset on each panel",
      onSurvey: "Continue across the survey",
      off: "No numbering"
    },
    descriptionLocation: {
      underTitle: "Under the question title",
      underInput: "Under the input field"
    },
    selectToRankAreasLayout: {
      horizontal: "Next to choices",
      vertical: "Above choices"
    },
    displayStyle: {
      decimal: "Decimal",
      currency: "Currency",
      percent: "Percentage",
      date: "Date"
    },
    totalDisplayStyle: {
      decimal: "Decimal",
      currency: "Currency",
      percent: "Percentage",
      date: "Date"
    },
    rowOrder: {
      initial: "Original"
    },
    questionOrder: {
      initial: "Original"
    },
    progressBarLocation: {
      top: "Top",
      bottom: "Bottom",
      topbottom: "Top and bottom",
      aboveheader: "Above the header",
      belowheader: "Below the header",
      off: "Hidden"
    },
    sum: "Sum",
    count: "Count",
    min: "Min",
    max: "Max",
    avg: "Avg",
    searchMode: {
      contains: "Contains",
      startsWith: "Starts with"
    },
    backgroundImageFit: {
      auto: "Auto",
      cover: "Cover",
      contain: "Contain",
      fill: "Stretch",
      tile: "Tile"
    },
    backgroundImageAttachment: {
      fixed: "Fixed",
      scroll: "Scroll"
    },
    headerView: {
      basic: "Basic",
      advanced: "Advanced"
    },
    inheritWidthFrom: {
      survey: "Same as survey",
      container: "Same as container"
    },
    backgroundColorSwitch: {
      none: "None",
      accentColor: "Accent color",
      custom: "Custom"
    },
    colorPalette: {
      light: "Light",
      dark: "Dark"
    },
    isPanelless: {
      false: "Default",
      true: "Without Panels"
    },
    progressBarInheritWidthFrom: {
      survey: "Same as survey",
      container: "Same as container"
    }
  },
  // Operators
  op: {
    empty: "Empty",
    notempty: "Not empty",
    equal: "Equals",
    notequal: "Does not equal",
    contains: "Contains",
    notcontains: "Does not contain",
    anyof: "Any of",
    allof: "All of",
    greater: "Greater than",
    less: "Less than",
    greaterorequal: "Greater than or equal to",
    lessorequal: "Less than or equal to",
    and: "and",
    or: "or"
  },
  // Embed window
  ew: {
    angular: "Use Angular version",
    jquery: "Use jQuery version",
    knockout: "Use Knockout version",
    react: "Use React version",
    vue: "Use Vue version",
    bootstrap: "For bootstrap framework",
    modern: "Modern theme",
    default: "Default theme",
    orange: "Orange theme",
    darkblue: "Darkblue theme",
    darkrose: "Darkrose theme",
    stone: "Stone theme",
    winter: "Winter theme",
    winterstone: "Winter-Stone theme",
    showOnPage: "Show survey on a page",
    showInWindow: "Show survey in a window",
    loadFromServer: "Load Survey JSON from server",
    titleScript: "Scripts and styles",
    titleHtml: "HTML",
    titleJavaScript: "JavaScript"
  },
  // Preview (Survey)
  ts: {
    selectPage: "Select the page to test it",
    showInvisibleElements: "Show invisible elements",
    hideInvisibleElements: "Hide invisible elements"
  },
  validators: {
    answercountvalidator: "Answer count",
    emailvalidator: "Email",
    expressionvalidator: "Expression",
    numericvalidator: "Number",
    regexvalidator: "Regex",
    textvalidator: "Text"
  },
  triggers: {
    completetrigger: "Complete survey",
    setvaluetrigger: "Set answer",
    copyvaluetrigger: "Copy answer",
    skiptrigger: "Skip to question",
    runexpressiontrigger: "Run expression",
    visibletrigger: "change visibility (deprecated)"
  },
  peplaceholder: {
    patternmask: {
      pattern: "Ex.: +1(999)-999-99-99"
    },
    datetimemask: {
      pattern: "Ex.: mm/dd/yyyy HH:MM:ss"
    },
    currencymask: {
      prefix: "Ex.: $",
      suffix: "Ex.: USD"
    },
    panelbase: {
      questionTitleWidth: "Ex.: 200px"
    },
    panellayoutcolumn: {
      effectiveWidth: "Ex.: 30%",
      questionTitleWidth: "Ex.: 200px"
    }
  },
  pehelp: {
    panel: {
      name: "A panel ID that is not visible to respondents.",
      description: "Type a panel subtitle.",
      // isRequired: "Prevents survey submission unless at least one nested question has an answer.",
      visibleIf: "Use the magic wand icon to set a conditional rule that determines panel visibility.",
      enableIf: "Use the magic wand icon to set a conditional rule that disables the read-only mode for the panel.",
      requiredIf: "Use the magic wand icon to set a conditional rule that prevents survey submission unless at least one nested question has an answer.",
      questionTitleLocation: 'Applies to all questions within this panel. When set to "Hidden", it also hides question descriptions. If you want to override this setting, define title alignment rules for individual questions. The "Inherit" option applies the page-level (if set) or survey-level setting ("Top" by default). ',
      questionTitleWidth: "Sets consistent width for question titles when they are aligned to the left of their question boxes. Accepts CSS values (px, %, in, pt, etc.).",
      questionErrorLocation: 'Sets the location of an error message in relation to all questions within the panel. The "Inherit" option applies the page-level (if set) or survey-level setting.',
      questionOrder: 'Keeps the original order of questions or randomizes them. The "Inherit" option applies the page-level (if set) or survey-level setting.',
      page: "Repositions the panel to the end of a selected page.",
      innerIndent: "Adds space or margin between the panel content and the left border of the panel box.",
      startWithNewLine: "Unselect to display the panel in one line with the previous question or panel. The setting doesn't apply if the panel is the first element in your form.",
      state: 'Choose from: "Expanded" - the panel is displayed in full and can be collapsed; "Collapsed" - the panel displays only the title and description and can be expanded; "Locked" - the panel is displayed in full and cannot be collapsed.',
      width: "Sets the width of the panel in proportion to other survey elements in the same line. Accepts CSS values (px, %, in, pt, etc.).",
      showQuestionNumbers: "Assigns numbers to questions nested within this panel.",
      effectiveColSpan: "Specifies how many columns this panel spans within the grid layout.",
      gridLayoutColumns: "This table lets you configure each grid column within the panel. It automatically sets the width percentage for each column based on the maximum number of elements in a row. To customize the grid layout, manually adjust these values and define the title width for all questions in each column."
    },
    paneldynamic: {
      name: "A panel ID that is not visible to respondents.",
      description: "Type a panel subtitle.",
      // isRequired: "Prevents survey submission unless at least one nested question has an answer.",
      visibleIf: "Use the magic wand icon to set a conditional rule that determines panel visibility.",
      enableIf: "Use the magic wand icon to set a conditional rule that disables the read-only mode for the panel.",
      requiredIf: "Use the magic wand icon to set a conditional rule that prevents survey submission unless at least one nested question has an answer.",
      templateQuestionTitleLocation: 'Applies to all questions within this panel. If you want to override this setting, define title alignment rules for individual questions. The "Inherit" option applies the page-level (if set) or survey-level setting ("Top" by default).',
      templateErrorLocation: 'Sets the location of an error message in relation to a question with invalid input. Choose between: "Top" - an error text is placed at the top of the question box; "Bottom" - an error text is placed at the bottom of the question box. The "Inherit" option applies the page-level (if set) or survey-level setting ("Top" by default).',
      errorLocation: 'Sets the location of an error message in relation to all questions within the panel. The "Inherit" option applies the page-level (if set) or survey-level setting.',
      // questionOrder: "Keeps the original order of questions or randomizes them. The \"Inherit\" option applies the page-level (if set) or survey-level setting.",
      page: "Repositions the panel to the end of a selected page.",
      innerIndent: "Adds space or margin between the panel content and the left border of the panel box.",
      startWithNewLine: "Unselect to display the panel in one line with the previous question or panel. The setting doesn't apply if the panel is the first element in your form.",
      state: 'Choose from: "Expanded" - the panel is displayed in full and can be collapsed; "Collapsed" - the panel displays only the title and description and can be expanded; "Locked" - the panel is displayed in full and cannot be collapsed.',
      width: "Sets the width of the panel in proportion to other survey elements in the same line. Accepts CSS values (px, %, in, pt, etc.).",
      templateTitle: "Type in a template for dynamic panel titles. Use {panelIndex} for the panel's general position and {visiblePanelIndex} for its order among visible panels. Insert these placeholders into the pattern to add automatic numbering.",
      templateTabTitle: "Type in a template for tab titles. Use {panelIndex} for a panel's general position and {visiblePanelIndex} for its order among visible panels. Insert these placeholders into the pattern to add automatic numbering.",
      tabTitlePlaceholder: "A fallback text for tab titles that applies when the tab title pattern doesn't produce a meaningful value.",
      templateVisibleIf: "This setting allows you to control the visibility of individual panels within the dynamic panel. Use the `{panel}` placeholder to reference the current panel in your expression.",
      titleLocation: 'This setting is automatically inherited by all questions within this panel. If you want to override this setting, define title alignment rules for individual questions. The "Inherit" option applies the page-level (if set) or survey-level setting ("Top" by default).',
      descriptionLocation: 'The "Inherit" option applies the page-level (if set) or survey-level setting ("Under the panel title" by default).',
      newPanelPosition: 'Defines the position of a newly added panel. By default, new panels are added to the end. Select "Next" to insert a new panel after the current one.',
      copyDefaultValueFromLastEntry: "Duplicates answers from the last panel and assigns them to the next added dynamic panel.",
      keyName: "Reference a question name to require a user to provide a unique response for this question in each panel."
    },
    copyDefaultValueFromLastEntry: "Duplicates answers from the last row and assigns them to the next added dynamic row.",
    defaultValueExpression: "This setting allows you to assign a default answer value based on an expression. The expression can include basic calculations - `{q1_id} + {q2_id}`, Boolean expressions, such as `{age} > 60`, and functions: `iif()`, `today()`, `age()`, `min()`, `max()`, `avg()`, etc. The value determined by this expression serves as the initial default value that can be overridden by a respondent's manual input.",
    resetValueIf: `Use the magic wand icon to set a conditional rule that determines when a respondent's input is reset to the value based on the "Default value expression" or "Set value expression" or to the "Default answer" value (if either is set).`,
    setValueIf: 'Use the magic wand icon to set a conditional rule that determines when to run the "Set value expression" and dynamically assign the resulting value as a response.',
    setValueExpression: 'Specify an expression that defines the value to be set when the conditions in the "Set value if" rule are met. The expression can include basic calculations - `{q1_id} + {q2_id}`, Boolean expressions, such as `{age} > 60`, and functions: `iif()`, `today()`, `age()`, `min()`, `max()`, `avg()`, etc. The value determined by this expression can be overridden by a respondent\'s manual input.',
    gridLayoutEnabled: `Survey Creator allows you to manually adjust the inline widths of form elements to control the layout. If this doesn't produce the desired outcome, you can enable the grid layout, which structures form elements using a column-based system. To configure layout columns, select a page or panel and use the "Question Settings"  "Grid columns" table. To adjust how many columns a question spans, select it and set the desired value in the "Layout"  "Column span" field.`,
    question: {
      name: "A question ID that is not visible to respondents.",
      description: "Type a question subtitle.",
      visibleIf: "Use the magic wand icon to set a conditional rule that determines question visibility.",
      enableIf: "Use the magic wand icon to set a conditional rule that disables the read-only mode for the question.",
      requiredIf: "Use the magic wand icon to set a conditional rule that prevents survey advancing or submission unless the question received an answer.",
      startWithNewLine: "Unselect to display the question in one line with the previous question or panel. The setting doesn't apply if the question is the first element in your form.",
      page: "Repositions the question to the end of a selected page.",
      state: 'Choose from: "Expanded" - the question box is displayed in full and can be collapsed; "Collapsed" - the question box displays only the title and description and can be expanded; "Locked" - the question box is displayed in full and cannot be collapsed.',
      titleLocation: 'Overrides title alignment rules defined on a panel, page, or survey level. When set to "Hidden", it also hides question descriptions. The "Inherit" option applies any higher-level settings (if set) or survey-level setting ("Top" by default).',
      descriptionLocation: 'The "Inherit" option applies the survey-level setting ("Under the question title" by default).',
      errorLocation: 'Sets the location of an error message in relation to the question with invalid input. Choose between: "Top" - an error text is placed at the top of the question box; "Bottom" - an error text is placed at the bottom of the question box. The "Inherit" option applies the survey-level setting ("Top" by default).',
      indent: "Adds space or margin between the question content and the left border of the question box.",
      width: "Sets the width of the question in proportion to other survey elements in the same line. Accepts CSS values (px, %, in, pt, etc.).",
      surveyvalidator: {
        expression: "Use the magic wand icon to set a validation rule for the question."
      },
      textUpdateMode: 'Choose from: "On lost focus" - the value is updated when the input field loses focus; "While typing" - the value is updated in real-time, as users are typing. The "Inherit" option applies the survey-level setting ("On lost focus" by default).',
      url: "You can use any web service as a data source for multiple-choice questions. To populate choice values, enter the URL of the service providing the data.",
      searchMode: "A comparison operation used to filter the drop-down list.",
      textWrapEnabled: "Long texts in choice options will automatically generate line breaks to fit within the drop-down menu. Unselect if you want the texts to clip.",
      effectiveColSpan: "Specifies how many columns this question spans within the grid layout."
    },
    signaturepad: {
      signatureWidth: "Sets the width of the displayed signature area and the resulting image.",
      signatureHeight: "Sets the height of the displayed signature area and the resulting image.",
      signatureAutoScaleEnabled: "Select if you want the signature area to fill all available space within the question box while maintaining the default 3:2 aspect ratio. When custom width and height values are set, the setting will keep the aspect ratio of these dimensions."
    },
    file: {
      imageHeight: "Adjusts the height of the image in the survey results.",
      imageWidth: "Adjusts the width of the image in the survey results.",
      allowImagesPreview: "Displays thumbnail previews for uploaded files when possible. Unselect if you want to show file icons instead."
    },
    image: {
      contentMode: 'The "Auto" option automatically determines the suitable mode for display - Image, Video, or YouTube - based on the source URL provided.'
    },
    imagepicker: {
      imageHeight: "Overrides the minimum and maximum height values.",
      imageWidth: "Overrides the minimum and maximum width values.",
      choices: '"Value" serves as an item ID used in conditional rules; "Text" is displayed to respondents.',
      contentMode: 'Choose between "Image" and "Video" to set the content mode of the media selector. If "Image" is selected, ensure that all options provided are image files in the following formats: JPEG, GIF, PNG, APNG, SVG, BMP, ICO. Similarly, if "Video" is selected, ensure that all options are direct links to video files in the following formats: MP4, MOV, WMV, FLV, AVI, MKV. Please note that YouTube links are not supported for video options.'
    },
    text: {
      size: `This setting only resizes the input field and doesn't affect the width of the question box. To limit the accepted input length, go to "Validation"  "Maximum character limit".`
    },
    comment: {
      rows: "Sets the number of displayed lines in the input field. If the input takes up more lines, the scroll bar will appear."
    },
    // survey templates
    survey: {
      readOnly: "Select if you want to prevent respondents from filling out your survey.",
      progressBarLocation: 'Sets the location of the progress bar. The "Auto" value displays the progress bar above or below the survey header.'
    },
    matrixdropdowncolumn: {
      name: "A column ID that is not visible to respondents.",
      isUnique: "When enabled for a column, a respondent is required to provide a unique response for each question within this column.",
      rows: "Sets the number of displayed lines in the input field. If the input takes up more lines, the scroll bar will appear.",
      visibleIf: "Use the magic wand icon to set a conditional rule that determines column visibility.",
      enableIf: "Use the magic wand icon to set a conditional rule that disables the read-only mode for the column.",
      requiredIf: "Use the magic wand icon to set a conditional rule that prevents survey submission unless at least one nested question has an answer.",
      showInMultipleColumns: "When selected, creates an individual column for each choice option.",
      colCount: 'Arranges choice options in a multi-column layout. When set to 0, the options are displayed in a single line. When set to -1, the actual value is inherited from the "Nested column count" property of the parent matrix.'
    },
    caseInsensitive: "Select if uppercase and lowercase letters in the regular expression must be treated as equivalent.",
    widthMode: 'Choose from: "Static" - sets a fixed width; "Responsive" - makes the survey occupy the full width of the screen; "Auto" - applies either of the two depending on the question types used.',
    cookieName: "Assign a unique cookie value for your survey. The cookie will be set in a respondent's browser upon survey completion to prevent repetitive survey submissions.",
    logo: "Paste an image link (no size limits) or click the folder icon to browse a file from your computer (up to 64KB).",
    logoWidth: "Sets a logo width in CSS units (px, %, in, pt, etc.).",
    logoHeight: "Sets a logo height in CSS units (px, %, in, pt, etc.).",
    logoFit: 'Choose from: "None" - image maintains its original size; "Contain" - image is resized to fit while maintaining its aspect ratio; "Cover" - image fills the entire box while maintaining its aspect ratio; "Fill" - image is stretched to fill the box without maintaining its aspect ratio.',
    autoAdvanceEnabled: "Select if you want the survey to auto-advance to the next page once a respondent has answered all questions on the current page. This feature won't apply if the last question on the page is open-ended or allows multiple answers.",
    autoAdvanceAllowComplete: "Select if you want the survey to complete automatically after a respondent answers all questions.",
    showNavigationButtons: "Sets the visibility of navigation buttons on a page.",
    navigationButtonsLocation: "Sets the location of navigation buttons on a page.",
    showPreviewBeforeComplete: "Enable the preview page with all or answered questions only.",
    questionTitleLocation: "Applies to all questions within the survey. This setting can be overridden by title alignment rules at lower levels: panel, page, or question. A lower-level setting will override those on a higher level.",
    requiredMark: "A symbol or a sequence of symbols indicating that an answer is required.",
    questionStartIndex: "Enter a number or letter with which you want to start numbering.",
    questionErrorLocation: 'Sets the location of an error message in relation to the question with invalid input. Choose between: "Top" - an error text is placed at the top of the question box; "Bottom" - an error text is placed at the bottom of the question box.',
    autoFocusFirstQuestion: "Select if you want the first input field on each page ready for text entry.",
    questionOrder: "Keeps the original order of questions or randomizes them. The effect of this setting is only visible in the Preview tab.",
    maxTextLength: "For text entry questions only.",
    maxCommentLength: "For question comments only.",
    commentAreaRows: "Sets the number of displayed lines in text areas for question comments. If the input takes up more lines, the scroll bar appears.",
    autoGrowComment: "Select if you want question comments and Long Text questions to auto-grow in height based on the entered text length.",
    allowResizeComment: "For question comments and Long Text questions only.",
    calculatedValues: "Custom variables serve as intermediate or auxiliary variables used in form calculations. They take respondent inputs as source values. Each custom variable has a unique name and an expression it's based on.",
    includeIntoResult: "Select if you wish the calculated value of the expression to be saved along with survey results.",
    triggers: 'A trigger is an event or condition that is based on an expression. Once the expression is evaluated to "true", a trigger sets off an action. Such an action can optionally have a target question it affects.',
    clearInvisibleValues: "Choose whether or not to clear values for questions hidden by conditional logic and when to do it.",
    textUpdateMode: 'Choose from: "On lost focus" - the value is updated when the input field loses focus; "While typing" - the value is updated in real-time, as users are typing.',
    columns: "The left value serves as a column ID used in conditional rules, the right value is displayed to respondents.",
    rows: "The left value serves as a row ID used in conditional rules, the right value is displayed to respondents.",
    columnMinWidth: "Accepts CSS values (px, %, in, pt, etc.).",
    rowTitleWidth: "Accepts CSS values (px, %, in, pt, etc.).",
    totalText: 'Visible only if at least one column displays total values set with "Aggregation method" or "Total value expression".',
    cellErrorLocation: 'Sets the location of an error message in relation to a cell with invalid input. The "Inherit" option applies the setting from the "Error message alignment" property.',
    detailErrorLocation: 'Sets the location of error messages for questions nested in detail sections. The "Inherit" option applies the setting from the "Error message alignment" property.',
    keyDuplicationError: 'When the "Prevent duplicate responses" property is enabled, a respondent attempting to submit a duplicate entry will receive the following error message.',
    totalExpression: "Allows you to calculate total values based on an expression. The expression can include basic calculations (`{q1_id} + {q2_id}`), Boolean expressions (`{age} > 60`) and functions ('iif()`, `today()`, `age()`, `min()`, `max()`, `avg()`, etc.).",
    confirmDelete: "Triggers a prompt asking to confirm the row deletion.",
    keyName: "Reference a column ID to require a user to provide a unique response for each question within the specified column.",
    description: "Type a subtitle.",
    locale: "Choose a language to begin creating your survey. To add a translation, switch to a new language and translate the original text here or in the Translations tab.",
    detailPanelMode: 'Sets the location of a detail section in relation to a row. Choose from: "None" - no expansion is added; "Under the row" - a row expansion is placed under each row of the matrix; "Under the row, display one row expansion only" - an expansion is displayed under a single row only, the remaining row expansions are collapsed.',
    imageFit: 'Choose from: "None" - image maintains its original size; "Contain" - image is resized to fit while maintaining its aspect ratio; "Cover" - image fills the entire box while maintaining its aspect ratio; "Fill" - image is stretched to fill the box without maintaining its aspect ratio.',
    autoGrow: 'The "Inherit" option applies a survey-level setting ("Disabled" by default).',
    allowResize: 'The "Inherit" option applies a survey-level setting ("Enabled" by default).',
    timeLimit: 'A time interval in seconds after which the survey auto-advances to the "Thank You" page. When set to 0, counts the time spent on the survey.',
    timeLimitPerPage: 'A time interval in seconds after which the survey auto-advances to the next page. Hides the "Previous" navigation button. When set to 0, counts the time spent on the current page.',
    validateVisitedEmptyFields: "Enable this option to trigger validation when a user focuses on an empty input field and then leaves it without making any changes.",
    page: {
      timeLimit: 'A time interval in seconds after which the survey auto-advances to the next page. Hides the "Previous" navigation button. When set to 0, counts the time spent on the current page.',
      // isRequired: "Prevents survey submission unless at least one nested question has an answer.",
      visibleIf: "Use the magic wand icon to set a conditional rule that determines page visibility.",
      enableIf: "Use the magic wand icon to set a conditional rule that disables the read-only mode for the page.",
      requiredIf: "Use the magic wand icon to set a conditional rule that prevents survey submission unless at least one nested question has an answer.",
      questionTitleLocation: 'Applies to all questions within this page. When set to "Hidden", it also hides question descriptions. If you want to override this setting, define title alignment rules for individual questions or panels. The "Inherit" option applies the survey-level setting ("Top" by default).',
      questionTitleWidth: "Sets consistent width for question titles when they are aligned to the left of their question boxes. Accepts CSS values (px, %, in, pt, etc.).",
      questionErrorLocation: 'Sets the location of an error message in relation to the question with invalid input. Choose between: "Top" - an error text is placed at the top of the question box; "Bottom" - an error text is placed at the bottom of the question box. The "Inherit" option applies the survey-level setting ("Top" by default).',
      questionOrder: 'Keeps the original order of questions or randomizes them. The "Inherit" option applies the survey-level setting ("Original" by default). The effect of this setting is only visible in the Preview tab.',
      showNavigationButtons: 'Sets the visibility of navigation buttons on the page. The "Inherit" option applies the survey-level setting, which defaults to "Visible".',
      gridLayoutColumns: "This table lets you configure each grid column on the page. It automatically sets the width percentage for each column based on the maximum number of elements in a row. To customize the grid layout, manually adjust these values and define the title width for all questions in each column."
    },
    timerLocation: "Sets the location of a timer on a page.",
    panelsState: 'Choose from: "Locked" - users cannot expand or collapse panels; "Collapse all" - all panels start in a collapsed state; "Expand all" - all panels start in an expanded state; "First expanded" - only the first panel is initially expanded. Applies if "Panel display mode" is set to "List" and the "Panel title pattern" property is specified.',
    imageLinkName: "Enter a shared property name within the array of objects that contains the image or video file URLs you want to display in the choice list.",
    choices: "The left value serves as an item ID used in conditional rules, the right value is displayed to respondents.",
    title: "Type a user-friendly title to display.",
    waitForUpload: "Ensures that users won't complete the survey until files are uploaded.",
    minWidth: "Accepts CSS values (px, %, in, pt, etc.).",
    maxWidth: "Accepts CSS values (px, %, in, pt, etc.).",
    width: "Accepts CSS values (px, %, in, pt, etc.).",
    valueName: "A join identifier is a custom key that you can assign to several questions to link them together and sync their values. These values will be merged into a single array or object and stored in survey results using the key as the property name.",
    defaultDisplayValue: "A value displayed in HTML questions and in the dynamic titles and descriptions of survey elements when the question value is empty.",
    useDisplayValuesInDynamicTexts: "In single- and multiple-selection question types, each choice option has an ID and display value. When selected, this setting shows a display value instead of an ID value in HTML questions and dynamic titles and descriptions of survey elements.",
    clearIfInvisible: 'Choose whether or not to clear question values hidden by conditional logic and when to do it. The "Inherit" option applies the survey-level setting ("Upon survey completion" by default).',
    choicesFromQuestionMode: 'Choose from: "All" - copies all choice options from the selected question; "Selected" - dynamically copies only selected choice options; "Unselected" - dynamically copies only unselected choice options. The "None" and "Other" options are copied by default if enabled in the source question.',
    choiceValuesFromQuestion: "In single- and multiple-selection question types, each choice option has an ID and display value. This setting specifies which matrix column or panel question should provide the IDs.",
    choiceTextsFromQuestion: "In single- and multiple-selection question types, each choice option has an ID and display value. This setting specifies which matrix column or panel question should provide the display texts.",
    showOtherItem: "When selected, users can include additional input in a separate comment box.",
    separateSpecialChoices: 'Displays each special choice option ("None", "Other", "Select All") on a new line, even when using a multiple-column layout.',
    path: "Specify the location within the service dataset where the target array of objects is located. Leave empty if the URL already points to the array.",
    choicesbyurl: {
      valueName: "Enter a uniform property name within the array of objects whose value will be stored as a response in survey results."
    },
    titleName: "Enter a uniform property name within the array of objects that contains the values you want to display in the choice list.",
    allowEmptyResponse: "Select to allow the service to return an empty response or array.",
    choicesVisibleIf: "Use the magic wand icon to set a conditional rule that determines the visibility of all choice options.",
    rateValues: "The left value serves as an item ID used in conditional rules, the right value is displayed to respondents.",
    rating: {
      displayMode: '"Auto" selects between the "Buttons" and "Dropdown" modes based on the available width. When the width is insufficient to display buttons, the question displays a dropdown.'
    },
    valuePropertyName: "Allows you to connect questions that produce results in different formats. When such questions are linked together using a join identifier, this shared property stores selected question values.",
    searchEnabled: "Select if you want to update the drop-down menu contents to match the search query that a user is typing in the input field.",
    valueTrue: "A value to save in survey results when respondents give a positive answer.",
    valueFalse: "A value to save in survey results when respondents give a negative answer.",
    showPreview: "It's not recommended that you disable this option as it overrides the Preview image and makes it hard for a user to understand whether the files have been uploaded.",
    needConfirmRemoveFile: "Triggers a prompt asking to confirm the file deletion.",
    selectToRankEnabled: "Enable to rank only selected choices. Users will drag selected items from the choice list to order them within the ranking area.",
    dataList: "Enter a list of choices that will be suggested to the respondent during input.",
    inputSize: "The setting only resizes the input fields and doesn't affect the width of the question box.",
    itemTitleWidth: "Sets consistent width for all item labels. Accepts CSS values (px, %, in, pt, etc.).",
    inputTextAlignment: 'Select how to align input value within the field. The default setting "Auto" aligns the input value to the right if currency or numeric masking is applied and to the left if not.',
    altText: "Serves as a substitute when the image cannot be displayed on a user's device and for accessibility purposes.",
    rateColorMode: 'Defines the color of the selected emoji when the Rating icon type is set to "Smileys". Choose between: "Default" - the selected emoji appears in default survey color; "Scale" - the selected emoji inherits color from the rating scale.',
    expression: {
      name: "An expression ID that is not visible to respondents.",
      description: "Type an expression subtitle.",
      expression: "An expression can include basic calculations (`{q1_id} + {q2_id}`), conditions (`{age} > 60`), and functions ('iif()`, `today()`, `age()`, `min()`, `max()`, `avg()`, etc.)."
    },
    storeOthersAsComment: 'Select to store the "Other" option value as a separate property in survey results.',
    format: "Use {0} as a placeholder for the actual value.",
    acceptedTypes: "Refer to the [accept](https://www.w3schools.com/tags/att_input_accept.asp) attribute description for more information.",
    columnColCount: 'Arranges choice options in a multi-column layout. When set to 0, the options are displayed in a single line. Applies only to columns with "Cell input type" set to Radio Button Group or Checkboxes.',
    autocomplete: "Select the data type that the user's browser can retrieve. This data is sourced either from past values entered by the user or from pre-configured values if any have been saved by the user for autocompletion.",
    filePlaceholder: 'Applies when "File source type" is "Local file" or when camera is unavailable',
    photoPlaceholder: 'Applies when "File source type" is "Camera".',
    fileOrPhotoPlaceholder: 'Applies when "File source type" is "Local file or camera".',
    colCount: "Arranges choice options in a multi-column layout. When set to 0, the options are displayed in a single line.",
    masksettings: {
      saveMaskedValue: "Select if you want to store the question value with an applied mask in survey results."
    },
    patternmask: {
      pattern: "The pattern can contain string literals and the following placeholders: `9` - for a digit; `a` - for an upper- or lower-case letter; `#` - for a digit or an upper- or lower-case letter. Use backslash `\\` to escape a character."
    },
    datetimemask: {
      pattern: "The pattern can contain separator characters and the following placeholders:<br>`m` - Month number.<br>`mm` - Month number, with leading zero for single-digit values.<br>`d` - Day of the month.<br>`dd` - Day of the month, with leading zero for single-digit values.<br>`yy` - The last two digits of the year.<br>`yyyy` - Four-digit year.<br>`H` - Hours in 24-hour format.<br>`HH` - Hours in 24-hour format, with leading zero for single-digit values.<br>`h` - Hours in 12-hour format.<br>`hh` - Hours in 12-hour format, with leading zero for single-digit values.<br>`MM` - Minutes.<br>`ss` - Seconds.<br>`TT` - 12-hour clock period in upper case (AM/PM).<br>`tt` - 12-hour clock period in lower case (am/pm)."
    },
    numericmask: {
      decimalSeparator: "A symbol used to separate the fractional part from the integer part of a displayed number.",
      thousandsSeparator: "A symbol used to separate the digits of a large number into groups of three.",
      precision: "Limits how many digits to retain after the decimal point for a displayed number."
    },
    currencymask: {
      prefix: "One or several symbols to be displayed before the value.",
      suffix: "One or several symbols to be displayed after the value."
    },
    theme: {
      isPanelless: "This setting applies only to questions outside of a panel.",
      primaryColor: "Sets a supplementary color that highlights key survey elements.",
      panelBackgroundTransparency: "Adjusts the transparency of panels and question boxes relative to the survey background.",
      questionBackgroundTransparency: "Adjusts the transparency of input elements relative to the survey background.",
      cornerRadius: "Sets the corner radius for all rectangular elements. Enable the Advanced Mode if you want to set individual corner radius values for input elements or panels and question boxes.",
      "--sjs-general-backcolor-dim": "Sets the main background color of the survey."
    },
    header: {
      inheritWidthFrom: 'The "Same as container" option auto-adjusts the header content area width to fit into the HTML element the survey is placed in.',
      textAreaWidth: "The width of the header area that contains the survey title and description, measured in pixels.",
      overlapEnabled: "When enabled, the top of the survey overlays the bottom of the header.",
      mobileHeight: "When set to 0, the height is calculated automatically to accommodate the header's content."
    },
    progressBarInheritWidthFrom: 'The "Same as container" option auto-adjusts the progress bar area width to fit into the HTML element the survey is placed in.'
  },
  // Properties
  p: {
    title: {
      name: "title",
      title: "Leave it empty, if it is the same as 'Name'"
    },
    multiSelect: "Allow multiple selection",
    showLabel: "Show image and video captions",
    swapOrder: "Swap the order of Yes and No",
    value: "Value",
    tabAlign: "Tab alignment",
    sourceType: "File source type",
    fitToContainer: "Fit to container",
    setValueExpression: "Set value expression",
    description: "Description",
    // Auto-generated string
    logoFit: "Logo fit",
    pages: "Pages",
    // Auto-generated string
    questions: "Questions",
    // Auto-generated string
    triggers: "Triggers",
    calculatedValues: "Custom variables",
    surveyId: "Survey id",
    // Auto-generated string
    surveyPostId: "Survey post id",
    // Auto-generated string
    surveyShowDataSaving: "Survey show data saving",
    // Auto-generated string
    questionDescriptionLocation: "Question description alignment",
    progressBarType: "Progress bar type",
    // Auto-generated string
    showTOC: "Show table of contents (TOC)",
    tocLocation: "TOC alignment",
    questionTitlePattern: "Question title pattern",
    // Auto-generated string
    widthMode: "Survey width mode",
    showBrandInfo: "Show brand info",
    // Auto-generated string
    useDisplayValuesInDynamicTexts: "Use display values in dynamic texts",
    visibleIf: "Visible if",
    // Auto-generated string
    defaultValueExpression: "Default value expression",
    requiredIf: "Required if",
    // Auto-generated string
    resetValueIf: "Reset value if",
    setValueIf: "Set value if",
    validators: "Validation rules",
    bindings: "Bindings",
    // Auto-generated string
    renderAs: "Render as",
    // Auto-generated string
    attachOriginalItems: "Attach original items",
    // Auto-generated string
    choices: "Choices",
    choicesByUrl: "Choices by url",
    // Auto-generated string
    currency: "Currency",
    // Auto-generated string
    cellHint: "Cell hint",
    // Auto-generated string
    totalMaximumFractionDigits: "Total maximum fraction digits",
    // Auto-generated string
    totalMinimumFractionDigits: "Total minimum fraction digits",
    // Auto-generated string
    columns: "Columns",
    // Auto-generated string
    detailElements: "Detail elements",
    // Auto-generated string
    allowAdaptiveActions: "Allow adaptive actions",
    // Auto-generated string
    defaultRowValue: "Default row value",
    // Auto-generated string
    detailPanelShowOnAdding: "Detail panel show on adding",
    // Auto-generated string
    choicesLazyLoadEnabled: "Choices lazy load enabled",
    // Auto-generated string
    choicesLazyLoadPageSize: "Choices lazy load page size",
    // Auto-generated string
    inputFieldComponent: "Input field component",
    // Auto-generated string
    itemComponent: "Item component",
    // Auto-generated string
    min: "Min",
    // Auto-generated string
    max: "Max",
    // Auto-generated string
    minValueExpression: "Min value expression",
    // Auto-generated string
    maxValueExpression: "Max value expression",
    // Auto-generated string
    step: "Step",
    // Auto-generated string
    dataList: "Items for auto-suggest",
    inputSize: "Input field width (in characters)",
    itemTitleWidth: "Item label width",
    inputTextAlignment: "Input value alignment",
    elements: "Elements",
    // Auto-generated string
    content: "Content",
    // Auto-generated string
    navigationTitle: "Navigation title",
    // Auto-generated string
    navigationDescription: "Navigation description",
    // Auto-generated string
    longTap: "Long tap",
    // Auto-generated string
    autoGrow: "Expand input field dynamically",
    allowResize: "Enable resize handle",
    acceptCarriageReturn: "Accept carriage return",
    // Auto-generated string
    displayMode: "Display mode",
    rateType: "Rate type",
    // Auto-generated string
    label: "Label",
    // Auto-generated string
    contentMode: "Content mode",
    imageFit: "Image and thumbnail fit",
    altText: "Alt text",
    height: "Height",
    // Auto-generated string
    mobileHeight: "Height on smartphones",
    penColor: "Pen color",
    // Auto-generated string
    backgroundColor: "Background color",
    templateElements: "Template elements",
    // Auto-generated string
    operator: "Operator",
    // Auto-generated string
    isVariable: "Is variable",
    // Auto-generated string
    runExpression: "Run expression",
    // Auto-generated string
    showCaption: "Show caption",
    // Auto-generated string
    iconName: "Icon name",
    // Auto-generated string
    iconSize: "Icon size",
    // Auto-generated string
    precision: "Precision",
    // Auto-generated string
    matrixDragHandleArea: "Matrix drag handle area",
    // Auto-generated string
    backgroundImage: "Background image",
    backgroundImageFit: "Background image fit",
    // Auto-generated string
    backgroundImageAttachment: "Background image attachment",
    // Auto-generated string
    backgroundOpacity: "Background opacity",
    // Auto-generated string
    selectToRankEnabled: "Allow selective ranking",
    selectToRankAreasLayout: "Ranking area alignment",
    selectToRankEmptyRankedAreaText: "Text to show if all options are selected",
    selectToRankEmptyUnrankedAreaText: "Placeholder text for the ranking area",
    allowCameraAccess: "Allow camera access",
    // Auto-generated string
    scaleColorMode: "Rating icon color mode",
    rateColorMode: "Smileys color scheme",
    copyDisplayValue: "Copy display value",
    // Auto-generated string
    effectiveColSpan: "Column span",
    progressBarInheritWidthFrom: "Progress bar area width"
  },
  theme: {
    advancedMode: "Advanced mode",
    pageTitle: "Page",
    questionTitle: "Question box",
    editorPanel: "Input element",
    lines: "Lines",
    primaryDefaultColor: "Default",
    primaryDarkColor: "Hover",
    primaryLightColor: "Selected",
    backgroundDimColor: "Background color",
    cornerRadius: "Corner radius",
    backcolor: "Default background",
    hovercolor: "Hover background",
    borderDecoration: "Border decoration",
    fontColor: "Font color",
    backgroundColor: "Background color",
    primaryForecolor: "Default color",
    primaryForecolorLight: "Disabled color",
    font: "Font",
    borderDefault: "Darker",
    borderLight: "Lighter",
    fontFamily: "Font family",
    fontWeightRegular: "Regular",
    fontWeightHeavy: "Heavy",
    fontWeightSemiBold: "Semi-bold",
    fontWeightBold: "Bold",
    color: "Color",
    placeholderColor: "Placeholder color",
    size: "Size",
    opacity: "Opacity",
    boxShadowX: "X",
    boxShadowY: "Y",
    boxShadowAddRule: "Add Shadow Effect",
    boxShadowBlur: "Blur",
    boxShadowSpread: "Spread",
    boxShadowDrop: "Drop",
    boxShadowInner: "Inner",
    names: {
      default: "Default",
      sharp: "Sharp",
      borderless: "Borderless",
      flat: "Flat",
      plain: "Plain",
      doubleborder: "Double Border",
      layered: "Layered",
      solid: "Solid",
      threedimensional: "3D",
      contrast: "Contrast"
    },
    colors: {
      teal: "Teal",
      blue: "Blue",
      purple: "Purple",
      orchid: "Orchid",
      tulip: "Tulip",
      brown: "Brown",
      green: "Green",
      gray: "Gray"
    }
  },
  creatortheme: {
    "--sjs-special-background": "Surface background",
    "--sjs-primary-background-500": "Primary",
    "--sjs-secondary-background-500": "Secondary",
    "surfaceScale": "Surface",
    "userInterfaceBaseUnit": "UI elements",
    "fontScale": "Font",
    names: {
      "sc2020": "Survey Creator 2020",
      "default-light": "Light",
      "default-dark": "Dark",
      "default-contrast": "Contrast"
    }
  }
};
function roundTo2Decimals(number) {
  return Math.round(number * 100) / 100;
}
var endLineRegExp = new RegExp("(\\r\\n|\\n|\\r)", "gm");
function clearNewLines(text) {
  return text.replace(endLineRegExp, "");
}
function copyObject(dst, src) {
  for (let key in src) {
    let source = src[key];
    if (typeof source === "object") {
      source = {};
      copyObject(source, src[key]);
    }
    dst[key] = source;
  }
}
function copyCssClasses(dest, source) {
  if (!source) return;
  if (typeof source === "string" || source instanceof String) {
    dest["root"] = source;
  } else {
    copyObject(dest, source);
  }
}
function capitalize(str) {
  if (!str) return str;
  str = str.replace(/[\s]+/g, " ");
  str = str.replace(/([\s]|^)(\S)/g, (_, p1, p2) => {
    return p1 + p2.toUpperCase();
  });
  return str;
}
function notShortCircuitAnd(...args) {
  return args.every((val) => val === true);
}
var imageMimeTypes = "image/png, image/gif, image/jpeg, image/apng, image/avif, image/svg+xml, image/webp";
function getAcceptedTypesByContentMode(contentMode) {
  if (["auto", "image"].indexOf(contentMode) > -1) {
    return imageMimeTypes;
  } else if (contentMode == "video") {
    return "video/*";
  } else {
    return "";
  }
}
function trimEmptyFields(object) {
  Object.keys(object).forEach((key) => {
    if (object[key] === void 0 || object[key] === null) {
      delete object[key];
    }
  });
}
function assign(...inputs) {
  const objects = (inputs || []).filter((obj) => !!obj);
  if (objects.length <= 1) {
    return;
  }
  if (objects.length == 2) {
    Object.keys(objects[1]).forEach((key) => objects[0][key] = objects[1][key]);
    trimEmptyFields(inputs[0]);
    return;
  }
  for (let i = 1; i < objects.length; i++) {
    assign(objects[0], objects[i]);
  }
}
function getOS() {
  var _a, _b;
  const userAgent = window.navigator.userAgent, platform = ((_b = (_a = window.navigator) === null || _a === void 0 ? void 0 : _a.userAgentData) === null || _b === void 0 ? void 0 : _b.platform) || window.navigator.platform, macosPlatforms = ["macOS", "Macintosh", "MacIntel", "MacPPC", "Mac68K"], windowsPlatforms = ["Win32", "Win64", "Windows", "WinCE"], iosPlatforms = ["iPhone", "iPad", "iPod"];
  let os = null;
  if (macosPlatforms.indexOf(platform) !== -1) {
    os = "Mac OS";
  } else if (iosPlatforms.indexOf(platform) !== -1) {
    os = "iOS";
  } else if (windowsPlatforms.indexOf(platform) !== -1) {
    os = "Windows";
  } else if (/Android/.test(userAgent)) {
    os = "Android";
  } else if (/Linux/.test(platform)) {
    os = "Linux";
  }
  return os;
}
var renamedKeys = {};
renamedKeys["tabs.preview"] = "ed.testSurvey";
renamedKeys["tabs.theme"] = "ed.themeSurvey";
renamedKeys["tabs.translation"] = "ed.translation";
renamedKeys["tabs.designer"] = "ed.designer";
renamedKeys["tabs.editor"] = "ed.jsonEditor";
renamedKeys["tabs.json"] = "tabs.editor";
renamedKeys["tabs.logic"] = "ed.logic";
var EditorLocalization = class {
  constructor() {
    this.defaultLocaleValue = "en";
    this.currentLocaleValue = "";
    this.camelCaseBreaking = true;
    this.locales = {};
    this.peByClass = {};
    this.peHelpByClass = {};
    this.pePlaceholderByClass = {};
  }
  reset() {
    this.peByClass = {};
    this.peHelpByClass = {};
    this.pePlaceholderByClass = {};
  }
  get defaultLocale() {
    return this.defaultLocaleValue;
  }
  set defaultLocale(val) {
    if (!val) val = "en";
    if (val !== this.defaultLocale) {
      this.defaultLocaleValue = val;
      this.reset();
    }
  }
  get currentLocale() {
    return this.currentLocaleValue;
  }
  set currentLocale(val) {
    if (!val) val = "";
    if (val !== this.currentLocale) {
      this.currentLocaleValue = val;
      this.reset();
    }
  }
  get presetStrings() {
    return this.presetStringsValues;
  }
  set presetStrings(val) {
    this.presetStringsValues = val;
    this.reset();
  }
  getString(strName, locale = null) {
    if (!strName) return strName;
    const oldVal = this.getOldKeysString(strName, locale);
    if (!!oldVal) return oldVal;
    const path = strName.split(".");
    return this.getStringByPath(path, locale);
  }
  getStringByPath(path, locale = null) {
    if (!locale) locale = this.currentLocale;
    const loc = this.getLocale(locale);
    const defaultLocale = this.getDefaultStrings();
    const locs = [];
    if (!!loc) locs.push(loc);
    if (!!locale && locale.indexOf("-") > -1) {
      const baseLocale = this.getLocale(locale.substring(0, locale.indexOf("-")));
      if (!!baseLocale) locs.push(baseLocale);
    }
    if (locs.length === 0 || locs[locs.length - 1] !== defaultLocale) {
      locs.push(defaultLocale);
    }
    const presetLoc = this.getPresetLocale(locale);
    if (!!presetLoc) {
      locs.unshift(presetLoc);
    }
    for (let i = 0; i < locs.length; i++) {
      const res = this.getStringByLocale(path, locs[i]);
      if (!!res || res === "") return res;
    }
    return path[path.length - 1];
  }
  hasString(strName, locale = null) {
    return this.getStringByLocale(strName.split("."), this.getLocale(locale)) !== void 0;
  }
  getStringByLocale(path, loc) {
    let obj = loc;
    for (let i = 0; i < path.length; i++) {
      if (typeof obj === "string") return void 0;
      obj = obj[path[i]];
      if (!obj && obj !== "") return void 0;
    }
    return obj;
  }
  getLocaleName(loc, defaultLocale = null, inEnglish) {
    if (!defaultLocale) {
      defaultLocale = surveyLocalization.defaultLocale;
    }
    let name = surveyLocalization.getLocaleName(loc || defaultLocale, inEnglish);
    if (name === loc) return name;
    name = capitalize(name);
    if (!loc) {
      name = editorLocalization.getString("ed.defaultLocale")["format"](name);
    }
    return name || loc;
  }
  getPropertyName(strName, defaultName = null) {
    var obj = this.getProperty(strName, defaultName);
    var name = obj["name"];
    if (!!name) {
      if (this.stringsDiff(name, strName)) return name;
      return this.getAutoPropertyName(name, defaultName);
    }
    return obj;
  }
  getPropertyTitle(strName) {
    var obj = this.getProperty(strName);
    if (obj["title"]) return obj["title"];
    return "";
  }
  getPropertyNameInEditor(typeName, propName, defaultName = null) {
    let obj = this.getPropertyInfoInEditorByType(typeName, propName, this.peByClass, "pe");
    if (!obj) {
      obj = this.getStringByPath(["pe", propName]);
    }
    if (this.stringsDiff(obj, propName)) return obj;
    return this.getPropertyName(propName, defaultName);
  }
  getPropertyHelpInEditor(typeName, propName, propType = void 0) {
    const res = this.getPropertyHelpInEditorCore(typeName, propName, this.peHelpByClass, "pehelp");
    if (!!res) return res;
    const loc = this.getLocale();
    return !!propType && !!loc && !!loc.pe ? loc.pe[propType + "Help"] : void 0;
  }
  getPropertyPlaceholder(typeName, propName) {
    let str = this.getPropertyHelpInEditorCore(typeName, propName, this.pePlaceholderByClass, "peplaceholder");
    if (!!str) return str === " " ? null : str;
    const loc = this.getLocale();
    if (!!loc && !!loc.peplaceholder) {
      str = loc.peplaceholder[propName];
    }
    if (!!str) return str;
    return !!loc && !!loc.pe ? loc.pe[propName + "_placeholder"] : void 0;
  }
  getPropertyHelpInEditorCore(typeName, propName, data, suffix) {
    let str = this.getPropertyInfoInEditorByType(typeName, propName, data, suffix);
    if (!!str) return str === " " ? null : str;
    const locs = this.getLocalesWithPreset();
    for (let i = 0; i < locs.length; i++) {
      const loc = locs[i];
      if (!!loc[suffix] && loc[suffix][propName]) return loc[suffix][propName];
    }
    return void 0;
  }
  getPropertyInfoInEditorByType(typeName, propName, peInfoByClass, postFix) {
    if (!typeName) return void 0;
    const locs = this.getLocalesWithPreset();
    for (let i = 0; i < locs.length; i++) {
      const res = this.getPropertyInfoInEditorByTypeCore(typeName, propName, peInfoByClass, postFix, locs[i]);
      if (!!res) return res;
    }
    return void 0;
  }
  getPropertyInfoInEditorByTypeCore(typeName, propName, peInfoByClass, postFix, loc) {
    let peClass = peInfoByClass[typeName];
    if (peClass === void 0) {
      peClass = this.getObjInEditorByTypeCore(typeName, peInfoByClass, postFix, loc);
    }
    while (!!peClass) {
      const res = peClass.props[propName];
      if (!!res && typeof res !== "function") return peClass.props[propName];
      peClass = peClass.parent;
    }
    return void 0;
  }
  getObjInEditorByTypeCore(typeName, peInfoByClass, postFix, loc) {
    if (!typeName) return void 0;
    peInfoByClass[typeName];
    const pe = !!loc ? loc[postFix] : void 0;
    if (!pe) return void 0;
    const propIndex = typeName.indexOf("@");
    if (propIndex > -1) {
      const parentRes = this.getObjInEditorByTypeCore(typeName.substring(0, propIndex), peInfoByClass, postFix, loc);
      if (!pe[typeName]) {
        peInfoByClass[typeName] = parentRes;
        return parentRes;
      }
      const res2 = {
        props: pe[typeName],
        parent: parentRes
      };
      peInfoByClass[typeName] = res2;
      return res2;
    }
    const classNames = [];
    let classInfo = Serializer.findClass(typeName);
    let res = void 0;
    while (!!classInfo) {
      const tName = classInfo.name;
      res = peInfoByClass[typeName];
      if (!!res) break;
      classNames.push(tName);
      if (pe[tName]) {
        res = {
          props: pe[tName],
          parent: this.getObjInEditorByTypeCore(classInfo.parentName, peInfoByClass, postFix, loc)
        };
        break;
      }
      if (!classInfo.parentName) break;
      classInfo = Serializer.findClass(classInfo.parentName);
    }
    for (var i = 0; i < classNames.length; i++) {
      peInfoByClass[classNames[i]] = res;
    }
    return res;
  }
  getProperty(strName, defaultName = null) {
    var obj = this.getStringByPath(["p", strName]);
    if (this.stringsDiff(obj, strName)) return obj;
    var pos = (strName + "").indexOf("_");
    if (pos < -1) return this.getAutoPropertyName(obj, defaultName);
    strName = (strName + "").substring(pos + 1);
    obj = this.getStringByPath(["p", strName]);
    if (this.stringsDiff(obj, strName)) return obj;
    return this.getAutoPropertyName(obj, defaultName);
  }
  convertToCamelCase(value, toLowCase = false) {
    if (!value) return value;
    value = value.trim();
    if (value.indexOf(" ") > -1) return value;
    let hasLowCase = false;
    for (var i = 0; i < value.length; i++) {
      if (value[i] !== value[i].toUpperCase()) {
        hasLowCase = true;
        break;
      }
    }
    if (!hasLowCase) return value;
    let res = value[0].toUpperCase();
    let isPrevUpperCase = false;
    const isUpperCase = (index) => {
      if (index >= value.length) return false;
      return value[index].toUpperCase() === value[index];
    };
    for (var i = 1; i < value.length; i++) {
      if (!isPrevUpperCase && isUpperCase(i)) {
        res += " ";
      }
      const requireConvert = !isPrevUpperCase && !isUpperCase(i + 1);
      res += requireConvert ? value[i].toLowerCase() : value[i];
      isPrevUpperCase = isUpperCase(i);
    }
    if (toLowCase) {
      res = res.toLowerCase();
    }
    return res;
  }
  getAutoPropertyName(propName, defaultName = null) {
    if (!!defaultName) return defaultName;
    if (!propName || !this.camelCaseBreaking) return propName;
    return this.convertToCamelCase(propName);
  }
  getPropertyValueInEditor(propName, value) {
    const loc = this.getLocale();
    if (!!loc && !!loc.pv && !!loc.pv[propName]) {
      const res = loc.pv[propName][value];
      if (!!res) return res;
    }
    return this.getPropertyValue(value);
  }
  getPropertyValue(value, locale = null) {
    return this.getValueInternal(value, "pv", locale);
  }
  getValidatorName(name, locale = null) {
    return this.getValueInternal(name, "validators", locale);
  }
  getTriggerName(name, locale = null) {
    return this.getValueInternal(name, "triggers", locale);
  }
  getLocale(locale) {
    if (!locale) locale = this.currentLocale;
    return (locale ? this.getLocaleStrings(locale) : this.getDefaultStrings()) || this.getDefaultStrings();
  }
  getLocaleStrings(loc) {
    return this.locales[loc];
  }
  setupLocale(loc, strings) {
    this.locales[loc] = strings;
  }
  getPresetLocale(locale) {
    if (!this.presetStrings) return void 0;
    const presetLoc = locale || this.currentLocale || this.defaultLocale;
    return this.presetStrings[presetLoc];
  }
  getLocalesWithPreset(locale) {
    const res = [];
    const presetLoc = this.getPresetLocale(locale);
    if (presetLoc) {
      res.push(presetLoc);
    }
    const loc = this.getLocale(locale);
    if (loc) {
      res.push(loc);
    }
    return res;
  }
  getValueInternal(value, prefix, locale = null) {
    if (!value || value.indexOf && value.indexOf(".") > -1) return "";
    value = value.toString();
    const res = this.getString(prefix + "." + value, locale);
    if (!!res) return res;
    return this.camelCaseBreaking ? this.convertToCamelCase(value, false) : value;
  }
  getLocales() {
    var res = [];
    res.push("");
    for (var key in this.locales) {
      res.push(key);
    }
    return res;
  }
  getDefaultStrings() {
    const loc = this.defaultLocale;
    if (!!loc && loc !== "en") {
      const strs = this.getLocale(loc);
      if (!!strs) return strs;
    }
    return defaultStrings;
  }
  stringsDiff(str1, str2) {
    if (typeof str1 === "function" || typeof str2 === "function") return false;
    return str1 !== str2;
  }
  getOldKeysString(str, locale = null) {
    const reNamedVal = renamedKeys[str];
    if (!reNamedVal) return void 0;
    const path = reNamedVal.split(".");
    const res = this.getStringByPath(path, locale);
    return res !== path[path.length - 1] ? res : void 0;
  }
};
var editorLocalization = new EditorLocalization();
surveyLocalization.onGetExternalString = (name, locale) => {
  const res = editorLocalization.getString(name, locale);
  return res !== name ? res : "";
};
function getLocString(strName, locale = null) {
  return editorLocalization.getString(strName, locale);
}
var defaultStrings = enStrings;
function setupLocale(localeConfig) {
  editorLocalization.setupLocale(localeConfig.localeCode, localeConfig.strings);
}
var QuestionConvertMode;
(function(QuestionConvertMode2) {
  QuestionConvertMode2[QuestionConvertMode2["AllTypes"] = 0] = "AllTypes";
  QuestionConvertMode2[QuestionConvertMode2["CompatibleTypes"] = 1] = "CompatibleTypes";
})(QuestionConvertMode || (QuestionConvertMode = {}));
var settings2 = {
  translation: {
    sortByName: false,
    //Set it to \xef\xbb\xbf; to tell system that it is UTF8 file. You can use other prefix as well
    exportPrefix: "",
    /**
     * The maximum number of locales that user can select at once for translation
     */
    maximumSelectedLocales: 7,
    /**
     * The name of the translation export file in csv format
     */
    exportFileName: "survey_translation.csv"
  },
  themeEditor: {
    exportFileName: "survey_theme.json",
    defaultFontFamily: "Open Sans"
  },
  operators: {
    empty: [],
    notempty: [],
    equal: ["!file"],
    notequal: ["!file"],
    contains: ["checkbox", "text", "comment"],
    notcontains: ["checkbox", "text", "comment"],
    anyof: ["selectbase"],
    allof: ["checkbox"],
    greater: ["!checkbox", "!imagepicker", "!boolean", "!file"],
    less: ["!checkbox", "!imagepicker", "!boolean", "!file"],
    greaterorequal: ["!checkbox", "!imagepicker", "!boolean", "!file"],
    lessorequal: ["!checkbox", "!imagepicker", "!boolean", "!file"]
  },
  defaultNewSurveyJSON: {},
  designer: {
    /**
     * The default question type on clicking Add Question button.
     */
    defaultAddQuestionType: "text",
    /**
     * Set this property to false, to hide "Add Question" button on designer surface
     */
    showAddQuestionButton: true
  },
  logic: {
    questionSortOrder: "asc",
    get defaultOperator() {
      return settings2.logic.defaultOperators.default;
    },
    set defaultOperator(val) {
      settings2.logic.defaultOperators.default = val;
    },
    defaultOperators: {
      default: "equal",
      checkbox: "allof",
      tagbox: "allof"
    },
    includeComplexQuestions: false,
    visibleActions: new Array(),
    invisibleTriggers: new Array(),
    logicItemTitleMaxChars: 50,
    openBracket: "{",
    closeBracket: "}",
    /**
     * Set these properties to false if you don't want to update expressions on changing question and column names and on changing choices values
     */
    updateExpressionsOnChanging: {
      questionName: true,
      columnName: true,
      choiceValue: true
    },
    /**
     * Set these properties to false if you don't want to update expressions on deleting question
     */
    updateExpressionsOnDeleting: {
      question: true
    }
  },
  /**
   * Determines which types of questions the conversion will be available for.
   */
  questionConvertMode: QuestionConvertMode.AllTypes,
  propertyGrid: {
    useButtonGroup: true,
    maxCharsInButtonGroup: 25,
    showNavigationButtons: false,
    enableSearch: true,
    maxColumns: 0,
    minChoices: 0,
    maxChoices: 0,
    maxRows: 0,
    maxRateValues: 0,
    maximumColumnsCount: 0,
    minimumChoicesCount: 0,
    maximumChoicesCount: 0,
    maximumRowsCount: 0,
    maximumRateValues: 0,
    generalTabName: "general",
    defaultExpandedTabName: "general",
    allowExpandMultipleCategories: false
  },
  toolbox: {
    /**
     * Use it to change the default question JSON on dropping it into designer or converting questions
     */
    defaultJSON: {
      dropdown: {
        choices: ["Item 1", "Item 2", "Item 3"]
      },
      tagbox: {
        choices: ["Item 1", "Item 2", "Item 3"]
      },
      checkbox: {
        choices: ["Item 1", "Item 2", "Item 3"]
      },
      radiogroup: {
        choices: ["Item 1", "Item 2", "Item 3"]
      },
      ranking: {
        choices: ["Item 1", "Item 2", "Item 3"]
      },
      imagepicker: {
        imageFit: "cover",
        choices: [{
          value: "Image 1",
          imageLink: "https://surveyjs.io/Content/Images/examples/image-picker/lion.jpg"
        }, {
          value: "Image 2",
          imageLink: "https://surveyjs.io/Content/Images/examples/image-picker/giraffe.jpg"
        }, {
          value: "Image 3",
          imageLink: "https://surveyjs.io/Content/Images/examples/image-picker/panda.jpg"
        }, {
          value: "Image 4",
          imageLink: "https://surveyjs.io/Content/Images/examples/image-picker/camel.jpg"
        }]
      },
      image: {
        imageFit: "cover",
        imageHeight: "auto",
        imageWidth: "100%"
      }
    }
  },
  /**
   * Notification settings
   */
  notifications: {
    lifetime: 2e3
  },
  /**
   * Auto save parameters
   */
  autoSave: {
    delay: 500
  },
  /**
   * Drag Drop Settings
   */
  dragDrop: {
    restrictDragQuestionBetweenPages: false,
    allowDragToTheSameLine: true
  },
  /**
   * Creator layout settings
   */
  layout: {
    showTabs: true,
    showToolbar: true,
    allowCollapseSidebar: true
  },
  jsonEditor: {
    indentation: 2,
    exportFileName: "survey.json"
  },
  useLegacyIcons: false
};
var EmptySurveyCreatorOptions = class {
  constructor() {
    this.isMobileView = false;
    this.allowEditExpressionsInTextEditor = true;
    this.maximumColumnsCount = settings2.propertyGrid.maximumColumnsCount;
    this.minimumChoicesCount = settings2.propertyGrid.minimumChoicesCount;
    this.maximumChoicesCount = settings2.propertyGrid.maximumChoicesCount;
    this.maximumRowsCount = settings2.propertyGrid.maximumRowsCount;
    this.maximumRateValues = settings2.propertyGrid.maximumRateValues;
    this.machineTranslationValue = false;
    this.inplaceEditForValues = false;
    this.maxNestedPanels = -1;
    this.translationLocalesOrder = [];
  }
  getProcessedTranslationItemText(locale, locString, newText, obj) {
    return newText;
  }
  getObjectDisplayName(obj, area, reason, displayName) {
    return displayName;
  }
  onCanShowPropertyCallback(object, property2, showMode, parentObj, parentProperty) {
    return true;
  }
  getElementAddornerCssCallback(obj, className) {
    return className;
  }
  onPropertyGridSurveyCreatedCallback(object, survey) {
  }
  onPropertyEditorCreatedCallback(object, property2, editor) {
  }
  onPropertyEditorUpdateTitleActionsCallback(object, property2, editor, titleActions) {
  }
  onPropertyGridShowModalCallback(object, property2, editor, popupEditor, popupModel) {
  }
  onIsPropertyReadOnlyCallback(obj, property2, readOnly, parentObj, parentProperty) {
    return readOnly;
  }
  onCanDeleteItemCallback(object, item, allowDelete) {
    return allowDelete;
  }
  onCollectionItemDeletingCallback(obj, property2, collection, item) {
    return true;
  }
  onCollectionItemAllowingCallback(obj, property2, collection, item, options) {
  }
  onItemValueAddedCallback(obj, propertyName, itemValue, itemValues) {
  }
  onFastEntryCallback(items, lines) {
    return items;
  }
  onMatrixDropdownColumnAddedCallback(matrix, column, columns) {
  }
  onSetPropertyEditorOptionsCallback(propertyName, obj, editorOptions) {
  }
  onGetErrorTextOnValidationCallback(propertyName, obj, value) {
    return null;
  }
  onValueChangingCallback(options) {
  }
  onGetElementEditorTitleCallback(obj, title) {
    return title;
  }
  startUndoRedoTransaction(name) {
  }
  stopUndoRedoTransaction() {
  }
  createSurvey(json2, reason, model, callback, area) {
    const survey = new SurveyModel(json2);
    if (!!callback) {
      callback(survey);
    }
    return survey;
  }
  onConditionQuestionsGetListCallback(propertyName, obj, editor, list, variables) {
    return "asc";
  }
  isConditionOperatorEnabled(questionName, question, operator, isEnabled) {
    return isEnabled;
  }
  onLogicGetTitleCallback(expression, displayExpression, text, logicItem) {
    return text;
  }
  getTranslationExportedText(obj, name, locString, locale, text) {
    return text;
  }
  uploadFiles(files, question, callback) {
  }
  getHasMachineTranslation() {
    return this.machineTranslationValue;
  }
  doMachineTranslation(fromLocale, toLocale, strings, callback) {
  }
  chooseFiles(input, callback, context) {
  }
  canAddPage(pageToAdd) {
    return true;
  }
};
function __decorate2(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var SurveyJSON5 = class _SurveyJSON5 {
  constructor(parseType = 0) {
    this.parseType = parseType;
  }
  parse(source, reviver = null, startFrom = 0, endAt = -1) {
    var result;
    this.text = String(source);
    this.at = startFrom;
    this.endAt = endAt;
    this.ch = " ";
    result = this.value();
    this.white();
    if (this.ch) {
      this.error("Syntax error");
    }
    return typeof reviver === "function" ? function walk(holder, key) {
      var k, v, value = holder[key];
      if (value && typeof value === "object") {
        for (k in value) {
          if (Object.prototype.hasOwnProperty.call(value, k)) {
            v = walk(value, k);
            if (v !== void 0) {
              value[k] = v;
            } else {
              delete value[k];
            }
          }
        }
      }
      return reviver.call(holder, key, value);
    }({
      "": result
    }, "") : result;
  }
  error(m) {
    var error = new SyntaxError();
    error.message = m;
    error["at"] = this.at;
    throw error;
  }
  next(c = null) {
    if (c && c !== this.ch) {
      this.error("Expected '" + c + "' instead of '" + this.ch + "'");
    }
    this.ch = this.chartAt();
    this.at += 1;
    return this.ch;
  }
  peek() {
    return this.chartAt();
  }
  chartAt() {
    if (this.endAt > -1 && this.at >= this.endAt) return "";
    return this.text.charAt(this.at);
  }
  identifier() {
    var key = this.ch;
    if (this.ch !== "_" && this.ch !== "$" && (this.ch < "a" || this.ch > "z") && (this.ch < "A" || this.ch > "Z")) {
      this.error("Bad identifier");
    }
    while (this.next() && (this.ch === "_" || this.ch === "$" || this.ch >= "a" && this.ch <= "z" || this.ch >= "A" && this.ch <= "Z" || this.ch >= "0" && this.ch <= "9")) {
      key += this.ch;
    }
    return key;
  }
  number() {
    var number, sign = "", string = "", base = 10;
    if (this.ch === "-" || this.ch === "+") {
      sign = this.ch;
      this.next(this.ch);
    }
    if (this.ch === "I") {
      number = this.word();
      if (typeof number !== "number" || isNaN(number)) {
        this.error("Unexpected word for number");
      }
      return sign === "-" ? -number : number;
    }
    if (this.ch === "N") {
      number = this.word();
      if (!isNaN(number)) {
        this.error("expected word to be NaN");
      }
      return number;
    }
    if (this.ch === "0") {
      string += this.ch;
      this.next();
      if (this.ch === "x" || this.ch === "X") {
        string += this.ch;
        this.next();
        base = 16;
      } else if (this.ch >= "0" && this.ch <= "9") {
        this.error("Octal literal");
      }
    }
    switch (base) {
      case 10:
        while (this.ch >= "0" && this.ch <= "9") {
          string += this.ch;
          this.next();
        }
        if (this.ch === ".") {
          string += ".";
          while (this.next() && this.ch >= "0" && this.ch <= "9") {
            string += this.ch;
          }
        }
        if (this.ch === "e" || this.ch === "E") {
          string += this.ch;
          this.next();
          if (this.ch === "-" || this.ch === "+") {
            string += this.ch;
            this.next();
          }
          while (this.ch >= "0" && this.ch <= "9") {
            string += this.ch;
            this.next();
          }
        }
        break;
      case 16:
        while (this.ch >= "0" && this.ch <= "9" || this.ch >= "A" && this.ch <= "F" || this.ch >= "a" && this.ch <= "f") {
          string += this.ch;
          this.next();
        }
        break;
    }
    if (sign === "-") {
      number = -string;
    } else {
      number = +string;
    }
    if (!isFinite(number)) {
      this.error("Bad number");
    } else {
      return number;
    }
  }
  string() {
    var hex, i, string = "", delim, uffff;
    if (this.ch === '"' || this.ch === "'") {
      delim = this.ch;
      while (this.next()) {
        if (this.ch === delim) {
          this.next();
          return string;
        } else if (this.ch === "\\") {
          this.next();
          if (this.ch === "u") {
            uffff = 0;
            for (i = 0; i < 4; i += 1) {
              hex = parseInt(this.next(), 16);
              if (!isFinite(hex)) {
                break;
              }
              uffff = uffff * 16 + hex;
            }
            string += String.fromCharCode(uffff);
          } else if (this.ch === "\r") {
            if (this.peek() === "\n") {
              this.next();
            }
          } else if (typeof _SurveyJSON5.escapee[this.ch] === "string") {
            string += _SurveyJSON5.escapee[this.ch];
          } else {
            break;
          }
        } else if (this.ch === "\n") {
          break;
        } else {
          string += this.ch;
        }
      }
    }
    this.error("Bad string");
  }
  inlineComment() {
    if (this.ch !== "/") {
      this.error("Not an inline comment");
    }
    do {
      this.next();
      if (this.ch === "\n" || this.ch === "\r") {
        this.next();
        return;
      }
    } while (this.ch);
  }
  blockComment() {
    if (this.ch !== "*") {
      this.error("Not a block comment");
    }
    do {
      this.next();
      while (this.ch === "*") {
        this.next("*");
        if (this.ch === "/") {
          this.next("/");
          return;
        }
      }
    } while (this.ch);
    this.error("Unterminated block comment");
  }
  comment() {
    if (this.ch !== "/") {
      this.error("Not a comment");
    }
    this.next("/");
    if (this.ch === "/") {
      this.inlineComment();
    } else if (this.ch === "*") {
      this.blockComment();
    } else {
      this.error("Unrecognized comment");
    }
  }
  white() {
    while (this.ch) {
      if (this.ch === "/") {
        this.comment();
      } else if (_SurveyJSON5.ws.indexOf(this.ch) >= 0) {
        this.next();
      } else {
        return;
      }
    }
  }
  word() {
    switch (this.ch) {
      case "t":
        this.next("t");
        this.next("r");
        this.next("u");
        this.next("e");
        return true;
      case "f":
        this.next("f");
        this.next("a");
        this.next("l");
        this.next("s");
        this.next("e");
        return false;
      case "n":
        this.next("n");
        this.next("u");
        this.next("l");
        this.next("l");
        return null;
      case "I":
        this.next("I");
        this.next("n");
        this.next("f");
        this.next("i");
        this.next("n");
        this.next("i");
        this.next("t");
        this.next("y");
        return Infinity;
      case "N":
        this.next("N");
        this.next("a");
        this.next("N");
        return NaN;
    }
    this.error("Unexpected '" + this.ch + "'");
  }
  array() {
    var array = [];
    if (this.ch === "[") {
      this.next("[");
      this.white();
      while (this.ch) {
        if (this.ch === "]") {
          this.next("]");
          return array;
        }
        if (this.ch === ",") {
          this.error("Missing array element");
        } else {
          array.push(this.value());
        }
        this.white();
        if (this.ch !== ",") {
          this.next("]");
          return array;
        }
        this.next(",");
        this.white();
      }
    }
    this.error("Bad array");
  }
  object() {
    var key, start, isFirstProperty = true, object = {};
    if (this.parseType > 0) {
      object[_SurveyJSON5.positionName] = {
        start: this.at - 1
      };
    }
    if (this.ch === "{") {
      this.next("{");
      this.white();
      start = this.at - 1;
      while (this.ch) {
        if (this.ch === "}") {
          if (this.parseType > 0) {
            object[_SurveyJSON5.positionName].end = start;
          }
          this.next("}");
          return object;
        }
        if (this.ch === '"' || this.ch === "'") {
          key = this.string();
        } else {
          key = this.identifier();
        }
        this.white();
        if (this.parseType > 1) {
          object[_SurveyJSON5.positionName][key] = {
            start,
            valueStart: this.at
          };
        }
        this.next(":");
        object[key] = this.value();
        if (this.parseType > 1) {
          start = this.at - 1;
          object[_SurveyJSON5.positionName][key].valueEnd = start;
          object[_SurveyJSON5.positionName][key].end = start;
        }
        this.white();
        if (this.ch !== ",") {
          if (this.parseType > 1) {
            object[_SurveyJSON5.positionName][key].valueEnd--;
            object[_SurveyJSON5.positionName][key].end--;
          }
          if (this.parseType > 0) {
            object[_SurveyJSON5.positionName].end = this.at - 1;
          }
          this.next("}");
          return object;
        }
        if (this.parseType > 1) {
          object[_SurveyJSON5.positionName][key].valueEnd--;
          if (!isFirstProperty) {
            object[_SurveyJSON5.positionName][key].end--;
          }
        }
        this.next(",");
        this.white();
        isFirstProperty = false;
      }
    }
    this.error("Bad object");
  }
  value() {
    this.white();
    switch (this.ch) {
      case "{":
        return this.object();
      case "[":
        return this.array();
      case '"':
      case "'":
        return this.string();
      case "-":
      case "+":
      case ".":
        return this.number();
      default:
        return this.ch >= "0" && this.ch <= "9" ? this.number() : this.word();
    }
  }
  stringify(obj, replacer = null, space = null) {
    if (replacer && typeof replacer !== "function" && !this.isArray(replacer)) {
      throw new Error("Replacer must be a function or an array");
    }
    this.replacer = replacer;
    this.indentStr = this.getIndent(space);
    this.objStack = [];
    var topLevelHolder = {
      "": obj
    };
    if (obj === void 0) {
      return this.getReplacedValueOrUndefined(topLevelHolder, "", true);
    }
    return this.internalStringify(topLevelHolder, "", true);
  }
  getIndent(space) {
    if (space) {
      if (typeof space === "string") {
        return space;
      } else if (typeof space === "number" && space >= 0) {
        return this.makeIndent(" ", space, true);
      }
    }
    return "";
  }
  getReplacedValueOrUndefined(holder, key, isTopLevel) {
    var value = holder[key];
    if (value && value.toJSON && typeof value.toJSON === "function") {
      value = value.toJSON();
    }
    if (typeof this.replacer === "function") {
      return this.replacer.call(holder, key, value);
    } else if (this.replacer) {
      if (isTopLevel || this.isArray(holder) || this.replacer.indexOf(key) >= 0) {
        return value;
      } else {
        return void 0;
      }
    } else {
      return value;
    }
  }
  isWordChar(char) {
    return char >= "a" && char <= "z" || char >= "A" && char <= "Z" || char >= "0" && char <= "9" || char === "_" || char === "$";
  }
  isWordStart(char) {
    return char >= "a" && char <= "z" || char >= "A" && char <= "Z" || char === "_" || char === "$";
  }
  isWord(key) {
    if (typeof key !== "string") {
      return false;
    }
    if (!this.isWordStart(key[0])) {
      return false;
    }
    var i = 1, length = key.length;
    while (i < length) {
      if (!this.isWordChar(key[i])) {
        return false;
      }
      i++;
    }
    return true;
  }
  // polyfills
  isArray(obj) {
    if (Array.isArray) {
      return Array.isArray(obj);
    } else {
      return Object.prototype.toString.call(obj) === "[object Array]";
    }
  }
  isDate(obj) {
    return Object.prototype.toString.call(obj) === "[object Date]";
  }
  isNaN(val) {
    return typeof val === "number" && val !== val;
  }
  checkForCircular(obj) {
    for (var i = 0; i < this.objStack.length; i++) {
      if (this.objStack[i] === obj) {
        throw new TypeError("Converting circular structure to JSON");
      }
    }
  }
  makeIndent(str, num, noNewLine = false) {
    if (!str) {
      return "";
    }
    if (str.length > 10) {
      str = str.substring(0, 10);
    }
    var indent = noNewLine ? "" : "\n";
    for (var i = 0; i < num; i++) {
      indent += str;
    }
    return indent;
  }
  escapeString(str) {
    _SurveyJSON5.escapable.lastIndex = 0;
    return _SurveyJSON5.escapable.test(str) ? '"' + str.replace(_SurveyJSON5.escapable, function(a) {
      var c = _SurveyJSON5.meta[a];
      return typeof c === "string" ? c : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
    }) + '"' : '"' + str + '"';
  }
  // End
  internalStringify(holder, key, isTopLevel) {
    var buffer, res;
    var obj_part = this.getReplacedValueOrUndefined(holder, key, isTopLevel);
    if (obj_part && !this.isDate(obj_part)) {
      obj_part = obj_part.valueOf();
    }
    switch (typeof obj_part) {
      case "boolean":
        return obj_part.toString();
      case "number":
        if (isNaN(obj_part) || !isFinite(obj_part)) {
          return "null";
        }
        return obj_part.toString();
      case "string":
        return this.escapeString(obj_part.toString());
      case "object":
        if (obj_part === null) {
          return "null";
        } else if (this.isArray(obj_part)) {
          this.checkForCircular(obj_part);
          buffer = "[";
          this.objStack.push(obj_part);
          for (var i = 0; i < obj_part.length; i++) {
            res = this.internalStringify(obj_part, i, false);
            buffer += this.makeIndent(this.indentStr, this.objStack.length);
            if (res === null || typeof res === "undefined") {
              buffer += "null";
            } else {
              buffer += res;
            }
            if (i < obj_part.length - 1) {
              buffer += ",";
            } else if (this.indentStr) {
              buffer += "\n";
            }
          }
          this.objStack.pop();
          buffer += this.makeIndent(this.indentStr, this.objStack.length, true) + "]";
        } else {
          this.checkForCircular(obj_part);
          buffer = "{";
          var nonEmpty = false;
          this.objStack.push(obj_part);
          for (var prop in obj_part) {
            if (obj_part.hasOwnProperty(prop)) {
              var value = this.internalStringify(obj_part, prop, false);
              isTopLevel = false;
              if (typeof value !== "undefined" && value !== null) {
                buffer += this.makeIndent(this.indentStr, this.objStack.length);
                nonEmpty = true;
                var propKey = this.isWord(prop) ? prop : this.escapeString(prop);
                buffer += propKey + ":" + (this.indentStr ? " " : "") + value + ",";
              }
            }
          }
          this.objStack.pop();
          if (nonEmpty) {
            buffer = buffer.substring(0, buffer.length - 1) + this.makeIndent(this.indentStr, this.objStack.length) + "}";
          } else {
            buffer = "{}";
          }
        }
        return buffer;
      default:
        return void 0;
    }
  }
};
SurveyJSON5.positionName = "pos";
SurveyJSON5.escapee = {
  "'": "'",
  '"': '"',
  "\\": "\\",
  "/": "/",
  "\n": "",
  // Replace escaped newlines in strings w/ empty string
  b: "\b",
  f: "\f",
  n: "\n",
  r: "\r",
  t: "	"
};
SurveyJSON5.ws = [" ", "	", "\r", "\n", "\v", "\f", "", "\uFEFF"];
SurveyJSON5.cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
SurveyJSON5.escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
SurveyJSON5.meta = {
  // table of character substitutions
  "\b": "\\b",
  "	": "\\t",
  "\n": "\\n",
  "\f": "\\f",
  "\r": "\\r",
  '"': '\\"',
  "\\": "\\\\"
};
var QuestionConverter = class _QuestionConverter {
  static get convertInfo() {
    if (!_QuestionConverter.convertInfoValue) {
      _QuestionConverter.convertInfoValue = {};
      _QuestionConverter.createDefaultQuestionConverterItems();
    }
    return _QuestionConverter.convertInfoValue;
  }
  static createDefaultQuestionConverterItems() {
    var classes = Serializer.getChildrenClasses("selectbase", true);
    for (var i = 0; i < classes.length; i++) {
      for (var j = 0; j < classes.length; j++) {
        if (i == j) continue;
        _QuestionConverter.addConvertInfo(classes[i].name, classes[j].name);
      }
    }
    _QuestionConverter.addConvertInfo("text", "comment");
    _QuestionConverter.addConvertInfo("comment", "text");
  }
  static addConvertInfo(className, convertToClassName) {
    if (!_QuestionConverter.convertInfo[className]) {
      _QuestionConverter.convertInfo[className] = [];
    }
    _QuestionConverter.convertInfo[className].push(convertToClassName);
  }
  static getConvertableClasses(className) {
    let res = _QuestionConverter.convertInfo[className];
    if (!!Array.isArray(res) && res.indexOf(className) < 0) {
      res.unshift(className);
    }
    return res;
  }
  static getConvertToClasses(className, availableTypes = null, includeCurrent = false) {
    var res = settings2.questionConvertMode == QuestionConvertMode.AllTypes ? getAllQuestionTypes(className, includeCurrent) : _QuestionConverter.getConvertableClasses(className);
    if (!res) return [];
    if (Array.isArray(availableTypes) && availableTypes.length > 0) {
      const types = [];
      res.forEach((item) => types.push(item));
      res = availableTypes.filter((item) => types.indexOf(item) >= 0);
    }
    return !!res ? res : [];
  }
  static getObjJSON(obj, defaultObjJSON) {
    const res = obj.toJSON();
    if (defaultObjJSON) {
      for (let key in defaultObjJSON) {
        if (res[key] && Helpers.isTwoValueEquals(res[key], defaultObjJSON[key])) {
          delete res[key];
        }
      }
    }
    return res;
  }
  static convertObject(obj, convertToClass, objJSON, defaultJSON = null, jsonToSetAfter = null) {
    if (!obj || !obj.parent || convertToClass == obj.getType() && !defaultJSON) return null;
    let newQuestion = !defaultJSON ? QuestionFactory.Instance.createQuestion(convertToClass, obj.name) : void 0;
    if (!newQuestion) {
      newQuestion = Serializer.createClass(convertToClass, {});
    }
    newQuestion.name = obj.name;
    const sourceJSON = defaultJSON;
    const json2 = sourceJSON ? Helpers.createCopy(sourceJSON) : newQuestion.toJSON();
    const qJson = objJSON || {};
    for (let key in qJson) {
      json2[key] = qJson[key];
    }
    if (jsonToSetAfter) {
      for (let key in jsonToSetAfter) {
        json2[key] = jsonToSetAfter[key];
      }
    }
    _QuestionConverter.updateJSON(json2, convertToClass, obj.getType());
    newQuestion.fromJSON(json2);
    _QuestionConverter.removeValidators(newQuestion);
    let panel = obj.parent;
    let index = panel.elements.indexOf(obj);
    panel.isConverting = true;
    var isSameLine = index + 1 < panel.elements.length ? panel.elements[index + 1].startWithNewLine === false : false;
    panel.removeElement(obj);
    panel.addElement(newQuestion, index);
    if (isSameLine) {
      panel.elements[index + 1].startWithNewLine = false;
    }
    delete panel.isConverting;
    newQuestion.onSurveyLoad();
    return newQuestion;
  }
  static updateJSON(json2, convertToClass, convertFromClass) {
    _QuestionConverter.updateJSONForRating(json2, convertToClass);
    _QuestionConverter.updateJSONForMatrices(json2, convertToClass, convertFromClass);
    _QuestionConverter.updateJSONForPanels(json2, convertToClass, convertFromClass);
    _QuestionConverter.updateJSONForBarrating(json2, convertToClass);
  }
  static updateJSONForMatrices(json2, convertToClass, convertFromClass) {
    if (Serializer.isDescendantOf(convertToClass, "matrix") && Serializer.isDescendantOf(convertFromClass, "matrixdropdownbase") && json2.columns) {
      let num = 0;
      json2.columns = json2.columns.map((col) => {
        const name = col.name ? col.name : typeof col === "string" ? col : "col" + num++;
        return col.title ? {
          value: name,
          text: col.title
        } : name;
      });
    }
    if (Serializer.isDescendantOf(convertToClass, "matrixdropdownbase") && Serializer.isDescendantOf(convertFromClass, "matrix") && json2.columns) {
      json2.columns = json2.columns.map((col) => ({
        name: _QuestionConverter.getColumnName(col.name || col.value || col),
        title: col.text
      }));
    }
  }
  static getColumnName(val) {
    if (Helpers.isNumber(val)) return "col" + val;
    return val;
  }
  static updateJSONForRating(json2, convertToClass) {
    if (convertToClass === "rating" && json2.choices) {
      json2.rateValues = json2.choices;
    }
    if (!!json2.rateValues && !Serializer.isDescendantOf(convertToClass, "matrixdropdownbase")) {
      json2.choices = json2.rateValues;
    }
  }
  static updateJSONForBarrating(json2, convertToClass) {
    if (convertToClass === "barrating") {
      json2.choices = [1, 2, 3, 4, 5];
    }
  }
  static updateJSONForPanels(json2, convertToClass, convertFromClass) {
    if (Serializer.isDescendantOf(convertToClass, "paneldynamic") && Serializer.isDescendantOf(convertFromClass, "panel") && json2.elements) {
      json2.templateElements = json2.elements;
      delete json2.elements;
    }
    if (Serializer.isDescendantOf(convertToClass, "panel") && Serializer.isDescendantOf(convertFromClass, "paneldynamic") && json2.templateElements) {
      json2.elements = json2.templateElements;
      delete json2.templateElements;
    }
  }
  static removeValidators(question) {
    const validators = question.validators;
    if (!Array.isArray(validators) || validators.length === 0) return;
    const supported = question.getSupportedValidators();
    for (var i = validators.length - 1; i >= 0; i--) {
      const valType = validators[i].getType().replace("validator", "");
      if (supported.indexOf(valType) < 0) {
        validators.splice(i, 1);
      }
    }
  }
};
function getAllQuestionTypes(className, includeCurrent = false) {
  var classes = Serializer.getChildrenClasses("question", true);
  var res = [];
  for (var i = 0; i < classes.length; i++) {
    if (includeCurrent || classes[i].name !== className) {
      res.push(classes[i].name);
    }
  }
  if (includeCurrent || className !== "panel") {
    res.push("panel");
  }
  const widgets = CustomWidgetCollection.Instance.widgets;
  for (var i = 0; i < widgets.length; i++) {
    if (includeCurrent || widgets[i].name !== className) {
      res.push(widgets[i].name);
    }
  }
  return res;
}
var opositeValues = {
  true: "false",
  True: "False",
  TRUE: "FALSE",
  false: "true",
  False: "True",
  FALSE: "TRUE",
  yes: "no",
  Yes: "No",
  YES: "NO",
  no: "yes",
  No: "Yes",
  NO: "YES"
};
function getOpositValue(str) {
  if (!!opositeValues[str]) return opositeValues[str];
  return null;
}
function hasValueInArray(values, search) {
  search = search.toString();
  for (var i = 0; i < values.length; i++) {
    if (!values[i]) continue;
    if (values[i].toString() === search) return true;
  }
  return false;
}
function getNumericFromString(str) {
  if (!str) return "";
  var num = "";
  for (var i = str.length - 1; i >= 0; i--) {
    if (str[i] >= "0" && str[i] <= "9") {
      num = str[i] + num;
    } else {
      if (!!num) return num;
    }
    if (num.length == 10) break;
  }
  return num;
}
function getNextItemValue(prefix, choices) {
  const values = choices.map((item) => item.value);
  return getNextValue(prefix, values);
}
function getNextItemText(choices) {
  const ln = choices.length;
  if (ln === 0) return "";
  if (!choices[ln - 1].text || choices[ln - 1].text === choices[ln - 1].value) return "";
  const values = [];
  choices.forEach((item) => {
    if (item.hasText) values.push(item.text);
  });
  choices.map((item) => item.text);
  const nextValue = getNextValue("", values, true);
  return !!nextValue ? nextValue.toString() : "";
}
function getNextValue(prefix, values, isText) {
  let oposite = null;
  if (values.length > 0) oposite = getOpositValue(values[values.length - 1]);
  if (oposite && values.indexOf(oposite) < 0) return oposite;
  var numStr = "";
  var baseValue;
  var numStrIndex = -1;
  for (var i = values.length - 1; i >= 0; i--) {
    if (!values[i]) continue;
    var str = values[i].toString();
    numStr = getNumericFromString(str);
    if (!!numStr) {
      numStrIndex = str.lastIndexOf(numStr);
      baseValue = values[i];
      break;
    }
  }
  if (numStrIndex > -1) {
    var num = parseInt(numStr);
    var isNumber = baseValue === num;
    var newValue;
    do {
      if (isNumber) {
        newValue = ++num;
      } else {
        var newNum = (num++).toString();
        while (numStr.length > newNum.length) {
          newNum = "0" + newNum;
        }
        newValue = str.substring(0, numStrIndex) + newNum + str.substring(numStrIndex + numStr.length);
      }
    } while (hasValueInArray(values, newValue));
    return newValue;
  }
  if (!prefix) {
    prefix = values[values.length - 1];
  }
  return isText ? "" : prefix + 1;
}
function propertyExists(obj, propertyName) {
  let result = true;
  if (!!obj && typeof obj.getType === "function") {
    const property2 = Serializer.findProperty(obj.getType(), propertyName);
    result = !!property2;
  }
  return result;
}
function isPropertyVisible(obj, propertyName) {
  let result = true;
  if (!!obj && typeof obj.getType === "function") {
    const property2 = Serializer.findProperty(obj.getType(), propertyName);
    result = !property2 || property2.visible;
  }
  return result;
}
function getQuestionFromObj(obj) {
  return obj instanceof MatrixDropdownColumn ? obj.templateQuestion : obj;
}
function scrollElementIntoView(elementId) {
  if (!elementId || typeof settings.environment.root === "undefined") return;
  const el = settings.environment.root.getElementById(elementId);
  if (!el) return;
  el.scrollIntoView({
    behavior: "smooth",
    block: "center",
    inline: "start"
  });
}
function assignDefaultClasses(destination, questionType2) {
  copyCssClasses(destination, defaultCss.question);
  copyCssClasses(destination, defaultCss[questionType2]);
  destination.list = defaultCss.list;
  destination.hasErrorTop = "";
  destination.hasErrorBottom = "";
}
function wrapTextByCurlyBraces(text) {
  return settings2.logic.openBracket + text + settings2.logic.closeBracket;
}
var ObjType;
(function(ObjType2) {
  ObjType2["Unknown"] = "unknown";
  ObjType2["Survey"] = "survey";
  ObjType2["Page"] = "page";
  ObjType2["Panel"] = "panel";
  ObjType2["Question"] = "question";
  ObjType2["Column"] = "column";
})(ObjType || (ObjType = {}));
var SurveyHelper = class _SurveyHelper {
  static getNewElementName(el) {
    const survey = el.getSurvey();
    if (!survey) return el.name;
    if (el.isPage) return this.getNewPageName(survey.pages);
    if (el.isPanel) return this.getNewPanelName(survey.getAllPanels());
    return this.getNewQuestionName(survey.getAllQuestions(false, false, true));
  }
  static getNewPageName(objs) {
    return _SurveyHelper.getNewName(objs, editorLocalization.getString("ed.newPageName"));
  }
  static isPageNameAutoGenerated(name) {
    return _SurveyHelper.isNameAutoGenerated(name, editorLocalization.getString("ed.newPageName"));
  }
  static isPagePropertiesAreModified(page) {
    if (!_SurveyHelper.isPageNameAutoGenerated(page.name)) return true;
    const json2 = page.toJSON();
    delete json2["name"];
    delete json2["elements"];
    for (var key in json2) return true;
    return false;
  }
  static getNewQuestionName(objs) {
    return _SurveyHelper.getNewName(objs, editorLocalization.getString("ed.newQuestionName"));
  }
  static getNewPanelName(objs) {
    return _SurveyHelper.getNewName(objs, editorLocalization.getString("ed.newPanelName"));
  }
  static generateNewName(name) {
    var pos = name.length;
    while (pos > 0 && name[pos - 1] >= "0" && name[pos - 1] <= "9") {
      pos--;
    }
    var base = name.substring(0, pos);
    var num = 0;
    if (pos < name.length) {
      num = parseInt(name.substring(pos));
    }
    num++;
    return base + num;
  }
  static getNewName(objs, baseName) {
    var hash = {};
    for (var i = 0; i < objs.length; i++) {
      hash[objs[i].name] = true;
    }
    var num = 1;
    while (true) {
      if (!hash[baseName + num.toString()]) break;
      num++;
    }
    return baseName + num.toString();
  }
  static isNameAutoGenerated(name, baseName) {
    if (!name || name.length < baseName.length) return false;
    const digits = name.substring(baseName.length);
    return Helpers.isNumber(digits);
  }
  static getObjectType(obj) {
    if (!obj || !obj["getType"]) return ObjType.Unknown;
    if (obj.isPage) return ObjType.Page;
    if (obj.isPanel) return ObjType.Panel;
    if (obj.getType() == "survey") return ObjType.Survey;
    if (obj.getType() == "matrixdropdowncolumn") return ObjType.Column;
    if (obj.isQuestion) return ObjType.Question;
    return ObjType.Unknown;
  }
  static getObjectTypeStr(obj) {
    var objType = _SurveyHelper.getObjectType(obj);
    if (objType === ObjType.Survey) return "survey";
    if (objType === ObjType.Page) return "page";
    if (objType === ObjType.Panel) return "panel";
    if (objType === ObjType.Question) return "question";
    if (objType === ObjType.Column) return "column";
    return "unknown";
  }
  static getObjectName(obj, showObjectTitle = false) {
    var objType = _SurveyHelper.getObjectType(obj);
    if (objType === ObjType.Survey) return editorLocalization.getString("ed.surveyTypeName");
    if (showObjectTitle && obj["title"]) return obj["title"];
    if (showObjectTitle && obj["text"]) return obj["text"];
    if (obj["name"]) return obj["name"];
    return "";
  }
  static getElements(element, includeHidden = false) {
    if (!element) return [];
    if (element.getElementsInDesign) return element.getElementsInDesign(includeHidden);
    if (element.elements) return element.elements;
    return [];
  }
  static addElements(elements, isPanel, result) {
    for (var i = 0; i < elements.length; i++) {
      if (elements[i].isPanel === isPanel) {
        result.push(elements[i]);
      }
      _SurveyHelper.addElements(_SurveyHelper.getElements(elements[i]), isPanel, result);
    }
  }
  static getAllElements(survey, isPanel) {
    const result = [];
    for (let i = 0; i < survey.pages.length; i++) {
      _SurveyHelper.addElements(survey.pages[i].elements, isPanel, result);
    }
    return result;
  }
  static isPropertyVisible(obj, property2, options = null, showMode = null, parentObj = null, parentProperty = null) {
    if (!property2 || !property2.visible) return false;
    if (!!showMode && !!property2.showMode && showMode !== property2.showMode) return false;
    if (!!property2.isVisible && !!obj.getLayoutType && !property2["isVisible"](obj.getLayoutType(), null)) return false;
    var canShow = !!options ? (object, property3) => {
      return options.onCanShowPropertyCallback(object, property3, showMode, parentObj, parentProperty);
    } : null;
    if (!!canShow && !canShow(obj, property2)) return false;
    return true;
  }
  static isNeedScrollIntoView(el, scrollIfElementBiggerThanContainer = false) {
    if (!el || !el.scrollIntoView) return;
    var rect = el.getBoundingClientRect();
    var scrollableDiv = _SurveyHelper.getScrollableDiv(el);
    if (!scrollableDiv) return;
    var height = scrollableDiv.clientHeight;
    if (rect.top < scrollableDiv.offsetTop) {
      return "top";
    } else {
      let offsetTop = height + scrollableDiv.offsetTop;
      if (rect.bottom > offsetTop && (rect.height < height || scrollIfElementBiggerThanContainer)) {
        return "bottom";
      }
    }
  }
  static scrollIntoViewIfNeeded(el, getOptions, scrollIfElementBiggerThanContainer = false) {
    const isNeedScroll = _SurveyHelper.isNeedScrollIntoView(el, scrollIfElementBiggerThanContainer);
    if (!isNeedScroll) return;
    const isNeedScrollToTop = isNeedScroll === "top";
    el.scrollIntoView(getOptions ? getOptions(isNeedScrollToTop) : isNeedScrollToTop);
  }
  static getScrollableDiv(el) {
    while (!!el) {
      if (!!el.id && el.id.indexOf("scrollableDiv") > -1) return el;
      if (!el.offsetParent) return null;
      el = el.offsetParent;
    }
    return null;
  }
  static moveItemInArray(list, obj, newIndex) {
    if (!list || list.length < 2) return false;
    if (newIndex < 0 || newIndex >= list.length) return false;
    var oldIndex = list.indexOf(obj);
    if (oldIndex < 0 || oldIndex == newIndex) return false;
    for (var i = 0; i < list.length; i++) {
      _SurveyHelper.disableSelectingObj(list[i]);
    }
    list.splice(oldIndex, 1);
    list.splice(newIndex, 0, obj);
    for (var i = 0; i < list.length; i++) {
      _SurveyHelper.enableSelectingObj(list[i]);
    }
    return true;
  }
  static applyItemValueArray(dest, src) {
    if (!src || src.length == 0) {
      dest.splice(0, dest.length);
      return;
    }
    if (dest.length > src.length) {
      dest.splice(src.length, dest.length - src.length);
    }
    if (dest.length < src.length) {
      var insertedArray = [];
      for (var i = dest.length; i < src.length; i++) {
        insertedArray.push(src[i]);
      }
      dest.splice.apply(dest, [dest.length, 0].concat(insertedArray));
    }
    for (var i = 0; i < dest.length; i++) {
      if (dest[i].value != src[i].value) {
        dest[i].value = src[i].value;
      }
      dest[i].text = src[i].hasText ? src[i].text : "";
    }
  }
  static disableSelectingObj(obj) {
    obj["disableSelecting"] = true;
  }
  static enableSelectingObj(obj) {
    delete obj["disableSelecting"];
  }
  static canSelectObj(obj) {
    return !obj || obj["disableSelecting"] !== true;
  }
  static warnNonSupported(name, newPropertyName) {
    let outputText = wrapTextByCurlyBraces(name) + " is not supported in V2.";
    if (!!newPropertyName) {
      outputText += " Use the '" + newPropertyName + "' property instead";
    }
    _SurveyHelper.warnText(outputText);
  }
  static warnText(text) {
    console.warn(text);
  }
  static deleteConditionProperties(json2) {
    delete json2["visible"];
    delete json2["visibleIf"];
    delete json2["readOnly"];
    delete json2["enableIf"];
    delete json2["valueName"];
    delete json2["choicesVisibleIf"];
    delete json2["choicesEnableIf"];
    delete json2["width"];
    delete json2["minWidth"];
    delete json2["maxWidth"];
  }
  static deleteRandomProperties(json2) {
    ["choicesOrder", "rowOrder"].forEach((prop) => {
      if (json2[prop] === "random") {
        delete json2[prop];
      }
    });
  }
  static updateQuestionJson(questionJson) {
    questionJson.storeOthersAsComment = false;
    delete questionJson.valuePropertyName;
    _SurveyHelper.deleteConditionProperties(questionJson);
    _SurveyHelper.deleteRandomProperties(questionJson);
    _SurveyHelper.deleteConditionPropertiesFromArray(questionJson.choices);
    _SurveyHelper.deleteConditionPropertiesFromArray(questionJson.rows);
    _SurveyHelper.deleteConditionPropertiesFromArray(questionJson.columns);
    _SurveyHelper.deleteConditionPropertiesFromArray(questionJson.rates);
  }
  static deleteConditionPropertiesFromArray(jsonArray) {
    if (!Array.isArray(jsonArray)) return;
    jsonArray.forEach((item) => {
      _SurveyHelper.deleteConditionProperties(item);
    });
  }
  static convertMatrixRowsToText(rows) {
    var result = rows.filter((row) => !row.cells[0].hasError).map((row) => row.cells.map((cell) => cell.value || "").join(ItemValue.Separator).replace(/\|$/, "")).join("\n");
    return result;
  }
  static convertItemValuesToText(items) {
    var text = "";
    items.forEach((item) => {
      if (text) text += "\n";
      text += item.value;
      if (item.pureText) text += ItemValue.Separator + item.pureText;
    });
    return text;
  }
  static convertTextToItemValues(text, properties, className) {
    var items = [];
    if (!text) return items;
    var texts = text.split("\n");
    for (var i = 0; i < texts.length; i++) {
      if (!texts[i]) continue;
      var elements = texts[i].split(ItemValue.Separator);
      var valueItem = Serializer.createClass(className);
      properties.forEach((p, i2) => {
        valueItem[p.name] = elements[i2];
      });
      items.push(valueItem);
    }
    return items;
  }
  static sortItems(items, propertyName = "text") {
    const getNumber = (str, index) => {
      let strNum = "";
      while (index < str.length && str[index] >= "0" && str[index] <= "9") {
        strNum += str[index];
        index++;
      }
      return parseFloat(strNum);
    };
    items.sort((a, b) => {
      const aVal = !!a[propertyName] ? a[propertyName] : "";
      const bVal = !!b[propertyName] ? b[propertyName] : "";
      let index = 0;
      while (index < aVal.length && index < bVal.length && aVal[index] === bVal[index]) index++;
      if (index < aVal.length && index < bVal.length) {
        while (index > 0 && aVal[index - 1] >= "0" && aVal[index - 1] <= "9") index--;
        const aNum = getNumber(aVal, index);
        const bNum = getNumber(bVal, index);
        if (aNum < bNum) return -1;
        if (aNum > bNum) return 1;
      }
      return aVal.localeCompare(bVal);
    });
  }
  static getQuestionContextIndexInfo(name, prefix = "") {
    const contextStrings = ["row", "panel"];
    for (var i = 0; i < contextStrings.length; i++) {
      const subStr = prefix + contextStrings[i] + ".";
      const index = name.indexOf(subStr);
      if (index > -1) return {
        index,
        name: subStr
      };
    }
    return void 0;
  }
  static isSupportCellEditor(type) {
    const supportedTypes = ["selectbase", "boolean", "rating"];
    for (let i = 0; i < supportedTypes.length; i++) {
      if (Serializer.isDescendantOf(type, supportedTypes[i])) return true;
    }
    return false;
  }
  static getElementDeepLength(element) {
    let res = 0;
    while (!!element) {
      if (element.isPanel) res++;
      element = element.parent;
    }
    return res;
  }
};
var SurveyForTextWorker = class extends SurveyModel {
  constructor(jsonObj) {
    super();
    this.setDesignMode(true);
    this.fromJSON(jsonObj);
  }
  //Run endLoading before fixing issues with unique names
  runEndLoadingFromJson() {
    if (this.isRunEndLoadingFromJson) return;
    this.isRunEndLoadingFromJson = true;
    super.endLoadingFromJson();
  }
  //Do nothing on end loading
  endLoadingFromJson() {
  }
  getSurveyData() {
    return null;
  }
};
var SurveyTextWorkerJsonErrorFixerBase = class {
  getCorrectAt(text, at, end) {
    return at;
  }
  get isFixable() {
    return false;
  }
  fixError(text, start, end) {
    return text;
  }
};
var SurveyTextWorkerError = class {
  constructor(at, text) {
    this.at = at;
    this.text = text;
    this.rowAt = -1;
    this.columnAt = -1;
  }
  get isFixable() {
    return this.fixer.isFixable;
  }
  fixError(text) {
    return text;
  }
  get fixer() {
    if (!this.fixerValue) {
      this.fixerValue = this.createFixer();
    }
    return this.fixerValue;
  }
  createFixer() {
    return new SurveyTextWorkerJsonErrorFixerBase();
  }
};
var SurveyTextWorkerParserError = class extends SurveyTextWorkerError {
  getErrorType() {
    return "parseerror";
  }
};
var SurveyTextWorkerJsonErrorFixer = class extends SurveyTextWorkerJsonErrorFixerBase {
  constructor(element, jsonObj) {
    super();
    this.element = element;
    this.jsonObj = jsonObj;
  }
  getNewIndex(text, findText, at, end) {
    const index = text.indexOf(findText, at);
    if (index > -1 && (end < 0 || index < end)) {
      return index;
    }
    return -1;
  }
  fixError(text, start, end) {
    const content = text.substring(start, end + 1);
    const json2 = JSON.parse(content);
    this.updatedJsonObjOnFix(json2);
    return this.replaceJson(text, start, end, json2);
  }
  updatedJsonObjOnFix(json2) {
  }
  replaceJson(text, start, end, json2) {
    let newContent = JSON.stringify(json2, null, settings2.jsonEditor.indentation);
    newContent = this.addLeftIndentIntoContent(text, newContent, start - 1);
    return text.substring(0, start) + newContent + text.substring(end + 1);
  }
  addLeftIndentIntoContent(text, content, index) {
    if (index <= 0) return content;
    let indent = "";
    while (index > 0 && (text[index] === " " || text[index] === "	")) {
      indent += text[index];
      index--;
    }
    if (!indent) return content;
    const lines = content.split("\n");
    for (let i = 1; i < lines.length; i++) {
      lines[i] = indent + lines[i];
    }
    return lines.join("\n");
  }
};
var SurveyTextWorkerJsonUnknownPropertyErrorFixer = class extends SurveyTextWorkerJsonErrorFixer {
  constructor(element, jsonObj, propertyName) {
    super(element, jsonObj);
    this.element = element;
    this.jsonObj = jsonObj;
    this.propertyName = propertyName;
  }
  getCorrectAt(text, at, end) {
    const propName = this.propertyName;
    if (!propName) return at;
    return this.getNewIndex(text, this.propertyName, at, end);
  }
};
var SurveyTextWorkerJsonArrayPropertyErrorFixer = class extends SurveyTextWorkerJsonUnknownPropertyErrorFixer {
  constructor(element, jsonObj, propertyName) {
    super(element, jsonObj, propertyName);
    this.element = element;
    this.jsonObj = jsonObj;
    this.propertyName = propertyName;
  }
  get isFixable() {
    return true;
  }
  updatedJsonObjOnFix(json2) {
    const obj = json2[this.propertyName];
    if (obj && !Array.isArray(obj)) {
      json2[this.propertyName] = [obj];
    }
  }
};
var SurveyTextWorkerJsonDuplicateNameErrorFixer = class extends SurveyTextWorkerJsonErrorFixer {
  get isFixable() {
    return true;
  }
  getCorrectAt(text, at, end) {
    let newAt = this.getNewIndex(text, "name:", at, end);
    if (newAt > at) return newAt;
    return this.getNewIndex(text, '"name":', at, end);
  }
  updatedJsonObjOnFix(json2) {
    var _a;
    const el = this.element;
    if ((_a = el.survey) === null || _a === void 0 ? void 0 : _a.runEndLoadingFromJson) {
      el.survey.runEndLoadingFromJson();
    }
    json2["name"] = SurveyHelper.getNewElementName(el);
  }
};
var SurveyTextWorkerJsonRequiredPropertyErrorFixer = class extends SurveyTextWorkerJsonErrorFixer {
  constructor(element, jsonObj, propertyName) {
    super(element, jsonObj);
    this.element = element;
    this.jsonObj = jsonObj;
    this.propertyName = propertyName;
  }
  get isFixable() {
    return this.propertyName === "name";
  }
  updatedJsonObjOnFix(json2) {
    let name = this.element["name"];
    if (!name) name = SurveyHelper.getNewElementName(this.element);
    json2["name"] = name;
  }
};
var SurveyTextWorkerJsonError = class extends SurveyTextWorkerError {
  constructor(jsonError) {
    super(jsonError.at, jsonError.getFullDescription());
    this.elementStart = jsonError.at;
    this.elementEnd = jsonError.end;
    this.element = jsonError.element;
    this.errorType = jsonError.type;
    this.propertyName = jsonError["propertyName"];
    this.jsonObj = jsonError.jsonObj;
  }
  createFixer() {
    if (this.errorType === "unknownproperty") return new SurveyTextWorkerJsonUnknownPropertyErrorFixer(this.element, this.jsonObj, this.propertyName);
    if (this.errorType === "arrayproperty") return new SurveyTextWorkerJsonArrayPropertyErrorFixer(this.element, this.jsonObj, this.propertyName);
    if (this.errorType === "duplicatename") return new SurveyTextWorkerJsonDuplicateNameErrorFixer(this.element, this.jsonObj);
    if (this.errorType === "requiredproperty") return new SurveyTextWorkerJsonRequiredPropertyErrorFixer(this.element, this.jsonObj, this.propertyName);
    return super.createFixer();
  }
  getErrorType() {
    return this.errorType;
  }
  get isFixable() {
    return this.fixer.isFixable && this.elementStart > -1 && this.elementEnd > this.elementStart;
  }
  correctAt(text) {
    const newAt = this.fixer.getCorrectAt(text, this.at, this.elementEnd);
    if (newAt > -1) {
      this.at = newAt;
    }
  }
  fixError(text) {
    return this.fixer.fixError(text, this.elementStart, this.elementEnd);
  }
};
var SurveyTextWorker = class _SurveyTextWorker {
  constructor(text) {
    this.text = text;
    if (!this.text || this.text.trim() == "") {
      this.text = "{}";
    }
    this.errors = [];
    this.process();
  }
  get survey() {
    return this.surveyValue;
  }
  get isJsonCorrect() {
    return !!this.surveyValue;
  }
  get isJsonHasErrors() {
    return this.errors.length > 0 || !this.isJsonCorrect;
  }
  process() {
    try {
      this.jsonValue = new SurveyJSON5(1).parse(this.text);
    } catch (error) {
      this.errors.push(new SurveyTextWorkerParserError(error.at, error.message));
    }
    if (this.jsonValue != null) {
      this.updateJsonPositions(this.jsonValue);
      if (!!_SurveyTextWorker.onProcessJson) {
        _SurveyTextWorker.onProcessJson(this.jsonValue);
      }
      this.surveyValue = new SurveyForTextWorker(this.jsonValue);
      const jsonErrors = this.surveyValue.jsonErrors;
      if (Array.isArray(jsonErrors)) {
        for (var i = 0; i < jsonErrors.length; i++) {
          const error = new SurveyTextWorkerJsonError(jsonErrors[i]);
          error.correctAt(this.text);
          this.errors.push(error);
        }
      }
      this.getDuplicatedNamesErrors().forEach((error) => this.errors.push(error));
    }
    this.setErrorsPositionByChartAt();
  }
  updateJsonPositions(jsonObj) {
    jsonObj["pos"]["self"] = jsonObj;
    for (var key in jsonObj) {
      var obj = jsonObj[key];
      if (obj && obj["pos"]) {
        jsonObj["pos"][key] = obj["pos"];
        this.updateJsonPositions(obj);
      }
    }
  }
  setErrorsPositionByChartAt() {
    if (this.errors.length === 0) return;
    this.errors.sort((el1, el2) => {
      if (el1.at > el2.at) return 1;
      if (el1.at < el2.at) return -1;
      return 0;
    });
    var position = {
      row: 0,
      column: 0
    };
    var startAt = 0;
    for (var i = 0; i < this.errors.length; i++) {
      let at = this.errors[i].at;
      position = this.getPostionByChartAt(position, startAt, at);
      var error = this.errors[i];
      if (at == error.at) {
        error.columnAt = position.column;
        error.rowAt = position.row;
      }
      startAt = at;
    }
  }
  getPostionByChartAt(startPosition, startAt, at) {
    var result = {
      row: startPosition.row,
      column: startPosition.column
    };
    var curChar = startAt;
    while (curChar < at) {
      if (this.text.charAt(curChar) == _SurveyTextWorker.newLineChar) {
        result.row++;
        result.column = 0;
      } else {
        result.column++;
      }
      curChar++;
    }
    return result;
  }
  getDuplicatedNamesErrors() {
    const res = [];
    this.getDuplicatedElements().forEach((el) => {
      const error = new SurveyTextWorkerJsonError(this.createDuplicatedError(el));
      error.correctAt(this.text);
      if (error) res.push(error);
    });
    return res;
  }
  getDuplicatedElements() {
    const res = [];
    const names = {};
    this.survey.pages.forEach((p) => this.checkDuplicatedElement(p, names, res));
    SurveyHelper.getAllElements(this.survey, true).forEach((p) => this.checkDuplicatedElement(p, names, res));
    SurveyHelper.getAllElements(this.survey, false).forEach((q) => this.checkDuplicatedElement(q, names, res));
    return res;
  }
  checkDuplicatedElement(el, names, duplicates) {
    const name = el["name"];
    if (names[name]) {
      duplicates.push(el);
    } else {
      names[name] = true;
    }
  }
  createDuplicatedError(el) {
    const pos = el["pos"];
    if (!pos) return void 0;
    const error = new JsonError("duplicatename", "The name: '" + el["name"] + "' is duplicated.");
    error.at = pos.start;
    error.end = pos.end;
    error.element = el;
    return error;
  }
};
SurveyTextWorker.newLineChar = "\n";
var JsonDuplicateNameError = class extends JsonError {
  constructor(el) {
    super("duplicatename", "The name: '" + el["name"] + "' is duplicated.");
    this.element = el;
  }
};
var SearchManager = class extends Base {
  get filterStringPlaceholder() {
    return this.getFilterStringPlaceholder();
  }
  getSearchActions() {
    return [new Action({
      id: "svd-grid-search-close",
      iconName: "icon-clear_16x16",
      component: "sv-action-bar-item",
      title: getLocString("ed.clear"),
      showTitle: false,
      iconSize: "auto",
      disableTabStop: true,
      innerCss: "svc-search__bar-item",
      visible: new ComputedUpdater(() => !!this.filterString),
      action: () => {
        this.clearFilterString();
      }
    })];
  }
  initActionBar() {
    this.searchActionBar.setItems(this.getSearchActions());
  }
  clearFilterString() {
    this.filterString = "";
  }
  onPropertyValueChanged(name, oldValue, newValue) {
    super.onPropertyValueChanged(name, oldValue, newValue);
    if (name === "filterString") {
      this.setFiterString(newValue, oldValue);
    }
  }
  constructor() {
    super();
    this.searchActionBar = new ActionContainer();
    this.initActionBar();
  }
  dispose() {
    this.searchActionBar.dispose();
    super.dispose();
  }
};
__decorate2([property()], SearchManager.prototype, "filterString", void 0);
__decorate2([property()], SearchManager.prototype, "isVisible", void 0);
__decorate2([property()], SearchManager.prototype, "matchCounterText", void 0);
var SearchManagerToolbox = class extends SearchManager {
  getFilterStringPlaceholder() {
    return getLocString("ed.toolboxFilteredTextPlaceholder");
  }
  setFiterString(newValue, oldValue) {
    this.toolbox.showSeparators = !newValue;
    this.toolbox.items.forEach((item) => item.visible = item.hasText(newValue));
    this.toolbox.showPlaceholder = !this.toolbox.items.filter((i) => i.visible).length;
    this.toolbox.categories.forEach((category) => {
      category.forceExpand = !!newValue;
      category.empty = category.items.filter((item) => item.visible).length == 0;
    });
  }
  clearFilterString() {
    this.filterString = "";
    this.toolbox.rootElement.querySelector("input").focus();
  }
};
__decorate2([property()], SearchManagerToolbox.prototype, "toolbox", void 0);
var listComponentCss = {
  root: "svc-list__container",
  itemsContainer: "svc-list",
  itemsContainerFiltering: "svc-list--filtering",
  emptyContainer: "svc-list__empty-container",
  emptyText: "svc-list__empty-text",
  filter: "svc-list__filter",
  filterIcon: "svc-list__filter-icon",
  filterInput: "svc-list__input",
  searchClearButtonIcon: "svc-list__filter-clear-button",
  loadingIndicator: "svc-list__loading-indicator",
  item: "svc-list__item",
  itemSelected: "svc-list__item--selected",
  itemGroup: "svc-list__item--group",
  itemGroupSelected: "svc-list__item--group-selected",
  itemWithIcon: "svc-list__item--with-icon",
  itemDisabled: "svc-list__item--disabled",
  itemFocused: "svc-list__item--focused",
  itemHovered: "svc-list__item--hovered",
  itemTextWrap: "svc-list__item-text--wrap",
  itemIcon: "svc-list__item-icon",
  itemMarkerIcon: "svc-list-item__marker-icon",
  itemSeparator: "svc-list__item-separator",
  itemBody: "svc-list__item-body"
};
var QuestionToolboxCategory = class extends Base {
  constructor(toolbox) {
    super();
    this.toolbox = toolbox;
  }
  get collapsed() {
    return !this.forceExpand && this.collapsedValue;
  }
  set collapsed(val) {
    this.collapsedValue = val;
  }
  toggleState() {
    if (this.toolbox) {
      this.toolbox.toggleCategoryState(this.name);
    }
  }
};
__decorate2([property()], QuestionToolboxCategory.prototype, "name", void 0);
__decorate2([property()], QuestionToolboxCategory.prototype, "title", void 0);
__decorate2([propertyArray()], QuestionToolboxCategory.prototype, "items", void 0);
__decorate2([property({
  defaultValue: false
})], QuestionToolboxCategory.prototype, "collapsedValue", void 0);
__decorate2([property({
  defaultValue: false
})], QuestionToolboxCategory.prototype, "forceExpand", void 0);
__decorate2([property()], QuestionToolboxCategory.prototype, "empty", void 0);
var QuestionToolboxItem = class _QuestionToolboxItem extends Action {
  static getItemClassNames(iconName) {
    return new CssClassBuilder().append("svc-toolbox__item").append("svc-toolbox__item--has-icon", !!iconName).append("svc-toolbox__item--" + iconName, !!iconName).toString();
  }
  constructor(item) {
    super(item);
    this.item = item;
    if (!this.id) {
      this.id = this.name;
    }
    const originalCss = this.css;
    this.css = new ComputedUpdater(() => {
      var _a;
      return new CssClassBuilder().append("svc-toolbox__tool").append("svc-toolbox__tool--action").append(originalCss).append("svc-toolbox__tool--pressed", this.isPressed).append("svc-toolbox__tool--has-icon", !!this.iconName).append("svc-toolbox__tool--has-subitems", !!(((_a = this.items) === null || _a === void 0 ? void 0 : _a.length) > 0)).append("svc-toolbox__tool--disabled", this.enabled === false).append("sv-action--hidden", !this.isVisible).toString();
    });
  }
  /**
   * A user-friendly toolbox item title.
   */
  get title() {
    return this.getTitle();
  }
  set title(val) {
    this.setTitle(val);
  }
  /**
   * Specifies whether users can interact with the toolbox item.
   *
   * Default value: `true`
   */
  get enabled() {
    return this.getEnabled();
  }
  set enabled(val) {
    this.setEnabled(val);
  }
  get renderedCss() {
    return new CssClassBuilder().append("svc-toolbox__item").append(this.className).append("svc-toolbox__item--has-subitems", this.hasSubItems).toString();
  }
  toJSON() {
    return this.item;
  }
  get typeName() {
    if (!!this.json && !!this.json.type) return this.json.type;
    return this.name;
  }
  get isPanel() {
    const type = this.typeName;
    return !!type && Serializer.isDescendantOf(type, "panelbase");
  }
  getArea(target) {
    return target.closest("#scrollableDiv-designer");
  }
  hasText(text) {
    if (!text) return;
    const textLowerCase = text.toLowerCase();
    return this.title.toLowerCase().indexOf(textLowerCase) >= 0 || this.name.toLowerCase().indexOf(textLowerCase) >= 0;
  }
  /**
   * Finds a subitem with a specified name in the collection of subitems belonging to this toolbox item.
   *
   * [Manage Toolbox Subitems](https://surveyjs.io/survey-creator/documentation/toolbox-customization#manage-toolbox-subitems (linkStyle))
   * @param name A subitem [`name`](https://surveyjs.io/survey-creator/documentation/api-reference/iquestiontoolboxitem#name).
   * @returns A [`QuestionToolboxItem`](https://surveyjs.io/survey-creator/documentation/api-reference/questiontoolboxitem) object that represents the subitem instance.
   */
  getSubitem(name) {
    var _a;
    return (_a = this.items) === null || _a === void 0 ? void 0 : _a.filter((i) => i.id === name)[0];
  }
  addSubitems(items) {
    if (!items || items.length < 1) return;
    this.setSubItems({
      items
    });
    this.popupModel.getAreaCallback = this.getArea;
    this.component = QuestionToolbox.defaultItemGroupComponent;
  }
  /**
   * Removes all subitems from this toolbox item.
   *
   * [Manage Toolbox Subitems](https://surveyjs.io/survey-creator/documentation/toolbox-customization#manage-toolbox-subitems (linkStyle))
   * @see removeSubitem
   * @see addSubitem
   */
  clearSubitems() {
    if (this.hasSubItems) {
      this.items = [];
      this.component = "";
      this.popupModel.dispose();
    }
  }
  /**
   * Adds a subitem to this toolbox item.
   *
   * [Manage Toolbox Subitems](https://surveyjs.io/survey-creator/documentation/toolbox-customization#manage-toolbox-subitems (linkStyle))
   * @param subitem An [`IQuestionToolboxItem`](https://surveyjs.io/survey-creator/documentation/api-reference/iquestiontoolboxitem) object that represents a subitem configuration.
   * @param index *(Optional)* A zero-based index at which to insert the subitem. If you do not specify this parameter, the subitem is added to the end.
   * @see removeSubitem
   * @see clearSubitems
   */
  addSubitem(subitem, index = -1) {
    if (!subitem) return;
    const newItem = new _QuestionToolboxItem(subitem);
    newItem.iconName = "";
    if (!newItem.className) newItem.className = _QuestionToolboxItem.getItemClassNames(newItem.iconName);
    newItem.className = new CssClassBuilder().append(newItem.className).append("svc-toolbox__item-subtype").toString();
    let array = (this.items || []).slice();
    if (index === -1) {
      array.push(newItem);
    } else {
      array.splice(index, 0, newItem);
    }
    this.addSubitems(array);
  }
  /**
   * Removes a specific subitem from this toolbox item.
   *
   * [Manage Toolbox Subitems](https://surveyjs.io/survey-creator/documentation/toolbox-customization#manage-toolbox-subitems (linkStyle))
   * @param subitem A subitem [`name`](https://surveyjs.io/survey-creator/documentation/api-reference/iquestiontoolboxitem#name) or an [`IQuestionToolboxItem`](https://surveyjs.io/survey-creator/documentation/api-reference/iquestiontoolboxitem) object that represents a subitem configuration.
   * @see clearSubitems
   * @see addSubitem
   */
  removeSubitem(subitem) {
    if (!this.hasSubItems || !subitem) return;
    const id = (subitem === null || subitem === void 0 ? void 0 : subitem.id) || subitem;
    if (!id) return;
    const removedItem = this.getSubitem(id);
    let array = (this.items || []).slice();
    const removedIndex = array.indexOf(removedItem);
    if (removedIndex > -1) {
      array.splice(removedIndex, 1);
    }
    if (array.length == 0) {
      this.clearSubitems();
    } else {
      this.addSubitems(array);
    }
  }
  get subitemsButtonIcon() {
    return "icon-next_16x16";
  }
};
var QuestionToolbox = class _QuestionToolbox extends AdaptiveActionContainer {
  get itemSelector() {
    return ".svc-toolbox__category>.svc-toolbox__tool--action";
  }
  get containerSelector() {
    return ".svc-scroll__scroller";
  }
  static getQuestionDefaultSettings(questionType2) {
    if (!settings2.toolbox || !settings2.toolbox.defaultJSON) return void 0;
    return settings2.toolbox.defaultJSON[questionType2];
  }
  static getSubTypePropertyName(questionType2) {
    let propertyName = "";
    if (questionType2 === "text") propertyName = "inputType";
    if (questionType2 === "rating") propertyName = "rateType";
    return propertyName;
  }
  get orderedQuestions() {
    return this._orderedQuestions;
  }
  set orderedQuestions(questions) {
    this._orderedQuestions = questions;
    this.reorderItems();
  }
  get toolboxNoResultsFound() {
    return getLocString("ed.toolboxNoResultsFound");
  }
  updateResponsiveness(isCompact, overflowBehavior) {
    if (overflowBehavior == "scroll" && this.creator && !this.creator.isTouch || this.creator && this.creator.toolboxLocation === "sidebar") {
      this.isResponsivenessDisabled = true;
      this.updateCallback && this.updateCallback(true);
      return;
    }
    if (this.hasCategories && this.showCategoryTitles) {
      if (isCompact) {
        this.isResponsivenessDisabled = false;
        this.raiseUpdate(true);
      } else {
        this.isResponsivenessDisabled = true;
        this.setActionsMode("large");
      }
      return;
    }
    this.isResponsivenessDisabled = false;
    this.raiseUpdate(true);
  }
  getAnimationOptions() {
    const onBeforeRunAnimation = (el) => {
      el.style.setProperty("--animation-width", getComputedStyle(el).width);
    };
    return {
      getAnimatedElement: () => {
        var _a;
        return (_a = this.rootElement) === null || _a === void 0 ? void 0 : _a.querySelector(".svc-toolbox__panel");
      },
      isAnimationEnabled: () => this.animationAllowed,
      getRerenderEvent: () => this.onElementRerendered,
      getLeaveOptions: () => {
        return {
          cssClass: "svc-toolbox__panel--leave",
          onAfterRunAnimation: () => {
            this.isFlyoutToCompactRunning = false;
          },
          onBeforeRunAnimation
        };
      },
      getEnterOptions: () => {
        return {
          cssClass: "svc-toolbox__panel--enter",
          onBeforeRunAnimation
        };
      }
    };
  }
  constructor(supportedQuestions = null, creator = null, useDefaultCategories = false) {
    super();
    this.supportedQuestions = supportedQuestions;
    this.creator = creator;
    this._orderedQuestions = ["radiogroup", "rating", "checkbox", "dropdown", "tagbox", "boolean", "file", "imagepicker", "ranking", "text", "comment", "multipletext", "panel", "paneldynamic", "matrix", "matrixdropdown", "matrixdynamic", "html", "expression", "image", "signaturepad"];
    this.copiedItemMaxCount = 3;
    this.allowExpandMultipleCategoriesValue = false;
    this.keepAllCategoriesExpandedValue = false;
    this.compactAnimation = new AnimationBoolean(this.getAnimationOptions(), (val) => {
      this.isCompactRendered = !val;
    }, () => !this.isCompactRendered);
    this.categoriesTitles = {};
    this.searchManager = new SearchManagerToolbox();
    this.subItemsShowDelay = 0;
    this.searchManager.isVisible = this.searchEnabled;
    this.searchManager.toolbox = this;
    this.searchItem = new Action({
      id: "searchItem-id",
      css: "svc-toolbox__tool svc-toolbox__search-button",
      innerCss: "svc-toolbox__item sv-dots__item",
      iconName: "icon-search",
      iconSize: "auto",
      component: "sv-action-bar-item",
      tooltip: surveyLocalization.getString("search"),
      action: () => {
        this.rootElement.querySelector("input").focus();
        this.isFocused = true;
      }
    });
    this.updateResponsiveness(this.isCompact, this.overflowBehavior);
    this.createDefaultItems(supportedQuestions, useDefaultCategories);
    this.initDotsItem();
  }
  initDotsItem() {
    this.dotsItem.innerCss = "svc-toolbox__item svc-toolbox__item--dots sv-dots__item";
    this.dotsItem.css = new ComputedUpdater(() => {
      return new CssClassBuilder().append("svc-toolbox__tool svc-toolbox__tool--dots").append("sv-action--hidden", !this.dotsItem.isVisible).toString();
    });
    this.dotsItem.popupModel.horizontalPosition = "right";
    this.dotsItem.popupModel.verticalPosition = "top";
    this.dragOrClickHelper = new DragOrClickHelper((pointerDownEvent, currentTarget, itemModel) => {
      var _a;
      const json2 = this.creator.getJSONForNewElement(itemModel.json);
      this.dotsItem.popupModel.hide();
      (_a = this.creator) === null || _a === void 0 ? void 0 : _a.onDragDropItemStart();
      this.dragDropHelper.startDragToolboxItem(pointerDownEvent, json2, itemModel);
    });
    this.hiddenItemsListModel.onPointerDown = (pointerDownEvent, item) => {
      if (!this.creator.readOnly) {
        this.dragOrClickHelper.onPointerDown(pointerDownEvent, item);
      }
    };
    this.dotsItem.popupModel.cssClass += " svc-toolbox-popup svc-creator-popup";
    this.hiddenItemsListModel.cssClasses = listComponentCss;
  }
  getDefaultQuestionCategories() {
    const questionCategoryMap = {};
    Object.keys(_QuestionToolbox.defaultCategories).forEach((key) => {
      const cat = _QuestionToolbox.defaultCategories[key];
      cat.forEach((name) => {
        if (!this.supportedQuestions || this.supportedQuestions.indexOf(name) != -1) {
          questionCategoryMap[name] = key;
        }
      });
    });
    return questionCategoryMap;
  }
  getCategoryTitle(name) {
    if (this.categoriesTitles[name]) return this.categoriesTitles[name];
    return getLocString("toolboxCategories." + name);
  }
  onActiveCategoryChanged(newValue) {
    const categories = this.categories;
    for (var i = 0; i < categories.length; i++) {
      var category = categories[i];
      category.collapsed = category.name !== newValue;
    }
  }
  get showSearch() {
    return this.searchEnabled && this.items.length > _QuestionToolbox.MINELEMENTCOUNT;
  }
  get showInSingleCategory() {
    return this.isCompactRendered || this.categories.length == 1 || !this.showCategoryTitles;
  }
  setRootElement(element) {
    this._rootElementValue = element;
    this._containerElementValue = element === null || element === void 0 ? void 0 : element.querySelector(this.containerSelector);
  }
  get containerElement() {
    return this._containerElementValue;
  }
  get rootElement() {
    return this._rootElementValue;
  }
  focusOut(e) {
    if (e.relatedTarget !== e.currentTarget && !e.currentTarget.contains(e.relatedTarget)) {
      this.isFocused = false;
      this.searchManager.filterString = "";
    }
  }
  get classNames() {
    return new CssClassBuilder().append("svc-toolbox").append("svc-toolbox--searchable", this.searchEnabled).append("svc-toolbox--no-separators", !this.showSeparators).append("svc-toolbox--flyout-to-compact-running", this.isFlyoutToCompactRunning).append("svc-toolbox--compact", this.isCompactRendered).append("svc-toolbox--flyout", this.isCompact && this.isFocused).append("svc-toolbox--scrollable", this.overflowBehavior == "scroll").toString();
  }
  setLocation(toolboxLocation) {
    if (toolboxLocation === "sidebar") {
      this.visibleActions.forEach((item) => item.mode = "small");
    } else {
      this.dotsItem.popupModel.horizontalPosition = this.creator.toolboxLocation == "right" ? "left" : "right";
    }
    this.updateResponsiveness(this.isCompact, this.overflowBehavior);
  }
  get jsonText() {
    return JSON.stringify(this.actions);
  }
  set jsonText(value) {
    this.actions = (value ? JSON.parse(value) : []).map((action) => new QuestionToolboxItem(action));
    this.onItemsChanged();
  }
  get copiedJsonText() {
    return JSON.stringify(this.copiedItems);
  }
  set copiedJsonText(value) {
    var newItems = value ? JSON.parse(value) : [];
    this.clearCopiedItems();
    for (let i = 0; i < newItems.length; i++) {
      newItems[i].isCopied = true;
      this.addItem(newItems[i]);
    }
  }
  /**
   * An array of toolbox items.
   * @see getItemByName
   * @see addItem
   * @see removeItem
   */
  get items() {
    return this.actions;
  }
  get itemNames() {
    const res = [];
    for (let i = 0; i < this.items.length; i++) {
      res.push(this.items[i].typeName);
    }
    return res;
  }
  get copiedItems() {
    const result = [];
    for (let i = 0; i < this.actions.length; i++) {
      if (this.actions[i].isCopied) result.push(this.actions[i]);
    }
    return result;
  }
  addItems(items, clearAll = false) {
    if (clearAll) {
      this.clearItems();
    }
    for (let i = 0; i < items.length; i++) {
      this.actions.push(this.getOrCreateToolboxItem(items[i]));
    }
    this.onItemsChanged();
  }
  addCopiedItem(question, options = null) {
    if (!options) options = {};
    const name = !!options.name ? options.name : question.name;
    const title = !!options.title ? options.title : name;
    const tooltip = !!options.tooltip ? options.tooltip : title;
    const iconName = !!options.iconName ? options.iconName : _QuestionToolbox.defaultIconName;
    const item = {
      id: name,
      name,
      title,
      tooltip,
      className: QuestionToolboxItem.getItemClassNames(iconName),
      isCopied: options.isCopied !== false,
      iconName,
      json: !!options.json ? options.json : this.getQuestionJSON(question),
      category: !!options.category ? options.category : ""
    };
    if (this.replaceItem(item)) return;
    const copied = this.copiedItems;
    if (this.copiedItemMaxCount > 0 && copied.length == this.copiedItemMaxCount) this.removeItem(copied[this.copiedItemMaxCount - 1].name);
    this.addItem(item);
  }
  getOrCreateToolboxItem(item) {
    if (item instanceof QuestionToolboxItem) {
      return item;
    } else {
      item.iconName = item.iconName ? item.iconName : _QuestionToolbox.defaultIconName;
      const newItem = new QuestionToolboxItem(item);
      this.createSubTypes(newItem);
      return newItem;
    }
  }
  createSubTypes(parentItem) {
    let property2 = null;
    const propName = _QuestionToolbox.getSubTypePropertyName(parentItem.id);
    if (propName) property2 = Serializer.findProperty(parentItem.id, propName);
    if (!property2 || !property2.visible) return;
    const newItems = property2.choices.map((ch) => {
      const newJson = Object.assign({}, parentItem.json);
      newJson[propName] = ch;
      const newId = parentItem.id != ch ? ch : parentItem.id + "-default";
      const innerItem = new QuestionToolboxItem({
        id: newId,
        name: newId,
        title: editorLocalization.getPropertyValueInEditor(propName, ch),
        className: QuestionToolboxItem.getItemClassNames() + " svc-toolbox__item-subtype",
        json: newJson,
        iconName: null,
        category: null,
        isCopied: false,
        component: _QuestionToolbox.defaultItemComponent
      });
      innerItem.propName = propName;
      innerItem.propValue = ch;
      return innerItem;
    });
    if (newItems) {
      parentItem.addSubitems(newItems);
    }
  }
  /**
   * Adds a new item to the Toolbox.
   * @param item A [toolbox item configuration](https://surveyjs.io/survey-creator/documentation/api-reference/iquestiontoolboxitem).
   * @param index *(Optional)* A zero-based index at which to insert the item. If you do not specify this parameter, the item is added to the end.
   * @see removeItem
   * @see replaceItem
   * @see items
   */
  addItem(item, index) {
    this.correctItem(item);
    const action = this.getOrCreateToolboxItem(item);
    if (index === void 0) {
      this.actions.push(action);
    } else {
      this.actions.splice(index, 0, action);
    }
    this.onItemsChanged();
  }
  correctItem(item) {
    if (!item.title) item.title = item.name;
    if (!item.tooltip) item.tooltip = item.title;
  }
  get dragDropHelper() {
    return this.creator.dragDropSurveyElements;
  }
  /**
   * Adds a new toolbox item and deletes an existing item with the same name (if there is any).
   * @param item A [toolbox item configuration](https://surveyjs.io/survey-creator/documentation/api-reference/iquestiontoolboxitem).
   * @see addItem
   */
  replaceItem(item) {
    this.correctItem(item);
    const index = this.indexOf(item.name);
    if (index < 0) return;
    this.actions[index] = this.getOrCreateToolboxItem(item);
    this.onItemsChanged();
    return true;
  }
  /**
   * Removes a [toolbox item](https://surveyjs.io/survey-creator/documentation/api-reference/iquestiontoolboxitem) with a specified name.
   * @param name A toolbox item's [`name`](https://surveyjs.io/survey-creator/documentation/api-reference/iquestiontoolboxitem#name).
   * @returns `true` if the item is successfully deleted or `false` otherwise.
   * @see clearItems
   * @see addItem
   * @see items
   */
  removeItem(name) {
    const index = this.indexOf(name);
    if (index < 0) return false;
    this.actions.splice(index, 1);
    this.onItemsChanged();
    return true;
  }
  /**
   * Removes all items from the Toolbox.
   * @see removeItem
   * @see addItem
   * @see items
   */
  clearItems() {
    this.actions = [];
    this.onItemsChanged();
  }
  clearCopiedItems() {
    const removedItems = this.copiedItems;
    for (let i = 0; i < removedItems.length; i++) {
      this.removeItem(removedItems[i].name);
    }
  }
  /**
   * Returns a [toolbox item](https://surveyjs.io/survey-creator/documentation/api-reference/questiontoolboxitem) with a specified name.
   * @param name A toolbox item's [`name`](https://surveyjs.io/survey-creator/documentation/api-reference/iquestiontoolboxitem#name).
   * @returns A toolbox item or `null` if a toolbox item with the specified name isn't found.
   */
  getItemByName(name) {
    if (!name) return null;
    const index = this.indexOf(name);
    return index > -1 ? this.actions[index] : null;
  }
  /**
   * Specifies whether more than one category can be in the expanded state at a time. Applies only if [`showCategoryTitles`](https://surveyjs.io/survey-creator/documentation/api-reference/questiontoolbox#showCategoryTitles) is `true`.
   *
   * If this property is `false`, the currently expanded category collapses when a user expands another category.
   *
   * Default value: `false`
   * @see keepAllCategoriesExpanded
   */
  get allowExpandMultipleCategories() {
    return this.allowExpandMultipleCategoriesValue;
  }
  set allowExpandMultipleCategories(val) {
    this.allowExpandMultipleCategoriesValue = val;
    this.updateCategoriesState();
  }
  /**
   * Specifies whether to expand all categories without the capability to collapse any of them. Applies only if [`showCategoryTitles`](https://surveyjs.io/survey-creator/documentation/api-reference/questiontoolbox#showCategoryTitles) is `true`.
   * @see allowExpandMultipleCategories
   */
  get keepAllCategoriesExpanded() {
    return this.keepAllCategoriesExpandedValue || !this.showCategoryTitlesValue;
  }
  set keepAllCategoriesExpanded(val) {
    this.keepAllCategoriesExpandedValue = val;
    this.canCollapseCategories = !this.keepAllCategoriesExpanded;
    this.updateCategoriesState();
  }
  /**
   * Specifies whether to display category titles in the Toolbox.
   *
   * Default value: `false`
   *
   * If this property is disabled, the Toolbox hides the titles but continues to display horizontal lines that divide categories. To remove these lines as well, call the [`removeCategories()`](https://surveyjs.io/survey-creator/documentation/api-reference/questiontoolbox#removeCategories) method.
   * @see allowExpandMultipleCategories
   * @see keepAllCategoriesExpanded
   */
  get showCategoryTitles() {
    return this.showCategoryTitlesValue;
  }
  set showCategoryTitles(val) {
    this.showCategoryTitlesValue = val;
    this.updateCategoriesState();
  }
  updateTitles() {
    this.actions.forEach((action) => {
      this.updateToolboxItemTitle(action);
    });
    if (Array.isArray(this.categories)) {
      this.categories.forEach((category) => {
        category.title = this.getCategoryTitle(category.name);
      });
    }
  }
  updateToolboxItemTitle(item) {
    this.updateActionTitle(item);
    this.updateActionTitle(item.innerItem);
    if (!Array.isArray(item.items)) return;
    item.items.forEach((subItem) => {
      const propName = subItem.propName;
      const propValue = subItem.propValue;
      if (!!propName && !!propValue) {
        subItem.title = editorLocalization.getPropertyValueInEditor(propName, propValue);
      }
    });
  }
  updateActionTitle(action) {
    const newTitle = editorLocalization.getString("qt." + action.id);
    if (!!newTitle && newTitle !== action.id) {
      action.title = newTitle;
      action.tooltip = newTitle;
    }
  }
  updateCategoriesState() {
    var noActive = this.allowExpandMultipleCategories || this.keepAllCategoriesExpanded;
    if (noActive) {
      this.activeCategory = "";
      if (this.keepAllCategoriesExpandedValue) {
        this.expandAllCategories();
      }
    } else {
      if (this.categories.length > 0) {
        this.activeCategory = this.categories[0].name;
      }
    }
  }
  /**
   * Changes the category of a toolbox item.
   * @param itemName A toolbox item's [`name`](https://surveyjs.io/survey-creator/documentation/api-reference/iquestiontoolboxitem#name).
   * @param categoryName A new category name. Out-of-the-box category names include `"general"`, `"choice"`, `"text"`, `"containers"`, `"matrix"`, and `"misc"`.
   * @see defineCategories
   */
  changeCategory(itemName, categoryName) {
    this.changeCategories([{
      name: itemName,
      category: categoryName
    }]);
  }
  /**
   * Changes the categories of multiple toolbox items.
   * @param items An array of objects with the following structure: `{ name: "toolboxItemName", category: "newCategoryName" }`.
   * @see defineCategories
   */
  changeCategories(items) {
    for (var i = 0; i < items.length; i++) {
      var item = items[i];
      var toolboxItem = this.getItemByName(item.name);
      if (toolboxItem) {
        toolboxItem.category = item.category;
      }
    }
    this.onItemsChanged();
  }
  /**
   * Defines toolbox categories from scratch.
   *
   * This method accepts an array of objects as the `categories` parameter. Each object defines a single category and lists items included into it. Unlisted items can be collected in the Misc category if you pass `true` as the `displayMisc` parameter. Optionally, you can override display titles for individual items.
   *
   * The following code defines two toolbox categories: Dropdowns and Text Input. Items that do not fall into either category are collected in Misc. The `"comment"` item has a custom display title.
   *
   * ```
   * creator.toolbox.defineCategories([{
   *   category: "Dropdowns",
   *   items: [
   *     "dropdown",
   *     "tagbox"
   *   ]
   * }, {
   *   category: "Text Input",
   *   items: [
   *     "text",
   *     // Override the display title
   *     { name: "comment", title: "Multi-Line Input" }
   *   ]
   * }], true);
   * ```
   *
   * [View Demo](https://surveyjs.io/survey-creator/examples/survey-toolbox-categories/ (linkStyle))
   * @param categories An array of new categories.
   * @param displayMisc Pass `true` if you want to collect unlisted toolbox items in the Misc category. Default value: `false`.
   */
  defineCategories(categories, displayMisc = false) {
    if (!Array.isArray(categories)) return;
    const items = this.getDefaultItems(this.supportedQuestions, false, true, true);
    const itemsHash = {};
    items.forEach((item) => {
      item.visible = false;
      itemsHash[item.id] = item;
    });
    if (Array.isArray(this.presetDefaultItems)) {
      this.presetDefaultItems.forEach((item) => {
        const action = itemsHash[item.name];
        if (action) {
          for (let key in item) {
            action[key] = item[key];
          }
        } else {
          if (!!item.json) {
            const tItem = new QuestionToolboxItem(item);
            itemsHash[tItem.id] = tItem;
            items.push(tItem);
          }
        }
      });
    }
    this.categoriesTitles = {};
    const actionList = new Array();
    categories.forEach((category) => {
      if (!!category.category && !!category.title) {
        this.categoriesTitles[category.category] = category.title;
      }
      if (!Array.isArray(category.items)) return;
      category.items.forEach((obj) => {
        let name = void 0;
        let title = void 0;
        if (typeof obj === "string") {
          name = obj;
        } else {
          name = obj.name;
          title = obj.title;
        }
        const item = itemsHash[name];
        if (item) {
          item.category = category.category;
          item.visible = true;
          if (!!title) {
            item.title = title;
          }
          actionList.push(item);
        }
      });
    });
    if (displayMisc) {
      items.forEach((item) => {
        if (!item.visible) {
          item.visible = true;
          item.category = "misc";
          actionList.push(item);
        }
      });
    }
    this.setItems(actionList);
    this.onItemsChanged(false);
  }
  /**
   * Removes all categories from the Toolbox.
   */
  removeCategories() {
    const allTypes = ElementFactory.Instance.getAllToolboxTypes();
    this.changeCategories(allTypes.map((t) => ({
      name: t,
      category: null
    })));
    this.onItemsChanged();
  }
  toggleCategoryState(categoryName) {
    if (this.keepAllCategoriesExpanded) return;
    if (this.allowExpandMultipleCategories) {
      var category = this.getCategoryByName(categoryName);
      if (category) {
        category.collapsed = !category.collapsed;
      }
    } else {
      this.activeCategory = categoryName;
    }
  }
  /**
   * Expands a category with a specified name. Applies only if [`showCategoryTitles`](https://surveyjs.io/survey-creator/documentation/api-reference/questiontoolbox#showCategoryTitles) is `true`.
   *
   * If [`allowExpandMultipleCategories`](https://surveyjs.io/survey-creator/documentation/api-reference/questiontoolbox#allowExpandMultipleCategories) is `false`, all other categories become collapsed.
   * @param categoryName A category name. Out-of-the-box category names include `"general"`, `"choice"`, `"text"`, `"containers"`, `"matrix"`, and `"misc"`.
   * @see collapseCategory
   */
  expandCategory(categoryName) {
    if (this.allowExpandMultipleCategories) {
      var category = this.getCategoryByName(categoryName);
      if (category) {
        category.collapsed = false;
      }
    } else {
      if (this.canCollapseCategories) {
        this.activeCategory = categoryName;
      }
    }
  }
  /**
   * Collapses a category with a specified name. Applies only if [`showCategoryTitles`](https://surveyjs.io/survey-creator/documentation/api-reference/questiontoolbox#showCategoryTitles) and [`allowExpandMultipleCategories`](https://surveyjs.io/survey-creator/documentation/api-reference/questiontoolbox#allowExpandMultipleCategories) are `true`.
   * @param categoryName A category name. Out-of-the-box category names include `"general"`, `"choice"`, `"text"`, `"containers"`, `"matrix"`, and `"misc"`.
   * @see expandCategory
   */
  collapseCategory(categoryName) {
    if (!this.allowExpandMultipleCategories) return;
    var category = this.getCategoryByName(categoryName);
    if (category) {
      category.collapsed = true;
    }
  }
  /**
   * Expands all categories. Applies only if [`showCategoryTitles`](https://surveyjs.io/survey-creator/documentation/api-reference/questiontoolbox#showCategoryTitles) and [`allowExpandMultipleCategories`](https://surveyjs.io/survey-creator/documentation/api-reference/questiontoolbox#allowExpandMultipleCategories) are `true`.
   * @see collapseAllCategories
   */
  expandAllCategories() {
    this.expandCollapseAllCategories(false);
  }
  /**
   * Collapses all categories. Applies only if [`showCategoryTitles`](https://surveyjs.io/survey-creator/documentation/api-reference/questiontoolbox#showCategoryTitles) and [`allowExpandMultipleCategories`](https://surveyjs.io/survey-creator/documentation/api-reference/questiontoolbox#allowExpandMultipleCategories) are `true`.
   * @see expandAllCategories
   */
  collapseAllCategories() {
    this.expandCollapseAllCategories(true);
  }
  expandCollapseAllCategories(isCollapsed) {
    const categories = this.categories;
    for (var i = 0; i < categories.length; i++) {
      categories[i].collapsed = isCollapsed;
    }
  }
  getCategoryByName(categoryName) {
    const categories = this.categories;
    for (var i = 0; i < categories.length; i++) {
      var category = categories[i];
      if (category.name === categoryName) return category;
    }
    return null;
  }
  onItemsChanged(changeActions = true) {
    var categories = new Array();
    var categoriesHash = {};
    var prevActiveCategory = this.activeCategory;
    for (let i = 0; i < this.actions.length; i++) {
      const item = this.actions[i];
      item.innerItem.action = () => {
        this.creator.clickToolboxItem(item.json);
      };
      if (item.visible === false) continue;
      const categoryName = item.category ? item.category : "general";
      if (!categoriesHash[categoryName]) {
        const category = this.createCategory();
        category.name = categoryName;
        category.title = this.getCategoryTitle(categoryName);
        category.collapsed = categoryName !== prevActiveCategory && !this.keepAllCategoriesExpanded;
        categoriesHash[categoryName] = category;
        categories.push(category);
      }
      categoriesHash[categoryName].items.push(item);
    }
    this.categories = categories;
    if (!this.keepAllCategoriesExpanded) {
      if (!this.allowExpandMultipleCategories) {
        if (prevActiveCategory && categoriesHash[prevActiveCategory]) {
          this.activeCategory = prevActiveCategory;
        } else {
          this.activeCategory = categories.length > 0 ? categories[0].name : "";
        }
      } else {
        if (categories.length > 0) {
          categories[0].collapsed = false;
        }
      }
    }
    if (changeActions) {
      let newItems = [];
      this.categories.forEach((cat) => {
        newItems = newItems.concat(cat.items);
      });
      this.actions = newItems;
    }
    this.hasCategories = categories.length > 1;
    this.updateItemSeparators();
    this.updateResponsiveness(this.isCompact, this.overflowBehavior);
  }
  createCategory() {
    return new QuestionToolboxCategory(this);
  }
  indexOf(name) {
    for (var i = 0; i < this.actions.length; i++) {
      if (this.actions[i].name == name) return i;
    }
    return -1;
  }
  updateItemSeparators() {
    const categories = this.hasCategories ? this.categories : [{
      items: this.actions
    }];
    categories.forEach((category, categoryIndex) => {
      (category.items || []).forEach((item, index) => {
        item.needSeparator = categoryIndex !== 0 && index == 0;
        if (item.innerItem) item.innerItem.needSeparator = item.needSeparator;
      });
    });
  }
  reorderItems() {
    this.actions.sort((i1, i2) => {
      var index1 = this._orderedQuestions.indexOf(i1.name);
      if (index1 === -1) index1 = Number.MAX_VALUE;
      var index2 = this._orderedQuestions.indexOf(i2.name);
      if (index2 === -1) index2 = Number.MAX_VALUE;
      return index1 - index2;
    });
    this.onItemsChanged();
  }
  /**
   * Adds default items to the Toolbox. If the Toolbox contains any items before you call this method, they will be removed.
   * @param supportedQuestions Specifies which question and panel types to include in the Toolbox.
   * @param useDefaultCategories Pass `true` if you want to create default categories.
   */
  createDefaultItems(supportedQuestions, useDefaultCategories) {
    supportedQuestions = supportedQuestions || this.supportedQuestions;
    this.clearItems();
    this.getDefaultItems(supportedQuestions, useDefaultCategories, true, true).forEach((item) => this.addToolBoxItem(item, this.actions));
    this.onItemsChanged();
  }
  getDefaultItems(supportedQuestions, useDefaultCategories, includeCustomWidgets, includeComponents) {
    let res = this.getDefaultQuestionItems(supportedQuestions, useDefaultCategories);
    if (includeCustomWidgets) {
      res = res.concat(this.getRegisterCustomWidgets());
    }
    if (includeComponents) {
      res = res.concat(this.getRegisterComponentQuestions());
    }
    return res;
  }
  getDefaultQuestionItems(supportedQuestions, useDefaultCategories) {
    const res = [];
    const questions = this.getQuestionTypes(supportedQuestions);
    const defaultCategories = useDefaultCategories ? this.getDefaultQuestionCategories() : {};
    for (var i = 0; i < questions.length; i++) {
      const name = questions[i];
      let question = ElementFactory.Instance.createElement(name, "q1");
      if (!question) {
        question = Serializer.createClass(name);
      }
      const json2 = this.getQuestionJSON(question);
      delete json2.name;
      const title = editorLocalization.getString("qt." + name);
      const iconName = "icon-" + name;
      const item = {
        id: name,
        name,
        iconName,
        title,
        tooltip: title,
        className: QuestionToolboxItem.getItemClassNames(iconName),
        json: json2,
        isCopied: false,
        category: defaultCategories[name] || ""
      };
      res.push(this.getOrCreateToolboxItem(item));
    }
    return res;
  }
  getRegisterComponentQuestions() {
    const res = [];
    ComponentCollection.Instance.items.forEach((item) => {
      const action = this.createToolboxItemFromJSON(item.json);
      if (!!action) {
        res.push(action);
      }
    });
    return res;
  }
  getRegisterCustomWidgets() {
    const res = [];
    CustomWidgetCollection.Instance.widgets.forEach((widget) => {
      if (widget.canShowInToolbox) {
        const action = this.createToolboxItemFromJSON(widget.widgetJson);
        if (!!action) {
          res.push(action);
        }
      }
    });
    return res;
  }
  addToolBoxItem(action, actions) {
    if (!action) return;
    const existingAction = this.getActionByIdFromArray(action.id, actions);
    if (!!existingAction) {
      actions.splice(actions.indexOf(existingAction), 1, action);
    } else {
      const index = Array.isArray(this.supportedQuestions) ? this.supportedQuestions.indexOf(action.id) : -1;
      if (index > -1) {
        actions.splice(index, 0, action);
      } else {
        actions.push(action);
      }
    }
  }
  getActionByIdFromArray(id, actions) {
    for (let i = 0; i < actions.length; i++) {
      if (actions[i].id === id) return actions[i];
    }
    return void 0;
  }
  createToolboxItemFromJSON(json2) {
    if (json2.showInToolbox === false || json2.internal === true || !json2.name) return void 0;
    const iconName = json2.iconName ? json2.iconName : _QuestionToolbox.defaultIconName;
    let title = editorLocalization.getString("qt." + json2.name);
    if (!title || title == json2.name) {
      title = this.getTitleFromJsonTitle(json2.title, json2.name);
    }
    if (!title) {
      title = json2.name;
    }
    var elementJson = json2.defaultJSON ? JSON.parse(JSON.stringify(json2.defaultJSON)) : {};
    if (!elementJson.type) {
      elementJson.type = json2.name;
    }
    delete elementJson.name;
    var category = json2.category ? json2.category : "";
    const item = new Action({
      id: json2.name,
      name: json2.name,
      iconName,
      title,
      tooltip: title,
      className: QuestionToolboxItem.getItemClassNames(iconName),
      json: elementJson,
      isCopied: false,
      category
    });
    return this.getOrCreateToolboxItem(item);
  }
  getTitleFromJsonTitle(title, name) {
    if (!title) return title;
    if (typeof title === "string") return title;
    if (typeof title !== "object") return title;
    for (let key in title) {
      const loc = editorLocalization.locales[key];
      if (title[key] && loc && loc.qt) {
        loc.qt[name] = title[key];
      }
    }
    return editorLocalization.getString("qt." + name);
  }
  getQuestionJSON(question) {
    var json2 = new JsonObject().toJsonObject(question);
    json2.type = question.getType();
    let defaultSettings = _QuestionToolbox.getQuestionDefaultSettings(json2.type);
    if (defaultSettings) {
      for (var key in defaultSettings) {
        json2[key] = defaultSettings[key];
      }
    }
    return json2;
  }
  isHiddenCustomWidget(name) {
    const widget = CustomWidgetCollection.Instance.getCustomWidgetByName(name);
    return !!widget && !widget.showInToolbox;
  }
  getQuestionTypes(supportedQuestions) {
    const allTypes = ElementFactory.Instance.getAllToolboxTypes();
    if (!supportedQuestions || supportedQuestions.length == 0) supportedQuestions = allTypes;
    const questions = [];
    for (let i = 0; i < this.orderedQuestions.length; i++) {
      const name2 = this.orderedQuestions[i];
      if (supportedQuestions.indexOf(name2) > -1 && allTypes.indexOf(name2) > -1) questions.push(name2);
    }
    for (let i = 0; i < supportedQuestions.length; i++) {
      var name = supportedQuestions[i];
      if (questions.indexOf(name) < 0 && allTypes.indexOf(name) > -1 && !this.isHiddenCustomWidget(name)) questions.push(name);
    }
    return questions;
  }
};
QuestionToolbox.MINELEMENTCOUNT = 10;
QuestionToolbox.defaultIconName = "icon-default";
QuestionToolbox.defaultItemComponent = "svc-toolbox-item";
QuestionToolbox.defaultItemGroupComponent = "svc-toolbox-item-group";
QuestionToolbox.defaultCategories = {
  choice: ["radiogroup", "rating", "checkbox", "dropdown", "tagbox", "boolean", "file", "imagepicker", "ranking"],
  text: ["text", "comment", "multipletext"],
  containers: ["panel", "paneldynamic"],
  matrix: ["matrix", "matrixdropdown", "matrixdynamic"],
  misc: ["html", "expression", "image", "signaturepad"]
};
__decorate2([property({
  defaultValue: false
})], QuestionToolbox.prototype, "showCategoryTitlesValue", void 0);
__decorate2([propertyArray()], QuestionToolbox.prototype, "categories", void 0);
__decorate2([property({
  defaultValue: "",
  onSet: (val, target) => {
    target.onActiveCategoryChanged(val);
  }
})], QuestionToolbox.prototype, "activeCategory", void 0);
__decorate2([property({
  defaultValue: false
})], QuestionToolbox.prototype, "hasCategories", void 0);
__decorate2([property({
  defaultValue: true
})], QuestionToolbox.prototype, "canCollapseCategories", void 0);
__decorate2([property({
  defaultValue: false,
  onSet: (val, target) => {
    target.updateResponsiveness(val, target.overflowBehavior);
    target.compactAnimation.sync(!(val && !target.isFocused));
  }
})], QuestionToolbox.prototype, "isCompact", void 0);
__decorate2([property({
  defaultValue: false
})], QuestionToolbox.prototype, "isCompactRendered", void 0);
__decorate2([property({
  defaultValue: false
})], QuestionToolbox.prototype, "isFlyoutToCompactRunning", void 0);
__decorate2([property({
  defaultValue: false,
  onSet: (val, target) => {
    if (target.animationAllowed) target.isFlyoutToCompactRunning = target.isCompact && !val;
    target.compactAnimation.sync(!(target.isCompact && !val));
  }
})], QuestionToolbox.prototype, "isFocused", void 0);
__decorate2([property({
  defaultValue: "scroll",
  onSet: (val, target) => {
    target.updateResponsiveness(target.isCompact, val);
  }
})], QuestionToolbox.prototype, "overflowBehavior", void 0);
__decorate2([property()], QuestionToolbox.prototype, "forceCompact", void 0);
__decorate2([property({
  defaultValue: true,
  onSet: (val, target) => {
    target.searchManager.isVisible = val;
  }
})], QuestionToolbox.prototype, "searchEnabled", void 0);
__decorate2([property({
  defaultValue: true
})], QuestionToolbox.prototype, "showSubitems", void 0);
__decorate2([property()], QuestionToolbox.prototype, "showPlaceholder", void 0);
__decorate2([property({
  defaultValue: true
})], QuestionToolbox.prototype, "showSeparators", void 0);
var SelectionHistory = class extends Base {
  constructor(creator) {
    super();
    this.creator = creator;
    this.items = [];
  }
  get hasPrev() {
    return this.currentIndex > 0;
  }
  get hasNext() {
    var index = this.currentIndex;
    return index > -1 && index < this.items.length - 1;
  }
  hasInHistory(obj) {
    return this.getIndex(obj) > -1;
  }
  prev() {
    this.selectElement(this.currentIndex - 1);
  }
  next() {
    this.selectElement(this.currentIndex + 1);
  }
  reset() {
    this.items = [];
    if (!!this.creator.selectedElement) {
      this.onObjSelected(this.creator.selectedElement);
    }
  }
  selectFromAction(obj, propertyName) {
    var index = this.currentIndex;
    if (index > -1 && index < this.items.length) {
      this.items[index].propertyName = propertyName;
    }
    this.creator.selectElement(obj);
  }
  onObjSelected(obj) {
    if (this.isChangingInternally) return;
    var index = this.currentIndex;
    if (index > -1) {
      this.items.splice(index, 1);
    }
    this.items.push({
      obj
    });
  }
  get currentIndex() {
    return this.getIndex(this.creator.selectedElement);
  }
  getIndex(obj) {
    if (!obj) return -1;
    this.updateItems();
    for (var i = 0; i < this.items.length; i++) {
      if (this.items[i].obj == obj) return i;
    }
    return -1;
  }
  selectElement(index) {
    if (index < 0 || index >= this.items.length) return;
    this.isChangingInternally = true;
    var item = this.items[index];
    this.creator.selectElement(item.obj, item.propertyName);
    this.isChangingInternally = false;
  }
  updateItems() {
    for (var i = this.items.length - 1; i >= 0; i--) {
      var obj = this.items[i].obj;
      if (!!obj && (obj.isDisposed || !obj.inSurvey)) {
        this.items.splice(i, 1);
      }
    }
  }
};
function getFirstNonTextElement(elements) {
  if (!elements || !elements.length) return;
  for (var i = 0; i < elements.length; i++) {
    if (elements[i].nodeName != "#text" && elements[i].nodeName != "#comment") return elements[i];
  }
  return null;
}
function findParentNode(className, sourceNode) {
  var parent = sourceNode;
  while (!!parent && !parent.classList.contains(className)) {
    parent = parent.parentElement;
  }
  return parent;
}
function getNodesFromKoComponentInfo(componentInfo) {
  let element = componentInfo.element;
  const siblings = [];
  if (element.nodeType !== 8) {
    return element.childNodes;
  }
  while (element = element.nextSibling) {
    if (element.nodeType === 3) continue;
    siblings.push(element);
  }
  return siblings;
}
function toggleHovered(e, element, timeout = 0) {
  const processedFlagName = "__svc_question_processed";
  const name = "svc-hovered";
  const nameReady = "svc-hovered-ready";
  function setClass(className, checkReady = null) {
    const arr = (element.className || "").split(" ");
    if (checkReady) {
      if (arr.indexOf(checkReady) == -1) {
        return;
      }
    }
    if (arr.indexOf(className) == -1) {
      element.className += " " + className;
    }
  }
  if (!e[processedFlagName] && e.type === "mouseover") {
    if (timeout) {
      setClass(nameReady);
      setTimeout(() => {
        setClass(name, nameReady);
      }, timeout);
    } else {
      setClass(name);
    }
    e[processedFlagName] = true;
  } else {
    element.className = (element.className || "").replace(" svc-hovered-ready", "");
    element.className = (element.className || "").replace(" svc-hovered", "");
  }
}
function select(element) {
  if (!window) return;
  var range, selection;
  if (window.getSelection && document.createRange) {
    selection = window.getSelection();
    range = document.createRange();
    range.selectNodeContents(element);
    selection.removeAllRanges();
    selection.addRange(range);
  } else if (document["selection"] && document.body["createTextRange"]) {
    range = document.body["createTextRange"]();
    range.moveToElementText(element);
    range.select();
  }
}
function saveToFileHandler(fileName, blob) {
  if (!window) return;
  if (window.navigator["msSaveOrOpenBlob"]) {
    window.navigator["msSaveBlob"](blob, fileName);
  } else {
    const elem = window.document.createElement("a");
    elem.href = window.URL.createObjectURL(blob);
    elem.download = fileName;
    document.body.appendChild(elem);
    elem.click();
    document.body.removeChild(elem);
  }
}
function focusFirstControl(renderedElements) {
  for (var i = 0; i < renderedElements.length; i++) {
    if (typeof renderedElements[i].getElementsByClassName === "function") {
      var elements = renderedElements[i].getElementsByClassName("svd-focusable");
      if (elements.length === 0 && renderedElements[i].className.indexOf("svd-focusable") !== -1) {
        elements = [renderedElements[i]];
      }
      if (elements.length > 0) {
        var element = elements[0];
        if (element.tagName.toLowerCase() !== "a") {
          element.focus({
            preventScroll: true
          });
          break;
        }
      }
    }
  }
}
var maxErrorLength = 150;
var JsonEditorBaseModel = class _JsonEditorBaseModel extends Base {
  constructor(creator) {
    super();
    this.creator = creator;
    this.isJSONChanged = false;
    this.isProcessingImmediately = false;
    this.jsonEditorChangedTimeoutId = -1;
  }
  get text() {
    return this.getText();
  }
  set text(val) {
    this.setText(val);
  }
  onEditorActivated() {
  }
  onPluginActivate() {
    this.text = this.creator.text;
    this.onEditorActivated();
    this.isJSONChanged = false;
  }
  onTextChanged() {
    if (this.jsonEditorChangedTimeoutId !== -1) {
      clearTimeout(this.jsonEditorChangedTimeoutId);
    }
    if (this.isProcessingImmediately) {
      this.jsonEditorChangedTimeoutId = -1;
    } else {
      const self2 = this;
      if (!!window) {
        this.jsonEditorChangedTimeoutId = window.setTimeout(() => {
          self2.jsonEditorChangedTimeoutId = -1;
          self2.processErrors(self2.text);
        }, _JsonEditorBaseModel.updateTextTimeout);
      }
    }
  }
  get errorList() {
    if (!this.errorListValue) {
      this.errorListValue = new ListModel({
        items: [],
        onSelectionChanged: (action) => {
          const error = action.data.error;
          if (!!error) this.gotoError(error.at, error.rowAt, error.columnAt);
        },
        allowSelection: false,
        searchEnabled: false
      });
      this.errorListValue.cssClasses = {
        item: "svc-json-errors__item",
        itemBody: "svc-json-error",
        itemsContainer: "svc-json-errors"
      };
      this.errorListValue.hasVerticalScroller = true;
    }
    return this.errorListValue;
  }
  setErrors(errors) {
    let hasErrors = errors.length > 0;
    if (hasErrors) {
      const actions = [];
      this.createErrorActions(errors).forEach((action) => actions.push(action));
      this.errorList.setItems(actions);
    }
    this.hasErrors = hasErrors;
  }
  gotoError(at, row, column) {
  }
  createErrorActions(errors) {
    const res = [];
    let counter = 1;
    errors.forEach((error) => {
      const line = error.rowAt > -1 ? "Line: " + (error.rowAt + 1) + ". " : "";
      let title = error.text;
      if (title.length > maxErrorLength + 3) {
        title = title.substring(0, maxErrorLength) + "...";
      }
      title = line + title;
      error.at;
      res.push(new Action({
        id: "error_" + counter++,
        component: "json-error-item",
        title,
        tooltip: error.text,
        iconName: "icon-error",
        iconSize: "auto",
        data: {
          error,
          showFixButton: error.isFixable,
          fixError: () => {
            this.text = error.fixError(this.text);
          },
          fixButtonIcon: "icon-fix",
          //todo
          fixButtonTitle: "Fix error"
        }
      }));
    });
    return res;
  }
  processErrors(text) {
    const textWorker = new SurveyTextWorker(text);
    this.setErrors(textWorker.errors);
  }
  get readOnly() {
    return this.creator.readOnly;
  }
};
JsonEditorBaseModel.updateTextTimeout = 1e3;
__decorate2([property()], JsonEditorBaseModel.prototype, "hasErrors", void 0);
var TabJsonEditorBasePlugin = class {
  constructor(creator) {
    this.creator = creator;
    this.saveToFileHandler = saveToFileHandler;
    this.createActions().forEach((action) => creator.toolbar.actions.push(action));
  }
  exportToFile(fileName) {
    if (this.model) {
      const jsonBlob = new Blob([this.model.text], {
        type: "application/json"
      });
      this.saveToFileHandler(fileName, jsonBlob);
    }
  }
  importFromFile(file, callback) {
    let fileReader = new FileReader();
    fileReader.onload = (e) => {
      const surveyJSONText = fileReader.result;
      if (this.model) {
        this.model.text = surveyJSONText;
        this.model.isJSONChanged = true;
      }
      callback && callback(surveyJSONText);
    };
    fileReader.readAsText(file);
  }
  copyToClipboard() {
    if (this.model) {
      navigator.clipboard.writeText(this.model.text);
    }
  }
  createActions() {
    const items = [];
    this.importAction = new Action({
      id: "svc-json-import",
      iconName: "icon-load",
      iconSize: "auto",
      locTitleName: "ed.surveyJsonImportButton",
      locTooltipName: "ed.surveyJsonImportButton",
      visible: new ComputedUpdater(() => {
        return this.creator.activeTab === "json";
      }),
      mode: "small",
      component: "sv-action-bar-item",
      needSeparator: true,
      action: () => {
        if (!document) return;
        if (!this.inputFileElement) {
          this.inputFileElement = document.createElement("input");
          this.inputFileElement.type = "file";
          this.inputFileElement.style.display = "none";
          this.inputFileElement.onchange = () => {
            if (this.inputFileElement.files.length < 1) return;
            this.importFromFile(this.inputFileElement.files[0]);
            this.inputFileElement.value = "";
          };
        }
        this.inputFileElement.click();
      }
    });
    items.push(this.importAction);
    this.exportAction = new Action({
      id: "svc-json-export",
      iconName: "icon-download",
      iconSize: "auto",
      locTitleName: "ed.surveyJsonExportButton",
      locTooltipName: "ed.surveyJsonExportButton",
      visible: new ComputedUpdater(() => {
        return this.creator.activeTab === "json";
      }),
      mode: "small",
      component: "sv-action-bar-item",
      action: () => {
        this.exportToFile(settings2.jsonEditor.exportFileName);
      }
    });
    items.push(this.exportAction);
    this.copyAction = new Action({
      id: "svc-json-copy",
      iconName: "icon-copy",
      iconSize: "auto",
      locTitleName: "ed.surveyJsonCopyButton",
      locTooltipName: "ed.surveyJsonCopyButton",
      visible: new ComputedUpdater(() => {
        return this.creator.activeTab === "json";
      }),
      mode: "small",
      component: "sv-action-bar-item",
      action: () => {
        this.copyToClipboard();
      }
    });
    items.push(this.copyAction);
    return items;
  }
  activate() {
    this.model = this.createModel(this.creator);
  }
  deactivate() {
    if (this.model) {
      if (!this.model.readOnly && this.model.isJSONChanged) {
        this.creator.selectedElement = void 0;
        this.creator.changeText(this.model.text, false, true);
        this.creator.selectedElement = this.creator.survey;
        this.creator.setModified({
          type: "JSON_EDITOR"
        });
      }
      this.model.dispose();
      this.model = void 0;
    }
    return true;
  }
  defaultAllowingDeactivate() {
    if (!this.model) return true;
    const textWorker = new SurveyTextWorker(this.model.text);
    if (!textWorker.isJsonCorrect) return void 0;
    return !textWorker.isJsonHasErrors;
  }
};
var AceJsonEditorModel = class _AceJsonEditorModel extends JsonEditorBaseModel {
  constructor(creator) {
    super(creator);
    this.aceCanUndo = false;
    this.aceCanRedo = false;
  }
  getText() {
    return !!this.aceEditor ? this.aceEditor.getValue() : "";
  }
  setText(value) {
    this.isProcessingImmediately = true;
    this.aceEditor.setValue(value);
    this.aceEditor.renderer.updateFull(true);
    this.aceEditor.getSession().getUndoManager().reset();
    this.processErrors(value);
    this.isProcessingImmediately = false;
  }
  init(aceEditor) {
    var _a, _b;
    this.aceEditor = aceEditor;
    const aceModules = (_b = (_a = window["ace"]) === null || _a === void 0 ? void 0 : _a.define) === null || _b === void 0 ? void 0 : _b.modules;
    if (!(aceModules && aceModules["ace/ext/searchbox"])) {
      this.aceEditor.commands["removeCommand"]("find");
    }
    this.aceEditor.setReadOnly(this.readOnly);
    if (_AceJsonEditorModel.aceBasePath) {
      try {
        window["ace"]["config"].set("basePath", _AceJsonEditorModel.aceBasePath);
        this.aceEditor.session.setMode("ace/mode/json");
      } catch (_c) {
      }
    }
    const self2 = this;
    this.aceEditor.setShowPrintMargin(false);
    this.aceEditor.getSession().on("change", () => {
      self2.onTextChanged();
    });
    this.aceEditor.getSession().setUseWorker(true);
    SurveyTextWorker.newLineChar = this.aceEditor.session.doc.getNewLineCharacter();
    this.onPluginActivate();
  }
  onPluginActivate() {
    super.onPluginActivate();
    this.aceEditor.setFontSize(14);
    if (this.creator.preferredColorPalette === "dark") {
      this.aceEditor.setTheme("ace/theme/clouds_midnight");
    }
  }
  updateUndoRedoState() {
    const undoManager = this.aceEditor.getSession().getUndoManager();
    this.aceCanUndo = undoManager.hasUndo();
    this.aceCanRedo = undoManager.hasRedo();
    var isFocused = this.aceEditor.isFocused();
    if (isFocused === true) {
      this.isJSONChanged = !undoManager.isClean();
    }
  }
  onTextChanged() {
    this.updateUndoRedoState();
    super.onTextChanged();
  }
  createAnnotations(errors) {
    const annotations = [];
    for (let i = 0; i < errors.length; i++) {
      const error = errors[i];
      const annotation = {
        row: error.rowAt,
        column: error.columnAt,
        text: error.text,
        type: "error"
      };
      annotations.push(annotation);
    }
    return annotations;
  }
  setErrors(errors) {
    super.setErrors(errors);
    this.aceEditor.getSession().setAnnotations(this.createAnnotations(errors));
    setTimeout(() => this.aceEditor.resize());
  }
  gotoError(at, row, column) {
    this.aceEditor.focus();
    this.aceEditor.renderer.scrollCursorIntoView({
      row: row + 1,
      column: column + 1
    }, 0.5);
    this.aceEditor.gotoLine(row + 1, column + 1);
  }
  onEditorActivated() {
    this.aceEditor.getSession().getUndoManager().markClean();
    this.updateUndoRedoState();
    this.aceEditor.focus();
  }
};
AceJsonEditorModel.aceBasePath = "";
__decorate2([property()], AceJsonEditorModel.prototype, "aceCanUndo", void 0);
__decorate2([property()], AceJsonEditorModel.prototype, "aceCanRedo", void 0);
var TabJsonEditorAcePlugin = class extends TabJsonEditorBasePlugin {
  constructor(creator) {
    super(creator);
    creator.addTab({
      name: "json",
      plugin: this,
      iconName: "icon-codeeditor-24x24",
      componentName: "svc-tab-json-editor-ace"
    });
  }
  createModel(creator) {
    return new AceJsonEditorModel(creator);
  }
  static hasAceEditor() {
    return typeof window !== "undefined" && typeof window["ace"] !== "undefined";
  }
};
var TextareaJsonEditorModel = class extends JsonEditorBaseModel {
  constructor(creator) {
    super(creator);
    this.ariaLabel = getLocString("tabs.json");
    this.onPluginActivate();
  }
  checkKey(data, e) {
    if (e.key === "Tab") {
      e.preventDefault();
      const textareaElement = e.target;
      const start = textareaElement.selectionStart;
      const end = textareaElement.selectionEnd;
      textareaElement.value = textareaElement.value.substring(0, start) + "	" + textareaElement.value.substring(end);
      textareaElement.selectionStart = textareaElement.selectionEnd = start + 1;
      e.stopPropagation();
    }
    return true;
  }
  getText() {
    return this._text;
  }
  setText(value) {
    this.isProcessingImmediately = true;
    this._text = value;
    this.processErrors(value);
    this.isProcessingImmediately = false;
  }
  gotoError(at, row, column) {
    if (!this.textElement) return;
    const el = this.textElement;
    el.selectionStart = at;
    el.selectionEnd = at;
    el.focus();
  }
  get errorButtonText() {
    return this.canShowErrors ? getLocString("ed.jsonHideErrors") : getLocString("ed.jsonShowErrors");
  }
  toggleErrors() {
    this.canShowErrors = !this.canShowErrors;
  }
  get userFriendlyErrors() {
    if (this._errors.length === 0) {
      return [];
    }
    const customErrors = [];
    for (let i = 0; i < this._errors.length - 1; i++) {
      customErrors[i] = this._errors[i].text;
      customErrors[i] += "\n\n";
    }
    customErrors[this._errors.length - 1] = this._errors[this._errors.length - 1].text;
    return customErrors;
  }
  get errors() {
    return this._errors;
  }
  onTextChanged() {
    this.isJSONChanged = true;
    super.onTextChanged();
  }
  setErrors(errors) {
    this._errors = errors;
    super.setErrors(errors);
  }
};
__decorate2([property({
  defaultValue: "",
  onSet: (_, target) => target.onTextChanged()
})], TextareaJsonEditorModel.prototype, "_text", void 0);
__decorate2([propertyArray()], TextareaJsonEditorModel.prototype, "_errors", void 0);
__decorate2([property({
  defaultValue: false
})], TextareaJsonEditorModel.prototype, "canShowErrors", void 0);
var TabJsonEditorTextareaPlugin = class extends TabJsonEditorBasePlugin {
  constructor(creator) {
    super(creator);
    creator.addTab({
      name: "json",
      plugin: this,
      iconName: "icon-codeeditor-24x24",
      componentName: "svc-tab-json-editor-textarea"
    });
  }
  createModel(creator) {
    return new TextareaJsonEditorModel(creator);
  }
};
var SurveySimulatorModel = class extends Base {
  surveyChanged() {
    const _this = this;
    this.survey.onOpenDropdownMenu.add((_, options) => {
      if (this.surveyProvider.isTouch) return;
      const device = simulatorDevices[_this.activeDevice];
      options.menuType = device.deviceType === "desktop" ? "dropdown" : device.deviceType == "tablet" ? "popup" : "overlay";
    });
  }
  constructor(surveyProvider) {
    super();
    this.surveyProvider = surveyProvider;
    this.activateZoom = () => {
      document.addEventListener("keydown", this.listenTryToZoom);
      document.addEventListener("wheel", this.listenTryToZoomWithWheel, {
        passive: false
      });
    };
    this.deactivateZoom = () => {
      document.removeEventListener("keydown", this.listenTryToZoom);
      document.removeEventListener("wheel", this.listenTryToZoomWithWheel);
    };
    this.listenTryToZoomWithWheel = (e) => this.tryToZoomWithWheel(e, e);
    this.listenTryToZoom = (e) => this.tryToZoom(e, e);
  }
  get zoomScale() {
    return this.currZoomScale;
  }
  tryToZoomWithWheel(data, event) {
    const diff = event.deltaY;
    if (event.ctrlKey || event.metaKey) {
      diff < 0 ? this.zoomSimulator("up", event) : this.zoomSimulator("down", event);
    }
    return true;
  }
  tryToZoom(data, event) {
    if (event.ctrlKey || event.metaKey) {
      if (event.keyCode == 107 || event.keyCode == 187) {
        this.zoomSimulator("up", event);
      }
      if (event.keyCode == 109 || event.keyCode == 189) {
        this.zoomSimulator("down", event);
      }
      if (event.keyCode == 48 || event.keyCode == 96) {
        this.zoomSimulator("zero", event);
      }
    }
    return true;
  }
  changeZoomScale(type) {
    const coef = 1.01;
    const multiplier = type === "up" ? coef : type === "down" ? 1 / coef : 1;
    this.currZoomScale = type === "zero" ? 1 : this.currZoomScale * multiplier;
  }
  zoomSimulator(type, event) {
    event.preventDefault();
    this.changeZoomScale(type);
    const simulator = document.getElementById("svd-simulator-wrapper");
    if (!!simulator) simulator.style.transform = "scale(" + this.currZoomScale + ")";
    event.stopPropagation();
  }
  resetZoomParameters() {
    this.currZoomScale = 1;
    const simulator = document.getElementById("svd-simulator-wrapper");
    if (!!simulator) simulator.style.transform = "";
  }
  get activeDevice() {
    return this.device;
  }
  set activeDevice(device) {
    this.device = device;
  }
  get landscapeOrientation() {
    return this.landscape;
  }
  // set landscapeOrientation(isLanscape: boolean) {
  //   this.landscape = isLanscape;
  // }
  get hasFrame() {
    var device = simulatorDevices[this.activeDevice];
    return this.simulatorEnabled && device.deviceType !== "desktop";
  }
  get simulatorFrame() {
    if (!this.hasFrame) {
      return void 0;
    }
    const device = simulatorDevices[this.activeDevice];
    const scale = 1;
    const deviceWidth = (this.landscapeOrientation ? device.height : device.width) / device.cssPixelRatio;
    const deviceHeight = (this.landscapeOrientation ? device.width : device.height) / device.cssPixelRatio;
    const deviceLandscapedFrameWidth = (this.landscapeOrientation ? device.height : device.width) / device.cssPixelRatio;
    const deviceLandscapedFrameHeight = (this.landscapeOrientation ? device.width : device.height) / device.cssPixelRatio;
    const frameWidth = deviceLandscapedFrameWidth * scale + 2 * (this.landscapeOrientation ? 64 : 16);
    const frameHeight = deviceLandscapedFrameHeight * scale + 2 * (this.landscapeOrientation ? 16 : 64);
    return {
      scale: this.simulatorScaleEnabled ? scale : 1,
      frameWidth,
      frameHeight,
      landscapedFrameWidth: this.landscapeOrientation ? frameHeight : frameWidth,
      landscapedFrameHeight: this.landscapeOrientation ? frameWidth : frameHeight,
      deviceWidth,
      deviceHeight,
      cssClass: device.cssClass + (this.landscapeOrientation ? " svd-simulator-frame-landscape" : "")
    };
  }
  getRootCss() {
    return new CssClassBuilder().append("svd-simulator-main").append("svd-simulator-main--frame", this.hasFrame).append("svd-simulator-main--desktop", this.device === "desktop").append("svd-simulator-main--running", this.isRunning).toString();
  }
};
__decorate2([property({
  defaultValue: true
})], SurveySimulatorModel.prototype, "landscape", void 0);
__decorate2([property({
  onSet: (newVal, target) => {
    target.surveyChanged();
  }
})], SurveySimulatorModel.prototype, "survey", void 0);
__decorate2([property({
  defaultValue: "desktop"
})], SurveySimulatorModel.prototype, "device", void 0);
__decorate2([property({
  defaultValue: "l"
})], SurveySimulatorModel.prototype, "orientation", void 0);
__decorate2([property({
  defaultValue: true
})], SurveySimulatorModel.prototype, "considerDPI", void 0);
__decorate2([property({
  defaultValue: true
})], SurveySimulatorModel.prototype, "isRunning", void 0);
__decorate2([property({
  defaultValue: true
})], SurveySimulatorModel.prototype, "simulatorEnabled", void 0);
__decorate2([property({
  defaultValue: true
})], SurveySimulatorModel.prototype, "simulatorScaleEnabled", void 0);
var DEFAULT_MONITOR_DPI = (typeof window !== "undefined" ? window.devicePixelRatio : 1) * 96;
var simulatorDevices = {
  desktop: {
    deviceType: "desktop",
    title: "Desktop"
  },
  // desktop_1280x720: {
  //   cssPixelRatio: 1,
  //   ppi: DEFAULT_MONITOR_DPI,
  //   width: 720,
  //   height: 1280,
  //   deviceType: "desktop",
  //   title: "Desktop 1280x720"
  // },
  // desktop_1440x900: {
  //   cssPixelRatio: 1,
  //   ppi: DEFAULT_MONITOR_DPI,
  //   width: 900,
  //   height: 1440,
  //   deviceType: "desktop",
  //   title: "Desktop 1440x900"
  // },
  // desktop_1920x1080: {
  //   cssPixelRatio: 1,
  //   ppi: DEFAULT_MONITOR_DPI,
  //   width: 1080,
  //   height: 1920,
  //   deviceType: "desktop",
  //   title: "Desktop 1920x1080"
  // },
  // iPhone: {
  //   cssPixelRatio: 2,
  //   ppi: 326,
  //   width: 640,
  //   height: 960,
  //   deviceType: "phone",
  //   title: "iPhone",
  //   cssClass: "svd-simulator-iphone4"
  // },
  // iPhone5: {
  //   cssPixelRatio: 2,
  //   ppi: 326,
  //   width: 640,
  //   height: 1136,
  //   deviceType: "phone",
  //   title: "iPhone 5",
  //   cssClass: "svd-simulator-iphone5",
  // },
  // iPhone6: {
  //   cssPixelRatio: 2,
  //   ppi: 326,
  //   width: 750,
  //   height: 1334,
  //   deviceType: "phone",
  //   title: "iPhone 6",
  //   cssClass: "svd-simulator-iphone6",
  // },
  // iPhone6plus: {
  //   cssPixelRatio: 2.6,
  //   ppi: 401,
  //   width: 1080,
  //   height: 1920,
  //   deviceType: "phone",
  //   title: "iPhone 6 Plus",
  //   cssClass: "svd-simulator-iphone6plus",
  // },
  // iPhone8: {
  //   cssPixelRatio: 2,
  //   ppi: 326,
  //   width: 750,
  //   height: 1334,
  //   deviceType: "phone",
  //   title: "iPhone 8",
  //   cssClass: "svd-simulator-iphone8",
  // },
  // iPhone8plus: {
  //   cssPixelRatio: 3,
  //   ppi: 401,
  //   width: 1080,
  //   height: 1920,
  //   deviceType: "phone",
  //   title: "iPhone 8 Plus",
  //   cssClass: "svd-simulator-iphone8plus",
  // },
  // iPhoneX: {
  //   cssPixelRatio: 3,
  //   ppi: 458,
  //   width: 1125,
  //   height: 2436,
  //   deviceType: "phone",
  //   title: "iPhone X",
  //   cssClass: "svd-simulator-iphonex",
  // },
  // iPhoneXmax: {
  //   cssPixelRatio: 3,
  //   ppi: 458,
  //   width: 1242,
  //   height: 2688,
  //   deviceType: "phone",
  //   title: "iPhone X Max",
  //   cssClass: "svd-simulator-iphonexmax",
  // },
  iPhoneSE: {
    cssPixelRatio: 2,
    ppi: 326,
    width: 750,
    height: 1334,
    deviceType: "phone",
    title: "iPhone SE",
    cssClass: "svd-simulator-iphonexmax"
  },
  iPhone15: {
    cssPixelRatio: 3,
    ppi: 460,
    width: 1179,
    height: 2556,
    deviceType: "phone",
    title: "iPhone 15",
    cssClass: "svd-simulator-iphonexmax"
  },
  iPhone15Plus: {
    cssPixelRatio: 3,
    ppi: 460,
    width: 1290,
    height: 2796,
    deviceType: "phone",
    title: "iPhone 15 Plus",
    cssClass: "svd-simulator-iphonexmax"
  },
  iPadMini: {
    cssPixelRatio: 2.5,
    ppi: 326,
    width: 1536,
    height: 2048,
    deviceType: "tablet",
    title: "iPad Mini",
    cssClass: "svd-simulator-ipadmini"
  },
  iPad: {
    cssPixelRatio: 2,
    ppi: 264,
    width: 1640,
    height: 2360,
    deviceType: "tablet",
    title: "iPad Air",
    cssClass: "svd-simulator-ipad"
  },
  // iPadPro: {
  //   cssPixelRatio: 2,
  //   ppi: 264,
  //   width: 1688,
  //   height: 2388,
  //   deviceType: "tablet",
  //   title: 'iPad Pro 11"',
  //   cssClass: "svd-simulator-ipadpro",
  // },
  // iPadPro13: {
  //   cssPixelRatio: 2,
  //   ppi: 264,
  //   width: 2048,
  //   height: 2732,
  //   deviceType: "tablet",
  //   title: 'iPad Pro 12,9"',
  //   cssClass: "svd-simulator-ipadpro13",
  // },
  androidPhone: {
    cssPixelRatio: 3,
    ppi: 411,
    width: 1080,
    height: 2048,
    deviceType: "phone",
    title: "Android Phone",
    cssClass: "svd-simulator-androidphone"
  },
  androidTablet: {
    cssPixelRatio: 1.5,
    ppi: 149,
    width: 800,
    height: 1280,
    deviceType: "tablet",
    title: "Android Tablet",
    cssClass: "svd-simulator-androidtablet"
  },
  // win10Phone: {
  //   cssPixelRatio: 2,
  //   ppi: 294,
  //   width: 720,
  //   height: 1280,
  //   deviceType: "phone",
  //   title: "Windows 10 Phone",
  //   cssClass: "svd-simulator-win10phone",
  // },
  microsoftSurface: {
    cssPixelRatio: 1,
    ppi: 148,
    width: 768,
    height: 1366,
    deviceType: "tablet",
    title: "Microsoft Surface",
    cssClass: "svd-simulator-mssurface"
  },
  genericPhone: {
    cssPixelRatio: 1,
    deviceType: "phone",
    title: "",
    cssClass: "svd-simulator-genphone"
  }
};
var Themes = {};
var PredefinedThemes = ["default"];
var defaultThemesOrder = ["default", "sharp", "borderless", "flat", "plain", "doubleborder", "layered", "solid", "threedimensional", "contrast"];
var PredefinedColors = {
  light: {
    teal: "rgba(11, 128, 128, 1)",
    blue: "rgba(39, 114, 203, 1)",
    purple: "rgba(122, 70, 187, 1)",
    orchid: "rgba(178, 61, 153, 1)",
    tulip: "rgba(191, 76, 97, 1)",
    brown: "rgba(177, 94, 47, 1)",
    green: "rgba(11, 134, 75, 1)"
  },
  dark: {
    teal: "rgba(22, 198, 187, 1)",
    blue: "rgba(109, 183, 252, 1)",
    purple: "rgba(173, 144, 255, 1)",
    orchid: "rgba(232, 113, 220, 1)",
    tulip: "rgba(245, 131, 151, 1)",
    brown: "rgba(252, 187, 89, 1)",
    green: "rgba(140, 204, 90, 1)"
  }
};
var PredefinedBackgroundColors = {
  light: {
    teal: "rgba(239, 249, 249, 1)",
    blue: "rgba(243, 247, 253, 1)",
    purple: "rgba(248, 244, 254, 1)",
    orchid: "rgba(252, 242, 250, 1)",
    tulip: "rgba(253, 243, 245, 1)",
    brown: "rgba(251, 245, 241, 1)",
    green: "rgba(240, 250, 243, 1)",
    gray: "rgba(246, 246, 246, 1)"
  },
  dark: {}
};
function getPredefinedColorsItemValues(colorPalette = "light") {
  return Object.keys(PredefinedColors[colorPalette]).map((colorName) => new ItemValue(PredefinedColors[colorPalette][colorName], getLocString("theme.colors." + colorName)));
}
function getPredefinedBackgoundColorsChoices(colorPalette = "light") {
  return Object.keys(PredefinedBackgroundColors[colorPalette]).map((colorName) => ({
    value: PredefinedBackgroundColors[colorPalette][colorName],
    text: getLocString("theme.colors." + colorName)
  }));
}
var DefaultFonts = ["Open Sans", "Arial, sans-serif", "Brush Script MT, cursive", "Courier New, monospace", "Garamond, serif", "Georgia, serif", "Tahoma, sans-serif", "Times New Roman, serif", "Trebuchet MS, sans-serif", "Verdana, sans-serif"];
function getElementsJSON$2() {
  return [{
    type: "dropdown",
    name: "family",
    title: getLocString("theme.fontFamily"),
    titleLocation: "left",
    descriptionLocation: "hidden",
    choices: [].concat(DefaultFonts),
    allowClear: false
  }, {
    type: "buttongroup",
    name: "weight",
    titleLocation: "hidden",
    descriptionLocation: "hidden",
    choices: [{
      value: "400",
      text: getLocString("theme.fontWeightRegular")
    }, {
      value: "600",
      text: getLocString("theme.fontWeightSemiBold")
    }, {
      value: "700",
      text: getLocString("theme.fontWeightBold")
    }, {
      value: "800",
      text: getLocString("theme.fontWeightHeavy")
    }]
  }, {
    type: "coloralpha",
    name: "color",
    colorTitle: getLocString("theme.color"),
    colorTitleLocation: "left",
    titleLocation: "hidden",
    descriptionLocation: "hidden"
  }, {
    type: "coloralpha",
    name: "placeholdercolor",
    colorTitle: getLocString("theme.placeholderColor"),
    colorTitleLocation: "left",
    titleLocation: "hidden",
    descriptionLocation: "hidden"
  }, {
    type: "spinedit",
    name: "size",
    title: getLocString("theme.size"),
    titleLocation: "left",
    descriptionLocation: "hidden",
    unit: "px",
    min: 0
  }];
}
if (!ComponentCollection.Instance.getCustomQuestionByName("font")) {
  ComponentCollection.Instance.add({
    name: "font",
    showInToolbox: false,
    internal: true,
    elementsJSON: getElementsJSON$2(),
    onInit() {
      Serializer.addProperties("font", [{
        name: "allowEmptyColorValue:boolean",
        default: false,
        visible: false
      }]);
    },
    onLoaded(question) {
      syncPropertiesFromComposite(question, "allowEmptyColorValue", question.allowEmptyColorValue);
    },
    onPropertyChanged(question, propertyName, newValue) {
      syncPropertiesFromComposite(question, propertyName, newValue);
    },
    onCreated(question) {
      const color = question.contentPanel.getQuestionByName("color");
      color.visible = question.name !== "surveyTitle" && question.name !== "surveyDescription";
      const placeholderColor = question.contentPanel.getQuestionByName("placeholdercolor");
      placeholderColor.visible = question.name === "editorFont";
      const family = question.contentPanel.getQuestionByName("family");
      family.choices = [].concat(DefaultFonts);
    },
    valueToQuestion(value) {
      return JSON.parse(JSON.stringify(value));
    },
    onValueChanged(question, name, newValue) {
    }
  });
}
function syncPropertiesFromComposite(question, propertyName, newValue) {
  const colorQuestion = question.contentPanel.questions[2];
  if (propertyName == "allowEmptyColorValue") {
    colorQuestion.allowEmptyValue = newValue;
  }
}
function updateFontSettingsJSON() {
  const config = ComponentCollection.Instance.getCustomQuestionByName("font");
  config.json.elementsJSON = getElementsJSON$2();
}
function fontsettingsToCssVariable(value = {}, property2, themeCssVariables) {
  Object.keys(value).forEach((key) => {
    const propertyName = `--sjs-font-${property2.name.toLocaleLowerCase()}-${key}`;
    if (!property2.defaultValue || value[key] !== property2.defaultValue[key]) {
      themeCssVariables[propertyName] = value[key] + (key === "size" ? "px" : "");
    } else {
      themeCssVariables[propertyName] = void 0;
    }
  });
}
function fontsettingsFromCssVariable(property2, themeCssVariables, defaultColorVariableName, defaultPlaceholderColorVariableName) {
  if (!property2) return;
  if (!property2.defaultValue) property2.defaultValue = {};
  assign(property2.defaultValue, {
    color: themeCssVariables[defaultColorVariableName],
    placeholdercolor: !!defaultPlaceholderColorVariableName ? themeCssVariables[defaultPlaceholderColorVariableName] : void 0
  });
  if (!property2.defaultValue["size"]) {
    property2.defaultValue["size"] = parseFloat(themeCssVariables["--sjs-font-size"]);
  }
  const result = Object.assign({}, property2.defaultValue);
  const fontSettingsFromTheme = Object.keys(themeCssVariables).filter((key) => key.indexOf(property2.name.toLocaleLowerCase()) !== -1);
  fontSettingsFromTheme.forEach((key) => {
    const propertyName = key.split("-").pop();
    if (propertyName === "size" && themeCssVariables[key] !== void 0) {
      result[propertyName] = parseFloat(themeCssVariables[key].toString());
    } else {
      result[propertyName] = themeCssVariables[key];
    }
  });
  return result;
}
function getElementsJSON$1() {
  return [{
    type: "coloralpha",
    name: "backcolor",
    colorTitle: getLocString("theme.backcolor"),
    colorTitleLocation: "left",
    titleLocation: "hidden",
    descriptionLocation: "hidden"
  }, {
    type: "coloralpha",
    name: "hovercolor",
    colorTitle: getLocString("theme.hovercolor"),
    colorTitleLocation: "left",
    titleLocation: "hidden",
    descriptionLocation: "hidden"
  }, {
    type: "spinedit",
    name: "cornerRadius",
    title: getLocString("theme.cornerRadius"),
    titleLocation: "left",
    descriptionLocation: "hidden",
    unit: "px",
    min: 0
  }];
}
if (!ComponentCollection.Instance.getCustomQuestionByName("backgroundcornerradius")) {
  ComponentCollection.Instance.add({
    name: "backgroundcornerradius",
    showInToolbox: false,
    internal: true,
    elementsJSON: getElementsJSON$1(),
    onInit() {
    },
    onCreated(question) {
    },
    valueToQuestion(value) {
      return JSON.parse(JSON.stringify(value));
    },
    onValueChanged(question, name, newValue) {
    }
  });
}
function updateBackgroundCornerRadiusJSON() {
  const config = ComponentCollection.Instance.getCustomQuestionByName("backgroundcornerradius");
  config.json.elementsJSON = getElementsJSON$1();
}
function backgroundCornerRadiusToCssVariable(value = {}, property2, themeCssVariables) {
  Object.keys(value).forEach((key) => {
    const propertyName = `--sjs-${property2.name.toLocaleLowerCase()}-${key}`;
    if (!property2.defaultValue || value[key] !== property2.defaultValue[key]) {
      themeCssVariables[propertyName] = value[key] + (key === "cornerRadius" ? "px" : "");
    } else {
      themeCssVariables[propertyName] = void 0;
    }
  });
}
function backgroundCornerRadiusFromCssVariable(property2, themeCssVariables, defaultBackcolorVariableName, defaultHovercolorVariableName, defaultCornerRadius = 4) {
  if (!property2) return;
  if (!property2.defaultValue) property2.defaultValue = {};
  assign(property2.defaultValue, {
    backcolor: themeCssVariables[defaultBackcolorVariableName],
    hovercolor: themeCssVariables[defaultHovercolorVariableName],
    cornerRadius: defaultCornerRadius
  });
  const result = Object.assign({}, property2.defaultValue);
  const objFromTheme = Object.keys(themeCssVariables).filter((key) => key.indexOf(property2.name.toLocaleLowerCase()) !== -1);
  objFromTheme.forEach((key) => {
    const propertyName = key.split("-").pop();
    if (propertyName === "cornerRadius" && themeCssVariables[key] !== void 0) {
      result[propertyName] = parseFloat(themeCssVariables[key].toString());
    } else {
      result[propertyName] = themeCssVariables[key];
    }
  });
  return result;
}
function getQuestionJSON() {
  return {
    "type": "paneldynamic",
    "minPanelCount": 1,
    "addPanelText": getLocString("theme.boxShadowAddRule"),
    "templateElements": [{
      "type": "spinedit",
      "name": "x",
      "unit": "px",
      "title": getLocString("theme.boxShadowX"),
      "titleLocation": "left"
    }, {
      "type": "spinedit",
      "name": "y",
      "unit": "px",
      "startWithNewLine": false,
      "title": getLocString("theme.boxShadowY"),
      "titleLocation": "left"
    }, {
      "type": "spinedit",
      "name": "blur",
      "unit": "px",
      "title": getLocString("theme.boxShadowBlur"),
      "min": 0,
      "titleLocation": "left"
    }, {
      "type": "spinedit",
      "name": "spread",
      "unit": "px",
      "min": 0,
      "startWithNewLine": false,
      "title": getLocString("theme.boxShadowSpread"),
      "titleLocation": "left"
    }, {
      "type": "coloralpha",
      "name": "color",
      "titleLocation": "hidden"
    }, {
      "type": "buttongroup",
      "name": "isInset",
      "titleLocation": "hidden",
      "choices": [{
        text: getLocString("theme.boxShadowDrop"),
        value: false
      }, {
        text: getLocString("theme.boxShadowInner"),
        value: true
      }]
    }]
  };
}
if (!ComponentCollection.Instance.getCustomQuestionByName("shadoweffects")) {
  ComponentCollection.Instance.add({
    name: "shadoweffects",
    showInToolbox: false,
    internal: true,
    questionJSON: getQuestionJSON(),
    onCreated(question) {
      question.valueFromDataCallback = (value) => {
        if (typeof value == "undefined") return [{}];
        return typeof value == "string" ? parseBoxShadow(value) : value;
      };
      question.valueToDataCallback = (value) => {
        if (!value) return "";
        if (typeof value == "string") {
          return value;
        } else {
          return createBoxShadow(Array.isArray(value) ? value : [value]);
        }
      };
      question.contentQuestion.panels.forEach((p) => p.questions.forEach((q) => q.allowRootStyle = false));
    }
  });
}
function updateShadowEffectsJSON() {
  const config = ComponentCollection.Instance.getCustomQuestionByName("shadoweffects");
  config.json.questionJSON = getQuestionJSON();
}
function createBoxShadow(value) {
  if (!Array.isArray(value)) return void 0;
  let hasValue = false;
  value.forEach((val) => {
    for (let key in val) {
      hasValue = true;
    }
  });
  if (!hasValue) return void 0;
  return value.map((val) => {
    var _a, _b, _c, _d, _e;
    return `${val.isInset == true ? "inset " : ""}${(_a = val.x) !== null && _a !== void 0 ? _a : 0}px ${(_b = val.y) !== null && _b !== void 0 ? _b : 0}px ${(_c = val.blur) !== null && _c !== void 0 ? _c : 0}px ${(_d = val.spread) !== null && _d !== void 0 ? _d : 0}px ${(_e = val.color) !== null && _e !== void 0 ? _e : "#000000"}`;
  }).join(",");
}
function createBoxShadowReset(value) {
  const resetValue = parseBoxShadow(value);
  resetValue.forEach((valueItem) => {
    valueItem.x = 0;
    valueItem.y = 0;
    valueItem.blur = 0;
    valueItem.spread = 0;
  });
  return createBoxShadow(resetValue);
}
function parseBoxShadow(value = "") {
  return value.split(/,(?![^(]*\))/).map((value2) => {
    const color = value2.match(/#[a-zA-Z0-9]+|rgba?\(.*?\)/);
    const isInset = value2.indexOf("inset") > -1;
    const res = {};
    if (isInset) {
      value2 = value2.replace("inset", "");
    }
    if (!!color) {
      res["color"] = color[0];
    }
    const values = value2.replace(/\s+/g, " ").replace(/^\s|\s$/g, "").split(" ");
    res["x"] = parseInt(values[0]) || 0;
    res["y"] = parseInt(values[1]) || 0;
    res["blur"] = parseInt(values[2]) || 0;
    res["spread"] = parseInt(values[3]) || 0;
    res["isInset"] = isInset;
    return res;
  });
}
function trimBoxShadowValue(value) {
  if (!value) return value;
  return value.replace(/\)\,\s/g, "),");
}
var HeaderModel = class _HeaderModel extends Base {
  getSurvey(live = false) {
    return this.owner;
  }
  fromJSON(json2, options) {
    super.fromJSON(json2, options);
    if (!!json2["backgroundImageOpacity"]) this.backgroundImageOpacity = json2["backgroundImageOpacity"] * 100;
  }
  setCssVariables(cssVariables) {
    if (cssVariables) {
      this["surveyTitle"] = fontsettingsFromCssVariable(this.getPropertyByName("surveyTitle"), cssVariables);
      this["surveyDescription"] = fontsettingsFromCssVariable(this.getPropertyByName("surveyDescription"), cssVariables);
      this["headerTitle"] = fontsettingsFromCssVariable(this.getPropertyByName("headerTitle"), cssVariables);
      this["headerDescription"] = fontsettingsFromCssVariable(this.getPropertyByName("headerDescription"), cssVariables);
    }
    const backgroundColorValue = cssVariables["--sjs-header-backcolor"];
    if (!!backgroundColorValue) {
      this["backgroundColorSwitch"] = this.getBackgroundColorSwitchByValue(backgroundColorValue);
      this["backgroundColor"] = this["backgroundColorSwitch"] === "custom" ? backgroundColorValue : void 0;
    }
  }
  toJSON(options) {
    const result = super.toJSON(options);
    delete result.type;
    delete result.logoPosition;
    delete result.headerView;
    if (this.backgroundImageOpacity !== 100) {
      result.backgroundImageOpacity = this.backgroundImageOpacity / 100;
    }
    const cssVariables = {};
    Object.keys(result).forEach((key) => {
      if (typeof result[key] === "object") {
        const property2 = this.getPropertyByName(key);
        if (property2.type === "font") {
          fontsettingsToCssVariable(result[key], property2, cssVariables);
          delete result[key];
        }
      }
    });
    this.setHeaderBackgroundColorCssVariable(cssVariables);
    result.cssVariables = cssVariables;
    delete result.backgroundColorSwitch;
    delete result.backgroundColor;
    return result;
  }
  saveToThemeJSON(json2, options) {
    const result = this.toJSON(options);
    assign(json2.cssVariables, result.cssVariables);
    delete result.cssVariables;
    if (Object.keys(result).length > 0) {
      json2.header = result;
    }
    json2.headerView = this["headerView"];
  }
  setHeaderBackgroundColorCssVariable(cssVariables) {
    var _a;
    if (this["backgroundColorSwitch"] === "none") {
      cssVariables["--sjs-header-backcolor"] = void 0;
    } else if (this["backgroundColorSwitch"] === "custom") {
      cssVariables["--sjs-header-backcolor"] = (_a = this["backgroundColor"]) !== null && _a !== void 0 ? _a : "transparent";
    } else {
      cssVariables["--sjs-header-backcolor"] = _HeaderModel.primaryColorStr;
    }
  }
  getBackgroundColorSwitchByValue(backgroundColor) {
    if (backgroundColor === _HeaderModel.primaryColorStr) return "accentColor";
    if (!backgroundColor || backgroundColor === "transparent") return "none";
    return "custom";
  }
  getType() {
    return "header";
  }
};
HeaderModel.primaryColorStr = "var(--sjs-primary-backcolor)";
function getDefaultTitleSetting() {
  const result = {
    family: settings2.themeEditor.defaultFontFamily,
    weight: "700",
    size: 32
  };
  return result;
}
function getDefaultDescriptionSetting(isAdvanced) {
  const result = {
    family: settings2.themeEditor.defaultFontFamily,
    weight: "400",
    size: 16
  };
  if (isAdvanced) {
    result["size"] = 20;
  }
  return result;
}
function getHorizontalAlignment(questionName) {
  return {
    type: "buttongroup",
    name: questionName,
    visibleIf: (obj) => obj.headerView === "advanced",
    choices: [{
      value: "left"
    }, {
      value: "center"
    }, {
      value: "right"
    }],
    defaultFunc: () => Serializer.getProperty("cover", questionName).defaultValue
  };
}
function getVerticalAlignment(questionName) {
  return {
    type: "buttongroup",
    name: questionName,
    displayName: "",
    visibleIf: (obj) => obj.headerView === "advanced",
    choices: [{
      value: "top"
    }, {
      value: "middle"
    }, {
      value: "bottom"
    }],
    defaultFunc: () => Serializer.getProperty("cover", questionName).defaultValue
  };
}
Serializer.addClass("header", [{
  type: "buttongroup",
  name: "headerView",
  default: "advanced",
  choices: [{
    value: "basic"
  }, {
    value: "advanced"
  }]
}, {
  type: "buttongroup",
  name: "logoPosition",
  visibleIf: (obj) => obj.headerView === "basic",
  defaultFunc: () => Serializer.getProperty("survey", "logoPosition").defaultValue,
  choices: [{
    value: "left"
  }, {
    value: "right"
  }]
}, {
  type: "spinedit",
  name: "height",
  visibleIf: (obj) => obj.headerView === "advanced",
  defaultFunc: () => Serializer.getProperty("cover", "height").defaultValue,
  onPropertyEditorUpdate: function(obj, editor) {
    if (!!editor) {
      editor.unit = "px";
      editor.min = 0;
    }
  }
}, {
  type: "spinedit",
  name: "mobileHeight",
  visibleIf: (obj) => obj.headerView === "advanced",
  defaultFunc: () => Serializer.getProperty("cover", "mobileHeight").defaultValue,
  onPropertyEditorUpdate: function(obj, editor) {
    if (!!editor) {
      editor.unit = "px";
      editor.min = 0;
    }
  }
}, {
  type: "buttongroup",
  name: "inheritWidthFrom",
  visibleIf: (obj) => obj.headerView === "advanced",
  defaultFunc: () => Serializer.getProperty("cover", "inheritWidthFrom").defaultValue,
  choices: [{
    value: "survey"
  }, {
    value: "container"
  }]
}, {
  type: "spinedit",
  name: "textAreaWidth",
  visibleIf: (obj) => obj.headerView === "advanced",
  defaultFunc: () => Serializer.getProperty("cover", "textAreaWidth").defaultValue,
  onPropertyEditorUpdate: function(obj, editor) {
    if (!!editor) {
      editor.unit = "px";
      editor.min = 0;
    }
  }
}, {
  type: "buttongroup",
  name: "backgroundColorSwitch",
  visibleIf: (obj) => obj.headerView === "advanced",
  isSerializable: false,
  default: "none",
  choices: [{
    value: "none"
  }, {
    value: "accentColor"
  }, {
    value: "custom"
  }]
}, {
  type: "color",
  name: "backgroundColor",
  displayName: "",
  visibleIf: (obj) => obj.headerView === "advanced",
  isSerializable: false,
  onPropertyEditorUpdate: function(obj, editor) {
    if (!!editor) {
      editor.allowEmptyValue = true;
      editor.enableIf = "{composite.backgroundColorSwitch} = 'custom'";
    }
  }
}, {
  name: "backgroundImage:file",
  visibleIf: (obj) => obj.headerView === "advanced",
  onPropertyEditorUpdate: function(obj, editor) {
    if (!!editor) {
      editor.storeDataAsText = false;
      editor.acceptedTypes = "image/*";
    }
  }
}, {
  type: "buttongroup",
  name: "backgroundImageFit",
  displayName: "",
  choices: [{
    value: "cover"
  }, {
    value: "fill"
  }, {
    value: "contain"
  }, {
    value: "tile"
  }],
  defaultFunc: () => Serializer.getProperty("cover", "backgroundImageFit").defaultValue,
  visibleIf: (obj) => obj.headerView === "advanced",
  onPropertyEditorUpdate: function(obj, editor) {
    if (!!editor) {
      editor.enableIf = "{composite.backgroundImage} notempty";
    }
  }
}, {
  type: "spinedit",
  name: "backgroundImageOpacity",
  visibleIf: (obj) => obj.headerView === "advanced",
  defaultFunc: () => {
    const defaultValue = Serializer.getProperty("cover", "backgroundImageOpacity").defaultValue;
    if (defaultValue !== void 0 && defaultValue !== null) {
      return defaultValue * 100;
    }
    return defaultValue;
  },
  onPropertyEditorUpdate: function(obj, editor) {
    if (!!editor) {
      editor.unit = "%";
      editor.min = 0;
      editor.max = 100;
      editor.step = 5;
      editor.titleLocation = "left";
      editor.enableIf = "{composite.backgroundImage} notempty";
    }
  }
}, {
  type: "boolean",
  name: "overlapEnabled",
  displayName: "",
  visibleIf: (obj) => obj.headerView === "advanced",
  onPropertyEditorUpdate: function(obj, editor) {
    if (!!editor) {
      editor.renderAs = "checkbox";
    }
  }
}, getHorizontalAlignment("logoPositionX"), getVerticalAlignment("logoPositionY"), getHorizontalAlignment("titlePositionX"), getVerticalAlignment("titlePositionY"), getHorizontalAlignment("descriptionPositionX"), getVerticalAlignment("descriptionPositionY")]);
Serializer.addProperties("header", [{
  type: "font",
  name: "surveyTitle",
  visibleIf: (obj) => obj.headerView === "basic",
  default: getDefaultTitleSetting()
}, {
  type: "font",
  name: "surveyDescription",
  visibleIf: (obj) => obj.headerView === "basic",
  default: getDefaultDescriptionSetting()
}, {
  type: "font",
  name: "headerTitle",
  default: getDefaultTitleSetting(),
  visibleIf: (obj) => obj.headerView === "advanced",
  onPropertyEditorUpdate: function(obj, editor) {
    if (!!editor) {
      editor.allowEmptyColorValue = true;
    }
  }
}, {
  type: "font",
  name: "headerDescription",
  default: getDefaultDescriptionSetting(true),
  visibleIf: (obj) => obj.headerView === "advanced",
  onPropertyEditorUpdate: function(obj, editor) {
    if (!!editor) {
      editor.allowEmptyColorValue = true;
    }
  }
}]);
function registerTheme(registerThemeCallback, ...themes) {
  themes.forEach((theme) => {
    if (theme.__surveyjs_internal_themes_hash) {
      const themesHash = theme;
      Object.keys(themesHash).forEach((key) => {
        if (key != "__surveyjs_internal_themes_hash" && key != "default" && typeof themesHash[key] !== "boolean") {
          registerThemeCallback(themesHash[key]);
        }
      });
    } else {
      registerThemeCallback(theme);
    }
  });
}
function sortDefaultThemes(defaultThemesOrder2, themes, resultArray) {
  const sortedThemeNames = [].concat(themes).sort((t1, t2) => {
    const firstIndex = defaultThemesOrder2.indexOf(t1);
    const secondIndex = defaultThemesOrder2.indexOf(t2);
    return (firstIndex < 0 ? Number.MAX_VALUE : firstIndex) - (secondIndex < 0 ? Number.MAX_VALUE : secondIndex);
  });
  sortedThemeNames.forEach((themeName) => {
    if (resultArray.indexOf(themeName) === -1) {
      resultArray.push(themeName);
    }
  });
}
var ColorCalculator = class {
  constructor() {
    this.colorSettings = [];
    this.isInitialized = false;
  }
  initializeColorSettings(baseColor, dependentolorValues) {
    const baseColorRgba = getRGBaChannelValues(baseColor);
    dependentolorValues.forEach((dependentolor) => {
      const dependentolorRgba = getRGBaChannelValues(dependentolor);
      const colorAlpha = dependentolorRgba[3];
      const baseColorHSB = RGBToHSB(baseColorRgba[0], baseColorRgba[1], baseColorRgba[2]);
      const colorHSB = RGBToHSB(dependentolorRgba[0], dependentolorRgba[1], dependentolorRgba[2]);
      const colorDelta = baseColorHSB[2] - colorHSB[2];
      this.colorSettings.push({
        colorAlpha,
        colorDelta
      });
    });
    this.isInitialized = !!this.colorSettings.length;
  }
  calculateDependentColorValues(newBaseColor) {
    let newBaseColorRbg = getRGBaChannelValues(newBaseColor);
    const newBaseColorHsb = RGBToHSB(newBaseColorRbg[0], newBaseColorRbg[1], newBaseColorRbg[2]);
    const result = this.colorSettings.map((setting) => {
      const newColorLightRGB = HSBToRGB(newBaseColorHsb[0], newBaseColorHsb[1], newBaseColorHsb[2] - setting.colorDelta);
      return convertRgbaToString(newColorLightRGB, setting.colorAlpha);
    });
    return result;
  }
};
var HueColorCalculator = class {
  constructor() {
    this.isInitialized = false;
  }
  initialize(baseColor) {
    const colorRbg = getRGBaChannelValues(baseColor);
    this.isInitialized = !!colorRbg.length;
    if (this.isInitialized) {
      this.colorHsb = RGBToHSB(colorRbg[0], colorRbg[1], colorRbg[2]);
      this.colorAlpha = colorRbg[3];
    }
  }
  calculateDependentColorValue(baseColor) {
    const baseColorRbg = getRGBaChannelValues(baseColor);
    const baseColorHsb = RGBToHSB(baseColorRbg[0], baseColorRbg[1], baseColorRbg[2]);
    const newColorRGB = HSBToRGB(baseColorHsb[0], this.colorHsb[1], this.colorHsb[2]);
    const resultColor = convertRgbaToString(newColorRGB, this.colorAlpha);
    return resultColor;
  }
};
function ingectAlpha(hexColor, alpha) {
  if (!!hexColor && alpha !== void 0) {
    const rgbValue = HEXToRGB(hexColor);
    return `rgba(${rgbValue[0]}, ${rgbValue[1]}, ${rgbValue[2]}, ${rgbValue[3] || alpha})`;
  }
}
function convertRgbaToString(rgbValues, alpha) {
  return `rgba(${rgbValues[0]}, ${rgbValues[1]}, ${rgbValues[2]}, ${alpha})`;
}
function parseRgbaFromString(value = "") {
  const matchRgb = value.match(/\((.*)\)/);
  if (matchRgb) {
    return matchRgb[1].split(",").map((i) => parseFloat(i));
  } else {
    return [];
  }
}
function getRGBaChannelValues(color) {
  let colorRgba = parseRgbaFromString(color);
  if (colorRgba.length === 0) {
    colorRgba = parseRgbaFromString(ingectAlpha(color, 1));
  }
  return colorRgba;
}
function parseColor(value = "") {
  const rgbValues = parseRgbaFromString(value);
  if (rgbValues.length !== 0) {
    let opacity = 1;
    if (rgbValues.length == 4) {
      opacity = rgbValues.pop();
    }
    const color = rgbValues.reduce((res, color2) => {
      const hex = color2.toString(16);
      return res + (hex.length == 1 ? "0" + hex : hex);
    }, "#");
    return {
      color,
      opacity: roundTo2Decimals(opacity * 100)
    };
  } else {
    return {
      color: value,
      opacity: 100
    };
  }
}
function HEXToRGB(baseColor) {
  if (!!baseColor) {
    const r = parseInt(baseColor.slice(1, 3), 16);
    const g = parseInt(baseColor.slice(3, 5), 16);
    const b = parseInt(baseColor.slice(5, 7), 16);
    const alpha = roundTo2Decimals(parseInt(baseColor.slice(7, 9), 16) / 255);
    return [r, g, b, alpha];
  }
  return [];
}
function HSBToRGB(h, s, b) {
  s /= 100;
  b /= 100;
  const k = (n) => (n + h / 60) % 6;
  const f = (n) => b * (1 - s * Math.max(0, Math.min(k(n), 4 - k(n), 1)));
  return [Math.round(255 * f(5)), Math.round(255 * f(3)), Math.round(255 * f(1))];
}
function RGBToHSB(r, g, b) {
  r /= 255;
  g /= 255;
  b /= 255;
  const v = Math.max(r, g, b), n = v - Math.min(r, g, b);
  const h = n === 0 ? 0 : n && v === r ? (g - b) / n : v === g ? 2 + (b - r) / n : 4 + (r - g) / n;
  return [60 * (h < 0 ? h + 6 : h), v && n / v * 100, v * 100];
}
function colorsAreEqual(color1, color2) {
  const color1Value = parseColor(color1);
  color1Value.color = color1Value.color.substring(0, 7).toUpperCase();
  const color2Value = parseColor(color2);
  color2Value.color = color2Value.color.substring(0, 7).toUpperCase();
  return color1Value.color === color2Value.color && color1Value.opacity === color2Value.opacity;
}
var EditableObject = class _EditableObject {
  static isCopyObject(obj) {
    return !!obj && obj["isCopy"];
  }
  static getSurvey(object) {
    if (object instanceof SurveyModel || !!object && !!object.getType && object.getType() == "survey") {
      return _EditableObject.getOriginalSurvey(object);
    }
    if (object instanceof MatrixDropdownColumn && !!object.colOwner) return object.colOwner["survey"];
    if (!!object) {
      if (!!object.survey) return _EditableObject.getOriginalSurvey(object.survey);
      if (!!object.owner) return _EditableObject.getSurvey(object.owner);
      if (!!object.errorOwner) return _EditableObject.getSurvey(object.errorOwner);
      if (!!object.locOwner) return _EditableObject.getSurvey(object.locOwner);
    }
    var original = _EditableObject.getOriginalObject(object);
    if (!!original && original !== object) return _EditableObject.getSurvey(original);
    return null;
  }
  static getOriginalObject(object) {
    return !!object && !!object["originalObj"] ? object["originalObj"] : object;
  }
  static getOriginalSurvey(survey) {
    return _EditableObject.getOriginalObject(survey);
  }
  constructor(obj) {
    this.objValue = obj;
    this.editableObjValue = this.createEditableObj();
  }
  get obj() {
    return this.objValue;
  }
  get editableObj() {
    return this.editableObjValue;
  }
  isPropertyChanged(propertyName) {
    if (propertyName == "pages") return false;
    return !Helpers.isTwoValueEquals(this.obj[propertyName], this.editableObj[propertyName]);
  }
  apply(propertyName) {
    if (!this.isPropertyChanged(propertyName)) return;
    this.obj[propertyName] = this.editableObj[propertyName];
  }
  reset() {
    this.assignProperties(this.editableObj);
  }
  applyAll(excludedProps = []) {
    var props = this.getProperties(excludedProps);
    for (var i = 0; i < props.length; i++) {
      this.apply(props[i]);
    }
  }
  getProperties(excludedProps) {
    var props = [];
    var newJSON = this.getObjJson(this.editableObj);
    var oldJSON = this.getObjJson(this.obj);
    for (var key in newJSON) {
      if (excludedProps.indexOf(key) > -1) continue;
      props.push(key);
    }
    for (var key in oldJSON) {
      if (excludedProps.indexOf(key) > -1 || props.indexOf(key) > -1) continue;
      props.push(key);
    }
    return props;
  }
  createEditableObj() {
    var type = this.obj.getType();
    var res = Serializer.createClass(type);
    if (res == null && type == "survey") {
      res = new SurveyModel();
    }
    this.assignProperties(res);
    if (type == "matrixdropdowncolumn") {
      res["colOwner"] = this.obj["colOwner"];
    }
    if (type != "survey") {
      if (!!res["setSurveyImpl"]) {
        res["setSurveyImpl"](this.obj["survey"]);
      } else {
        if (!!this.obj["survey"] && !res["survey"]) {
          res["survey"] = this.obj["survey"];
        }
      }
    }
    if (!!this.obj["parent"]) {
      res["parent"] = this.obj["parent"];
    }
    res["isCopy"] = true;
    res["originalObj"] = this.obj;
    return res;
  }
  assignProperties(obj) {
    new JsonObject().toObject(this.getObjJson(), obj);
  }
  getObjJson(obj = null) {
    if (!obj) obj = this.obj;
    var jsonObj = new JsonObject();
    jsonObj.lightSerializing = true;
    return jsonObj.toJsonObject(obj);
  }
};
var UndoRedoManager = class {
  constructor() {
    this._ignoreChanges = false;
    this._isExecuting = false;
    this._preparingTransaction = null;
    this._transactions = [];
    this._currentTransactionIndex = -1;
    this.transactionCounter = 0;
  }
  onPropertyValueChanged(name, oldValue, newValue, sender, arrayChanges) {
    if (EditableObject.isCopyObject(sender)) return;
    if (this.isIgnoring) return;
    if (sender["ignoreUndoRedo"] === true) return;
    let transaction = this._preparingTransaction;
    let action = arrayChanges ? new UndoRedoArrayAction(name, sender, arrayChanges) : new UndoRedoAction(name, oldValue, newValue, sender);
    if (!transaction) {
      transaction = new Transaction(name);
      transaction.addAction(action);
      this._addTransaction(transaction);
      return;
    }
    transaction.addAction(action);
  }
  isCorrectProperty(sender, propertyName) {
    var prop = Serializer.getOriginalProperty(sender, propertyName);
    return !!prop && prop.isSerializable;
  }
  tryMergeTransaction(sender, propertyName, newValue) {
    if (propertyName === "name") return false;
    const lastTransaction = this._getCurrentTransaction();
    if (!lastTransaction || lastTransaction.actions.length == 0) return false;
    const lastAction = lastTransaction.actions[lastTransaction.actions.length - 1];
    return lastAction.tryMerge(sender, propertyName, newValue);
  }
  isCopyObject(sender) {
  }
  _cutOffTail() {
    if (this._currentTransactionIndex + 1 !== this._transactions.length) {
      this._transactions.length = this._currentTransactionIndex + 1;
    }
  }
  get isIgnoring() {
    return this._ignoreChanges || this._isExecuting;
  }
  _addTransaction(transaction) {
    if (transaction.isEmpty()) return;
    this._cutOffTail();
    if (this._transactions[this._currentTransactionIndex] !== transaction) {
      this._transactions.push(transaction);
      this._currentTransactionIndex++;
    }
    this.canUndoRedoCallback();
  }
  _getCurrentTransaction() {
    const index = this._currentTransactionIndex;
    const currentTransaction = this._transactions[index];
    return currentTransaction;
  }
  _getNextTransaction() {
    const index = this._currentTransactionIndex;
    const nextTransaction = this._transactions[index + 1];
    return nextTransaction;
  }
  notifyChangesFinished(transaction, isUndo = false) {
    if (transaction.actions.length > 0) {
      !!this.changesFinishedCallback && this.changesFinishedCallback(transaction.actions, isUndo);
    }
  }
  canUndoRedoCallback() {
  }
  startTransaction(name) {
    if (this.isIgnoring) return;
    this.transactionCounter++;
    if (this._preparingTransaction) return;
    this._preparingTransaction = new Transaction(name);
  }
  stopTransaction() {
    if (this.isIgnoring) return;
    if (this.transactionCounter > 0) {
      this.transactionCounter--;
    }
    if (!this._preparingTransaction || this.transactionCounter > 0) return;
    this._addTransaction(this._preparingTransaction);
    if (this.transactionCounter === 0) {
      this.notifyChangesFinished(this._preparingTransaction);
    }
    this._preparingTransaction = null;
  }
  setUndoCallbackForTransaction(callback) {
    if (!this._preparingTransaction) return;
    this._preparingTransaction.undoCallback = callback;
  }
  get isProcessingUndoRedo() {
    return this._isExecuting === true;
  }
  canUndo() {
    return !!this._getCurrentTransaction();
  }
  undo() {
    const currentTransaction = this._getCurrentTransaction();
    if (!this.canUndo()) return;
    this._isExecuting = true;
    currentTransaction.rollback();
    this._isExecuting = false;
    this._currentTransactionIndex--;
    this.canUndoRedoCallback();
    this.notifyChangesFinished(currentTransaction, true);
  }
  canRedo() {
    return !!this._getNextTransaction();
  }
  redo() {
    const nextTransaction = this._getNextTransaction();
    if (!this.canRedo()) return;
    this._isExecuting = true;
    nextTransaction.apply();
    this._isExecuting = false;
    this._currentTransactionIndex++;
    this.canUndoRedoCallback();
    this.notifyChangesFinished(nextTransaction);
  }
  suspend() {
    this._ignoreChanges = true;
  }
  resume() {
    this._ignoreChanges = false;
  }
};
var Transaction = class {
  constructor(_name) {
    this._name = _name;
    this._actions = [];
    this.undoCallback = () => {
    };
  }
  apply() {
    const actions = this._actions;
    for (let index = 0; index < actions.length; index++) {
      const action = actions[index];
      action.apply();
    }
  }
  rollback() {
    const actions = this._actions;
    for (let index = actions.length - 1; index >= 0; index--) {
      const action = actions[index];
      action.rollback();
    }
    this.undoCallback();
  }
  addAction(action) {
    this._actions.push(action);
  }
  isEmpty() {
    return this._actions.length === 0;
  }
  get actions() {
    return this._actions;
  }
};
var UndoRedoAction = class _UndoRedoAction {
  constructor(_propertyName, _oldValue, _newValue, _sender) {
    this._propertyName = _propertyName;
    this._oldValue = _oldValue;
    this._newValue = _newValue;
    this._sender = _sender;
    this.tickCount = (/* @__PURE__ */ new Date()).getTime();
  }
  apply() {
    this._sender[this._propertyName] = this._newValue;
  }
  rollback() {
    this._sender[this._propertyName] = this._oldValue;
  }
  getChanges(isUndo = false) {
    return {
      object: this._sender,
      propertyName: this._propertyName,
      oldValue: isUndo ? this._newValue : this._oldValue,
      newValue: isUndo ? this._oldValue : this._newValue
    };
  }
  getDeletedElement(isUndo) {
    return void 0;
  }
  getInsertedElement(isUndo) {
    return void 0;
  }
  getIndex() {
    return -1;
  }
  tryMerge(sender, propertyName, newValue) {
    if (sender !== this._sender || propertyName !== this._propertyName || newValue == this._oldValue) return false;
    const prop = Serializer.getOriginalProperty(sender, propertyName);
    if (!prop || prop.type !== "string" && prop.type !== "text") return false;
    if ((/* @__PURE__ */ new Date()).getTime() - this.tickCount > _UndoRedoAction.maximumMergeTime) return false;
    this._newValue = newValue;
    return true;
  }
};
UndoRedoAction.maximumMergeTime = 1e3;
var UndoRedoArrayAction = class {
  constructor(_propertyName, _sender, arrayChanges) {
    this._propertyName = _propertyName;
    this._sender = _sender;
    this._index = 0;
    this._itemsToAdd = [];
    this._deletedItems = [];
    this.survey = _sender.getSurvey();
    this._index = arrayChanges.index;
    this._itemsToAdd = arrayChanges.itemsToAdd;
    this._deletedItems = arrayChanges.deletedItems;
  }
  apply() {
    this.rollback();
  }
  rollback() {
    this._sender = this.getSenderElement();
    if (!this._sender) return;
    const array = this._sender[this._propertyName];
    const index = this._index;
    const deleteCount = this._itemsToAdd.length;
    const itemsToAdd = this.getItemsToAdd();
    this._deletedItems = array.splice.apply(array, [index, deleteCount].concat(itemsToAdd));
    this._itemsToAdd = [].concat(itemsToAdd);
  }
  getChanges() {
    return {
      object: this._sender,
      propertyName: this._propertyName,
      oldValue: this._deletedItems,
      newValue: this._itemsToAdd
    };
  }
  getDeletedElement(isUndo) {
    return this.getMovedElement(this._deletedItems, this._itemsToAdd, isUndo);
  }
  getInsertedElement(isUndo) {
    return this.getMovedElement(this._itemsToAdd, this._deletedItems, isUndo);
  }
  getIndex() {
    return this._index;
  }
  getMovedElement(items1, items2, isUndo) {
    const items = isUndo ? items2 : items1;
    if (Array.isArray(items) && items.length === 1) return items[0];
    return void 0;
  }
  tryMerge(sender, propertyName, newValue) {
    return false;
  }
  getSenderElement() {
    if (!this._sender.isDisposed || !this.survey) return this._sender;
    const name = this._sender["name"];
    if (this._sender["isPage"] === true) {
      if (this.survey.pages.length === 0) return this.survey.addNewPage();
      return this.survey.getPageByName(name);
    }
    if (this._sender["isPanel"] === true) return this.survey.getPanelByName(name);
    if (this._sender["isQuestion"] === true) return this.survey.getQuestionByName(name);
    return this._sender;
  }
  getItemsToAdd() {
    const res = [];
    for (let i = 0; i < this._deletedItems.length; i++) {
      let obj = this._deletedItems[i];
      if (obj.isDisposed && obj.getType) {
        const json2 = obj.toJSON();
        obj = Serializer.createClass(obj.getType());
        obj.fromJSON(json2);
      }
      res.push(obj);
    }
    return res;
  }
};
function getElementsJSON() {
  return [{
    name: "color",
    type: "color",
    titleLocation: "hidden"
  }, {
    name: "opacity",
    startWithNewLine: false,
    type: "spinedit",
    title: getLocString("theme.opacity"),
    min: 0,
    max: 100,
    defaultValue: 100,
    unit: "%",
    titleLocation: "left"
  }];
}
if (!ComponentCollection.Instance.getCustomQuestionByName("coloralpha")) {
  ComponentCollection.Instance.add({
    name: "coloralpha",
    showInToolbox: false,
    internal: true,
    elementsJSON: getElementsJSON(),
    onInit() {
      Serializer.addProperties("coloralpha", [{
        name: "choices:itemvalue[]",
        visible: false
      }, {
        name: "colorTitleLocation:string",
        default: "hidden",
        visible: false
      }, {
        name: "allowEmptyValue:boolean",
        default: false,
        visible: false
      }, {
        name: "colorTitle:string",
        visible: false
      }]);
    },
    onLoaded(question) {
      syncPropertiesFromCompositeToColor(question, "colorTitle", question.colorTitle);
      syncPropertiesFromCompositeToColor(question, "colorTitleLocation", question.colorTitleLocation);
      syncPropertiesFromCompositeToColor(question, "choices", question.choices);
      syncPropertiesFromCompositeToColor(question, "allowEmptyValue", question.allowEmptyValue);
    },
    onPropertyChanged(question, propertyName, newValue) {
      syncPropertiesFromCompositeToColor(question, propertyName, newValue);
    },
    valueToQuestion(value) {
      return !!value ? createColor(value) : "";
    },
    valueFromQuestion(value) {
      return typeof value == "string" || typeof value == "undefined" ? parseColor(value) : value;
    },
    onCreated(question) {
      question.contentPanel.questions.forEach((q) => q.allowRootStyle = false);
    }
  });
}
function updatecoloralphaJSON() {
  const config = ComponentCollection.Instance.getCustomQuestionByName("coloralpha");
  config.json.elementsJSON = getElementsJSON();
}
function syncPropertiesFromCompositeToColor(question, propertyName, newValue) {
  const colorQuestion = question.contentPanel.questions[0];
  if (!colorQuestion) {
    return;
  }
  if (propertyName == "colorTitleLocation") {
    colorQuestion.titleLocation = newValue;
  }
  if (propertyName == "colorTitle") {
    colorQuestion.title = newValue;
  }
  if (propertyName == "choices") {
    colorQuestion.choices = newValue;
  }
  if (propertyName == "allowEmptyValue") {
    colorQuestion.allowEmptyValue = newValue;
  }
}
function createColor(value) {
  return ingectAlpha(value.color, value.opacity / 100);
}
function updateCustomQuestionJSONs() {
  updateShadowEffectsJSON();
  updateFontSettingsJSON();
  updatecoloralphaJSON();
  updateBackgroundCornerRadiusJSON();
}
function registerSurveyTheme(...themes) {
  const importedThemeNames = [];
  registerTheme((theme) => {
    const creatorThemeVariables = {};
    const creatorTheme = {};
    assign(creatorThemeVariables, theme.cssVariables);
    assign(creatorTheme, theme, {
      cssVariables: creatorThemeVariables
    });
    const creatorThemeName = getThemeFullName(theme);
    Themes[creatorThemeName] = creatorTheme;
    importedThemeNames.push(theme.themeName);
  }, ...themes);
  sortDefaultThemes(defaultThemesOrder, importedThemeNames, PredefinedThemes);
}
function getThemeFullName(theme) {
  const themeName = theme.themeName || ThemeModel.DefaultTheme.themeName || "default";
  let fullThemeName = themeName + "-" + (theme.colorPalette || "light");
  if (theme.isPanelless === true) {
    fullThemeName += "-panelless";
  }
  return fullThemeName;
}
function isThemeEmpty(theme) {
  if (!theme) {
    return true;
  }
  const themeProperties = Object.keys(theme);
  return themeProperties.length == 0 || themeProperties.length == 1 && themeProperties[0] == "cssVariables" && Object.keys(theme.cssVariables).length == 0;
}
function findSuitableTheme(themeName, colorPalette, isPanelless, probeThemeFullName) {
  let suitableTheme = Themes[probeThemeFullName];
  if (!!suitableTheme) {
    return suitableTheme;
  }
  const appropriateThemeNames = Object.keys(Themes).filter((fullName) => fullName.indexOf(themeName + "-") === 0);
  for (let fullThemeName of appropriateThemeNames) {
    if (fullThemeName.indexOf(themeName + "-" + colorPalette) === 0) {
      probeThemeFullName = themeName + "-" + colorPalette;
    }
    if (fullThemeName.indexOf(themeName + "-" + colorPalette + (isPanelless ? "-panelless" : "")) === 0) {
      probeThemeFullName = themeName + "-" + colorPalette + (isPanelless ? "-panelless" : "");
    }
  }
  suitableTheme = Themes[appropriateThemeNames[0]];
  if (!!suitableTheme) {
    return suitableTheme;
  }
  const defaultNearestThemeFullName = getThemeFullName({
    themeName: ThemeModel.DefaultTheme.themeName,
    colorPalette: colorPalette || "light",
    isPanelless
  });
  return Themes[defaultNearestThemeFullName] || ThemeModel.DefaultTheme;
}
function getObjectDiffs(obj1, obj2 = {}) {
  const result = {};
  Object.keys(obj1).forEach((key) => {
    if (typeof obj1[key] === "object") {
      result[key] = getObjectDiffs(obj1[key], obj2[key]);
    } else {
      if (obj1[key] !== void 0 && obj1[key] != obj2[key]) {
        result[key] = obj1[key];
      }
    }
  });
  return result;
}
function getThemeChanges(fullTheme, baseTheme) {
  if (!baseTheme) {
    let probeThemeFullName = getThemeFullName(fullTheme);
    baseTheme = findSuitableTheme(fullTheme.themeName, fullTheme.colorPalette, fullTheme.isPanelless, probeThemeFullName);
  }
  const themeChanges = getObjectDiffs(fullTheme, baseTheme);
  Object.keys(themeChanges).forEach((propertyName) => {
    if (propertyName.toLowerCase().indexOf("background") !== -1) {
      if (themeChanges[propertyName] === "" || themeChanges[propertyName] === Serializer.findProperty("survey", propertyName).defaultValue) {
        delete themeChanges[propertyName];
      }
    }
  });
  themeChanges.themeName = baseTheme.themeName || ThemeModel.DefaultTheme.themeName || "default";
  themeChanges.colorPalette = baseTheme.colorPalette || "light";
  themeChanges.isPanelless = !!baseTheme.isPanelless;
  return themeChanges;
}
var ThemeModel = class _ThemeModel extends Base {
  static get DefaultTheme() {
    if (!this.defaultThemeValue) {
      return Themes["default-light"] || {};
    } else {
      return this.defaultThemeValue;
    }
  }
  static set DefaultTheme(val) {
    this.defaultThemeValue = val;
  }
  getFullThemeName(_themeName) {
    if (this.colorPalette === "light") {
      return _themeName || this.themeName;
    }
    return (_themeName || this.themeName) + "-" + this.colorPalette;
  }
  get defaultSessionTheme() {
    return this._defaultSessionTheme;
  }
  set defaultSessionTheme(theme) {
    this._defaultSessionTheme = theme;
  }
  get cssVariables() {
    return this.toJSON()["cssVariables"] || {};
  }
  get themeCssCustomizations() {
    const customizations = {};
    assign(customizations, this.themeCssVariablesChanges);
    return customizations;
  }
  getType() {
    return "theme";
  }
  setNewHeaderProperty() {
    const header = new HeaderModel();
    header.owner = this;
    this.setPropertyValue("header", header);
  }
  hasVariations(palette) {
    let themeHasModeVariations = false;
    let themeHasPaletteVariations = false;
    const registeredThemes = Object.keys(Themes);
    let themeLight = this.themeName + "-light";
    let themeDark = this.themeName + "-dark";
    if (this.isPanelless) {
      themeLight += "-panelless";
      themeDark += "-panelless";
    }
    themeHasPaletteVariations = registeredThemes.indexOf(themeLight) !== -1 && registeredThemes.indexOf(themeDark) !== -1;
    let themePanels = this.themeName + "-" + this.colorPalette;
    let themePanelless = themePanels + "-panelless";
    themeHasModeVariations = registeredThemes.indexOf(themePanels) !== -1 && registeredThemes.indexOf(themePanelless) !== -1;
    if (palette) {
      return themeHasPaletteVariations;
    } else {
      return themeHasModeVariations;
    }
  }
  initializeColorCalculator(cssVariables) {
    const baseColorName = "--sjs-primary-backcolor";
    const cssValuesExists = this.dependentColorNames.every((name) => !!cssVariables[name]);
    if (!cssVariables[baseColorName] || !cssValuesExists) {
      return;
    }
    const dependentColorValues = this.dependentColorNames.map((name) => {
      return cssVariables[name];
    });
    this.colorCalculator.initializeColorSettings(cssVariables[baseColorName], dependentColorValues);
  }
  updatePropertiesDependentOnPrimaryColor(value) {
    if (!this.colorCalculator.isInitialized) return;
    const newDependentColors = this.colorCalculator.calculateDependentColorValues(value);
    this.dependentColorNames.forEach((name, index) => {
      this.setPropertyValue(name, newDependentColors[index]);
      this.setThemeCssVariablesChanges(name, newDependentColors[index]);
    });
  }
  cssVariablePropertiesChanged(name, value, property2) {
    let nameProcessed = true;
    if (name === "primaryColor") {
      this.setPropertyValue("--sjs-primary-backcolor", value);
      this.setThemeCssVariablesChanges("--sjs-primary-backcolor", value);
      this.updatePropertiesDependentOnPrimaryColor(value);
    } else if (name === "--sjs-primary-backcolor") {
      this["primaryColor"] = value;
      this.updatePropertiesDependentOnPrimaryColor(value);
    } else if (name === "--sjs-shadow-inner" || name === "--sjs-shadow-small") {
      const newBoxShadowReset = createBoxShadowReset(value);
      this.setPropertyValue(name + "-reset", newBoxShadowReset);
      this.setThemeCssVariablesChanges(name + "-reset", newBoxShadowReset);
    } else if (name == "scale") {
      this.setThemeCssVariablesChanges("--sjs-base-unit", value * 8 / 100 + "px");
    } else if (name == "fontSize") {
      this.setThemeCssVariablesChanges("--sjs-font-size", value * 16 / 100 + "px");
    } else if (name == "cornerRadius") {
      this.setThemeCssVariablesChanges("--sjs-corner-radius", value + "px");
    } else if (name === "questionBackgroundTransparency" || name === "editorPanel") {
      let baseColor = parseColor(this.getPropertyValue("--sjs-general-backcolor-dim-light")).color;
      let questionBackgroundTransparencyValue = this.getPropertyValue("questionBackgroundTransparency");
      this.setThemeCssVariablesChanges("--sjs-editor-background", ingectAlpha(baseColor, questionBackgroundTransparencyValue / 100));
    } else if (name === "panelBackgroundTransparency" || name === "questionPanel") {
      let baseColor = parseColor(this.getPropertyValue("--sjs-general-backcolor")).color;
      let panelBackgroundTransparencyValue = this.getPropertyValue("panelBackgroundTransparency");
      this.setThemeCssVariablesChanges("--sjs-question-background", ingectAlpha(baseColor, panelBackgroundTransparencyValue / 100));
    } else {
      nameProcessed = false;
    }
    let typeProcessed = true;
    if (property2.type === "font") {
      fontsettingsToCssVariable(value, property2, this.themeCssVariablesChanges);
      this.onThemePropertyChanged.fire(this, {
        name,
        value
      });
    } else if (property2.type === "backgroundcornerradius") {
      backgroundCornerRadiusToCssVariable(value, property2, this.themeCssVariablesChanges);
      this.onThemePropertyChanged.fire(this, {
        name,
        value
      });
    } else {
      typeProcessed = false;
    }
    return nameProcessed || typeProcessed;
  }
  setThemeCssVariablesChanges(name, value) {
    if (this.themeCssVariablesChanges[name] !== value) {
      this.themeCssVariablesChanges[name] = value;
      this.onThemePropertyChanged.fire(this, {
        name,
        value
      });
    }
  }
  constructor() {
    super();
    this.themeCssVariablesChanges = {};
    this.colorCalculator = new ColorCalculator();
    this.dependentColorNames = ["--sjs-primary-backcolor-light", "--sjs-primary-backcolor-dark"];
    this._defaultSessionTheme = _ThemeModel.DefaultTheme;
    this.onThemeSelected = new EventBase();
    this.onThemePropertyChanged = new EventBase();
    this.onAllowModifyTheme = new EventBase();
    this.blockThemeChangedNotifications = 0;
    updateCustomQuestionJSONs();
    this.setNewHeaderProperty();
    this.onPropertyValueChangedCallback = (name, oldValue, newValue, sender, arrayChanges) => {
      this.onThemePropertyValueChangedCallback(name, oldValue, newValue, sender, arrayChanges);
    };
  }
  initialize(surveyTheme = {}, survey, creator) {
    this._defaultSessionTheme = _ThemeModel.DefaultTheme;
    this.backgroundImage = "backgroundImage" in surveyTheme ? surveyTheme.backgroundImage : survey === null || survey === void 0 ? void 0 : survey.backgroundImage;
    this.backgroundImageFit = surveyTheme.backgroundImageFit !== void 0 ? surveyTheme.backgroundImageFit : survey === null || survey === void 0 ? void 0 : survey.backgroundImageFit;
    this.backgroundImageAttachment = surveyTheme.backgroundImageAttachment !== void 0 ? surveyTheme.backgroundImageAttachment : survey === null || survey === void 0 ? void 0 : survey.backgroundImageAttachment;
    this.backgroundOpacity = ((surveyTheme.backgroundOpacity !== void 0 ? surveyTheme.backgroundOpacity : survey === null || survey === void 0 ? void 0 : survey.backgroundOpacity) || 1) * 100;
    this.loadTheme(surveyTheme, creator && creator.preferredColorPalette);
    this.header["logoPosition"] = survey === null || survey === void 0 ? void 0 : survey.logoPosition;
    this.undoRedoManager = new UndoRedoManager();
  }
  get header() {
    return this.getPropertyValue("header");
  }
  set header(val) {
    if (!val) return;
    this.setNewHeaderProperty();
    this.header.fromJSON(val.toJSON());
  }
  loadTheme(theme, preferredColorPalette) {
    this.blockThemeChangedNotifications += 1;
    try {
      let probeThemeFullName = getThemeFullName({
        themeName: theme.themeName,
        colorPalette: theme.colorPalette || preferredColorPalette,
        isPanelless: theme.isPanelless
      });
      const baseTheme = findSuitableTheme(theme.themeName, theme.colorPalette || preferredColorPalette, theme.isPanelless, probeThemeFullName);
      const themeChanges = getThemeChanges(theme, baseTheme);
      this.themeName = themeChanges.themeName;
      this.colorPalette = themeChanges.colorPalette;
      this.isPanelless = themeChanges.isPanelless;
      this.backgroundImage = theme.backgroundImage || this.backgroundImage;
      this.backgroundImageFit = theme.backgroundImageFit || this.backgroundImageFit;
      this.backgroundImageAttachment = theme.backgroundImageAttachment || this.backgroundImageAttachment;
      const effectiveThemeCssVariables = {};
      assign(effectiveThemeCssVariables, _ThemeModel.DefaultTheme.cssVariables || {}, baseTheme.cssVariables || {});
      assign(effectiveThemeCssVariables, theme.cssVariables || {}, this.themeCssVariablesChanges);
      const effectiveTheme = {
        backgroundImage: this.backgroundImage || baseTheme.backgroundImage || "",
        backgroundImageFit: this.backgroundImageFit || baseTheme.backgroundImageFit,
        backgroundImageAttachment: this.backgroundImageAttachment || baseTheme.backgroundImageAttachment,
        backgroundOpacity: this.backgroundOpacity / 100 || baseTheme.backgroundOpacity
      };
      const effectiveHeader = {};
      if (Object.keys(effectiveHeader).length > 0) {
        effectiveTheme.header = effectiveHeader;
      }
      assign(effectiveTheme, theme, {
        cssVariables: effectiveThemeCssVariables,
        themeName: this.themeName,
        colorPalette: this.colorPalette,
        isPanelless: this.isPanelless
      });
      this.initializeColorCalculator(effectiveTheme.cssVariables);
      this.fromJSON(effectiveTheme);
    } finally {
      this.blockThemeChangedNotifications -= 1;
    }
  }
  resetTheme() {
    this.setTheme({
      themeName: this.defaultSessionTheme.themeName,
      isPanelless: this.defaultSessionTheme.isPanelless,
      colorPalette: this.defaultSessionTheme.colorPalette
    });
  }
  setTheme(theme) {
    const headerBackgroundColorValue = this.themeCssVariablesChanges["--sjs-header-backcolor"];
    this.themeCssVariablesChanges = {};
    if (headerBackgroundColorValue !== void 0) {
      this.themeCssVariablesChanges["--sjs-header-backcolor"] = headerBackgroundColorValue;
    }
    try {
      this.blockThemeChangedNotifications += 1;
      this.iteratePropertiesHash((hash, key) => {
        this.setPropertyValue(key, void 0);
      });
      this.setNewHeaderProperty();
    } finally {
      this.blockThemeChangedNotifications -= 1;
    }
    this.loadTheme(theme);
    this.onThemeSelected.fire(this, {
      theme: this.toJSON()
    });
  }
  selectTheme(themeName, colorPalette = "light", themeMode = "panels") {
    this.themeName = themeName;
    this.colorPalette = colorPalette;
    this.isPanelless = themeMode === "lightweight";
    const theme = this.findSuitableTheme(themeName);
    this.setTheme(theme);
  }
  generalPropertiesChanged(name, value) {
    if (["themeName", "isPanelless", "colorPalette"].indexOf(name) !== -1) {
      if (name === "themeName") {
        this.loadTheme(this.findSuitableTheme(value) || {
          [name]: value,
          isPanelless: this.isPanelless,
          colorPalette: this.colorPalette
        });
      }
      if (name === "isPanelless") {
        this.loadTheme({
          themeName: this.themeName,
          isPanelless: value,
          colorPalette: this.colorPalette
        });
      }
      if (name === "colorPalette") {
        this.loadTheme({
          themeName: this.themeName,
          isPanelless: this.isPanelless,
          colorPalette: value
        });
      }
      this.onThemeSelected.fire(this, {
        theme: this.toJSON()
      });
      return true;
    }
    return false;
  }
  onThemePropertyValueChangedCallback(name, oldValue, newValue, sender, arrayChanges) {
    if (!!this.undoRedoManager) {
      if (this.blockThemeChangedNotifications == 0) {
        this.undoRedoManager.startTransaction(name + " changed");
      }
      this.undoRedoManager.onPropertyValueChanged(name, oldValue, newValue, sender, arrayChanges);
    }
    if (this.blockThemeChangedNotifications > 0) return;
    let processedInternally = false;
    if (this !== sender) {
      const senderJSON = sender.toJSON();
      if (!!senderJSON.cssVariables) {
        Object.keys(senderJSON.cssVariables).forEach((key) => this.setThemeCssVariablesChanges(key, senderJSON.cssVariables[key]));
      }
      this.onThemePropertyChanged.fire(this, {
        name,
        value: newValue
      });
      processedInternally = true;
    }
    if (name.indexOf("--") === 0) {
      this.setThemeCssVariablesChanges(name, newValue);
      processedInternally = true;
    }
    if (this.generalPropertiesChanged(name, newValue)) {
      if (!!this.undoRedoManager && this.blockThemeChangedNotifications == 0) {
        this.undoRedoManager.stopTransaction();
      }
      return;
    }
    this.blockThemeChangedNotifications += 1;
    if (this === sender && ["backgroundImage", "backgroundImageFit", "backgroundImageAttachment", "backgroundOpacity"].indexOf(name) !== -1) {
      this[name] = newValue;
      this.onThemePropertyChanged.fire(this, {
        name,
        value: newValue
      });
      this.blockThemeChangedNotifications -= 1;
      if (!!this.undoRedoManager && this.blockThemeChangedNotifications == 0) {
        this.undoRedoManager.stopTransaction();
      }
      return;
    }
    if (this.cssVariablePropertiesChanged(name, newValue, sender.getPropertyByName(name))) {
      processedInternally = true;
    }
    if (!processedInternally) {
      this.onThemePropertyChanged.fire(this, {
        name,
        value: newValue
      });
    }
    this.blockThemeChangedNotifications -= 1;
    if (!!this.undoRedoManager && this.blockThemeChangedNotifications == 0) {
      this.undoRedoManager.stopTransaction();
    }
  }
  findSuitableTheme(themeName) {
    let probeThemeFullName = getThemeFullName({
      themeName,
      colorPalette: this.colorPalette,
      isPanelless: this.isPanelless
    });
    return findSuitableTheme(themeName, this.colorPalette, this.isPanelless, probeThemeFullName);
  }
  fromJSON(json2, options) {
    if (!json2) return;
    const _json = {};
    assign(_json, json2);
    delete _json["header"];
    delete _json["cssVariables"];
    super.fromJSON(_json, options);
    const _headerJson = {};
    assign(_headerJson, json2.header);
    if (!!json2["headerView"]) _headerJson["headerView"] = json2["headerView"];
    this.header.fromJSON(_headerJson || {});
    if (json2.cssVariables) {
      this["primaryColor"] = json2.cssVariables["--sjs-primary-backcolor"];
      super.fromJSON(json2.cssVariables, options);
      this.header.setCssVariables(json2.cssVariables);
      this.scale = !!this["--sjs-base-unit"] ? roundTo2Decimals(parseFloat(this["--sjs-base-unit"]) * 100 / 8) : void 0;
      this.fontSize = !!this["--sjs-font-size"] ? roundTo2Decimals(parseFloat(this["--sjs-font-size"]) * 100 / 16) : void 0;
      this.cornerRadius = this["--sjs-corner-radius"] ? roundTo2Decimals(parseFloat(this["--sjs-corner-radius"])) : void 0;
      if (!!json2["backgroundOpacity"]) this.backgroundOpacity = json2["backgroundOpacity"] * 100;
      this["questionPanel"] = backgroundCornerRadiusFromCssVariable(this.getPropertyByName("questionPanel"), json2.cssVariables, "--sjs-general-backcolor", "--sjs-general-backcolor-dark", this.cornerRadius);
      this["editorPanel"] = backgroundCornerRadiusFromCssVariable(this.getPropertyByName("editorPanel"), json2.cssVariables, "--sjs-general-backcolor-dim-light", "--sjs-general-backcolor-dim-dark", this.cornerRadius);
      Serializer.getProperties("theme").forEach((property2) => {
        if (property2.type === "font") {
          this[property2.name] = fontsettingsFromCssVariable(property2, json2.cssVariables);
        }
      });
      this["pageTitle"] = fontsettingsFromCssVariable(this.getPropertyByName("pageTitle"), json2.cssVariables, "--sjs-general-dim-forecolor");
      this["pageDescription"] = fontsettingsFromCssVariable(this.getPropertyByName("pageDescription"), json2.cssVariables, "--sjs-general-dim-forecolor-light");
      this["questionTitle"] = fontsettingsFromCssVariable(this.getPropertyByName("questionTitle"), json2.cssVariables, "--sjs-general-forecolor");
      this["questionDescription"] = fontsettingsFromCssVariable(this.getPropertyByName("questionDescription"), json2.cssVariables, "--sjs-general-forecolor-light");
      this["editorFont"] = fontsettingsFromCssVariable(this.getPropertyByName("editorFont"), json2.cssVariables, "--sjs-general-forecolor", "--sjs-general-forecolor-light");
    }
  }
  toJSON(options) {
    if (this.scale !== void 0) {
      this["--sjs-base-unit"] = this.scale * 8 / 100 + "px";
    }
    if (this.fontSize !== void 0) {
      this["--sjs-font-size"] = this.fontSize * 16 / 100 + "px";
    }
    if (this.cornerRadius !== void 0) {
      this["--sjs-corner-radius"] = this.cornerRadius + "px";
    }
    const result = super.toJSON(options);
    result["backgroundImage"] = this.backgroundImage || "";
    result["backgroundOpacity"] = this.backgroundOpacity / 100;
    result["backgroundImageAttachment"] = this.backgroundImageAttachment;
    result["backgroundImageFit"] = this.backgroundImageFit;
    const cssVariables = {};
    Object.keys(result).forEach((key) => {
      if (key.indexOf("--") == 0) {
        cssVariables[key] = result[key];
        delete result[key];
      } else if (typeof result[key] === "object") {
        const property2 = this.getPropertyByName(key);
        if (property2.type === "font") {
          fontsettingsToCssVariable(result[key], property2, cssVariables);
          delete result[key];
        }
        if (property2.type === "backgroundcornerradius") {
          backgroundCornerRadiusToCssVariable(result[key], property2, cssVariables);
          delete result[key];
        }
      }
    });
    result.cssVariables = cssVariables;
    this.header.saveToThemeJSON(result, options);
    return result;
  }
};
__decorate2([property()], ThemeModel.prototype, "backgroundImage", void 0);
__decorate2([property()], ThemeModel.prototype, "backgroundImageFit", void 0);
__decorate2([property()], ThemeModel.prototype, "backgroundImageAttachment", void 0);
__decorate2([property()], ThemeModel.prototype, "backgroundOpacity", void 0);
__decorate2([property()], ThemeModel.prototype, "themeName", void 0);
__decorate2([property()], ThemeModel.prototype, "colorPalette", void 0);
__decorate2([property()], ThemeModel.prototype, "isPanelless", void 0);
__decorate2([property()], ThemeModel.prototype, "groupAppearanceAdvancedMode", void 0);
__decorate2([property({
  onSet: (newValue, target) => {
    let basecolor = parseColor(target.questionPanel.backcolor).color;
    const newColor = ingectAlpha(basecolor, newValue / 100);
    if (target.questionPanel.backcolor !== newColor) {
      const newQuestionPanel = Object.assign({}, target.questionPanel);
      newQuestionPanel.backcolor = newColor;
      target.questionPanel = newQuestionPanel;
    }
  }
})], ThemeModel.prototype, "panelBackgroundTransparency", void 0);
__decorate2([property({
  onSet: (newValue, target) => {
    let basecolor = parseColor(target.editorPanel.backcolor).color;
    const newColor = ingectAlpha(basecolor, newValue / 100);
    if (target.editorPanel.backcolor !== newColor) {
      const newEditorPanel = Object.assign({}, target.editorPanel);
      newEditorPanel.backcolor = newColor;
      target.editorPanel = newEditorPanel;
    }
  }
})], ThemeModel.prototype, "questionBackgroundTransparency", void 0);
__decorate2([property()], ThemeModel.prototype, "scale", void 0);
__decorate2([property()], ThemeModel.prototype, "cornerRadius", void 0);
__decorate2([property()], ThemeModel.prototype, "fontSize", void 0);
__decorate2([property({
  onSet: (newValue, target) => {
    let opacity = parseColor(newValue.backcolor).opacity;
    if (target.panelBackgroundTransparency !== opacity) {
      target.panelBackgroundTransparency = opacity;
    }
  }
})], ThemeModel.prototype, "questionPanel", void 0);
__decorate2([property({
  onSet: (newValue, target) => {
    let opacity = parseColor(newValue.backcolor).opacity;
    if (target.questionBackgroundTransparency !== opacity) {
      target.questionBackgroundTransparency = opacity;
    }
  }
})], ThemeModel.prototype, "editorPanel", void 0);
var themeNameValues = PredefinedThemes.map((theme) => ({
  value: theme,
  text: getLocString("theme.names." + theme)
}));
Serializer.addClass("theme", [{
  type: "dropdown",
  name: "themeName",
  choices: themeNameValues,
  category: "general"
}, {
  type: "buttongroup",
  name: "colorPalette",
  displayName: "",
  choices: [{
    value: "light"
  }, {
    value: "dark"
  }],
  category: "general",
  enableIf: (obj) => {
    return !obj || obj.hasVariations(true);
  }
}, {
  type: "buttongroup",
  name: "isPanelless",
  choices: [{
    value: false
  }, {
    value: true
  }],
  category: "general",
  enableIf: (obj) => {
    return !obj || obj.hasVariations(false);
  }
}, {
  type: "spinedit",
  isSerializable: false,
  name: "scale",
  onPropertyEditorUpdate: function(obj, editor) {
    if (!!editor) {
      editor.unit = "%";
      editor.min = 0;
      editor.step = 5;
    }
  }
}, {
  type: "spinedit",
  isSerializable: false,
  name: "cornerRadius",
  onPropertyEditorUpdate: function(obj, editor) {
    if (!!editor) {
      editor.unit = "px";
      editor.min = 0;
    }
  }
}, {
  name: "advancedMode",
  type: "switchToggle",
  isSerializable: false,
  default: false,
  onPropertyEditorUpdate: function(obj, editor) {
    if (!!editor) {
      editor.titleLocation = "hidden";
      editor.renderAs = "switch";
    }
  }
}, {
  type: "spinedit",
  isSerializable: false,
  name: "fontSize",
  onPropertyEditorUpdate: function(obj, editor) {
    if (!!editor) {
      editor.unit = "%";
      editor.min = 0;
      editor.step = 5;
    }
  }
}, {
  type: "spinedit",
  isSerializable: false,
  name: "panelBackgroundTransparency",
  default: 100,
  onPropertyEditorUpdate: function(obj, editor) {
    if (!!editor) {
      editor.unit = "%";
      editor.min = 0;
      editor.max = 100;
      editor.step = 5;
    }
  }
}, {
  type: "spinedit",
  isSerializable: false,
  name: "questionBackgroundTransparency",
  default: 100,
  onPropertyEditorUpdate: function(obj, editor) {
    if (!!editor) {
      editor.unit = "%";
      editor.min = 0;
      editor.max = 100;
      editor.step = 5;
    }
  }
}, {
  type: "backgroundcornerradius",
  name: "editorPanel"
}, {
  type: "backgroundcornerradius",
  name: "questionPanel"
}], (json2) => {
  return new ThemeModel();
});
Serializer.addProperties("theme", [{
  name: "backgroundImage:file",
  onPropertyEditorUpdate: function(obj, editor) {
    if (!!editor) {
      editor.storeDataAsText = false;
      editor.acceptedTypes = "image/*";
    }
  }
}, {
  name: "backgroundImageFit",
  displayName: "",
  enableIf: function(obj) {
    return !!obj.backgroundImage;
  },
  choices: [{
    value: "auto"
  }, {
    value: "contain"
  }, {
    value: "cover"
  }],
  default: "cover"
}, {
  name: "backgroundImageAttachment",
  displayName: "",
  enableIf: function(obj) {
    return !!obj.backgroundImage;
  },
  choices: [{
    value: "fixed"
  }, {
    value: "scroll"
  }],
  default: "scroll"
}, {
  type: "spinedit",
  isSerializable: false,
  name: "backgroundOpacity",
  enableIf: function(obj) {
    return !!obj.backgroundImage;
  },
  default: 100,
  onPropertyEditorUpdate: function(obj, editor) {
    if (!!editor) {
      editor.unit = "%";
      editor.min = 0;
      editor.max = 100;
      editor.step = 5;
      editor.titleLocation = "left";
    }
  }
}, {
  type: "header",
  name: "header",
  isSerializable: false,
  onPropertyEditorUpdate: function(obj, editor) {
    if (!!editor) {
      const questions = editor.contentPanel.elements;
      const callback = (editor2) => {
        if (editor2.getType() === "panel") {
          editor2["elements"].forEach((el) => {
            callback(el);
          });
        }
        const obj2 = editor2.obj;
        if (!obj2) return;
        const property2 = editor2.property;
        if (!!property2 && property2.onPropertyEditorUpdate) {
          property2.onPropertyEditorUpdate(obj2, editor2);
        }
      };
      questions.forEach((question) => {
        callback(question);
      });
    }
  }
}, {
  type: "color",
  isSerializable: false,
  name: "primaryColor"
}, {
  type: "dropdown",
  name: "--sjs-font-family",
  default: settings2.themeEditor.defaultFontFamily,
  choices: [].concat(DefaultFonts),
  onPropertyEditorUpdate: function(obj, editor) {
    if (!!editor) {
      editor.allowClear = false;
      editor.choices = [].concat(DefaultFonts);
    }
  }
}, {
  name: "--sjs-font-size",
  visible: false,
  default: "16px"
}, {
  name: "--sjs-corner-radius",
  visible: false
}, {
  name: "--sjs-base-unit",
  visible: false
}, {
  name: "--sjs-corner-radius",
  visible: false
}, {
  type: "font",
  name: "pageTitle",
  default: {
    family: settings2.themeEditor.defaultFontFamily,
    weight: "700",
    size: 24
  }
}, {
  type: "font",
  name: "pageDescription",
  default: {
    family: settings2.themeEditor.defaultFontFamily,
    weight: "700",
    size: 24
  }
}, {
  type: "shadoweffects",
  name: "--sjs-shadow-small",
  onSetValue: function(obj, value) {
    obj.setPropertyValue("--sjs-shadow-small", trimBoxShadowValue(value));
  }
}, {
  type: "font",
  name: "questionTitle",
  default: {
    family: settings2.themeEditor.defaultFontFamily,
    weight: "600",
    size: 16
  }
}, {
  type: "font",
  name: "questionDescription",
  default: {
    family: settings2.themeEditor.defaultFontFamily,
    weight: "400",
    size: 16
  }
}, {
  type: "shadoweffects",
  name: "--sjs-shadow-inner",
  onSetValue: function(obj, value) {
    obj.setPropertyValue("--sjs-shadow-inner", trimBoxShadowValue(value));
  }
}, {
  type: "font",
  name: "editorFont",
  default: {
    family: settings2.themeEditor.defaultFontFamily,
    weight: "400",
    size: 16
  }
}, {
  type: "coloralpha",
  name: "--sjs-border-default",
  onPropertyEditorUpdate: function(obj, editor) {
    if (!!editor) {
      editor.colorTitle = getLocString("theme.borderDefault");
      editor.colorTitleLocation = "left";
    }
  }
}, {
  type: "coloralpha",
  name: "--sjs-border-light",
  displayName: "",
  onPropertyEditorUpdate: function(obj, editor) {
    if (!!editor) {
      editor.colorTitle = getLocString("theme.borderLight");
      editor.colorTitleLocation = "left";
    }
  }
}, {
  name: "--sjs-general-backcolor",
  visible: false
}, {
  name: "--sjs-general-backcolor-dark",
  visible: false
}, {
  name: "--sjs-general-backcolor-dim-light",
  visible: false
}, {
  name: "--sjs-general-backcolor-dim-dark",
  visible: false
}, {
  name: "--sjs-general-forecolor",
  visible: false
}, {
  name: "--sjs-general-forecolor-light",
  visible: false
}, {
  name: "--sjs-general-dim-forecolor",
  visible: false
}, {
  name: "--sjs-general-dim-forecolor-light",
  visible: false
}, {
  name: "--sjs-secondary-backcolor",
  visible: false
}, {
  name: "--sjs-secondary-backcolor-light",
  visible: false
}, {
  name: "--sjs-secondary-backcolor-semi-light",
  visible: false
}, {
  name: "--sjs-secondary-forecolor",
  visible: false
}, {
  name: "--sjs-secondary-forecolor-light",
  visible: false
}, {
  name: "--sjs-shadow-small-reset",
  visible: false,
  onSetValue: function(obj, value) {
    obj.setPropertyValue("--sjs-shadow-small-reset", trimBoxShadowValue(value));
  }
}, {
  name: "--sjs-shadow-medium",
  visible: false,
  onSetValue: function(obj, value) {
    obj.setPropertyValue("--sjs-shadow-medium", trimBoxShadowValue(value));
  }
}, {
  name: "--sjs-shadow-large",
  visible: false,
  onSetValue: function(obj, value) {
    obj.setPropertyValue("--sjs-shadow-large", trimBoxShadowValue(value));
  }
}, {
  name: "--sjs-shadow-inner-reset",
  visible: false,
  onSetValue: function(obj, value) {
    obj.setPropertyValue("--sjs-shadow-inner-reset", trimBoxShadowValue(value));
  }
}, {
  name: "--sjs-border-light",
  visible: false
}, {
  name: "--sjs-border-default",
  visible: false
}, {
  name: "--sjs-border-inside",
  visible: false
}, {
  name: "--sjs-special-red-forecolor",
  visible: false
}, {
  name: "--sjs-special-green",
  visible: false
}, {
  name: "--sjs-special-green-light",
  visible: false
}, {
  name: "--sjs-special-green-forecolor",
  visible: false
}, {
  name: "--sjs-special-blue",
  visible: false
}, {
  name: "--sjs-special-blue-light",
  visible: false
}, {
  name: "--sjs-special-blue-forecolor",
  visible: false
}, {
  name: "--sjs-special-yellow",
  visible: false
}, {
  name: "--sjs-special-yellow-light",
  visible: false
}, {
  name: "--sjs-special-yellow-forecolor",
  visible: false
}, {
  name: "--sjs-article-font-xx-large-textDecoration",
  visible: false
}, {
  name: "--sjs-article-font-xx-large-fontWeight",
  visible: false
}, {
  name: "--sjs-article-font-xx-large-fontStyle",
  visible: false
}, {
  name: "--sjs-article-font-xx-large-fontStretch",
  visible: false
}, {
  name: "--sjs-article-font-xx-large-letterSpacing",
  visible: false
}, {
  name: "--sjs-article-font-xx-large-lineHeight",
  visible: false
}, {
  name: "--sjs-article-font-xx-large-paragraphIndent",
  visible: false
}, {
  name: "--sjs-article-font-xx-large-textCase",
  visible: false
}, {
  name: "--sjs-article-font-x-large-textDecoration",
  visible: false
}, {
  name: "--sjs-article-font-x-large-fontWeight",
  visible: false
}, {
  name: "--sjs-article-font-x-large-fontStyle",
  visible: false
}, {
  name: "--sjs-article-font-x-large-fontStretch",
  visible: false
}, {
  name: "--sjs-article-font-x-large-letterSpacing",
  visible: false
}, {
  name: "--sjs-article-font-x-large-lineHeight",
  visible: false
}, {
  name: "--sjs-article-font-x-large-paragraphIndent",
  visible: false
}, {
  name: "--sjs-article-font-x-large-textCase",
  visible: false
}, {
  name: "--sjs-article-font-large-textDecoration",
  visible: false
}, {
  name: "--sjs-article-font-large-fontWeight",
  visible: false
}, {
  name: "--sjs-article-font-large-fontStyle",
  visible: false
}, {
  name: "--sjs-article-font-large-fontStretch",
  visible: false
}, {
  name: "--sjs-article-font-large-letterSpacing",
  visible: false
}, {
  name: "--sjs-article-font-large-lineHeight",
  visible: false
}, {
  name: "--sjs-article-font-large-paragraphIndent",
  visible: false
}, {
  name: "--sjs-article-font-large-textCase",
  visible: false
}, {
  name: "--sjs-article-font-medium-textDecoration",
  visible: false
}, {
  name: "--sjs-article-font-medium-fontWeight",
  visible: false
}, {
  name: "--sjs-article-font-medium-fontStyle",
  visible: false
}, {
  name: "--sjs-article-font-medium-fontStretch",
  visible: false
}, {
  name: "--sjs-article-font-medium-letterSpacing",
  visible: false
}, {
  name: "--sjs-article-font-medium-lineHeight",
  visible: false
}, {
  name: "--sjs-article-font-medium-paragraphIndent",
  visible: false
}, {
  name: "--sjs-article-font-medium-textCase",
  visible: false
}, {
  name: "--sjs-article-font-default-textDecoration",
  visible: false
}, {
  name: "--sjs-article-font-default-fontWeight",
  visible: false
}, {
  name: "--sjs-article-font-default-fontStyle",
  visible: false
}, {
  name: "--sjs-article-font-default-fontStretch",
  visible: false
}, {
  name: "--sjs-article-font-default-letterSpacing",
  visible: false
}, {
  name: "--sjs-article-font-default-lineHeight",
  visible: false
}, {
  name: "--sjs-article-font-default-paragraphIndent",
  visible: false
}, {
  name: "--sjs-article-font-default-textCase",
  visible: false
}, {
  type: "color",
  name: "--sjs-general-backcolor-dim"
}, {
  type: "coloralpha",
  name: "--sjs-primary-backcolor",
  onPropertyEditorUpdate: function(obj, editor) {
    if (!!editor) {
      editor.colorTitle = getLocString("theme.primaryDefaultColor");
      editor.colorTitleLocation = "left";
    }
  }
}, {
  type: "coloralpha",
  name: "--sjs-primary-backcolor-dark",
  displayName: "",
  onPropertyEditorUpdate: function(obj, editor) {
    if (!!editor) {
      editor.colorTitle = getLocString("theme.primaryDarkColor");
      editor.colorTitleLocation = "left";
    }
  }
}, {
  type: "coloralpha",
  name: "--sjs-primary-backcolor-light",
  displayName: "",
  onPropertyEditorUpdate: function(obj, editor) {
    if (!!editor) {
      editor.colorTitle = getLocString("theme.primaryLightColor");
      editor.colorTitleLocation = "left";
    }
  }
}, {
  type: "coloralpha",
  name: "--sjs-primary-forecolor",
  onPropertyEditorUpdate: function(obj, editor) {
    if (!!editor) {
      editor.colorTitle = getLocString("theme.primaryForecolor");
      editor.colorTitleLocation = "left";
    }
  }
}, {
  type: "coloralpha",
  name: "--sjs-primary-forecolor-light",
  displayName: "",
  onPropertyEditorUpdate: function(obj, editor) {
    if (!!editor) {
      editor.colorTitle = getLocString("theme.primaryForecolorLight");
      editor.colorTitleLocation = "left";
    }
  }
}, {
  type: "coloralpha",
  name: "--sjs-special-red",
  onPropertyEditorUpdate: function(obj, editor) {
    if (!!editor) {
      editor.colorTitle = getLocString("theme.fontColor");
      editor.colorTitleLocation = "left";
    }
  }
}, {
  type: "coloralpha",
  name: "--sjs-special-red-light",
  displayName: "",
  onPropertyEditorUpdate: function(obj, editor) {
    if (!!editor) {
      editor.colorTitle = getLocString("theme.backgroundColor");
      editor.colorTitleLocation = "left";
    }
  }
}]);
var PreviewViewModel = class _PreviewViewModel extends Base {
  get activeLanguage() {
    return this.getPropertyValue("activeLanguage", this.survey.locale || surveyLocalization.defaultLocale);
  }
  set activeLanguage(val) {
    if (val === this.activeLanguage) return;
    this.setPropertyValue("activeLanguage", val);
    this.survey.locale = val;
  }
  get survey() {
    return this.simulator.survey;
  }
  get pageActions() {
    return this.pages.actions;
  }
  get isPageToolbarVisible() {
    return this.pages.visibleActions.length > 0 && !this.surveyProvider.isMobileView;
  }
  constructor(surveyProvider, startThemeClasses = defaultCss) {
    super();
    this.surveyProvider = surveyProvider;
    this.startThemeClasses = startThemeClasses;
    this.enableInvisiblePages = true;
    this.pages = new ActionContainer();
    this.simulator = new SurveySimulatorModel(surveyProvider);
    this.pages.cssClasses = {
      root: "sv-action-bar svc-pages-toolbar",
      item: "svc-preview-pager__item",
      itemActive: "svc-preview-pager__item--active",
      itemPressed: "svc-preview-pager__item--pressed",
      itemAsIcon: "svc-preview-pager__item--icon",
      itemIcon: "svc-preview-pager-item__icon",
      itemTitle: "svc-preview-pager-item__title"
    };
  }
  get isMobileView() {
    return this.surveyProvider.isMobileView;
  }
  get showResults() {
    return this.getShowResults();
  }
  updateSimulatorSurvey(json2, theme) {
    const newSurvey = this.surveyProvider.createSurvey(json2 || {}, this.getTabName(), this, (survey) => {
      let preferredTheme = void 0;
      if (isThemeEmpty(this.surveyProvider.theme)) {
        preferredTheme = findSuitableTheme(void 0, this.surveyProvider.preferredColorPalette, void 0, void 0);
      }
      survey.applyTheme(preferredTheme || this.surveyProvider.theme);
      survey.setCss(theme, false);
      survey.fitToContainer = true;
      survey.addLayoutElement({
        id: "complete-customization",
        container: "completePage",
        component: "svc-complete-page",
        data: this
      });
    });
    const hasSurveyBefore = !!this.simulator.survey;
    this.simulator.survey = newSurvey;
    if (this.onSurveyCreatedCallback) this.onSurveyCreatedCallback(this.survey);
    this.survey.onComplete.add((sender) => {
      this.isRunning = false;
    });
    if (!!this.survey["onNavigateToUrl"]) {
      this.survey["onNavigateToUrl"].add((sender, options) => {
        const url = options.url;
        options.url = "";
        if (!!url && options.allow) {
          const message = getLocString("ed.navigateToMsg") + " '" + url + "'.";
          if (!!this.surveyProvider) {
            this.surveyProvider.notify(message);
          } else {
            alert(message);
          }
        }
      });
    }
    this.survey.onStarted.add((sender) => {
      this.setActivePageItem(this.simulator.survey.activePage, true);
    });
    this.survey.onCurrentPageChanged.add((sender, options) => {
      this.activePage = options.newCurrentPage;
      this.setActivePageItem(options.oldCurrentPage, false);
      this.setActivePageItem(options.newCurrentPage, true);
    });
    this.survey.onPageVisibleChanged.add((sender, options) => {
      this.updatePageItem(options.page);
      this.updatePrevNextPageActionState();
    });
    if (hasSurveyBefore) {
      this.show();
    }
  }
  setJSON(json2, currTheme) {
    this.json = json2;
    if (json2 != null) {
      if (json2.cookieName) {
        delete json2.cookieName;
      }
    }
    this.updateSimulatorSurvey(json2, currTheme);
  }
  initialize(json2, options) {
    this.setJSON(json2, this.startThemeClasses);
    this.updatePageList();
    if (options.showPagesInTestSurveyTab !== void 0) {
      this.showPagesInTestSurveyTab = options.showPagesInTestSurveyTab;
    }
    this.buildActions();
  }
  updatePageItem(page) {
    const item = this.getPageItemByPage(page);
    if (item) {
      item.enabled = this.enableInvisiblePages && this.showInvisibleElements || page.isVisible;
    }
  }
  getCurrentPageItem() {
    return this.pageListItems[this.survey.pages.indexOf(this.survey.activePage)];
  }
  getSelectPageTitle() {
    return this.activePage && this.getPageTitle(this.activePage, "preview-tab:selected-page", "survey-tester-selected") || getLocString("ts.selectPage");
  }
  getPageTitle(page, area = "preview-tab:page-list", reason = "survey-tester") {
    const pageTitle = page.title.replace(_PreviewViewModel.tagRegex, "");
    let title = this.surveyProvider.getObjectDisplayName(page, area, reason, pageTitle);
    if (title === page.name && title.indexOf("page") === 0) {
      const index = this.survey.pages.indexOf(page);
      return editorLocalization.getString("ed.pageTypeName") + " " + (index + 1);
    }
    return title;
  }
  updatePageList() {
    const pages = [];
    for (let i = 0; i < this.survey.pages.length; i++) {
      const page = this.survey.pages[i];
      const pageItem = {
        id: page.name,
        data: page,
        title: this.getPageTitle(page),
        enabled: this.enableInvisiblePages && this.showInvisibleElements || page.isVisible,
        visible: true
      };
      if (!page.isVisible) {
        pageItem.css = "svc-page-invisible";
        pageItem.markerIconName = "icon-invisible-items";
      }
      pages.push(pageItem);
    }
    this.pageListItems = pages;
  }
  getTabName() {
    return "";
  }
  getShowResults() {
    return false;
  }
  show() {
    this.showInvisibleElements = false;
    this.activePage = this.survey.activePage;
    this.survey.locale = this.activeLanguage;
    this.isRunning = true;
  }
  testAgain() {
    this.setJSON(this.json, this.simulator.survey.css);
    this.updatePageList();
    this.show();
  }
  isSurveyRunning() {
    var _a;
    const state = (_a = this.survey) === null || _a === void 0 ? void 0 : _a.state;
    return state === "running" || state === "starting";
  }
  buildActions() {
    const pageActions = [];
    const setNearPage = (isNext) => {
      const currentIndex = this.survey.currentPageNo;
      const shift = isNext ? 1 : -1;
      let newIndex = currentIndex + shift;
      if (this.survey.state === "starting" && isNext) {
        newIndex = 0;
      }
      let nearPage = this.showInvisibleElements ? this.survey.pages[newIndex] : this.survey.visiblePages[newIndex];
      if (!isNext && currentIndex === 0 && this.survey.firstPageIsStartPage && this.survey.pages.length > 0) {
        nearPage = this.survey.pages[0];
      }
      const pageIndex = this.survey.pages.indexOf(nearPage);
      this.activePage = this.survey.pages[pageIndex];
      this.selectPageAction.data.selectedItem = this.pageListItems[pageIndex];
    };
    if (this.prevPageAction) {
      this.prevPageAction.visible = new ComputedUpdater(() => {
        const isRunning = this.isSurveyRunning();
        const isActiveTab = this.getTabName() === this.surveyProvider.activeTab;
        return notShortCircuitAnd(this.isRunning, isActiveTab, this.pageListItems.length > 1) && isRunning;
      });
      this.prevPageAction.iconName = new ComputedUpdater(() => {
        return this.surveyProvider.isMobileView ? "icon-arrow-left" : "icon-arrow-left_16x16";
      });
      this.prevPageAction.action = () => setNearPage(false);
      pageActions.push(this.prevPageAction);
    }
    this.selectPageAction = createDropdownActionModel({
      id: "pageSelector",
      css: "svc-page-selector",
      title: this.getSelectPageTitle(),
      visible: this.isRunning && this.pageListItems.length > 1 && this.showPagesInTestSurveyTab
    }, {
      items: this.pageListItems,
      allowSelection: true,
      selectedItem: this.getCurrentPageItem(),
      onSelectionChanged: (item) => {
        this.activePage = item.data;
        for (let i = 0; i < this.survey.pages.length && this.survey.pages[i] !== this.activePage; i++) {
          this.survey.pages[i].passed = true;
        }
      },
      cssClass: "svc-creator-popup",
      cssClasses: listComponentCss,
      verticalPosition: "top",
      horizontalPosition: "center"
    });
    pageActions.push(this.selectPageAction);
    this.selectPageAction.visible = new ComputedUpdater(() => {
      return this.isSurveyRunning();
    });
    if (this.nextPageAction) {
      this.nextPageAction.visible = new ComputedUpdater(() => {
        const isRunning = this.isSurveyRunning();
        const isActiveTab = this.getTabName() === this.surveyProvider.activeTab;
        return notShortCircuitAnd(this.isRunning, isActiveTab, this.pageListItems.length > 1) && isRunning;
      });
      this.nextPageAction.iconName = new ComputedUpdater(() => {
        return this.surveyProvider.isMobileView ? "icon-arrow-right" : "icon-arrow-right_16x16";
      });
      this.nextPageAction.action = () => setNearPage(true);
      pageActions.push(this.nextPageAction);
    }
    this.pages.actions = pageActions;
    this.pages.containerCss = "sv-action-bar--pages";
    this.updatePrevNextPageActionState();
  }
  setActivePageItem(page, val) {
    const item = this.getPageItemByPage(page);
    if (item) {
      item.active = val;
    }
  }
  getPageItemByPage(page) {
    const model = this.selectPageAction.popupModel.contentComponentData.model;
    if (!model || !Array.isArray(model.actions)) return void 0;
    const items = model.actions;
    for (let i = 0; i < items.length; i++) {
      if (items[i].data === page) return items[i];
    }
    return null;
  }
  updateResultsTemplate(theme) {
    this.simulator.survey.setCss(theme, false);
    this.simulator.survey.render();
  }
  setTheme(themeName, themeMapper) {
    const availableThemes = themeMapper.filter((item) => item.name === themeName);
    let theme = defaultCss;
    if (availableThemes.length > 0) {
      theme = availableThemes[0].theme;
    }
    this.isRunning ? this.updateSimulatorSurvey(this.json, theme) : this.updateResultsTemplate(theme);
  }
  onPropertyValueChanged(name, oldValue, newValue) {
    super.onPropertyValueChanged(name, oldValue, newValue);
    if (!this.pages.hasActions) return;
    if (name === "activePage") {
      this.updatePrevNextPageActionState();
      this.selectPageAction.title = this.getSelectPageTitle();
    }
    if (name === "isRunning" || name === "pageListItems" || name === "showPagesInTestSurveyTab") {
      this.selectPageAction.popupModel.contentComponentData.model.items = this.pageListItems;
      this.selectPageAction.popupModel.contentComponentData.model.selectedItem = this.getCurrentPageItem();
      this.selectPageAction.visible = this.isRunning && this.pageListItems.length > 1 && this.showPagesInTestSurveyTab;
    }
  }
  updatePrevNextPageActionState() {
    if (!this.prevPageAction || !this.survey) return;
    const isPrevEnabled = this.survey.firstPageIsStartPage && this.survey.state !== "starting" || !this.survey.firstPageIsStartPage && !this.survey.isFirstPage;
    this.prevPageAction.enabled = isPrevEnabled;
    const isNextEnabled = this.survey && this.survey.visiblePages.indexOf(this.activePage) !== this.survey.visiblePages.length - 1;
    this.nextPageAction.enabled = isNextEnabled;
  }
  get placeholderTitleText() {
    if (this.isMobileView) return getLocString("ed.previewPlaceholderTitleMobile");
    return getLocString("ed.previewPlaceholderTitle");
  }
  get placeholderDescriptionText() {
    if (this.isMobileView) return getLocString("ed.previewPlaceholderDescriptionMobile");
    return getLocString("ed.previewPlaceholderDescription");
  }
  onScroll() {
    this.survey.onScroll();
    return true;
  }
  dispose() {
    if (this.selectPageAction) {
      this.selectPageAction.dispose();
    }
    this.simulator.dispose();
    super.dispose();
  }
};
PreviewViewModel.tagRegex = /(<([^>]+)>)/ig;
__decorate2([property({
  defaultValue: false,
  onSet: (val, target) => {
    target.simulator.survey.showInvisibleElements = val;
  }
})], PreviewViewModel.prototype, "showInvisibleElements", void 0);
__decorate2([property({
  defaultValue: true
})], PreviewViewModel.prototype, "showPagesInTestSurveyTab", void 0);
__decorate2([property({
  defaultValue: true,
  onSet: (value, target) => {
    if (!!target.simulator) target.simulator.isRunning = value;
  }
})], PreviewViewModel.prototype, "isRunning", void 0);
__decorate2([propertyArray()], PreviewViewModel.prototype, "pageListItems", void 0);
__decorate2([property({
  onSet: (val, target) => {
    if (!!val) {
      const survey = target.simulator.survey;
      if (survey.firstPageIsStartPage) {
        if (val === survey.pages[0]) {
          survey.clear(false, true);
        } else {
          if (survey.state == "starting") {
            survey.setPropertyValue("isStartedState", false);
          }
        }
      }
      if (survey.state !== "starting") {
        survey.currentPage = val;
      }
    }
    target.updatePrevNextPageActionState();
  }
})], PreviewViewModel.prototype, "activePage", void 0);
var TestSurveyTabViewModel = class extends PreviewViewModel {
  constructor(surveyProvider, startThemeClasses) {
    super(surveyProvider, startThemeClasses);
  }
  getTabName() {
    return "preview";
  }
  getShowResults() {
    return this.surveyProvider.previewShowResults && !this.isRunning && !this.isMobileView;
  }
};
var TabTestPlugin = class {
  get previewDevice() {
    if (!!this.model) {
      this._previewDevice = this.model.simulator.device;
    }
    return this._previewDevice;
  }
  set previewDevice(newValue) {
    this.setDevice(newValue);
  }
  setDevice(newValue) {
    this._previewDevice = newValue || "desktop";
    if (!!this.model) {
      this.model.simulator.device = newValue;
      this.model.simulator.resetZoomParameters();
    }
    let currentType = simulatorDevices[this._previewDevice].deviceType;
    this.orientationSelectorAction.enabled = currentType != "desktop";
    this.deviceSelectorAction.iconName = "icon-device-" + currentType;
    this.deviceSelectorAction.title = getLocString("pe.simulator");
    this.deviceSelectorAction.data.selectedItem = {
      id: this._previewDevice
    };
  }
  setDefaultLanguageOption(opt) {
    const vis = opt === true || opt === "all" || opt === "auto" && this.model.survey.getUsedLocales().length > 1;
    this.languageSelectorAction.visible = vis;
    let languages = [];
    if (vis) {
      languages = this.getLanguages(opt !== "all" ? this.model.survey.getUsedLocales() : null);
    }
    this.languageSelectorAction.popupModel.contentComponentData.model.setItems(languages);
    this.languageSelectorAction.data.selectedItem = languages.filter((lang) => lang.id === this.model.activeLanguage)[0];
  }
  getLanguages(usedLanguages = null) {
    const res = [];
    const locales = !!usedLanguages && usedLanguages.length > 1 ? usedLanguages : surveyLocalization.getLocales();
    for (let i = 0; i < locales.length; i++) {
      const loc = locales[i];
      res.push({
        id: loc,
        title: editorLocalization.getLocaleName(loc)
      });
    }
    return res;
  }
  updateActions() {
    this.languageSelectorAction.title = editorLocalization.getLocaleName(this.model.activeLanguage);
    this.languageSelectorAction.visible = true;
    if (this.creator.showSimulatorInTestSurveyTab) {
      this.setDevice(this.model.simulator.device);
      this.deviceSelectorAction.data.selectedItem = {
        id: this.model.simulator.device
      };
      this.orientationSelectorAction.title = getLocString("pe.portraitOrientation");
    }
    if (this.creator.showInvisibleElementsInTestSurveyTab) {
      this.invisibleToggleAction.active = this.model.showInvisibleElements;
      this.invisibleToggleAction.visible = this.model.isRunning;
    }
    if (this.creator.showDefaultLanguageInTestSurveyTab != void 0) {
      this.setDefaultLanguageOption(this.creator.showDefaultLanguageInTestSurveyTab);
    }
  }
  setPreviewTheme(themeName) {
    this.simulatorTheme = surveyCss[themeName] || surveyCss[defaultThemeName];
  }
  createVisibleUpdater() {
    return new ComputedUpdater(() => {
      return this.creator.activeTab === "preview";
    });
  }
  constructor(creator) {
    this.creator = creator;
    this.simulatorTheme = surveyCss[defaultThemeName];
    this._previewDevice = "";
    creator.addTab({
      name: "preview",
      plugin: this,
      iconName: "icon-preview"
    });
    this.setPreviewTheme(this.creator.previewTheme);
    this.createActions().forEach((action) => creator.toolbar.actions.push(action));
  }
  activate() {
    const tabModel = new TestSurveyTabViewModel(this.creator, this.simulatorTheme);
    tabModel.simulator.device = this.previewDevice || this.creator.previewDevice || "desktop";
    tabModel.simulator.landscape = this.creator.previewOrientation != "portrait";
    this.model = tabModel;
    this.update();
  }
  update() {
    if (!this.model) return;
    const options = {
      showPagesInTestSurveyTab: this.creator.showPagesInTestSurveyTab
    };
    this.testAgainAction.locStrsChanged();
    this.model.testAgainAction = this.testAgainAction;
    this.model.prevPageAction = this.prevPageAction;
    this.model.nextPageAction = this.nextPageAction;
    this.model.initialize(this.creator.JSON, options);
    this.updateActions();
    this.model.show();
    this.model.onPropertyChanged.add((sender, options2) => {
      if (options2.name === "isRunning") {
        this.invisibleToggleAction && (this.invisibleToggleAction.visible = this.model.isRunning);
        this.testAgainAction.visible = !this.model.isRunning;
      }
    });
  }
  deactivate() {
    if (this.model) {
      this._previewDevice = this.model.simulator.device;
      this.simulatorTheme = this.model.simulator.survey.css;
      this.model.onSurveyCreatedCallback = void 0;
      this.model.dispose();
      this.model = void 0;
    }
    this.languageSelectorAction.visible = false;
    this.testAgainAction.visible = false;
    this.invisibleToggleAction && (this.invisibleToggleAction.visible = false);
    return true;
  }
  createActions() {
    const items = [];
    this.testAgainAction = new Action({
      id: "testSurveyAgain",
      visible: false,
      locTitleName: "ed.testSurveyAgain",
      action: () => {
        this.model.testAgain();
      }
    });
    if (this.creator.showSimulatorInTestSurveyTab) {
      const deviceSelectorItems = Object.keys(simulatorDevices).filter((key) => !!simulatorDevices[key].title).map((key) => {
        var _a;
        return {
          id: key,
          title: simulatorDevices[key].title,
          visibleIndex: (_a = simulatorDevices[key].visibleIndex) !== null && _a !== void 0 ? _a : Number.MAX_VALUE
        };
      });
      this.deviceSelectorAction = createDropdownActionModel({
        id: "deviceSelector",
        iconName: "icon-device-desktop",
        iconSize: "auto",
        mode: "small",
        visible: new ComputedUpdater(() => {
          return notShortCircuitAnd(this.creator.activeTab === "preview", this.creator.showSimulatorInTestSurveyTab, !this.creator.isTouch);
        })
      }, {
        items: deviceSelectorItems,
        allowSelection: true,
        onSelectionChanged: (item) => {
          this.setDevice(item.id);
        },
        horizontalPosition: "center",
        cssClass: "svc-creator-popup",
        cssClasses: listComponentCss,
        onHide: () => {
          this.deviceSelectorAction.enabled = true;
        },
        onShow: () => {
          this.deviceSelectorAction.enabled = false;
        }
      });
      items.push(this.deviceSelectorAction);
      this.orientationSelectorAction = new Action({
        id: "orientationSelector",
        iconName: "icon-device-rotate",
        iconSize: "auto",
        mode: "small",
        visible: new ComputedUpdater(() => {
          return notShortCircuitAnd(this.creator.activeTab === "preview", this.creator.showSimulatorInTestSurveyTab, !this.creator.isTouch);
        }),
        action: () => {
          this.model.simulator.landscape = !this.model.simulator.landscape;
          this.orientationSelectorAction.title = getLocString(!this.model.simulator.landscape ? "pe.landscapeOrientation" : "pe.portraitOrientation");
        }
      });
      items.push(this.orientationSelectorAction);
    }
    if (this.creator.showInvisibleElementsInTestSurveyTab) {
      this.invisibleToggleAction = new Action({
        id: "showInvisible",
        iconName: "icon-invisible-items",
        iconSize: "auto",
        mode: "small",
        needSeparator: new ComputedUpdater(() => {
          return !this.creator.isMobileView;
        }),
        locTitleName: "ts.showInvisibleElements",
        visible: false,
        action: () => {
          this.model.showInvisibleElements = !this.model.showInvisibleElements;
          this.invisibleToggleAction.active = !this.invisibleToggleAction.active;
          this.invisibleToggleAction.title = getLocString(!this.model.showInvisibleElements ? "ts.showInvisibleElements" : "ts.hideInvisibleElements");
        }
      });
      items.push(this.invisibleToggleAction);
    }
    this.languageSelectorAction = createDropdownActionModel({
      id: "languageSelector",
      iconName: "icon-language",
      iconSize: "auto",
      visible: false,
      mode: new ComputedUpdater(() => {
        return this.creator.isMobileView ? "small" : "large";
      })
    }, {
      items: [],
      allowSelection: true,
      onSelectionChanged: (item) => {
        this.model.activeLanguage = item.id;
        this.languageSelectorAction.title = editorLocalization.getLocaleName(item.id);
      },
      horizontalPosition: "center",
      cssClass: "svc-creator-popup",
      cssClasses: listComponentCss,
      onHide: () => {
        this.languageSelectorAction.enabled = true;
      },
      onShow: () => {
        this.languageSelectorAction.enabled = false;
      }
    });
    items.push(this.languageSelectorAction);
    this.designerAction = new Action({
      id: "svd-designer",
      iconName: "icon-config",
      iconSize: "auto",
      action: () => {
        this.creator.switchTab("designer");
      },
      visible: this.createVisibleUpdater(),
      locTitleName: "ed.designer",
      showTitle: false
    });
    this.previewAction = new Action({
      id: "svd-preview",
      iconName: "icon-preview",
      iconSize: "auto",
      active: true,
      visible: this.createVisibleUpdater(),
      locTitleName: "tabs.preview",
      showTitle: false,
      action: () => {
      }
    });
    this.prevPageAction = new Action({
      id: "prevPage",
      iconName: "icon-arrow-left_16x16",
      iconSize: "auto",
      needSeparator: new ComputedUpdater(() => {
        return this.creator.isMobileView;
      }),
      visible: false
    });
    this.nextPageAction = new Action({
      id: "nextPage",
      iconName: "icon-arrow-right_16x16",
      iconSize: "auto",
      visible: false
    });
    return items;
  }
  addFooterActions() {
    this.creator.footerToolbar.actions.push(this.designerAction);
    this.creator.footerToolbar.actions.push(this.previewAction);
    this.creator.footerToolbar.actions.push(this.prevPageAction);
    this.creator.footerToolbar.actions.push(this.nextPageAction);
    this.invisibleToggleAction && this.creator.footerToolbar.actions.push(this.invisibleToggleAction);
  }
};
var ExpressionToDisplayText = class _ExpressionToDisplayText {
  constructor(survey, options = null) {
    this.survey = survey;
    this.options = options;
  }
  toDisplayText(expression) {
    if (!this.survey) return expression;
    this.showTitles = !!this.options && (this.options.useElementTitles == true || this.options.showTitlesInExpressions == true);
    var parser = new ConditionsParser();
    var node = parser.parseExpression(expression);
    if (!node) return expression;
    if (!!node["getType"]) return this.toDisplayTextCore(node);
    if (!this.showTitles) return expression;
    var variables = [];
    node.setVariables(variables);
    return this.replaceVariables(expression, variables);
  }
  toExpression(node) {
    return this.toDisplayTextCore(node);
  }
  toDisplayTextCore(node) {
    this.currentQuestion = null;
    var self2 = this;
    var isRoot = true;
    var strFunc = function(op) {
      var locIsRoot = isRoot;
      isRoot = false;
      if (self2.showTitles && op.getType() == "variable") {
        return self2.getQuestionText(op);
      }
      if (self2.showTitles && op.getType() == "const") {
        return self2.getDisplayText(op);
      }
      if (op.getType() == "binary") {
        self2.proceedBinary(op);
        return self2.getDisplayBinary(op, locIsRoot, strFunc);
      }
      if (op.getType() == "unary") {
        return self2.getDisplayUnary(op, strFunc);
      }
      return void 0;
    };
    return node.toString(strFunc);
  }
  getQuestionText(op) {
    var question = this.getQuestionByName(op.variable);
    if (!question || !question.title) return op.variable;
    return wrapTextByCurlyBraces(question.title);
  }
  getDisplayText(op) {
    if (!this.currentQuestion) return void 0;
    var res = this.currentQuestion.getDisplayValue(true, op.correctValue);
    return !!res ? new Const(res).toString() : void 0;
  }
  getDisplayOperand(op, func) {
    return !!op ? op.toString(func) : "";
  }
  getDisplayOperator(operator) {
    var res = _ExpressionToDisplayText.operatorText[operator];
    if (!!res) return res;
    return editorLocalization.getString("op." + operator);
  }
  getDisplayBinary(op, isRoot, func) {
    return (isRoot ? "" : "(") + this.getDisplayOperand(op.leftOperand, func) + " " + this.getDisplayOperator(op.operator) + " " + this.getDisplayOperand(op.rightOperand, func) + (isRoot ? "" : ")");
  }
  getDisplayUnary(op, func) {
    var exp = op.expression.toString(func);
    var operator = this.getDisplayOperator(op.operator);
    if (op.operator == "empty" || op.operator == "notempty") return exp + " " + operator;
    return operator + " " + exp;
  }
  proceedBinary(op) {
    if (op.isArithmetic || op.isConjunction) {
      this.currentQuestion = null;
      return;
    }
    this.currentQuestion = this.getQuestionFromOperands(op.leftOperand, op.rightOperand);
    if (!this.currentQuestion) {
      this.currentQuestion = this.getQuestionFromOperands(op.rightOperand, op.leftOperand);
    }
  }
  getQuestionFromOperands(op1, op2) {
    if (!op1 || !op2) return null;
    if (op1.getType() != "variable") return null;
    var op2Type = op2.getType();
    if (op2Type != "const" && op2Type != "function" && op2Type != "array") return null;
    return this.getQuestionByName(op1.variable);
  }
  replaceVariables(expression, variables) {
    for (var i = 0; i < variables.length; i++) {
      expression = this.replaceVariable(expression, variables[i]);
    }
    return expression;
  }
  replaceVariable(expression, variable) {
    var question = this.getQuestionByName(variable);
    if (!question || !question.title) return expression;
    return expression.replace(wrapTextByCurlyBraces(variable), wrapTextByCurlyBraces(question.title));
  }
  getQuestionByName(name) {
    if (!this.survey) return null;
    return this.survey.getQuestionByValueName(name);
  }
};
ExpressionToDisplayText.operatorText = {
  less: "<",
  lessorequal: "<=",
  greater: ">",
  greaterorequal: ">=",
  equal: "==",
  notequal: "!=",
  plus: "+",
  minus: "-",
  mul: "*",
  div: "/",
  power: "^",
  mod: "%",
  negate: "!"
};
var ExpressionRemoveVariable = class {
  constructor() {
  }
  remove(expression, variable) {
    var parser = new ConditionsParser();
    var node = parser.parseExpression(expression);
    if (!node) return expression;
    this.wasRemoved = false;
    if (!!node["getType"]) {
      var op = this.processOperand(node, variable);
      if (!this.wasRemoved) return expression;
      return !!op ? op.toString() : "";
    }
    return expression;
  }
  processOperand(op, variable) {
    if (!op) return null;
    if (op.getType() == "variable") {
      return this.processVariable(op, variable);
    }
    if (op.getType() == "unary") {
      return this.processUnary(op, variable);
    }
    if (op.getType() == "binary") {
      return this.proceedBinary(op, variable);
    }
    return op;
  }
  processVariable(op, variable) {
    if (op.variable !== variable) return op;
    this.wasRemoved = true;
    return null;
  }
  processUnary(op, variable) {
    var expression = this.processOperand(op.expression, variable);
    if (!!expression) return op;
    this.wasRemoved = true;
    return null;
  }
  proceedBinary(op, variable) {
    var left = this.processOperand(op.leftOperand, variable);
    var right = this.processOperand(op.rightOperand, variable);
    if (!!left && !!right) {
      if (left !== op.leftOperand || right !== op.rightOperand) return new BinaryOperand(op.operator, left, right, op.isArithmetic);
      return op;
    }
    if (!left && !right) return null;
    var res = !!left ? left : right;
    return res.getType() == "binary" ? res : null;
  }
};
var SurveyLogicExpressionUpdater = class _SurveyLogicExpressionUpdater {
  constructor(expresion) {
    this.constChanges = [];
    this.operand = new ConditionsParser().parseExpression(expresion);
  }
  update(varName, oldValue, newValue) {
    this.updateOperand(this.operand, varName.toLocaleLowerCase(), oldValue, newValue);
  }
  get isModified() {
    return this.constChanges.length > 0;
  }
  toString() {
    var self2 = this;
    var isRoot = true;
    var strFunc = function(op) {
      var locIsRoot = isRoot;
      isRoot = false;
      if (op.getType() === "const") {
        return self2.constToString(op);
      }
      if (op.getType() === "binary") {
        return self2.binaryToString(op, locIsRoot, strFunc);
      }
      return void 0;
    };
    return this.operand.toString(strFunc);
  }
  constToString(op) {
    for (var i = 0; i < this.constChanges.length; i++) {
      if (this.constChanges[i].op === op) return this.constChanges[i].val;
    }
    return op.toString();
  }
  binaryToString(op, isRoot, func) {
    return (isRoot ? "" : "(") + this.operandToString(op.leftOperand, func) + " " + this.operatorToString(op.operator) + " " + this.operandToString(op.rightOperand, func) + (isRoot ? "" : ")");
  }
  operandToString(op, func) {
    return !!op ? op.toString(func) : "";
  }
  operatorToString(operator) {
    var res = _SurveyLogicExpressionUpdater.operatorText[operator];
    return !!res ? res : operator;
  }
  updateOperand(op, varName, oldValue, newValue) {
    if (op.getType() == "binary") {
      const bOP = op;
      if (bOP.isConjunction) {
        this.updateOperand(bOP.leftOperand, varName, oldValue, newValue);
        this.updateOperand(bOP.rightOperand, varName, oldValue, newValue);
      } else {
        if (this.hasVarName(bOP.leftOperand, varName)) {
          this.updateOperandConst(bOP.rightOperand, oldValue, newValue);
        } else {
          if (this.hasVarName(bOP.rightOperand, varName)) {
            this.updateOperandConst(bOP.leftOperand, oldValue, newValue);
          }
        }
      }
    }
  }
  hasVarName(op, varName) {
    if (!op || op.getType() !== "variable") return;
    return op.variable.toLowerCase() === varName;
  }
  updateOperandConst(op, oldValue, newValue) {
    if (op.getType() === "array") {
      const aOp = op;
      if (Array.isArray(aOp.values)) {
        aOp.values.forEach((item) => this.updateOperandConst(item, oldValue, newValue));
      }
    }
    if (op.getType() !== "const") return;
    const cOp = op;
    if (Helpers.isTwoValueEquals(cOp.correctValue, oldValue)) {
      newValue = this.getCorrectNewValue(cOp, newValue);
      this.constChanges.push({
        op,
        val: newValue
      });
    }
  }
  getCorrectNewValue(op, newValue) {
    const str = op.toString();
    if (!!str && !Helpers.isTwoValueEquals(op.correctValue, str)) {
      if (str[0] === '"' || str[0] === "'") {
        return str[0] + newValue + str[0];
      }
    }
    return newValue;
  }
};
SurveyLogicExpressionUpdater.operatorText = {
  less: "<",
  lessorequal: "<=",
  greater: ">",
  greaterorequal: ">=",
  equal: "=",
  notequal: "!=",
  plus: "+",
  minus: "-",
  mul: "*",
  div: "/",
  power: "^",
  mod: "%",
  negate: "!"
};
function updateLogicExpression(expression, varName, oldValue, newValue) {
  const updater = new SurveyLogicExpressionUpdater(expression);
  updater.update(varName, oldValue, newValue);
  return updater.isModified ? updater.toString() : expression;
}
function getLogicString(name) {
  return editorLocalization.getString("ed.lg." + name);
}
var SurveyLogicType = class _SurveyLogicType {
  static expressionToDisplayText(survey, options, expression) {
    return new ExpressionToDisplayText(survey, options).toDisplayText(expression);
  }
  constructor(logicType, survey, options = null) {
    this.logicType = logicType;
    this.survey = survey;
    this.options = options;
    this.mergeWithBaseClass();
  }
  mergeWithBaseClass() {
    if (!this.logicType.baseClass) return;
    const baseClass = SurveyLogicTypes.baseTypes[this.logicType.baseClass];
    if (!baseClass) return;
    for (var key in baseClass) {
      if (!this.logicType[key]) {
        this.logicType[key] = baseClass[key];
      }
    }
  }
  hasNeededTypes(types) {
    if (types.indexOf(this.baseClass) < 0) return false;
    const inCls = this.logicType.incorrectClasses;
    if (Array.isArray(inCls)) {
      for (let i = 0; i < inCls.length; i++) {
        if (types.indexOf(inCls[i]) > -1) return false;
      }
    }
    return true;
  }
  get name() {
    return this.logicType.name;
  }
  get baseClass() {
    return this.logicType.baseClass;
  }
  get propertyName() {
    return this.logicType.propertyName;
  }
  get hasVisibleElements() {
    return this.logicType.isInvisible !== true;
  }
  get dynamicPropertyName() {
    return this.logicType.dynamicPropertyName;
  }
  get dependedOnPropertyName() {
    return this.logicType.dependedOnPropertyName;
  }
  get visible() {
    if (!this.showInUI) return false;
    if (!!this.logicType.showIf) return this.logicType.showIf(this.survey);
    return true;
  }
  get showTitlesInExpression() {
    return !!this.options && (this.options.useElementTitles || this.options.showTitlesInExpressions);
  }
  createNewObj(srcObj) {
    const obj = Serializer.createClass(this.baseClass);
    if (!!srcObj) {
      obj.fromJSON(srcObj.toJSON());
    }
    obj["survey"] = this.survey;
    if (obj.setOwner) {
      obj.setOwner(this.survey);
    }
    if (obj instanceof ItemValue || obj instanceof SurveyTrigger) {
      obj["isGhost"] = true;
    }
    return obj;
  }
  cloneElement(el) {
    if (this.isTrigger) return this.createNewObj(el);
    return el;
  }
  areElementsEqual(el1, el2) {
    if (el1 === el2) return true;
    if (!this.isTrigger || el1.getType() !== el2.getType()) return false;
    return Helpers.isTwoValueEquals(el1.toJSON(), el2.toJSON());
  }
  saveNewElement(el) {
    var collection = !!this.logicType.getCollection ? this.logicType.getCollection(this.survey) : null;
    if (!collection && this.isTrigger) {
      collection = this.survey.triggers;
    }
    if (!!collection && collection.indexOf(el) < 0) {
      collection.push(el);
    }
  }
  get showInUI() {
    return this.logicType.showInUI !== false;
  }
  get isUniqueItem() {
    return this.logicType.isUniqueItem === true;
  }
  get questionNames() {
    return this.logicType.questionNames;
  }
  get displayName() {
    return getLogicString(this.name + "Name");
  }
  get description() {
    return getLogicString(this.name + "Description");
  }
  getParentElement(element) {
    return !!this.logicType.getParentElement ? this.logicType.getParentElement(element) : null;
  }
  get hasSelectorChoices() {
    return !!this.logicType.getSelectorChoices;
  }
  getSelectorChoices(survey, context) {
    if (!this.hasSelectorChoices) return null;
    return this.logicType.getSelectorChoices(survey, context);
  }
  getDisplayText(element) {
    var str = getLogicString(this.name + "Text");
    if (!!this.logicType.getDisplayText) return this.logicType.getDisplayText(element, str, this);
    if (!!this.logicType.getElementName) {
      element = this.getElementByName(this.logicType.getElementName(element));
    }
    const name = this.getElementDisplayName(element);
    if (!!name) {
      const parentElement = this.getParentElement(element);
      const parentName = this.getElementDisplayName(parentElement);
      return str["format"](name, parentName);
    }
    return str;
  }
  getElementDisplayName(element) {
    if (!element) return "";
    let res = "";
    if (this.showTitlesInExpression) {
      res = element["title"];
    }
    if (!res) {
      res = element["name"] || "";
    }
    return wrapTextByCurlyBraces(res);
  }
  getElementByName(name) {
    if (!this.survey) return null;
    const question = this.survey.getQuestionByName(name);
    if (!!question) return question;
    return this.survey.getPageByName(name);
  }
  formatElName(name) {
    const el = this.getElementByName(name);
    return this.getElementDisplayName(el);
  }
  formatExpression(expression) {
    return _SurveyLogicType.expressionToDisplayText(this.survey, this.options, expression);
  }
  supportContext(context) {
    if (!this.logicType.supportContext) return false;
    return this.logicType.supportContext(context);
  }
  get isTrigger() {
    return !!this.baseClass && this.baseClass.indexOf("trigger") > -1;
  }
};
function hasMatrixColumns(survey) {
  const questions = survey.getAllQuestions();
  for (var i = 0; i < questions.length; i++) {
    const q = questions[i];
    if (q instanceof QuestionMatrixDropdownModelBase) {
      if (q.columns.length > 0) return true;
    }
  }
  return false;
}
var SurveyLogicTypes = class {
};
SurveyLogicTypes.baseTypes = {
  panel: {
    showIf: function(survey) {
      return survey.getAllPanels().length > 0;
    },
    getSelectorChoices(survey, context) {
      return survey.getAllPanels();
    }
  },
  question: {
    showIf: function(survey) {
      return survey.getAllQuestions().length > 0;
    },
    supportContext(context) {
      return Array.isArray(context["templateElements"]) || Array.isArray(context["detailElements"]) && context["detailElements"].length > 0;
    },
    getParentElement(element) {
      return !!element ? element.parentQuestion : null;
    },
    getSelectorChoices(survey, context) {
      const res = new Array();
      const questions = survey.getAllQuestions();
      const addElement = function(el) {
        res.push(el);
        if (el.isPanel) {
          el.elements.forEach((child) => addElement(child));
        }
      };
      for (var i = 0; i < questions.length; i++) {
        const q = questions[i];
        if (!context) {
          res.push(q);
        }
        if (q instanceof QuestionPanelDynamicModel && (!context || context === q)) {
          q.templateElements.forEach((el) => addElement(el));
        }
        if (q instanceof QuestionMatrixDropdownModelBase && (!context || context === q)) {
          q.detailElements.forEach((el) => addElement(el));
        }
      }
      return res;
    }
  },
  matrixdropdowncolumn: {
    showIf: function(survey) {
      return hasMatrixColumns(survey);
    },
    supportContext(context) {
      return Array.isArray(context["columns"]);
    },
    getParentElement(element) {
      return !!element ? element.colOwner : null;
    },
    getSelectorChoices(survey, context) {
      const res = [];
      const questions = survey.getAllQuestions();
      for (var i = 0; i < questions.length; i++) {
        const question = questions[i];
        if (question instanceof QuestionMatrixDropdownModelBase && (!context || context === question)) {
          const columns = question.columns;
          for (var j = 0; j < columns.length; j++) {
            res.push(columns[j]);
          }
        }
      }
      return res;
    }
  }
};
SurveyLogicTypes.types = [{
  name: "page_visibility",
  baseClass: "page",
  propertyName: "visibleIf",
  showIf: function(survey) {
    return survey.pages.length > 1;
  },
  getSelectorChoices(survey, context) {
    return survey.pages;
  }
}, {
  name: "page_enable",
  baseClass: "page",
  propertyName: "enableIf",
  showIf: function(survey) {
    return survey.pages.length > 1;
  },
  getSelectorChoices(survey, context) {
    return survey.pages;
  }
}, {
  name: "page_require",
  baseClass: "page",
  propertyName: "requiredIf",
  showIf: function(survey) {
    return survey.pages.length > 1;
  },
  getSelectorChoices(survey, context) {
    return survey.pages;
  }
}, {
  name: "panel_visibility",
  baseClass: "panel",
  incorrectClasses: ["page"],
  propertyName: "visibleIf"
}, {
  name: "panel_enable",
  baseClass: "panel",
  incorrectClasses: ["page"],
  propertyName: "enableIf"
}, {
  name: "panel_require",
  baseClass: "panel",
  incorrectClasses: ["page"],
  propertyName: "requiredIf"
}, {
  name: "question_visibility",
  baseClass: "question",
  propertyName: "visibleIf"
}, {
  name: "question_enable",
  baseClass: "question",
  propertyName: "enableIf"
}, {
  name: "question_require",
  baseClass: "question",
  propertyName: "requiredIf"
}, {
  name: "question_resetValue",
  baseClass: "question",
  propertyName: "resetValueIf"
}, {
  name: "question_setValue",
  baseClass: "question",
  propertyName: "setValueIf",
  getDisplayText: (element, formatStr, lt) => {
    return getDisplayTextForSetValueIf(element, formatStr, lt);
  }
}, {
  name: "question_setValueExpression",
  baseClass: "question",
  propertyName: "setValueExpression",
  showInUI: false
}, {
  name: "column_visibility",
  baseClass: "matrixdropdowncolumn",
  propertyName: "visibleIf"
}, {
  name: "column_enable",
  baseClass: "matrixdropdowncolumn",
  propertyName: "enableIf"
}, {
  name: "column_require",
  baseClass: "matrixdropdowncolumn",
  propertyName: "requiredIf"
}, {
  name: "column_resetValue",
  baseClass: "matrixdropdowncolumn",
  propertyName: "resetValueIf"
}, {
  name: "column_setValue",
  baseClass: "matrixdropdowncolumn",
  propertyName: "setValueIf",
  getDisplayText: (element, formatStr, lt) => {
    return getDisplayTextForSetValueIf(element, formatStr, lt);
  }
}, {
  name: "column_setValueExpression",
  baseClass: "matrixdropdowncolumn",
  propertyName: "setValueExpression",
  showInUI: false
}, {
  name: "expression_expression",
  baseClass: "expression",
  propertyName: "expression",
  showInUI: false
}, {
  name: "matrixdropdowncolumn_totalExpression",
  baseClass: "matrixdropdowncolumn",
  propertyName: "totalExpression",
  showInUI: false
}, {
  name: "trigger_complete",
  baseClass: "completetrigger",
  propertyName: "expression",
  isUniqueItem: true,
  isInvisible: true
}, {
  name: "trigger_setvalue",
  baseClass: "setvaluetrigger",
  propertyName: "expression",
  dynamicPropertyName: "setValue",
  dependedOnPropertyName: "setToName",
  questionNames: ["setToName"],
  getDisplayText: function(element, formatStr, lt) {
    if (Helpers.isValueEmpty(element["setValue"])) {
      formatStr = getLogicString("trigger_setvalueEmptyText");
    }
    return formatStr["format"](lt.formatElName(element["setToName"]), element["setValue"]);
  }
}, {
  name: "trigger_copyvalue",
  baseClass: "copyvaluetrigger",
  propertyName: "expression",
  questionNames: ["setToName", "fromName"],
  getDisplayText: function(element, formatStr, lt) {
    return formatStr["format"](lt.formatElName(element["setToName"]), lt.formatElName(element["fromName"]));
  }
}, {
  name: "trigger_skip",
  baseClass: "skiptrigger",
  propertyName: "expression",
  questionNames: ["gotoName"],
  isUniqueItem: true,
  getElementName: function(element) {
    return element["gotoName"];
  }
}, {
  name: "trigger_runExpression",
  baseClass: "runexpressiontrigger",
  propertyName: "expression",
  questionNames: ["setToName"],
  getDisplayText: function(element, formatStr, lt) {
    var res = getLogicString("trigger_runExpressionText1");
    res = res["format"](lt.formatExpression(element["runExpression"]));
    var setToName = element["setToName"];
    if (!!setToName) {
      var str = getLogicString("trigger_runExpressionText2");
      res += str["format"](lt.formatElName(element["setToName"]));
    }
    return res;
  }
}, {
  name: "completedHtmlOnCondition",
  baseClass: "htmlconditionitem",
  propertyName: "expression",
  isUniqueItem: true,
  getCollection: (survey) => {
    return survey.completedHtmlOnCondition;
  }
}, {
  name: "trigger_runExpression_Expression",
  baseClass: "runexpressiontrigger",
  propertyName: "runExpression",
  showInUI: false
}, {
  name: "question_expressionValidator",
  baseClass: "expressionvalidator",
  propertyName: "expression",
  showInUI: false
}, {
  name: "matrix_rowsVisibleIf",
  baseClass: "matrix",
  propertyName: "rowsVisibleIf",
  showInUI: false
}, {
  name: "matrix_columnsVisibleIf",
  baseClass: "matrix",
  propertyName: "columnsVisibleIf",
  showInUI: false
}, {
  name: "matrixdropdown_rowsVisibleIf",
  baseClass: "matrixdropdown",
  propertyName: "rowsVisibleIf",
  showInUI: false
}, {
  name: "select_choicesVisibleIf",
  baseClass: "selectbase",
  propertyName: "choicesVisibleIf",
  showInUI: false
}, {
  name: "select_choicesEnableIf",
  baseClass: "selectbase",
  propertyName: "choicesEnableIf",
  showInUI: false
}, {
  name: "itemvalue_visibleIf",
  baseClass: "itemvalue",
  propertyName: "visibleIf",
  showInUI: false
}, {
  name: "itemvalue_enableIf",
  baseClass: "itemvalue",
  propertyName: "enableIf",
  showInUI: false
}, {
  name: "calculatedValue",
  baseClass: "calculatedvalue",
  propertyName: "expression",
  showInUI: false
}];
function getDisplayTextForSetValueIf(element, formatStr, lt) {
  const name = lt.formatElName(element["name"]);
  let exp = element["setValueExpression"];
  if (!exp) {
    return getLogicString("trigger_setvalueEmptyText")["format"](name);
  }
  return formatStr["format"](name, exp);
}
var SurveyLogicAction = class _SurveyLogicAction {
  constructor(logicType, element, survey) {
    this.surveyValue = survey;
    this.logicTypeValue = logicType;
    this.elementValue = element;
  }
  get logicType() {
    return this.logicTypeValue;
  }
  get element() {
    return this.elementValue;
  }
  get parentElement() {
    if (!this.element || !this.logicType) return null;
    return this.logicType.getParentElement(this.element);
  }
  get survey() {
    return this.surveyValue;
  }
  apply(expression, isRenaming = false) {
    if (!!this.element && !!this.logicType) {
      this.element[this.logicType.propertyName] = expression;
      if (!expression) {
        if (Serializer.isDescendantOf(this.element.getType(), "surveytrigger")) {
          this.removeElement(this.survey.triggers, this.element);
        }
        if (Serializer.isDescendantOf(this.element.getType(), "htmlconditionitem")) {
          this.removeElement(this.survey.completedHtmlOnCondition, this.element);
        }
      }
    }
  }
  removeElement(items, element) {
    var index = items.indexOf(this.element);
    if (index > -1) {
      items.splice(index, 1);
    }
  }
  renameQuestion(oldName, newName) {
    if (!this.element) return;
    var names = this.questionNames;
    for (var i = 0; i < names.length; i++) {
      var str = this.element[names[i]];
      if (!!str && str.toLowerCase() == oldName.toLowerCase()) {
        this.element[names[i]] = newName;
      }
    }
  }
  clone() {
    const el = this.logicType.cloneElement(this.element);
    return new _SurveyLogicAction(this.logicType, el, this.survey);
  }
  equals(action) {
    if (this.logicType !== action.logicType) return false;
    return this.logicType.areElementsEqual(this.element, action.element);
  }
  get name() {
    return !!this.logicType ? this.logicType.displayName : "";
  }
  get logicTypeName() {
    return !!this.logicType ? this.logicType.name : void 0;
  }
  get logicTypeDescription() {
    return !!this.logicType ? this.logicType.description : "";
  }
  get text() {
    return !!this.logicType ? this.logicType.getDisplayText(this.element) : "";
  }
  get deleteActionText() {
    return getLogicString("deleteAction");
  }
  getLocString(name) {
    return editorLocalization.getString(name);
  }
  isSuitableByQuestionName(questionName) {
    let res = this.elementName === questionName || this.elementName.indexOf(questionName + ".") === 0;
    if (!res) {
      res = this.questionNamesValues.filter((question) => {
        return question === questionName || question.indexOf(questionName + ".") === 0;
      }).length > 0;
    }
    return res;
  }
  isSuitableByLogicType(logicTypeName) {
    if (!this.logicTypeName) return true;
    return logicTypeName === this.logicTypeName;
  }
  addQuestionNames(names) {
    const name = this.elementOwnerName;
    if (!!this.elementName && names.indexOf(name) === -1) {
      names.push(name);
    }
    this.questionNamesValues.forEach((name2) => {
      if (!!name2 && names.indexOf(name2) === -1) {
        names.push(name2);
      }
    });
  }
  get questionNames() {
    if (!this.logicType || !this.logicType.questionNames) return [];
    return this.logicType.questionNames;
  }
  get elementName() {
    if (!this.element) return "";
    var prefix = "";
    const owner = this.getOwnerElement();
    if (!!owner && owner !== this.element) {
      prefix = owner.name + ".";
    }
    return prefix + this.element.name || "";
  }
  get elementOwnerName() {
    const owner = this.getOwnerElement();
    return !!owner ? owner.name || "" : "";
  }
  getOwnerElement() {
    if (!this.element) return null;
    const parentElement = this.parentElement;
    return !!parentElement ? parentElement : this.element;
  }
  get questionNamesValues() {
    return this.questionNames.map((name) => this.element[name]);
  }
};
var SurveyLogicItem = class _SurveyLogicItem {
  constructor(owner, expression = "") {
    this.owner = owner;
    this.expression = expression;
    this.idValue = ++_SurveyLogicItem.counter;
    this.isNew = false;
    this.isModified = false;
    this.actionsValue = [];
    this.removedActions = [];
  }
  get actions() {
    return this.actionsValue;
  }
  get id() {
    return this.idValue;
  }
  get name() {
    return "logicItem" + this.id;
  }
  get survey() {
    return this.owner.survey;
  }
  getVisibleLogicTypes() {
    return this.owner.getVisibleLogicTypes();
  }
  get expressionText() {
    const text = this.getExpressionAsDisplayText();
    if (!text) return editorLocalization.getString("ed.lg.itemEmptyExpressionText");
    return text;
  }
  get actionsText() {
    return this.actions.map((action) => action.text).join(", ");
  }
  getDisplayText() {
    const conditionText = this.getExpressionAsDisplayText();
    let actionsText = "";
    this.actions.forEach((action) => {
      actionsText += ", " + action.text;
    });
    if (!!conditionText && !!actionsText) {
      const text = this.ifText + " " + conditionText + actionsText;
      return text.replace(new RegExp("({|})", "gm"), "'");
    } else {
      return editorLocalization.getString("ed.lg.itemEmptyExpressionText");
    }
  }
  edit() {
    if (!!this.owner) {
      this.owner.editItem(this);
    }
  }
  remove() {
    if (!!this.owner) {
      this.owner.removeItem(this);
    }
  }
  get isReadOnly() {
    return !!this.owner && this.owner.readOnly;
  }
  addNewAction(action) {
    this.actions.push(action);
  }
  removeAction(action) {
    this.replaceActionCore(null, action);
  }
  replaceAction(newAction, oldAction) {
    if (!!oldAction) {
      this.replaceActionCore(newAction, oldAction);
    } else {
      this.addNewAction(newAction);
    }
  }
  clone() {
    const res = new _SurveyLogicItem(this.owner, this.expression);
    for (var i = 0; i < this.actions.length; i++) {
      res.addNewAction(this.actions[i].clone());
    }
    return res;
  }
  equals(item) {
    if (this.expression !== item.expression) return false;
    if (this.actions.length !== item.actions.length) return false;
    for (let i = 0; i < this.actions.length; i++) {
      if (!this.actions[i].equals(item.actions[i])) return false;
    }
    return true;
  }
  replaceActionCore(newAction, oldAction) {
    this.removedActions.push(oldAction);
    var index = this.actions.indexOf(oldAction);
    if (index > -1) {
      if (!!newAction) {
        this.actions.splice(index, 1, newAction);
      } else {
        this.actions.splice(index, 1);
      }
    }
  }
  apply(expression) {
    if (!expression) {
      this.removeActions();
    } else {
      this.removeSameActions();
    }
    for (var i = 0; i < this.removedActions.length; i++) {
      this.removedActions[i].apply("");
    }
    this.removedActions = [];
    this.applyExpression(expression, false);
  }
  renameQuestion(oldName, newName) {
    if (!oldName || !newName || oldName === newName) return;
    ["", "panel.", "row."].forEach((prefix) => this.renameQuestionInExpression(prefix + oldName, prefix + newName, [settings2.logic.closeBracket, ".", "["]));
    var ops = this.actions;
    for (var i = 0; i < ops.length; i++) {
      ops[i].renameQuestion(oldName, newName);
    }
  }
  renameColumn(question, column, oldName) {
    if (!this.canUpdateExpressionByQuestion(question)) return;
    if (this.actions[0].parentElement === question) {
      this.renameQuestionInExpression("row." + oldName, "row." + column.name, [settings2.logic.closeBracket]);
    }
    const rows = question["rows"];
    if (!Array.isArray(rows) || !this.isQuestionInExpression(question)) return;
    const questionPrefix = this.getItemValueQuestionName(question) + ".";
    for (var i = 0; i < rows.length; i++) {
      if (Helpers.isValueEmpty(rows[i].value)) continue;
      const rowName = rows[i].value.toString() + ".";
      this.renameQuestionInExpression(questionPrefix + rowName + oldName, questionPrefix + rowName + column.name, [settings2.logic.closeBracket]);
    }
  }
  renameItemValue(question, item, oldValue) {
    if (!this.canUpdateExpressionByQuestion(question)) return;
    if (!!question.parentQuestion) {
      if (Array.isArray(question.parentQuestion["rows"])) {
        this.renameDropdownColumnItemValue(question, item, oldValue);
      }
      if (this.actions[0].parentElement !== question.parentQuestion) return;
    }
    if (!this.isQuestionInExpression(question)) return;
    const questionName = this.getItemValueQuestionName(question).toLocaleLowerCase();
    const rows = question["rows"];
    let newExpression = this.expression;
    if (!Array.isArray(rows)) {
      newExpression = updateLogicExpression(newExpression, questionName, oldValue, item.value);
    } else {
      for (var i = 0; i < rows.length; i++) {
        if (Helpers.isValueEmpty(rows[i].value)) continue;
        const rowName = "." + rows[i].value.toString();
        newExpression = updateLogicExpression(newExpression, questionName + rowName, oldValue, item.value);
      }
    }
    if (newExpression != this.expression) {
      this.applyExpression(newExpression, true);
    }
  }
  renameDropdownColumnItemValue(question, item, oldValue) {
    const matrix = question.parentQuestion;
    if (!this.isQuestionInExpression(matrix)) return;
    const columnPostFix = "." + question.getValueName();
    if (!this.isStrContainsInExpression(columnPostFix + settings2.logic.closeBracket)) return;
    const questionPrefix = matrix.getValueName() + ".";
    const rows = matrix["rows"];
    let newExpression = this.expression;
    for (var i = 0; i < rows.length; i++) {
      if (Helpers.isValueEmpty(rows[i].value)) continue;
      const rowName = rows[i].value.toString();
      newExpression = updateLogicExpression(newExpression, questionPrefix + rowName + columnPostFix, oldValue, item.value);
    }
    if (newExpression != this.expression) {
      this.applyExpression(newExpression, true);
    }
  }
  renameRowValue(question, item, oldValue) {
    if (!this.canUpdateExpressionByQuestion(question) || !this.isQuestionInExpression(question)) return;
    const questionName = this.getItemValueQuestionName(question);
    this.renameQuestionInExpression(questionName + "." + oldValue.toString(), questionName + "." + item.value.toString(), [settings2.logic.closeBracket, "."]);
  }
  canUpdateExpressionByQuestion(question) {
    return !!this.expression && !!question.name && this.actions.length > 0;
  }
  isQuestionInExpression(question) {
    return this.isStrContainsInExpression(this.getItemValueQuestionName(question).toLocaleLowerCase());
  }
  isStrContainsInExpression(str) {
    if (!str) return false;
    return this.expression.toLocaleLowerCase().indexOf(str.toLocaleLowerCase()) > -1;
  }
  getItemValueQuestionName(question) {
    const valName = question.getValueName();
    if (!!question.parentQuestion) {
      if (question.parentQuestion.isDescendantOf("paneldynamic")) return "panel." + valName;
      if (question.parentQuestion.isDescendantOf("matrixdropdownbase")) return "row." + valName;
    }
    return valName;
  }
  removeQuestion(name) {
    this.removeQuestionInExpression(name);
  }
  getQuestionNames() {
    const res = [];
    this.getQuestionNamesFromExpression(res);
    this.getQuestionNamesFromActions(res);
    return res;
  }
  getActionTypes() {
    return this.actions.map((action) => action.logicTypeName);
  }
  getContext() {
    const exp = this.expression;
    if (!exp) return null;
    if (!SurveyHelper.getQuestionContextIndexInfo(exp, "{")) return null;
    for (var i = 0; i < this.actions.length; i++) {
      const parentEl = this.actions[i].parentElement;
      if (!!parentEl) {
        return parentEl;
      }
    }
    return null;
  }
  getQuestionNamesFromExpression(names) {
    const conditionRunner = new ConditionRunner(this.expression);
    conditionRunner.getVariables().forEach((item) => {
      if (names.indexOf(item) === -1) names.push(item);
    });
  }
  getQuestionNamesFromActions(names) {
    this.actions.forEach((action) => action.addQuestionNames(names));
  }
  getExpressionAsDisplayText() {
    return !!this.owner ? this.owner.getExpressionAsDisplayText(this.expression) : this.expression;
  }
  get editText() {
    return editorLocalization.getString("pe.edit");
  }
  get deleteText() {
    return editorLocalization.getString("pe.delete");
  }
  get ifText() {
    return editorLocalization.getString("pe.if");
  }
  isSuitable(filteredName, logicTypeName = "") {
    if (!filteredName && !logicTypeName) return true;
    if (!filteredName) {
      return this.isSuitableByLogicTypeInActions(logicTypeName);
    }
    if (!logicTypeName) {
      return this.isSuitableInExpression(filteredName) || this.isSuitableByNameInActions(filteredName);
    }
    return (this.isSuitableInExpression(filteredName) || this.isSuitableByNameInActions(filteredName)) && this.isSuitableByLogicTypeInActions(logicTypeName);
  }
  isSuitableInExpression(filteredName) {
    return this.expression.indexOf(wrapTextByCurlyBraces(filteredName)) !== -1 || this.expression.indexOf("'" + filteredName + ".") !== -1;
  }
  isSuitableByNameInActions(filteredName) {
    return this.actions.some((action) => action.isSuitableByQuestionName(filteredName));
  }
  isSuitableByLogicTypeInActions(logicTypeName) {
    return this.actions.some((action) => action.isSuitableByLogicType(logicTypeName));
  }
  renameQuestionInExpression(oldName, newName, postFixes) {
    if (!this.expression) return;
    oldName = oldName.toLowerCase();
    if (!this.isStrContainsInExpression(oldName)) return;
    const ob = settings2.logic.openBracket;
    oldName = ob + oldName;
    newName = ob + newName;
    let newExpression = this.expression;
    postFixes.forEach((ch) => {
      newExpression = this.renameQuestionInExpressionCore(newExpression, newExpression.toLocaleLowerCase(), oldName + ch, newName + ch);
    });
    if (newExpression != this.expression) {
      this.applyExpression(newExpression, true);
    }
  }
  renameQuestionInExpressionCore(expression, lowCaseExpression, oldSubStr, newSubStr) {
    var index = lowCaseExpression.lastIndexOf(oldSubStr, lowCaseExpression.length);
    while (index > -1) {
      expression = expression.substring(0, index) + newSubStr + expression.substring(index + oldSubStr.length);
      lowCaseExpression = lowCaseExpression.substring(0, index);
      index = lowCaseExpression.lastIndexOf(oldSubStr, index);
    }
    return expression;
  }
  removeQuestionInExpression(name) {
    if (!this.expression) return;
    var expR = new ExpressionRemoveVariable();
    var newExpression = expR.remove(this.expression, name);
    if (newExpression != this.expression) {
      this.applyExpression(newExpression, true);
    }
  }
  applyExpression(expression, isRenaming) {
    this.expression = expression;
    var ops = this.actions;
    for (var i = 0; i < ops.length; i++) {
      ops[i].apply(expression, isRenaming);
    }
  }
  removeActions() {
    var ops = this.actions;
    for (var i = ops.length - 1; i >= 0; i--) {
      this.removeAction(ops[i]);
    }
  }
  removeSameActions() {
    var ops = this.actions;
    for (var i = ops.length - 1; i >= 0; i--) {
      for (var j = i - 1; j >= 0; j--) {
        if (ops[i].equals(ops[j])) {
          this.removeAction(ops[i]);
          break;
        }
      }
    }
  }
};
SurveyLogicItem.counter = 0;
function initLogicOperator(question) {
  question.popupModel.isFocusedContent = true;
  question.popupModel.setWidthByTarget = false;
  question.popupModel.positionMode = "flex";
  question.popupModel.showPointer = true;
  question.dropdownListModel["listModel"].searchEnabled = question.searchEnabled;
}
var LogicEvent = class extends EventBase {
};
var SurveyLogic = class _SurveyLogic extends Base {
  static get visibleActions() {
    return settings2.logic.visibleActions;
  }
  static set visibleActions(val) {
    settings2.logic.visibleActions = val;
  }
  static get types() {
    return SurveyLogicTypes.types;
  }
  constructor(survey, options = null) {
    super();
    this.survey = survey;
    this.options = options;
    this.invisibleItems = [];
    this.onLogicItemSaved = new LogicEvent();
    this.onLogicItemValidation = new LogicEvent();
    this.onLogicItemRemoving = new LogicEvent();
    this.onLogicItemRemoved = new LogicEvent();
    if (!this.options) this.options = new EmptySurveyCreatorOptions();
    this.readOnly = this.optionsReadOnly;
    this.update();
  }
  dispose() {
    super.dispose();
    this.onEndEditing();
    this.survey = void 0;
  }
  get editableItem() {
    return this.editableItemValue;
  }
  /**
   * There are 3 modes: view, new, edit
   */
  get mode() {
    return this.modeValue;
  }
  set mode(val) {
    if (this.modeValue === val) return;
    const oldValue = this.mode;
    this.modeValue = val;
    this.errorText = "";
    if (val == "view" && (oldValue == "edit" || oldValue == "new")) {
      this.onEndEditing();
    }
  }
  getLocString(name) {
    return editorLocalization.getString(name);
  }
  getTypeByName(name) {
    for (var i = 0; i < this.logicTypes.length; i++) {
      if (this.logicTypes[i].name == name) return this.logicTypes[i];
    }
    return null;
  }
  update(survey = null, options = null) {
    if (!!survey) {
      this.survey = survey;
    }
    if (!!options) {
      this.options = options;
    }
    this.logicTypes = this.createLogicTypes();
    this.updateVisibleItems();
    this.invisibleItems = this.buildItems(false);
    this.readOnly = this.optionsReadOnly;
    this.mode = "view";
  }
  updateVisibleItems() {
    this.items = this.buildItems(true);
    this.editableItemValue = null;
  }
  get optionsReadOnly() {
    return !!this.options && this.options.readOnly;
  }
  saveEditableItem() {
    if (!this.editableItem || this.hasError()) return false;
    !!this.options && this.options.startUndoRedoTransaction();
    this.onEditableItemApply();
    const hasInList = this.items.indexOf(this.editableItem) < 0;
    if (hasInList) {
      this.items.push(this.editableItem);
    }
    const isNew = !hasInList || this.editableItem.isNew;
    this.editableItem.isNew = false;
    this.onItemChanged(this.editableItem, isNew ? "new" : "modify");
    !!this.options && this.options.stopUndoRedoTransaction();
    this.onLogicItemSaved.fire(this, {
      item: this.editableItem
    });
    return true;
  }
  saveEditableItemAndBack() {
    var res = this.saveEditableItem();
    if (res) {
      this.mode = "view";
    }
    return res;
  }
  onEditableItemApply() {
  }
  onItemChanged(item, changeType) {
    if (!!this.onChangedCallback) {
      this.onChangedCallback(item, changeType);
    }
  }
  renameQuestion(oldName, newName) {
    this.items.forEach((item) => item.renameQuestion(oldName, newName));
    this.invisibleItems.forEach((item) => item.renameQuestion(oldName, newName));
  }
  renameItemValue(item, oldValue) {
    const question = this.getItemValueQuestion(item, oldValue);
    if (!question) return;
    this.items.forEach((lItem) => lItem.renameItemValue(question, item, oldValue));
    this.invisibleItems.forEach((lItem) => lItem.renameItemValue(question, item, oldValue));
  }
  renameRowValue(item, oldValue) {
    const question = this.getItemValueQuestion(item, oldValue);
    if (!question) return;
    this.items.forEach((lItem) => lItem.renameRowValue(question, item, oldValue));
    this.invisibleItems.forEach((lItem) => lItem.renameRowValue(question, item, oldValue));
  }
  renameColumn(column, oldName) {
    const question = column.colOwner;
    if (!question || !question.isQuestion) return;
    this.items.forEach((lItem) => lItem.renameColumn(question, column, oldName));
    this.invisibleItems.forEach((lItem) => lItem.renameColumn(question, column, oldName));
  }
  getItemValueQuestion(item, oldValue) {
    if (!item.locOwner || Helpers.isValueEmpty(oldValue) || Helpers.isValueEmpty(item.value)) return null;
    const owner = item.locOwner;
    return owner.isQuestion ? owner : null;
  }
  removeQuestion(name) {
    this.removeQuestionCore(name, this.items);
    this.removeQuestionCore(name, this.invisibleItems);
  }
  hasError() {
    if (!this.editableItem) return false;
    if (this.hasErrorInUI()) return true;
    var exp = new ExpressionRunner(this.getExpressionText());
    var options = {
      item: this.editableItem,
      error: "",
      usedNamesInExpression: exp.getVariables(),
      actions: this.getEditingActions()
    };
    this.onLogicItemValidation.fire(this, options);
    this.errorText = options.error;
    const creator = this.survey.creator;
    if (!!this.errorText && !!creator) creator.notify(this.errorText, "error");
    return !!this.errorText;
  }
  getUsedQuestions() {
    const names = {};
    this.items.forEach((item) => {
      item.getQuestionNames().forEach((name) => {
        const question = this.survey.getQuestionByName(name);
        if (!!question && !names[name]) {
          names[name] = question;
        }
      });
    });
    let res = [];
    Object.keys(names).forEach((item) => {
      if (!!names[item]) {
        res.push(names[item]);
      }
    });
    return res;
  }
  getUsedActionTypes() {
    const types = {};
    this.items.forEach((item) => {
      item.getActionTypes().forEach((name) => {
        if (!types[name]) {
          types[name] = this.logicTypes.filter((logicType) => logicType.name == name)[0];
        }
      });
    });
    let res = [];
    Object.keys(types).forEach((item) => {
      if (!!types[item]) {
        res.push(types[item]);
      }
    });
    return res;
  }
  hasErrorInUI() {
    return false;
  }
  getExpressionText() {
    return "";
  }
  getEditingActions() {
    return [];
  }
  onReadOnlyChanged() {
  }
  removeQuestionCore(name, items) {
    for (var i = 0; i < items.length; i++) {
      items[i].removeQuestion(name);
    }
  }
  addNew() {
    !!this.options && this.options.startUndoRedoTransaction();
    var logicItem = new SurveyLogicItem(this);
    logicItem.isNew = true;
    this.items.push(logicItem);
    this.editItemCore(logicItem);
    !!this.options && this.options.stopUndoRedoTransaction();
  }
  editItem(item) {
    !!this.options && this.options.startUndoRedoTransaction();
    this.editItemCore(item);
    !!this.options && this.options.stopUndoRedoTransaction();
  }
  editItemCore(item) {
    this.editableItemValue = item;
    this.onStartEditing();
    this.mode = item.isNew ? "new" : "edit";
  }
  onStartEditing() {
  }
  onEndEditing() {
    this.editableItemValue = null;
  }
  canRemoveItem(item) {
    const eventOptions = {
      item,
      allowRemove: true
    };
    this.onLogicItemRemoving.fire(this, eventOptions);
    return eventOptions.allowRemove;
  }
  removeItem(item, checkCanRemove = true) {
    if (checkCanRemove && !this.canRemoveItem(item)) return;
    !!this.options && this.options.startUndoRedoTransaction();
    item.apply("");
    var index = this.items.indexOf(item);
    if (index > -1) {
      this.items.splice(index, 1);
    }
    this.onItemChanged(item, "delete");
    !!this.options && this.options.stopUndoRedoTransaction();
    this.onLogicItemRemoved.fire(this, {
      item
    });
  }
  addAction(lt, element = null) {
    var action = this.createNewAction(lt, element);
    this.editableItem.addNewAction(action);
    return action;
  }
  addNewAction() {
    return this.addAction(null, null);
  }
  createNewAction(lt, element) {
    var action = new SurveyLogicAction(lt, element, this.survey);
    return action;
  }
  getVisibleLogicTypes() {
    var res = [];
    var logicTypes = this.logicTypes;
    for (var i = 0; i < logicTypes.length; i++) {
      if (logicTypes[i].visible) {
        res.push(logicTypes[i]);
      }
    }
    return res;
  }
  removeAction(action) {
    if (!this.editableItem) return;
    this.editableItem.removeAction(action);
    if (this.editableItem.actions.length == 0) {
      this.addNewAction();
    }
  }
  getExpressionAsDisplayText(expression) {
    return SurveyLogicType.expressionToDisplayText(this.survey, this.options, expression);
  }
  buildItems(showInUI) {
    var res = [];
    var hash = {};
    var elements = this.getAllElements();
    for (var i = 0; i < elements.length; i++) {
      this.buildItemsByElement(elements[i], res, hash, showInUI);
    }
    return res;
  }
  getAllElements() {
    var res = [];
    this.AddElements(this.survey.pages, res);
    this.AddElements(SurveyLogicTypes.baseTypes.question.getSelectorChoices(this.survey, null), res);
    this.AddElements(this.survey.getAllPanels(), res);
    this.AddElements(this.survey.triggers, res);
    this.AddElements(this.survey.completedHtmlOnCondition, res);
    this.AddElements(this.survey.calculatedValues, res);
    this.AddElements(SurveyLogicTypes.baseTypes.matrixdropdowncolumn.getSelectorChoices(this.survey, null), res);
    this.AddElements(this.getValidators(), res);
    this.AddElements(this.getItemValues(), res);
    return res;
  }
  getValidators() {
    var res = [];
    var questions = this.survey.getAllQuestions();
    for (var i = 0; i < questions.length; i++) {
      this.AddElements(questions[i].validators, res);
    }
    return res;
  }
  getItemValues() {
    var res = [];
    var questions = this.survey.getAllQuestions();
    for (var i = 0; i < questions.length; i++) {
      var q = questions[i];
      var choices = q["choices"];
      if (!choices) continue;
      var prop = Serializer.findProperty(q.getType(), "choices");
      if (!prop || prop.type !== "itemvalue[]") continue;
      this.AddElements(choices, res);
    }
    return res;
  }
  AddElements(src, dest) {
    for (var i = 0; i < src.length; i++) {
      dest.push(src[i]);
    }
  }
  buildItemsByElement(element, dest, hash, showInUI) {
    var types = this.getElementAllTypes(element);
    for (var i = 0; i < this.logicTypes.length; i++) {
      var lt = this.logicTypes[i];
      if (lt.showInUI !== showInUI) continue;
      var expression = element[lt.propertyName];
      if (lt.hasNeededTypes(types) && !Helpers.isValueEmpty(expression)) {
        var key = this.getLogicItemHashKey(expression, element);
        var item = hash[key];
        if (!item) {
          item = new SurveyLogicItem(this, expression);
          hash[key] = item;
          dest.push(item);
        }
        var action = this.createNewAction(lt, element);
        item.addNewAction(action);
      }
    }
  }
  getLogicItemHashKey(expression, element) {
    const parentQuestion = this.getParentQuestion(element);
    const parentName = !!parentQuestion ? "@" + parentQuestion.name : "";
    return parentName + expression.replace(" ", "").toLowerCase();
  }
  getParentQuestion(element) {
    const parentQuestion = element.parentQuestion;
    if (!!parentQuestion) return parentQuestion;
    if (element.isDescendantOf("matrixdropdowncolumn")) return element.colOwner;
    return null;
  }
  getElementAllTypes(element) {
    var types = [];
    var type = element.getType();
    types.push(type);
    while (!!type && type != "base") {
      var cl = Serializer.findClass(type);
      if (!cl) break;
      type = cl.parentName;
      if (!!type) {
        types.push(type);
      }
    }
    return types;
  }
  createLogicTypes() {
    var res = [];
    _SurveyLogic.types.forEach((logicType) => {
      if (this.isLogicTypeVisible(logicType)) {
        res.push(new SurveyLogicType(logicType, this.survey, this.options));
      }
    });
    return res;
  }
  isLogicTypeVisible(logicType) {
    const visActions = _SurveyLogic.visibleActions;
    if (visActions.length > 0 && visActions.indexOf(logicType.name) < 0) return false;
    const prefix = "trigger_";
    if (logicType.name.indexOf(prefix) === 0) {
      return settings2.logic.invisibleTriggers.indexOf(logicType.name.substring(prefix.length)) < 0;
    }
    return true;
  }
};
__decorate2([propertyArray()], SurveyLogic.prototype, "items", void 0);
__decorate2([propertyArray()], SurveyLogic.prototype, "logicTypes", void 0);
__decorate2([property()], SurveyLogic.prototype, "errorText", void 0);
__decorate2([property({
  onSet: (value, target) => {
    target.onReadOnlyChanged();
  }
})], SurveyLogic.prototype, "readOnly", void 0);
__decorate2([property()], SurveyLogic.prototype, "placeholderHtml", void 0);
var papaparse_min$1 = {
  exports: {}
};
var papaparse_min = papaparse_min$1.exports;
var hasRequiredPapaparse_min;
function requirePapaparse_min() {
  if (hasRequiredPapaparse_min) return papaparse_min$1.exports;
  hasRequiredPapaparse_min = 1;
  (function(module, exports) {
    ((e, t) => {
      module.exports = t();
    })(papaparse_min, function r() {
      var n = "undefined" != typeof self ? self : "undefined" != typeof window ? window : void 0 !== n ? n : {};
      var d, s = !n.document && !!n.postMessage, a = n.IS_PAPA_WORKER || false, o = {}, h = 0, v = {};
      function u(e) {
        this._handle = null, this._finished = false, this._completed = false, this._halted = false, this._input = null, this._baseIndex = 0, this._partialLine = "", this._rowCount = 0, this._start = 0, this._nextChunk = null, this.isFirstChunk = true, this._completeResults = {
          data: [],
          errors: [],
          meta: {}
        }, function(e2) {
          var t = w(e2);
          t.chunkSize = parseInt(t.chunkSize), e2.step || e2.chunk || (t.chunkSize = null);
          this._handle = new i(t), (this._handle.streamer = this)._config = t;
        }.call(this, e), this.parseChunk = function(t, e2) {
          var i2 = parseInt(this._config.skipFirstNLines) || 0;
          if (this.isFirstChunk && 0 < i2) {
            let e3 = this._config.newline;
            e3 || (r2 = this._config.quoteChar || '"', e3 = this._handle.guessLineEndings(t, r2)), t = [...t.split(e3).slice(i2)].join(e3);
          }
          this.isFirstChunk && U(this._config.beforeFirstChunk) && void 0 !== (r2 = this._config.beforeFirstChunk(t)) && (t = r2), this.isFirstChunk = false, this._halted = false;
          var i2 = this._partialLine + t, r2 = (this._partialLine = "", this._handle.parse(i2, this._baseIndex, !this._finished));
          if (!this._handle.paused() && !this._handle.aborted()) {
            t = r2.meta.cursor, i2 = (this._finished || (this._partialLine = i2.substring(t - this._baseIndex), this._baseIndex = t), r2 && r2.data && (this._rowCount += r2.data.length), this._finished || this._config.preview && this._rowCount >= this._config.preview);
            if (a) n.postMessage({
              results: r2,
              workerId: v.WORKER_ID,
              finished: i2
            });
            else if (U(this._config.chunk) && !e2) {
              if (this._config.chunk(r2, this._handle), this._handle.paused() || this._handle.aborted()) return void (this._halted = true);
              this._completeResults = r2 = void 0;
            }
            return this._config.step || this._config.chunk || (this._completeResults.data = this._completeResults.data.concat(r2.data), this._completeResults.errors = this._completeResults.errors.concat(r2.errors), this._completeResults.meta = r2.meta), this._completed || !i2 || !U(this._config.complete) || r2 && r2.meta.aborted || (this._config.complete(this._completeResults, this._input), this._completed = true), i2 || r2 && r2.meta.paused || this._nextChunk(), r2;
          }
          this._halted = true;
        }, this._sendError = function(e2) {
          U(this._config.error) ? this._config.error(e2) : a && this._config.error && n.postMessage({
            workerId: v.WORKER_ID,
            error: e2,
            finished: false
          });
        };
      }
      function f(e) {
        var r2;
        (e = e || {}).chunkSize || (e.chunkSize = v.RemoteChunkSize), u.call(this, e), this._nextChunk = s ? function() {
          this._readChunk(), this._chunkLoaded();
        } : function() {
          this._readChunk();
        }, this.stream = function(e2) {
          this._input = e2, this._nextChunk();
        }, this._readChunk = function() {
          if (this._finished) this._chunkLoaded();
          else {
            if (r2 = new XMLHttpRequest(), this._config.withCredentials && (r2.withCredentials = this._config.withCredentials), s || (r2.onload = y(this._chunkLoaded, this), r2.onerror = y(this._chunkError, this)), r2.open(this._config.downloadRequestBody ? "POST" : "GET", this._input, !s), this._config.downloadRequestHeaders) {
              var e2, t = this._config.downloadRequestHeaders;
              for (e2 in t) r2.setRequestHeader(e2, t[e2]);
            }
            var i2;
            this._config.chunkSize && (i2 = this._start + this._config.chunkSize - 1, r2.setRequestHeader("Range", "bytes=" + this._start + "-" + i2));
            try {
              r2.send(this._config.downloadRequestBody);
            } catch (e3) {
              this._chunkError(e3.message);
            }
            s && 0 === r2.status && this._chunkError();
          }
        }, this._chunkLoaded = function() {
          4 === r2.readyState && (r2.status < 200 || 400 <= r2.status ? this._chunkError() : (this._start += this._config.chunkSize || r2.responseText.length, this._finished = !this._config.chunkSize || this._start >= ((e2) => null !== (e2 = e2.getResponseHeader("Content-Range")) ? parseInt(e2.substring(e2.lastIndexOf("/") + 1)) : -1)(r2), this.parseChunk(r2.responseText)));
        }, this._chunkError = function(e2) {
          e2 = r2.statusText || e2;
          this._sendError(new Error(e2));
        };
      }
      function l(e) {
        (e = e || {}).chunkSize || (e.chunkSize = v.LocalChunkSize), u.call(this, e);
        var i2, r2, n2 = "undefined" != typeof FileReader;
        this.stream = function(e2) {
          this._input = e2, r2 = e2.slice || e2.webkitSlice || e2.mozSlice, n2 ? ((i2 = new FileReader()).onload = y(this._chunkLoaded, this), i2.onerror = y(this._chunkError, this)) : i2 = new FileReaderSync(), this._nextChunk();
        }, this._nextChunk = function() {
          this._finished || this._config.preview && !(this._rowCount < this._config.preview) || this._readChunk();
        }, this._readChunk = function() {
          var e2 = this._input, t = (this._config.chunkSize && (t = Math.min(this._start + this._config.chunkSize, this._input.size), e2 = r2.call(e2, this._start, t)), i2.readAsText(e2, this._config.encoding));
          n2 || this._chunkLoaded({
            target: {
              result: t
            }
          });
        }, this._chunkLoaded = function(e2) {
          this._start += this._config.chunkSize, this._finished = !this._config.chunkSize || this._start >= this._input.size, this.parseChunk(e2.target.result);
        }, this._chunkError = function() {
          this._sendError(i2.error);
        };
      }
      function c(e) {
        var i2;
        u.call(this, e = e || {}), this.stream = function(e2) {
          return i2 = e2, this._nextChunk();
        }, this._nextChunk = function() {
          var e2, t;
          if (!this._finished) return e2 = this._config.chunkSize, i2 = e2 ? (t = i2.substring(0, e2), i2.substring(e2)) : (t = i2, ""), this._finished = !i2, this.parseChunk(t);
        };
      }
      function p(e) {
        u.call(this, e = e || {});
        var t = [], i2 = true, r2 = false;
        this.pause = function() {
          u.prototype.pause.apply(this, arguments), this._input.pause();
        }, this.resume = function() {
          u.prototype.resume.apply(this, arguments), this._input.resume();
        }, this.stream = function(e2) {
          this._input = e2, this._input.on("data", this._streamData), this._input.on("end", this._streamEnd), this._input.on("error", this._streamError);
        }, this._checkIsFinished = function() {
          r2 && 1 === t.length && (this._finished = true);
        }, this._nextChunk = function() {
          this._checkIsFinished(), t.length ? this.parseChunk(t.shift()) : i2 = true;
        }, this._streamData = y(function(e2) {
          try {
            t.push("string" == typeof e2 ? e2 : e2.toString(this._config.encoding)), i2 && (i2 = false, this._checkIsFinished(), this.parseChunk(t.shift()));
          } catch (e3) {
            this._streamError(e3);
          }
        }, this), this._streamError = y(function(e2) {
          this._streamCleanUp(), this._sendError(e2);
        }, this), this._streamEnd = y(function() {
          this._streamCleanUp(), r2 = true, this._streamData("");
        }, this), this._streamCleanUp = y(function() {
          this._input.removeListener("data", this._streamData), this._input.removeListener("end", this._streamEnd), this._input.removeListener("error", this._streamError);
        }, this);
      }
      function i(m2) {
        var n2, s2, a2, t, o2 = Math.pow(2, 53), h2 = -o2, u2 = /^\s*-?(\d+\.?|\.\d+|\d+\.\d+)([eE][-+]?\d+)?\s*$/, d2 = /^((\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z)))$/, i2 = this, r2 = 0, f2 = 0, l2 = false, e = false, c2 = [], p2 = {
          data: [],
          errors: [],
          meta: {}
        };
        function y2(e2) {
          return "greedy" === m2.skipEmptyLines ? "" === e2.join("").trim() : 1 === e2.length && 0 === e2[0].length;
        }
        function g2() {
          if (p2 && a2 && (k("Delimiter", "UndetectableDelimiter", "Unable to auto-detect delimiting character; defaulted to '" + v.DefaultDelimiter + "'"), a2 = false), m2.skipEmptyLines && (p2.data = p2.data.filter(function(e3) {
            return !y2(e3);
          })), _2()) {
            let t2 = function(e3, t3) {
              U(m2.transformHeader) && (e3 = m2.transformHeader(e3, t3)), c2.push(e3);
            };
            if (p2) if (Array.isArray(p2.data[0])) {
              for (var e2 = 0; _2() && e2 < p2.data.length; e2++) p2.data[e2].forEach(t2);
              p2.data.splice(0, 1);
            } else p2.data.forEach(t2);
          }
          function i3(e3, t2) {
            for (var i4 = m2.header ? {} : [], r4 = 0; r4 < e3.length; r4++) {
              var n3 = r4, s3 = e3[r4], s3 = ((e4, t3) => ((e5) => (m2.dynamicTypingFunction && void 0 === m2.dynamicTyping[e5] && (m2.dynamicTyping[e5] = m2.dynamicTypingFunction(e5)), true === (m2.dynamicTyping[e5] || m2.dynamicTyping)))(e4) ? "true" === t3 || "TRUE" === t3 || "false" !== t3 && "FALSE" !== t3 && (((e5) => {
                if (u2.test(e5)) {
                  e5 = parseFloat(e5);
                  if (h2 < e5 && e5 < o2) return 1;
                }
              })(t3) ? parseFloat(t3) : d2.test(t3) ? new Date(t3) : "" === t3 ? null : t3) : t3)(n3 = m2.header ? r4 >= c2.length ? "__parsed_extra" : c2[r4] : n3, s3 = m2.transform ? m2.transform(s3, n3) : s3);
              "__parsed_extra" === n3 ? (i4[n3] = i4[n3] || [], i4[n3].push(s3)) : i4[n3] = s3;
            }
            return m2.header && (r4 > c2.length ? k("FieldMismatch", "TooManyFields", "Too many fields: expected " + c2.length + " fields but parsed " + r4, f2 + t2) : r4 < c2.length && k("FieldMismatch", "TooFewFields", "Too few fields: expected " + c2.length + " fields but parsed " + r4, f2 + t2)), i4;
          }
          var r3;
          p2 && (m2.header || m2.dynamicTyping || m2.transform) && (r3 = 1, !p2.data.length || Array.isArray(p2.data[0]) ? (p2.data = p2.data.map(i3), r3 = p2.data.length) : p2.data = i3(p2.data, 0), m2.header && p2.meta && (p2.meta.fields = c2), f2 += r3);
        }
        function _2() {
          return m2.header && 0 === c2.length;
        }
        function k(e2, t2, i3, r3) {
          e2 = {
            type: e2,
            code: t2,
            message: i3
          };
          void 0 !== r3 && (e2.row = r3), p2.errors.push(e2);
        }
        U(m2.step) && (t = m2.step, m2.step = function(e2) {
          p2 = e2, _2() ? g2() : (g2(), 0 !== p2.data.length && (r2 += e2.data.length, m2.preview && r2 > m2.preview ? s2.abort() : (p2.data = p2.data[0], t(p2, i2))));
        }), this.parse = function(e2, t2, i3) {
          var r3 = m2.quoteChar || '"', r3 = (m2.newline || (m2.newline = this.guessLineEndings(e2, r3)), a2 = false, m2.delimiter ? U(m2.delimiter) && (m2.delimiter = m2.delimiter(e2), p2.meta.delimiter = m2.delimiter) : ((r3 = ((e3, t3, i4, r4, n3) => {
            var s3, a3, o3, h3;
            n3 = n3 || [",", "	", "|", ";", v.RECORD_SEP, v.UNIT_SEP];
            for (var u3 = 0; u3 < n3.length; u3++) {
              for (var d3, f3 = n3[u3], l3 = 0, c3 = 0, p3 = 0, g3 = (o3 = void 0, new E({
                comments: r4,
                delimiter: f3,
                newline: t3,
                preview: 10
              }).parse(e3)), _3 = 0; _3 < g3.data.length; _3++) i4 && y2(g3.data[_3]) ? p3++ : (d3 = g3.data[_3].length, c3 += d3, void 0 === o3 ? o3 = d3 : 0 < d3 && (l3 += Math.abs(d3 - o3), o3 = d3));
              0 < g3.data.length && (c3 /= g3.data.length - p3), (void 0 === a3 || l3 <= a3) && (void 0 === h3 || h3 < c3) && 1.99 < c3 && (a3 = l3, s3 = f3, h3 = c3);
            }
            return {
              successful: !!(m2.delimiter = s3),
              bestDelimiter: s3
            };
          })(e2, m2.newline, m2.skipEmptyLines, m2.comments, m2.delimitersToGuess)).successful ? m2.delimiter = r3.bestDelimiter : (a2 = true, m2.delimiter = v.DefaultDelimiter), p2.meta.delimiter = m2.delimiter), w(m2));
          return m2.preview && m2.header && r3.preview++, n2 = e2, s2 = new E(r3), p2 = s2.parse(n2, t2, i3), g2(), l2 ? {
            meta: {
              paused: true
            }
          } : p2 || {
            meta: {
              paused: false
            }
          };
        }, this.paused = function() {
          return l2;
        }, this.pause = function() {
          l2 = true, s2.abort(), n2 = U(m2.chunk) ? "" : n2.substring(s2.getCharIndex());
        }, this.resume = function() {
          i2.streamer._halted ? (l2 = false, i2.streamer.parseChunk(n2, true)) : setTimeout(i2.resume, 3);
        }, this.aborted = function() {
          return e;
        }, this.abort = function() {
          e = true, s2.abort(), p2.meta.aborted = true, U(m2.complete) && m2.complete(p2), n2 = "";
        }, this.guessLineEndings = function(e2, t2) {
          e2 = e2.substring(0, 1048576);
          var t2 = new RegExp(P(t2) + "([^]*?)" + P(t2), "gm"), i3 = (e2 = e2.replace(t2, "")).split("\r"), t2 = e2.split("\n"), e2 = 1 < t2.length && t2[0].length < i3[0].length;
          if (1 === i3.length || e2) return "\n";
          for (var r3 = 0, n3 = 0; n3 < i3.length; n3++) "\n" === i3[n3][0] && r3++;
          return r3 >= i3.length / 2 ? "\r\n" : "\r";
        };
      }
      function P(e) {
        return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
      function E(C) {
        var S = (C = C || {}).delimiter, O = C.newline, x = C.comments, I = C.step, A = C.preview, T = C.fastMode, D = null, L = false, F = null == C.quoteChar ? '"' : C.quoteChar, j = F;
        if (void 0 !== C.escapeChar && (j = C.escapeChar), ("string" != typeof S || -1 < v.BAD_DELIMITERS.indexOf(S)) && (S = ","), x === S) throw new Error("Comment character same as delimiter");
        true === x ? x = "#" : ("string" != typeof x || -1 < v.BAD_DELIMITERS.indexOf(x)) && (x = false), "\n" !== O && "\r" !== O && "\r\n" !== O && (O = "\n");
        var z = 0, M = false;
        this.parse = function(i2, t, r2) {
          if ("string" != typeof i2) throw new Error("Input must be a string");
          var n2 = i2.length, e = S.length, s2 = O.length, a2 = x.length, o2 = U(I), h2 = [], u2 = [], d2 = [], f2 = z = 0;
          if (!i2) return b();
          if (T || false !== T && -1 === i2.indexOf(F)) {
            for (var l2 = i2.split(O), c2 = 0; c2 < l2.length; c2++) {
              if (d2 = l2[c2], z += d2.length, c2 !== l2.length - 1) z += O.length;
              else if (r2) return b();
              if (!x || d2.substring(0, a2) !== x) {
                if (o2) {
                  if (h2 = [], k(d2.split(S)), R(), M) return b();
                } else k(d2.split(S));
                if (A && A <= c2) return h2 = h2.slice(0, A), b(true);
              }
            }
            return b();
          }
          for (var p2 = i2.indexOf(S, z), g2 = i2.indexOf(O, z), _2 = new RegExp(P(j) + P(F), "g"), m2 = i2.indexOf(F, z); ; ) if (i2[z] === F) for (m2 = z, z++; ; ) {
            if (-1 === (m2 = i2.indexOf(F, m2 + 1))) return r2 || u2.push({
              type: "Quotes",
              code: "MissingQuotes",
              message: "Quoted field unterminated",
              row: h2.length,
              index: z
            }), E2();
            if (m2 === n2 - 1) return E2(i2.substring(z, m2).replace(_2, F));
            if (F === j && i2[m2 + 1] === j) m2++;
            else if (F === j || 0 === m2 || i2[m2 - 1] !== j) {
              -1 !== p2 && p2 < m2 + 1 && (p2 = i2.indexOf(S, m2 + 1));
              var y2 = v2(-1 === (g2 = -1 !== g2 && g2 < m2 + 1 ? i2.indexOf(O, m2 + 1) : g2) ? p2 : Math.min(p2, g2));
              if (i2.substr(m2 + 1 + y2, e) === S) {
                d2.push(i2.substring(z, m2).replace(_2, F)), i2[z = m2 + 1 + y2 + e] !== F && (m2 = i2.indexOf(F, z)), p2 = i2.indexOf(S, z), g2 = i2.indexOf(O, z);
                break;
              }
              y2 = v2(g2);
              if (i2.substring(m2 + 1 + y2, m2 + 1 + y2 + s2) === O) {
                if (d2.push(i2.substring(z, m2).replace(_2, F)), w2(m2 + 1 + y2 + s2), p2 = i2.indexOf(S, z), m2 = i2.indexOf(F, z), o2 && (R(), M)) return b();
                if (A && h2.length >= A) return b(true);
                break;
              }
              u2.push({
                type: "Quotes",
                code: "InvalidQuotes",
                message: "Trailing quote on quoted field is malformed",
                row: h2.length,
                index: z
              }), m2++;
            }
          }
          else if (x && 0 === d2.length && i2.substring(z, z + a2) === x) {
            if (-1 === g2) return b();
            z = g2 + s2, g2 = i2.indexOf(O, z), p2 = i2.indexOf(S, z);
          } else if (-1 !== p2 && (p2 < g2 || -1 === g2)) d2.push(i2.substring(z, p2)), z = p2 + e, p2 = i2.indexOf(S, z);
          else {
            if (-1 === g2) break;
            if (d2.push(i2.substring(z, g2)), w2(g2 + s2), o2 && (R(), M)) return b();
            if (A && h2.length >= A) return b(true);
          }
          return E2();
          function k(e2) {
            h2.push(e2), f2 = z;
          }
          function v2(e2) {
            var t2 = 0;
            return t2 = -1 !== e2 && (e2 = i2.substring(m2 + 1, e2)) && "" === e2.trim() ? e2.length : t2;
          }
          function E2(e2) {
            return r2 || (void 0 === e2 && (e2 = i2.substring(z)), d2.push(e2), z = n2, k(d2), o2 && R()), b();
          }
          function w2(e2) {
            z = e2, k(d2), d2 = [], g2 = i2.indexOf(O, z);
          }
          function b(e2) {
            if (C.header && !t && h2.length && !L) {
              var s3 = h2[0], a3 = {}, o3 = new Set(s3);
              let n3 = false;
              for (let r3 = 0; r3 < s3.length; r3++) {
                let i3 = s3[r3];
                if (a3[i3 = U(C.transformHeader) ? C.transformHeader(i3, r3) : i3]) {
                  let e3, t2 = a3[i3];
                  for (; e3 = i3 + "_" + t2, t2++, o3.has(e3); ) ;
                  o3.add(e3), s3[r3] = e3, a3[i3]++, n3 = true, (D = null === D ? {} : D)[e3] = i3;
                } else a3[i3] = 1, s3[r3] = i3;
                o3.add(i3);
              }
              n3 && console.warn("Duplicate headers found and renamed."), L = true;
            }
            return {
              data: h2,
              errors: u2,
              meta: {
                delimiter: S,
                linebreak: O,
                aborted: M,
                truncated: !!e2,
                cursor: f2 + (t || 0),
                renamedHeaders: D
              }
            };
          }
          function R() {
            I(b()), h2 = [], u2 = [];
          }
        }, this.abort = function() {
          M = true;
        }, this.getCharIndex = function() {
          return z;
        };
      }
      function g(e) {
        var t = e.data, i2 = o[t.workerId], r2 = false;
        if (t.error) i2.userError(t.error, t.file);
        else if (t.results && t.results.data) {
          var n2 = {
            abort: function() {
              r2 = true, _(t.workerId, {
                data: [],
                errors: [],
                meta: {
                  aborted: true
                }
              });
            },
            pause: m,
            resume: m
          };
          if (U(i2.userStep)) {
            for (var s2 = 0; s2 < t.results.data.length && (i2.userStep({
              data: t.results.data[s2],
              errors: t.results.errors,
              meta: t.results.meta
            }, n2), !r2); s2++) ;
            delete t.results;
          } else U(i2.userChunk) && (i2.userChunk(t.results, n2, t.file), delete t.results);
        }
        t.finished && !r2 && _(t.workerId, t.results);
      }
      function _(e, t) {
        var i2 = o[e];
        U(i2.userComplete) && i2.userComplete(t), i2.terminate(), delete o[e];
      }
      function m() {
        throw new Error("Not implemented.");
      }
      function w(e) {
        if ("object" != typeof e || null === e) return e;
        var t, i2 = Array.isArray(e) ? [] : {};
        for (t in e) i2[t] = w(e[t]);
        return i2;
      }
      function y(e, t) {
        return function() {
          e.apply(t, arguments);
        };
      }
      function U(e) {
        return "function" == typeof e;
      }
      return v.parse = function(e, t) {
        var i2 = (t = t || {}).dynamicTyping || false;
        U(i2) && (t.dynamicTypingFunction = i2, i2 = {});
        if (t.dynamicTyping = i2, t.transform = !!U(t.transform) && t.transform, !t.worker || !v.WORKERS_SUPPORTED) return i2 = null, v.NODE_STREAM_INPUT, "string" == typeof e ? (e = ((e2) => 65279 !== e2.charCodeAt(0) ? e2 : e2.slice(1))(e), i2 = new (t.download ? f : c)(t)) : true === e.readable && U(e.read) && U(e.on) ? i2 = new p(t) : (n.File && e instanceof File || e instanceof Object) && (i2 = new l(t)), i2.stream(e);
        (i2 = (() => {
          var e2;
          return !!v.WORKERS_SUPPORTED && (e2 = (() => {
            var e3 = n.URL || n.webkitURL || null, t2 = r.toString();
            return v.BLOB_URL || (v.BLOB_URL = e3.createObjectURL(new Blob(["var global = (function() { if (typeof self !== 'undefined') { return self; } if (typeof window !== 'undefined') { return window; } if (typeof global !== 'undefined') { return global; } return {}; })(); global.IS_PAPA_WORKER=true; ", "(", t2, ")();"], {
              type: "text/javascript"
            })));
          })(), (e2 = new n.Worker(e2)).onmessage = g, e2.id = h++, o[e2.id] = e2);
        })()).userStep = t.step, i2.userChunk = t.chunk, i2.userComplete = t.complete, i2.userError = t.error, t.step = U(t.step), t.chunk = U(t.chunk), t.complete = U(t.complete), t.error = U(t.error), delete t.worker, i2.postMessage({
          input: e,
          config: t,
          workerId: i2.id
        });
      }, v.unparse = function(e, t) {
        var n2 = false, _2 = true, m2 = ",", y2 = "\r\n", s2 = '"', a2 = s2 + s2, i2 = false, r2 = null, o2 = false, h2 = ((() => {
          if ("object" == typeof t) {
            if ("string" != typeof t.delimiter || v.BAD_DELIMITERS.filter(function(e2) {
              return -1 !== t.delimiter.indexOf(e2);
            }).length || (m2 = t.delimiter), "boolean" != typeof t.quotes && "function" != typeof t.quotes && !Array.isArray(t.quotes) || (n2 = t.quotes), "boolean" != typeof t.skipEmptyLines && "string" != typeof t.skipEmptyLines || (i2 = t.skipEmptyLines), "string" == typeof t.newline && (y2 = t.newline), "string" == typeof t.quoteChar && (s2 = t.quoteChar), "boolean" == typeof t.header && (_2 = t.header), Array.isArray(t.columns)) {
              if (0 === t.columns.length) throw new Error("Option columns is empty");
              r2 = t.columns;
            }
            void 0 !== t.escapeChar && (a2 = t.escapeChar + s2), t.escapeFormulae instanceof RegExp ? o2 = t.escapeFormulae : "boolean" == typeof t.escapeFormulae && t.escapeFormulae && (o2 = /^[=+\-@\t\r].*$/);
          }
        })(), new RegExp(P(s2), "g"));
        "string" == typeof e && (e = JSON.parse(e));
        if (Array.isArray(e)) {
          if (!e.length || Array.isArray(e[0])) return u2(null, e, i2);
          if ("object" == typeof e[0]) return u2(r2 || Object.keys(e[0]), e, i2);
        } else if ("object" == typeof e) return "string" == typeof e.data && (e.data = JSON.parse(e.data)), Array.isArray(e.data) && (e.fields || (e.fields = e.meta && e.meta.fields || r2), e.fields || (e.fields = Array.isArray(e.data[0]) ? e.fields : "object" == typeof e.data[0] ? Object.keys(e.data[0]) : []), Array.isArray(e.data[0]) || "object" == typeof e.data[0] || (e.data = [e.data])), u2(e.fields || [], e.data || [], i2);
        throw new Error("Unable to serialize unrecognized input");
        function u2(e2, t2, i3) {
          var r3 = "", n3 = ("string" == typeof e2 && (e2 = JSON.parse(e2)), "string" == typeof t2 && (t2 = JSON.parse(t2)), Array.isArray(e2) && 0 < e2.length), s3 = !Array.isArray(t2[0]);
          if (n3 && _2) {
            for (var a3 = 0; a3 < e2.length; a3++) 0 < a3 && (r3 += m2), r3 += k(e2[a3], a3);
            0 < t2.length && (r3 += y2);
          }
          for (var o3 = 0; o3 < t2.length; o3++) {
            var h3 = (n3 ? e2 : t2[o3]).length, u3 = false, d2 = n3 ? 0 === Object.keys(t2[o3]).length : 0 === t2[o3].length;
            if (i3 && !n3 && (u3 = "greedy" === i3 ? "" === t2[o3].join("").trim() : 1 === t2[o3].length && 0 === t2[o3][0].length), "greedy" === i3 && n3) {
              for (var f2 = [], l2 = 0; l2 < h3; l2++) {
                var c2 = s3 ? e2[l2] : l2;
                f2.push(t2[o3][c2]);
              }
              u3 = "" === f2.join("").trim();
            }
            if (!u3) {
              for (var p2 = 0; p2 < h3; p2++) {
                0 < p2 && !d2 && (r3 += m2);
                var g2 = n3 && s3 ? e2[p2] : p2;
                r3 += k(t2[o3][g2], p2);
              }
              o3 < t2.length - 1 && (!i3 || 0 < h3 && !d2) && (r3 += y2);
            }
          }
          return r3;
        }
        function k(e2, t2) {
          var i3, r3;
          return null == e2 ? "" : e2.constructor === Date ? JSON.stringify(e2).slice(1, 25) : (r3 = false, o2 && "string" == typeof e2 && o2.test(e2) && (e2 = "'" + e2, r3 = true), i3 = e2.toString().replace(h2, a2), (r3 = r3 || true === n2 || "function" == typeof n2 && n2(e2, t2) || Array.isArray(n2) && n2[t2] || ((e3, t3) => {
            for (var i4 = 0; i4 < t3.length; i4++) if (-1 < e3.indexOf(t3[i4])) return true;
            return false;
          })(i3, v.BAD_DELIMITERS) || -1 < i3.indexOf(m2) || " " === i3.charAt(0) || " " === i3.charAt(i3.length - 1)) ? s2 + i3 + s2 : i3);
        }
      }, v.RECORD_SEP = String.fromCharCode(30), v.UNIT_SEP = String.fromCharCode(31), v.BYTE_ORDER_MARK = "\uFEFF", v.BAD_DELIMITERS = ["\r", "\n", '"', v.BYTE_ORDER_MARK], v.WORKERS_SUPPORTED = !s && !!n.Worker, v.NODE_STREAM_INPUT = 1, v.LocalChunkSize = 10485760, v.RemoteChunkSize = 5242880, v.DefaultDelimiter = ",", v.Parser = E, v.ParserHandle = i, v.NetworkStreamer = f, v.FileStreamer = l, v.StringStreamer = c, v.ReadableStreamStreamer = p, n.jQuery && ((d = n.jQuery).fn.parse = function(o2) {
        var i2 = o2.config || {}, h2 = [];
        return this.each(function(e2) {
          if (!("INPUT" === d(this).prop("tagName").toUpperCase() && "file" === d(this).attr("type").toLowerCase() && n.FileReader) || !this.files || 0 === this.files.length) return true;
          for (var t = 0; t < this.files.length; t++) h2.push({
            file: this.files[t],
            inputElem: this,
            instanceConfig: d.extend({}, i2)
          });
        }), e(), this;
        function e() {
          if (0 === h2.length) U(o2.complete) && o2.complete();
          else {
            var e2, t, i3, r2, n2 = h2[0];
            if (U(o2.before)) {
              var s2 = o2.before(n2.file, n2.inputElem);
              if ("object" == typeof s2) {
                if ("abort" === s2.action) return e2 = "AbortError", t = n2.file, i3 = n2.inputElem, r2 = s2.reason, void (U(o2.error) && o2.error({
                  name: e2
                }, t, i3, r2));
                if ("skip" === s2.action) return void u2();
                "object" == typeof s2.config && (n2.instanceConfig = d.extend(n2.instanceConfig, s2.config));
              } else if ("skip" === s2) return void u2();
            }
            var a2 = n2.instanceConfig.complete;
            n2.instanceConfig.complete = function(e3) {
              U(a2) && a2(e3, n2.file, n2.inputElem), u2();
            }, v.parse(n2.file, n2.instanceConfig);
          }
        }
        function u2() {
          h2.splice(0, 1), e();
        }
      }), a && (n.onmessage = function(e) {
        e = e.data;
        void 0 === v.WORKER_ID && e && (v.WORKER_ID = e.workerId);
        "string" == typeof e.input ? n.postMessage({
          workerId: v.WORKER_ID,
          results: v.parse(e.input, e.config),
          finished: true
        }) : (n.File && e.input instanceof File || e.input instanceof Object) && (e = v.parse(e.input, e.config)) && n.postMessage({
          workerId: v.WORKER_ID,
          results: e,
          finished: true
        });
      }), (f.prototype = Object.create(u.prototype)).constructor = f, (l.prototype = Object.create(u.prototype)).constructor = l, (c.prototype = Object.create(c.prototype)).constructor = c, (p.prototype = Object.create(u.prototype)).constructor = p, v;
    });
  })(papaparse_min$1);
  return papaparse_min$1.exports;
}
var papaparse_minExports = requirePapaparse_min();
var propertyGridCss = {
  root: "spg-root-modern",
  container: "spg-container-modern",
  header: "spg-title spg-container-modern__title",
  body: "spg-body",
  bodyEmpty: "spg-body spg-body--empty",
  footer: "spg-footer spg-body__footer spg-clearfix",
  title: "",
  description: "",
  logo: "spg-logo",
  logoImage: "spg-logo__image",
  headerText: "spg-header__text",
  navigationButton: "",
  completedPage: "spg-completedpage",
  navigation: {
    complete: "spg-btn spg-footer__complete-btn",
    prev: "spg-btn spg-footer__prev-btn",
    next: "spg-btn spg-footer__next-btn",
    start: "spg-btn spg-footer__start-btn",
    preview: "spg-btn spg-footer__preview-btn",
    edit: "spg-btn spg-footer__edit-btn"
  },
  panel: {
    expandableAnimating: "",
    title: "spg-title spg-panel__title",
    titleBar: "sd-action-title-bar spg-action-title-bar",
    contentEnter: "spg-panel__content--enter",
    contentLeave: "spg-panel__content--leave",
    titleExpandable: "spg-panel__title--expandable",
    titleExpanded: "spg-panel__title--expanded",
    titleCollapsed: "spg-panel__title--collapsed",
    titleOnError: "spg-panel__title--error",
    description: "spg-description spg-panel__description",
    container: "spg-panel spg-row__panel",
    content: "spg-panel__content",
    icon: "spg-panel__icon",
    iconExpanded: "spg-panel__icon--expanded",
    footer: "spg-panel__footer",
    requiredMark: "spg-panel__required-text"
  },
  paneldynamic: {
    mainRoot: "spg-question spg-row__question",
    root: "spg-paneldynamic",
    navigation: "spg-paneldynamic__navigation",
    title: "spg-title spg-question__title",
    button: "spg-action-button spg-action-button--text",
    buttonRemove: "spg-action-button--danger",
    buttonAdd: "spg-paneldynamic__add-btn",
    panelsContainer: "",
    panelWrapper: "spg-paneldynamic__panel-wrapper",
    panelWrapperList: "",
    progressTop: "spg-paneldynamic__progress spg-paneldynamic__progress--top",
    progressBottom: "spg-paneldynamic__progress spg-paneldynamic__progress--bottom",
    buttonPrev: "spg-paneldynamic__prev-btn",
    buttonNext: "spg-paneldynamic__next-btn",
    progressContainer: "spg-paneldynamic__progress-container",
    progress: "spg-progress",
    progressBar: "spg-progress__bar",
    progressText: "spg-paneldynamic__progress-text",
    panelFooter: "spg-panel__footer",
    separator: "spg-paneldynamic__separator"
  },
  progress: "spg-progress spg-body__progress",
  progressBar: "spg-progress__bar",
  progressText: "spg-progress__text",
  progressTextInBar: "spg-hidden",
  page: {
    root: "spg-page spg-body__page",
    title: "spg-title spg-page__title",
    description: "spg-description spg-page__description"
  },
  pageTitle: "spg-title spg-page__title",
  pageDescription: "spg-description spg-page__description",
  row: "spg-row spg-clearfix",
  rowEnter: "spg-row--enter",
  rowLeave: "spg-row--leave",
  rowDelayedEnter: "spg-row--delayed-fade-in",
  rowMultiple: "spg-row--multiple",
  question: {
    mainRoot: "spg-question spg-row__question",
    flowRoot: "spg-question spg-row__question spg-row__question--flow",
    asCell: "spg-table__cell",
    header: "spg-question__header",
    headerLeft: "spg-question__header--location--left",
    headerTop: "spg-question__header--location--top",
    headerBottom: "spg-question__header--location--bottom",
    content: "spg-question__content",
    contentLeft: "spg-question__content--left",
    titleLeftRoot: "spg-question--location--left",
    titleOnAnswer: "spg-question__title--answer",
    titleOnError: "spg-question__title--error",
    title: "spg-title spg-question__title",
    titleBar: "sd-action-title-bar spg-action-title-bar",
    requiredMark: "spg-question__required-text",
    number: "spg-question__num",
    description: "spg-description spg-question__description",
    descriptionUnderInput: "spg-description spg-question__description",
    comment: "spg-comment",
    required: "spg-question--required",
    titleRequired: "spg-question__title--required",
    indent: 0,
    footer: "spg-question__footer",
    formGroup: "spg-question__form-group",
    hasError: "",
    disabled: "spg-question--disabled",
    confirmDialog: "spg-popup--confirm sv-popup--confirm svc-creator-popup"
  },
  image: {
    root: "spg-image",
    image: "sv_image_image"
  },
  error: {
    root: "spg-question__erbox",
    icon: "spg-question__erbox-icon",
    item: "",
    locationTop: "spg-question__erbox--location--top",
    locationBottom: "spg-question__erbox--location--bottom"
  },
  checkbox: {
    root: "spg-selectbase",
    item: "spg-item spg-checkbox spg-selectbase__item",
    itemSelectAll: "spg-checkbox--selectall",
    itemNone: "spg-checkbox--none",
    itemDisabled: "spg-item--disabled spg-checkbox--disabled",
    itemChecked: "spg-checkbox--checked",
    itemHover: "spg-checkbox--allowhover",
    itemInline: "spg-selectbase__item--inline",
    label: "spg-selectbase__label",
    // label: "spg-checkbox",
    itemSvgIconId: "#icon-v2check",
    labelChecked: "",
    //itemControl: "spg-visuallyhidden spg-item__control",
    itemControl: "spg-checkbox__control",
    itemDecorator: "spg-checkbox__svg",
    //itemDecorator: "spg-checkbox__hidden",
    //controlLabel: "spg-item__control-label",
    controlLabel: "spg-checkbox__caption",
    materialDecorator: "spg-checkbox__rectangle",
    //materialDecorator: "spg-item__decorator spg-checkbox__decorator",
    other: "spg-comment spg-question__other",
    column: "spg-selectbase__column"
  },
  radiogroup: {
    root: "spg-selectbase",
    item: "spg-item spg-radio spg-selectbase__item",
    itemInline: "spg-selectbase__item--inline",
    label: "spg-selectbase__label",
    labelChecked: "",
    itemDisabled: "spg-item--disabled spg-radio--disabled",
    itemChecked: "spg-radio--checked",
    itemHover: "spg-radio--allowhover",
    itemControl: "spg-visuallyhidden spg-item__control",
    itemDecorator: "spg-item__svg spg-radio__svg",
    controlLabel: "spg-item__control-label",
    materialDecorator: "spg-item__decorator spg-radio__decorator",
    other: "spg-comment spg-question__other",
    clearButton: "spg-btn spg-selectbase__clear-btn",
    column: "spg-selectbase__column"
  },
  boolean: {
    mainRoot: "spg-question spg-row__question spg-question--boolean",
    rootCheckbox: "spg-selectbase",
    checkboxItem: "spg-checkbox",
    checkboxItemChecked: "spg-checkbox--checked",
    checkboxitemIndeterminate: "spg-checkbox--indeterminate",
    checkboxItemDisabled: "spg-checkbox--disabled",
    svgIconId: "#icon-v2check",
    checkboxLabel: "spg-selectbase__label",
    controlCheckbox: "spg-checkbox__control",
    checkboxControlLabel: "spg-checkbox__caption",
    checkboxItemDecorator: "spg-checkbox__svg",
    checkboxMaterialDecorator: "spg-checkbox__rectangle"
  },
  text: {
    root: "spg-input spg-text",
    small: "spg-row__question--small",
    content: "spg-question__content spg-text__content",
    remainingCharacterCounter: "spg-remaining-character-counter",
    onError: "spg-input--error"
  },
  multipletext: {
    root: "spg-multipletext",
    item: "spg-multipletext__item",
    itemTitle: "spg-multipletext__item-title",
    content: "spg-multipletext__content spg-text__content",
    row: "spg-multipletext__row",
    cell: "spg-multipletext__cell"
  },
  dropdown: {
    root: "",
    popup: "spg-dropdown-popup svc-creator-popup",
    small: "spg-row__question--small sd-row__question--small",
    control: "spg-input spg-dropdown sd-input sd-dropdown",
    controlEmpty: "spg-dropdown--empty sd-dropdown--empty",
    controlValue: "sd-dropdown__value spg-dropdown__value",
    filterStringInput: "sd-dropdown__filter-string-input spg-dropdown__filter-string-input",
    other: "spg-comment spg-question__other",
    onError: "spg-input--error",
    selectWrapper: "sv-dropdown_select-wrapper spg-dropdown_select-wrapper",
    chevronButton: "sd-dropdown_chevron-button spg-dropdown_chevron-button",
    chevronButtonSvg: "sd-dropdown_chevron-button-svg spg-dropdown_chevron-button-svg",
    chevronButtonIconId: "icon-chevron",
    cleanButton: "spg-dropdown__clean-button spg-input__edit-button"
  },
  buttongroup: {
    root: "spg-button-group",
    item: "spg-button-group__item",
    itemIcon: "spg-button-group__item-icon",
    itemDecorator: "spg-button-group__item-decorator",
    itemCaption: "spg-button-group__item-caption",
    itemHover: "spg-button-group__item--hover",
    itemSelected: "spg-button-group__item--selected",
    itemDisabled: "spg-button-group__item--disabled",
    itemControl: "sv-visuallyhidden",
    disabled: "spg-question--disabled"
  },
  imagepicker: {
    root: "spg-imagepicker",
    item: "spg-imagepicker__item",
    itemInline: "spg-imagepicker__item--inline",
    itemChecked: "spg-imagepicker__item--checked",
    itemDisabled: "spg-imagepicker__item--disabled",
    itemHover: "spg-imagepicker__item--allowhover",
    label: "spg-imagepicker__label",
    itemControl: "spg-imagepicker__control",
    image: "spg-imagepicker__image",
    itemText: "spg-imagepicker__text",
    clearButton: "spg-btn",
    other: "spg-comment spg-question__other"
  },
  matrix: {
    tableWrapper: "spg-matrix spg-table-wrapper",
    root: "spg-table",
    rowError: "spg-matrix__row--error",
    cell: "spg-table__cell spg-matrix__cell",
    headerCell: "spg-table__cell spg-table__cell--header",
    label: "spg-item spg-radio spg-matrix__label",
    itemValue: "spg-visuallyhidden spg-item__control spg-radio__control",
    itemChecked: "spg-radio--checked",
    itemDisabled: "spg-item--disabled spg-radio--disabled",
    itemHover: "spg-radio--allowhover",
    materialDecorator: "spg-item__decorator spg-radio__decorator",
    itemDecorator: "spg-item__svg spg-radio__svg",
    cellText: "spg-matrix__text",
    cellTextSelected: "spg-matrix__text--checked",
    cellTextDisabled: "spg-matrix__text--disabled"
  },
  matrixdropdown: {
    tableWrapper: "spg-table-wrapper",
    root: "spg-table",
    cell: "spg-table__cell",
    headerCell: "spg-table__cell spg-table__cell--header",
    emptyCell: "spg-table__cell--empty",
    rowEnter: "spg-table__row--enter",
    rowLeave: "spg-table__row--leave"
  },
  matrixdynamic: {
    tableWrapper: "spg-table-wrapper",
    root: "spg-table spg-matrixdynamic",
    content: "spg-matrixdynamic__content spg-text__content",
    cell: "spg-table__cell",
    row: "spg-table__row",
    rowDisabled: "spg-table__row-disabled",
    rowReadOnly: "spg-table__row-readonly",
    headerCell: "spg-table__cell spg-table__cell--header",
    button: "spg-btn",
    detailRow: "spg-table__row spg-table__row--detail",
    detailButton: "spg-table__cell--detail-button",
    detailButtonExpanded: "spg-table__cell--detail-button--expanded",
    detailIcon: "spg-detail-panel__icon",
    detailIconExpanded: "spg-detail-panel__icon--expanded",
    detailPanelCell: "spg-table__cell spg-table__cell--detail-panel",
    actionsCell: "spg-table__cell spg-table__cell--actions",
    buttonAdd: "spg-matrixdynamic__add-btn spg-action-button spg-action-button--large",
    buttonRemove: "spg-matrixdynamic__remove-btn",
    iconAdd: "",
    iconRemove: "",
    dragElementDecorator: "spg-drag-element__svg",
    iconDragElement: "#icon-drag-24x24",
    iconDrag: "spg-matrixdynamic__drag-element",
    footer: "",
    dragDropGhostPositionTop: "spg-matrixdynamic__drag-drop-ghost-position-top",
    dragDropGhostPositionBottom: "spg-matrixdynamic__drag-drop-ghost-position-bottom",
    noRowsSection: "spg-matrixdynamic__placeholder",
    noRowsText: "spg-matrixdynamic__placeholder-text",
    cellQuestionWrapper: "spg-table__question-wrapper",
    draggedRow: "spg-matrixdynamic__dragged-row",
    emptyCell: "spg-table__cell--empty",
    rowEnter: "spg-table__row--enter",
    rowLeave: "spg-table__row--leave"
  },
  rating: {
    root: "spg-rating",
    item: "spg-rating__item",
    selected: "spg-rating__item--selected",
    minText: "spg-rating__min-text",
    itemText: "spg-rating__item-text",
    maxText: "spg-rating__max-text",
    disabled: "spg-rating--disabled"
  },
  comment: {
    root: "spg-input spg-comment",
    content: "spg-question__content spg-comment__content",
    remainingCharacterCounter: "spg-remaining-character-counter",
    small: "spg-row__question--small",
    onError: "spg-input--error"
  },
  expression: "",
  file: {
    root: "spg-file",
    other: "spg-comment spg-question__other",
    placeholderInput: "spg-visuallyhidden",
    preview: "spg-file__preview",
    fileSign: "spg-hidden",
    fileSignBottom: "spg-file__sign",
    fileDecorator: "spg-file__decorator",
    fileInput: "spg-visuallyhidden",
    noFileChosen: "spg-description spg-file__no-file-chosen",
    chooseFile: "spg-btn spg-file__choose-btn",
    disabled: "spg-file__choose-btn--disabled",
    removeButton: "spg-hidden",
    removeButtonBottom: "spg-btn spg-file__clean-btn",
    removeFile: "spg-hidden",
    removeFileSvg: "spg-file__remove-svg",
    wrapper: "spg-file__wrapper"
  },
  signaturepad: {
    root: "spg-signaturepad sjs_sp_container",
    small: "spg-row__question--small",
    controls: "sjs_sp_controls",
    clearButton: "sjs_sp_clear"
  },
  propertygrid_bindings: {
    content: "spg-question__content spg-question__nopadding spg-question-group"
  },
  propertygrid_restfull: {
    content: "spg-question__content spg-question__nopadding spg-restfull"
  },
  propertygrid_masksettings: {
    content: "spg-question__content spg-question__nopadding spg-masksettings"
  },
  propertygrid_header: {
    mainRoot: "spg-header",
    content: "spg-question__content spg-question__nopadding"
  },
  coloralpha: {
    content: "spg-question__content spg-question__nopadding spg-question__content-coloralpha"
  },
  font: {
    content: "spg-question__content spg-question__nopadding spg-question-composite__content"
  },
  backgroundcornerradius: {
    content: "spg-question__content spg-question__nopadding spg-question-composite__content"
  },
  saveData: {
    root: "",
    saving: "",
    error: "",
    success: "",
    saveAgainButton: ""
  },
  window: {
    root: "sv_window",
    body: "sv_window_content",
    header: {
      root: "sv_window_title",
      title: "",
      button: "",
      buttonExpanded: "",
      buttonCollapsed: ""
    }
  },
  list: JSON.parse(JSON.stringify(listComponentCss)),
  actionBar: {
    root: "spg-action-bar",
    item: "spg-action-button",
    itemPressed: "spg-action-button--pressed",
    itemAsIcon: "spg-action-button--icon",
    itemIcon: "spg-action-button__icon",
    itemTitle: "spg-action-button__title"
  },
  spinedit: {
    root: "spg-input spg-spin-editor spg-input-container",
    control: "spg-spin-editor__input spg-input-container__input",
    buttonsContainer: "spg-input-container__buttons-container",
    arrowButton: "spg-input__edit-button",
    increaseButtonIcon: "icon-arrow-up",
    decreaseButtonIcon: "icon-arrow-down"
  },
  color: {
    root: "spg-input spg-color-editor spg-input-container",
    swatch: "spg-color-editor__color-swatch",
    swatchDefault: "spg-color-editor__color-swatch--default",
    swatchDisabled: "spg-color-editor__color-swatch--disabled",
    colorInput: "spg-color-editor__color-input",
    control: "spg-color-editor__input spg-input-container__input",
    colorDropdown: "spg-input__edit-button",
    colorDropdownIcon: "icon-drop-down-arrow",
    swatchIcon: "icon-color-picker"
  },
  textwithreset: {
    root: "spg-input spg-input-container",
    rootMultiline: "spg-input-container--multiline",
    control: "spg-input-container__input",
    controlMultiline: "spg-input-container__input spg-comment",
    resetButton: "spg-input__edit-button",
    resetButtonIcon: "icon-reset",
    content: "spg-question__content spg-text__content",
    remainingCharacterCounter: "spg-remaining-character-counter",
    onError: "spg-input--error"
  },
  fileedit: {
    root: "spg-input spg-input-container spg-file-edit",
    control: "spg-input-container__input",
    buttonsContainer: "spg-input-container__buttons-container",
    chooseButtonIcon: "icon-choosefile",
    clearButtonIcon: "icon-cancel-24x24",
    fileInput: "sd-visuallyhidden",
    clearButton: "spg-input__edit-button",
    chooseButton: "spg-input__edit-button spg-file-edit__choose-button",
    chooseButtonDisabled: "spg-input__edit-button--disabled"
  },
  linkvalue: {
    content: "spg-link"
  }
};
var defaultProperties = {
  question: {
    properties: ["name", "title", "description", "visible", "readOnly", "isRequired", "showCommentArea", "commentText", "commentPlaceholder", {
      name: "visibleIf",
      tab: "logic"
    }, {
      name: "enableIf",
      tab: "logic"
    }, {
      name: "requiredIf",
      tab: "logic"
    }, {
      name: "bindings",
      tab: "logic"
    }, {
      name: "defaultValueExpression",
      tab: "logic"
    }, {
      name: "resetValueIf",
      tab: "logic"
    }, {
      name: "setValueIf",
      tab: "logic"
    }, {
      name: "setValueExpression",
      tab: "logic"
    }, {
      name: "page",
      tab: "layout"
    }, {
      name: "startWithNewLine",
      tab: "layout"
    }, {
      name: "showNumber",
      tab: "layout"
    }, {
      name: "state",
      tab: "layout"
    }, {
      name: "titleLocation",
      tab: "layout"
    }, {
      name: "descriptionLocation",
      tab: "layout"
    }, {
      name: "errorLocation",
      tab: "layout"
    }, {
      name: "indent",
      tab: "layout"
    }, {
      name: "width",
      tab: "layout"
    }, {
      name: "minWidth",
      tab: "layout"
    }, {
      name: "maxWidth",
      tab: "layout"
    }, {
      name: "effectiveColSpan",
      tab: "layout"
    }, {
      name: "valueName",
      tab: "data"
    }, {
      name: "defaultValue",
      tab: "data"
    }, {
      name: "correctAnswer",
      tab: "data"
    }, {
      name: "useDisplayValuesInDynamicTexts",
      tab: "data"
    }, {
      name: "defaultDisplayValue",
      tab: "data"
    }, {
      name: "clearIfInvisible",
      tab: "data"
    }, {
      name: "validators",
      tab: "validation"
    }, {
      name: "requiredErrorText",
      tab: "validation"
    }],
    tabs: [{
      name: "layout",
      index: 100
    }, {
      name: "logic",
      index: 200
    }, {
      name: "data",
      index: 300
    }, {
      name: "validation",
      index: 400
    }]
  },
  comment: {
    properties: [{
      name: "rows",
      tab: "layout"
    }, {
      name: "cols",
      tab: "layout"
    }, "placeholder", {
      name: "maxLength",
      tab: "validation"
    }, {
      name: "textUpdateMode",
      tab: "data"
    }, {
      name: "autoGrow",
      tab: "layout"
    }, {
      name: "allowResize",
      tab: "layout"
    }]
  },
  file: {
    properties: ["sourceType", "visible", "readOnly", "isRequired", "showCommentArea", "allowMultiple", {
      name: "showPreview"
    }, "allowImagesPreview", "waitForUpload", "needConfirmRemoveFile", {
      name: "storeDataAsText"
    }, "allowCameraAccess", "acceptedTypes", "maxSize", "imageHeight", "imageWidth", "filePlaceholder", "photoPlaceholder", "fileOrPhotoPlaceholder"]
  },
  signaturepad: {
    properties: ["dataFormat", "signatureWidth", "signatureHeight", "signatureAutoScaleEnabled", "showPlaceholder", "placeholder", "placeholderReadOnly", "allowClear", "backgroundImage", "backgroundColor", "penMinWidth", "penMaxWidth", "penColor", "waitForUpload", {
      name: "storeDataAsText"
    }]
  },
  html: {
    properties: ["html"]
  },
  matrixdropdownbase: {
    properties: ["cellType", "optionsCaption", "detailPanelMode", "detailPanelShowOnAdding", {
      name: "showHeader",
      tab: "layout"
    }, {
      name: "showColumnHeader",
      tab: "layout"
    }, {
      name: "verticalAlign",
      tab: "layout"
    }, {
      name: "alternateRows",
      tab: "layout"
    }, {
      name: "columnsVisibleIf",
      tab: "logic"
    }, {
      name: "rowsVisibleIf",
      tab: "logic"
    }, {
      name: "columnLayout",
      tab: "layout"
    }, {
      name: "transposeData",
      tab: "layout"
    }, {
      name: "horizontalScroll",
      tab: "layout"
    }, {
      name: "columnColCount",
      tab: "layout"
    }, {
      name: "columnMinWidth",
      tab: "layout"
    }, {
      name: "cellErrorLocation",
      tab: "layout"
    }, {
      name: "detailErrorLocation",
      tab: "layout"
    }],
    tabs: [{
      name: "columns",
      index: 10
    }, {
      name: "rows",
      index: 11
    }, {
      name: "choices",
      index: 12
    }]
  },
  matrixdynamic: {
    properties: ["allowAddRows", "allowRemoveRows", "allowRowReorder", "rowCount", "minRowCount", "maxRowCount", "addRowButtonLocation", "addRowText", "removeRowText", "confirmDelete", "confirmDeleteText", "placeholder", {
      name: "hideColumnsIfEmpty",
      tab: "columns"
    }, {
      name: "noRowsText",
      tab: "columns"
    }, {
      name: "defaultRowValue",
      tab: "data"
    }, {
      name: "copyDefaultValueFromLastEntry",
      tab: "data"
    }, {
      name: "keyName",
      tab: "validation"
    }, {
      name: "keyDuplicationError",
      tab: "validation"
    }]
  },
  matrixdropdown: {
    properties: ["totalText", "placeholder", {
      name: "hideIfRowsEmpty",
      tab: "rows"
    }, {
      name: "rowTitleWidth",
      tab: "layout"
    }, {
      name: "keyDuplicationError",
      tab: "validation"
    }]
  },
  matrix: {
    properties: [{
      name: "eachRowRequired",
      tab: "validation"
    }, {
      name: "eachRowUnique",
      tab: "validation"
    }, {
      name: "showHeader",
      tab: "layout"
    }, {
      name: "showColumnHeader",
      tab: "layout"
    }, {
      name: "verticalAlign",
      tab: "layout"
    }, {
      name: "alternateRows",
      tab: "layout"
    }, {
      name: "rowOrder",
      tab: "rows"
    }, {
      name: "hideIfRowsEmpty",
      tab: "rows"
    }, {
      name: "columnsVisibleIf",
      tab: "logic"
    }, {
      name: "rowsVisibleIf",
      tab: "logic"
    }, {
      name: "columnMinWidth",
      tab: "layout"
    }, {
      name: "rowTitleWidth",
      tab: "layout"
    }],
    tabs: [{
      name: "columns",
      index: 10
    }, {
      name: "rows",
      index: 11
    }, {
      name: "cells",
      index: 500
    }]
  },
  multipletext: {
    properties: [{
      name: "colCount",
      tab: "layout"
    }, {
      name: "inputSize",
      tab: "layout"
    }, {
      name: "itemErrorLocation",
      tab: "layout"
    }],
    tabs: [{
      name: "items",
      index: 10
    }]
  },
  rating: {
    properties: [{
      name: "displayMode",
      tab: "rateValues"
    }, {
      name: "rateCount",
      tab: "rateValues"
    }, {
      name: "rateMin",
      tab: "rateValues"
    }, {
      name: "rateMax",
      tab: "rateValues"
    }, {
      name: "rateStep",
      tab: "rateValues"
    }, {
      name: "minRateDescription",
      tab: "rateValues"
    }, {
      name: "maxRateDescription",
      tab: "rateValues"
    }, {
      name: "rateDescriptionLocation",
      tab: "rateValues"
    }, {
      name: "displayRateDescriptionsAsExtremeItems",
      tab: "rateValues"
    }],
    tabs: [{
      name: "rateValues",
      index: 10
    }]
  },
  selectbase: {
    properties: [{
      name: "choicesFromQuestion",
      tab: "choices"
    }, {
      name: "choicesFromQuestionMode",
      tab: "choices"
    }, {
      name: "choiceValuesFromQuestion",
      tab: "choices"
    }, {
      name: "choiceTextsFromQuestion",
      tab: "choices"
    }, {
      name: "choicesOrder",
      tab: "choices"
    }, {
      name: "colCount",
      tab: "layout"
    }, {
      name: "textWrapEnabled",
      tab: "choices"
    }, {
      name: "showOtherItem",
      tab: "choices"
    }, {
      name: "otherText",
      tab: "choices"
    }, {
      name: "otherPlaceholder",
      tab: "choices"
    }, {
      name: "showNoneItem",
      tab: "choices"
    }, {
      name: "noneText",
      tab: "choices"
    }, {
      name: "showRefuseItem",
      tab: "choices"
    }, {
      name: "refuseText",
      tab: "choices"
    }, {
      name: "showDontKnowItem",
      tab: "choices"
    }, {
      name: "dontKnowText",
      tab: "choices"
    }, {
      name: "hideIfChoicesEmpty",
      tab: "logic"
    }, {
      name: "choicesVisibleIf",
      tab: "logic"
    }, {
      name: "choicesEnableIf",
      tab: "logic"
    }, {
      name: "otherErrorText",
      tab: "validation"
    }, {
      name: "separateSpecialChoices",
      tab: "choices"
    }],
    tabs: [{
      name: "choices",
      index: 10
    }, {
      name: "choicesByUrl",
      index: 11
    }]
  },
  checkbox: {
    properties: [{
      name: "showSelectAllItem",
      tab: "choices"
    }, {
      name: "selectAllText",
      tab: "choices"
    }, {
      name: "minSelectedChoices",
      tab: "choices"
    }, {
      name: "maxSelectedChoices",
      tab: "choices"
    }, {
      name: "separateSpecialChoices",
      tab: "choices"
    }]
  },
  ranking: {
    properties: [{
      name: "selectToRankEnabled"
    }, {
      name: "selectToRankAreasLayout"
    }, {
      name: "minSelectedChoices",
      tab: "choices"
    }, {
      name: "maxSelectedChoices",
      tab: "choices"
    }]
  },
  radiogroup: {
    properties: [{
      name: "allowClear",
      tab: "choices"
    }, {
      name: "separateSpecialChoices",
      tab: "choices"
    }]
  },
  dropdown: {
    properties: ["placeholder", "autocomplete", {
      name: "choicesMin",
      tab: "choices"
    }, {
      name: "choicesMax",
      tab: "choices"
    }, {
      name: "choicesStep",
      tab: "choices"
    }, {
      name: "allowClear",
      tab: "choices"
    }, {
      name: "searchMode",
      tab: "choices"
    }]
  },
  tagbox: {
    properties: ["closeOnSelect", "placeholder", {
      name: "searchEnabled",
      tab: "choices"
    }, {
      name: "searchMode",
      tab: "choices"
    }, {
      name: "hideSelectedItems",
      tab: "choices"
    }, {
      name: "allowClear",
      tab: "choices"
    }]
  },
  imagepicker: {
    properties: ["contentMode", "imageFit", "isResponsive", "minImageWidth", "maxImageWidth", "minImageHeight", "maxImageHeight", "imageHeight", "imageWidth", "multiSelect", "showLabel"]
  },
  image: {
    properties: ["imageLink", "contentMode", "imageFit", "imageHeight", "imageWidth", "text"]
  },
  "itemvalue[]@choices": {
    properties: [{
      name: "visibleIf"
    }, {
      name: "enableIf"
    }],
    tabs: [{
      name: "general"
    }]
  },
  "itemvalue[]@rows": {
    properties: [{
      name: "visibleIf"
    }, {
      name: "enableIf"
    }],
    tabs: [{
      name: "general"
    }]
  },
  "itemvalue[]@columns": {
    properties: [{
      name: "visibleIf"
    }, {
      name: "enableIf"
    }],
    tabs: [{
      name: "general"
    }]
  },
  text: {
    properties: ["inputType", "min", "max", "step", "placeholder", "autocomplete", "dataList", {
      name: "minValueExpression",
      tab: "logic"
    }, {
      name: "maxValueExpression",
      tab: "logic"
    }, {
      name: "inputSize",
      tab: "layout"
    }, {
      name: "inputTextAlignment",
      tab: "layout"
    }, {
      name: "maxLength",
      tab: "validation"
    }, {
      name: "minErrorText",
      tab: "validation"
    }, {
      name: "maxErrorText",
      tab: "validation"
    }, {
      name: "textUpdateMode",
      tab: "data"
    }, {
      name: "maskType",
      tab: "mask"
    }, {
      name: "maskSettings",
      tab: "mask"
    }],
    tabs: [{
      name: "mask",
      index: 250
    }]
  },
  boolean: {
    properties: ["label", "labelTrue", "labelFalse", "showTitle", {
      name: "valueTrue",
      tab: "data"
    }, {
      name: "valueFalse",
      tab: "data"
    }]
  },
  expression: {
    properties: ["expression", "displayStyle", "currency", "format", "maximumFractionDigits", "minimumFractionDigits", "useGrouping"]
  },
  "panellayoutcolumn": {
    properties: ["effectiveWidth", "questionTitleWidth"]
  },
  matrixdropdowncolumn: {
    properties: ["name", "title"]
  },
  "matrixdropdowncolumn@default": {
    properties: ["name", "title", "cellType", "visible", "readOnly", "isRequired", "isUnique", "showInMultipleColumns", "width", "minWidth", {
      name: "visibleIf",
      tab: "logic"
    }, {
      name: "enableIf",
      tab: "logic"
    }, {
      name: "requiredIf",
      tab: "logic"
    }, {
      name: "defaultValueExpression",
      tab: "logic"
    }, {
      name: "resetValueIf",
      tab: "logic"
    }, {
      name: "setValueIf",
      tab: "logic"
    }, {
      name: "setValueExpression",
      tab: "logic"
    }, {
      name: "totalType",
      tab: "totals"
    }, {
      name: "totalDisplayStyle",
      tab: "totals"
    }, {
      name: "totalCurrency",
      tab: "totals"
    }, {
      name: "totalFormat",
      tab: "totals"
    }, {
      name: "totalExpression",
      tab: "totals"
    }, {
      name: "validators",
      tab: "validation"
    }, {
      name: "requiredErrorText",
      tab: "validation"
    }, {
      name: "defaultDisplayValue",
      tab: "data"
    }],
    tabs: [{
      name: "general",
      index: 5
    }, {
      name: "logic",
      index: 20
    }, {
      name: "data",
      index: 25
    }, {
      name: "totals",
      index: 40
    }, {
      name: "validation",
      index: 60
    }]
  },
  "matrixdropdowncolumn@checkbox": {
    properties: [{
      name: "choicesFromQuestion",
      tab: "choices"
    }, {
      name: "choicesFromQuestionMode",
      tab: "choices"
    }, {
      name: "choiceValuesFromQuestion",
      tab: "choices"
    }, {
      name: "choiceTextsFromQuestion",
      tab: "choices"
    }, {
      name: "showOtherItem",
      tab: "choices"
    }, {
      name: "otherText",
      tab: "choices"
    }, {
      name: "otherPlaceholder",
      tab: "choices"
    }, {
      name: "choicesOrder",
      tab: "choices"
    }, {
      name: "colCount",
      tab: "choices"
    }, {
      name: "showSelectAllItem",
      tab: "choices"
    }, {
      name: "showNoneItem",
      tab: "choices"
    }, {
      name: "noneText",
      tab: "choices"
    }, {
      name: "showRefuseItem",
      tab: "choices"
    }, {
      name: "refuseText",
      tab: "choices"
    }, {
      name: "showDontKnowItem",
      tab: "choices"
    }, {
      name: "dontKnowText",
      tab: "choices"
    }, {
      name: "minSelectedChoices",
      tab: "choices"
    }, {
      name: "maxSelectedChoices",
      tab: "choices"
    }, {
      name: "selectAllText",
      tab: "choices"
    }, {
      name: "choicesVisibleIf",
      tab: "logic"
    }, {
      name: "choicesEnableIf",
      tab: "logic"
    }],
    tabs: [{
      name: "choices",
      index: 10
    }, {
      name: "choicesByUrl",
      index: 11
    }]
  },
  "matrixdropdowncolumn@radiogroup": {
    properties: [{
      name: "choicesFromQuestion",
      tab: "choices"
    }, {
      name: "choicesFromQuestionMode",
      tab: "choices"
    }, {
      name: "choiceValuesFromQuestion",
      tab: "choices"
    }, {
      name: "choiceTextsFromQuestion",
      tab: "choices"
    }, {
      name: "showOtherItem",
      tab: "choices"
    }, {
      name: "otherText",
      tab: "choices"
    }, {
      name: "otherPlaceholder",
      tab: "choices"
    }, {
      name: "choicesOrder",
      tab: "choices"
    }, {
      name: "colCount",
      tab: "choices"
    }, {
      name: "showNoneItem",
      tab: "choices"
    }, {
      name: "noneText",
      tab: "choices"
    }, {
      name: "showRefuseItem",
      tab: "choices"
    }, {
      name: "refuseText",
      tab: "choices"
    }, {
      name: "showDontKnowItem",
      tab: "choices"
    }, {
      name: "dontKnowText",
      tab: "choices"
    }, {
      name: "choicesVisibleIf",
      tab: "logic"
    }, {
      name: "choicesEnableIf",
      tab: "logic"
    }],
    tabs: [{
      name: "choices",
      index: 10
    }, {
      name: "choicesByUrl",
      index: 11
    }]
  },
  "matrixdropdowncolumn@dropdown": {
    properties: ["placeholder", {
      name: "choicesFromQuestion",
      tab: "choices"
    }, {
      name: "choicesFromQuestionMode",
      tab: "choices"
    }, {
      name: "choiceValuesFromQuestion",
      tab: "choices"
    }, {
      name: "choiceTextsFromQuestion",
      tab: "choices"
    }, {
      name: "showOtherItem",
      tab: "choices"
    }, {
      name: "otherText",
      tab: "choices"
    }, {
      name: "otherPlaceholder",
      tab: "choices"
    }, {
      name: "choicesOrder",
      tab: "choices"
    }, {
      name: "optionsCaption",
      tab: "choices"
    }, {
      name: "showNoneItem",
      tab: "choices"
    }, {
      name: "noneText",
      tab: "choices"
    }, {
      name: "showRefuseItem",
      tab: "choices"
    }, {
      name: "refuseText",
      tab: "choices"
    }, {
      name: "showDontKnowItem",
      tab: "choices"
    }, {
      name: "dontKnowText",
      tab: "choices"
    }, {
      name: "choicesMin",
      tab: "choices"
    }, {
      name: "choicesMax",
      tab: "choices"
    }, {
      name: "choicesStep",
      tab: "choices"
    }, {
      name: "allowClear",
      tab: "choices"
    }, {
      name: "choicesVisibleIf",
      tab: "logic"
    }, {
      name: "choicesEnableIf",
      tab: "logic"
    }],
    tabs: [{
      name: "choices",
      index: 10
    }, {
      name: "choicesByUrl",
      index: 11
    }]
  },
  "matrixdropdowncolumn@tagbox": {
    properties: ["placeholder", {
      name: "choicesFromQuestion",
      tab: "choices"
    }, {
      name: "choicesFromQuestionMode",
      tab: "choices"
    }, {
      name: "choiceValuesFromQuestion",
      tab: "choices"
    }, {
      name: "choiceTextsFromQuestion",
      tab: "choices"
    }, {
      name: "showOtherItem",
      tab: "choices"
    }, {
      name: "otherText",
      tab: "choices"
    }, {
      name: "otherPlaceholder",
      tab: "choices"
    }, {
      name: "choicesOrder",
      tab: "choices"
    }, {
      name: "optionsCaption",
      tab: "choices"
    }, {
      name: "showNoneItem",
      tab: "choices"
    }, {
      name: "noneText",
      tab: "choices"
    }, {
      name: "showRefuseItem",
      tab: "choices"
    }, {
      name: "refuseText",
      tab: "choices"
    }, {
      name: "showDontKnowItem",
      tab: "choices"
    }, {
      name: "dontKnowText",
      tab: "choices"
    }, {
      name: "choicesMin",
      tab: "choices"
    }, {
      name: "choicesMax",
      tab: "choices"
    }, {
      name: "choicesStep",
      tab: "choices"
    }, {
      name: "allowClear",
      tab: "choices"
    }, {
      name: "choicesVisibleIf",
      tab: "logic"
    }, {
      name: "choicesEnableIf",
      tab: "logic"
    }],
    tabs: [{
      name: "choices",
      index: 10
    }, {
      name: "choicesByUrl",
      index: 11
    }]
  },
  "matrixdropdowncolumn@text": {
    properties: ["inputType", "min", "max", "step", "placeholder", "dataList", "maxLength", {
      name: "maskType",
      tab: "mask"
    }, {
      name: "maskSettings",
      tab: "mask"
    }],
    tabs: [{
      name: "mask",
      index: 20
    }]
  },
  "matrixdropdowncolumn@comment": {
    properties: ["rows", "placeholder ", "maxLength"]
  },
  "matrixdropdowncolumn@boolean": {
    properties: [{
      name: "labelTrue",
      tab: "data"
    }, {
      name: "labelFalse",
      tab: "data"
    }, {
      name: "valueTrue",
      tab: "data"
    }, {
      name: "valueFalse",
      tab: "data"
    }, {
      name: "defaultValue",
      tab: "data"
    }],
    tabs: [{
      name: "data",
      index: 25
    }]
  },
  "matrixdropdowncolumn@expression": {
    properties: ["expression", "displayStyle", "currency"]
  },
  "matrixdropdowncolumn@rating": {
    properties: [{
      name: "displayMode",
      tab: "rateValues"
    }, {
      name: "rateType",
      tab: "rateValues"
    }, {
      name: "rateCount",
      tab: "rateValues"
    }, {
      name: "rateColorMode",
      tab: "rateValues"
    }, {
      name: "scaleColorMode",
      tab: "rateValues"
    }, {
      name: "autoGenerate",
      tab: "rateValues"
    }, {
      name: "rateMin",
      tab: "rateValues"
    }, {
      name: "rateMax",
      tab: "rateValues"
    }, {
      name: "rateStep",
      tab: "rateValues"
    }, {
      name: "rateValues",
      tab: "rateValues"
    }, {
      name: "minRateDescription",
      tab: "rateValues"
    }, {
      name: "maxRateDescription",
      tab: "rateValues"
    }, {
      name: "rateDescriptionLocation",
      tab: "rateValues"
    }, {
      name: "displayRateDescriptionsAsExtremeItems",
      tab: "rateValues"
    }],
    tabs: [{
      name: "rateValues",
      index: 5
    }]
  },
  multipletextitem: {
    properties: ["name", "title", "inputType", "isRequired", "inputSize", "placeholder", "inputTextAlignment", {
      name: "maxLength",
      tab: "validation"
    }, {
      name: "requiredErrorText",
      tab: "validation"
    }, {
      name: "validators",
      tab: "validation"
    }, {
      name: "defaultValueExpression",
      tab: "logic"
    }, {
      name: "minValueExpression",
      tab: "logic"
    }, {
      name: "maxValueExpression",
      tab: "logic"
    }, {
      name: "maskType",
      tab: "mask"
    }, {
      name: "maskSettings",
      tab: "mask"
    }],
    tabs: [{
      name: "logic",
      index: 200
    }, {
      name: "mask",
      index: 250
    }, {
      name: "validation",
      index: 300
    }]
  },
  "multipletext@items": {
    properties: ["name", "title"]
  },
  calculatedvalue: {
    properties: ["name", "expression", "includeIntoResult"]
  },
  "calculatedvalue@items": {
    properties: ["name", "expression"]
  },
  paneldynamic: {
    properties: ["renderMode", "displayMode", "templateTabTitle", "tabTitlePlaceholder", "tabAlign", "panelCount", "minPanelCount", "maxPanelCount", "panelsState", {
      name: "allowAddPanel"
    }, {
      name: "allowRemovePanel"
    }, "addPanelText", "removePanelText", "templateTitle", "templateDescription", "noEntriesText", "confirmDelete", "confirmDeleteText", "prevPanelText", "nextPanelText", "showQuestionNumbers", "showRangeInProgress", "showProgressBar", "progressBarLocation", {
      name: "defaultPanelValue",
      tab: "data"
    }, {
      name: "copyDefaultValueFromLastEntry",
      tab: "data"
    }, {
      name: "templateQuestionTitleLocation",
      tab: "questionSettings"
    }, {
      name: "templateErrorLocation",
      tab: "questionSettings"
    }, {
      name: "removePanelButtonLocation",
      tab: "layout"
    }, {
      name: "keyName",
      tab: "validation"
    }, {
      name: "keyDuplicationError",
      tab: "validation"
    }]
  },
  panelbase: {
    properties: ["name", "title", "description", "visible", "readOnly", {
      name: "visibleIf",
      tab: "logic"
    }, {
      name: "enableIf",
      tab: "logic"
    }, {
      name: "requiredIf",
      tab: "logic"
    }, {
      name: "questionTitleLocation",
      tab: "questionSettings"
    }, {
      name: "questionTitleWidth",
      tab: "questionSettings"
    }, {
      name: "questionErrorLocation",
      tab: "questionSettings"
    }, {
      name: "gridLayoutColumns",
      tab: "questionSettings",
      index: 900
    }],
    tabs: [{
      name: "questionSettings",
      index: 100
    }, {
      name: "logic",
      index: 200
    }, {
      name: "data",
      index: 300
    }, {
      name: "validation",
      index: 400
    }]
  },
  panel: {
    properties: ["isRequired", {
      name: "questionOrder",
      tab: "questionSettings"
    }, {
      name: "innerIndent",
      tab: "questionSettings"
    }, {
      name: "requiredErrorText",
      tab: "validation"
    }, {
      name: "page",
      tab: "layout"
    }, {
      name: "startWithNewLine",
      tab: "layout"
    }, {
      name: "state",
      tab: "layout"
    }, {
      name: "width",
      tab: "layout"
    }, {
      name: "minWidth",
      tab: "layout"
    }, {
      name: "maxWidth",
      tab: "layout"
    }, {
      name: "effectiveColSpan",
      tab: "layout"
    }, {
      name: "showNumber",
      tab: "numbering"
    }, {
      name: "showQuestionNumbers",
      tab: "numbering"
    }, {
      name: "questionStartIndex",
      tab: "numbering"
    }],
    tabs: [{
      name: "layout",
      index: 150
    }, {
      name: "numbering",
      index: 350
    }]
  },
  page: {
    properties: ["navigationTitle", "navigationDescription", "timeLimit", "maxTimeToFinish", {
      name: "questionOrder",
      tab: "questionSettings"
    }, {
      name: "showNavigationButtons",
      tab: "navigation"
    }],
    tabs: [{
      name: "navigation",
      index: 350
    }, {
      name: "layout",
      visible: false
    }]
  },
  survey: {
    properties: ["title", "description", "showTitle", "readOnly", "locale", "cookieName", "widthMode", "width", "fitToContainer", {
      name: "questionsOnPageMode",
      tab: "navigation"
    }, {
      name: "firstPageIsStartPage",
      tab: "navigation"
    }, {
      name: "autoAdvanceEnabled",
      tab: "navigation"
    }, {
      name: "autoAdvanceAllowComplete",
      tab: "navigation"
    }, {
      name: "showNavigationButtons",
      tab: "navigation"
    }, {
      name: "navigationButtonsLocation",
      tab: "navigation"
    }, {
      name: "showPrevButton",
      tab: "navigation"
    }, {
      name: "showProgressBar",
      tab: "navigation"
    }, {
      name: "progressBarType",
      tab: "navigation"
    }, {
      name: "progressBarLocation",
      tab: "navigation"
    }, {
      name: "progressBarShowPageTitles",
      tab: "navigation"
    }, {
      name: "progressBarShowPageNumbers",
      tab: "navigation"
    }, {
      name: "showTOC",
      tab: "navigation"
    }, {
      name: "tocLocation",
      tab: "navigation"
    }, {
      name: "showPreviewBeforeComplete",
      tab: "navigation"
    }, {
      name: "previewMode",
      tab: "navigation"
    }, {
      name: "previewText",
      tab: "navigation"
    }, {
      name: "editText",
      tab: "navigation"
    }, {
      name: "startSurveyText",
      tab: "navigation"
    }, {
      name: "pagePrevText",
      tab: "navigation"
    }, {
      name: "pageNextText",
      tab: "navigation"
    }, {
      name: "completeText",
      tab: "navigation"
    }, {
      name: "questionOrder",
      tab: "question"
    }, {
      name: "questionTitleLocation",
      tab: "question"
    }, {
      name: "questionDescriptionLocation",
      tab: "question"
    }, {
      name: "showQuestionNumbers",
      tab: "question"
    }, {
      name: "questionTitlePattern",
      tab: "question"
    }, {
      name: "requiredMark",
      tab: "question"
    }, {
      name: "questionStartIndex",
      tab: "question"
    }, {
      name: "questionErrorLocation",
      tab: "question"
    }, {
      name: "autoFocusFirstQuestion",
      tab: "question"
    }, {
      name: "maxTextLength",
      tab: "question"
    }, {
      name: "maxCommentLength",
      tab: "question"
    }, {
      name: "commentAreaRows",
      tab: "question"
    }, {
      name: "autoGrowComment",
      tab: "question"
    }, {
      name: "allowResizeComment",
      tab: "question"
    }, {
      name: "showPageTitles",
      tab: "pages"
    }, {
      name: "showPageNumbers",
      tab: "pages"
    }, {
      name: "gridLayoutEnabled",
      tab: "pages"
    }, {
      name: "calculatedValues",
      tab: "logic"
    }, {
      name: "triggers",
      tab: "logic"
    }, {
      name: "clearInvisibleValues",
      tab: "data"
    }, {
      name: "textUpdateMode",
      tab: "data"
    }, {
      name: "partialSendEnabled",
      tab: "data"
    }, {
      name: "storeOthersAsComment",
      tab: "data"
    }, {
      name: "autoFocusFirstError",
      tab: "validation"
    }, {
      name: "checkErrorsMode",
      tab: "validation"
    }, {
      name: "validateVisitedEmptyFields",
      tab: "validation"
    }, {
      name: "navigateToUrl",
      tab: "showOnCompleted"
    }, {
      name: "navigateToUrlOnCondition",
      tab: "showOnCompleted"
    }, {
      name: "showCompletePage",
      tab: "showOnCompleted"
    }, {
      name: "completedHtml",
      tab: "showOnCompleted"
    }, {
      name: "completedHtmlOnCondition",
      tab: "showOnCompleted"
    }, {
      name: "loadingHtml",
      tab: "showOnCompleted"
    }, {
      name: "completedBeforeHtml",
      tab: "showOnCompleted"
    }, {
      name: "showTimer",
      tab: "timer"
    }, {
      name: "timerLocation",
      tab: "timer"
    }, {
      name: "timeLimit",
      tab: "timer"
    }, {
      name: "timeLimitPerPage",
      tab: "timer"
    }, {
      name: "timerInfoMode",
      tab: "timer"
    }, {
      name: "maxTimeToFinish",
      tab: "timer"
    }, {
      name: "maxTimeToFinishPage",
      tab: "timer"
    }, {
      name: "showTimerPanel",
      tab: "timer"
    }, {
      name: "showTimerPanelMode",
      tab: "timer"
    }, {
      name: "logo",
      tab: "logo"
    }, {
      name: "logoPosition",
      tab: "logo"
    }, {
      name: "logoWidth",
      tab: "logo"
    }, {
      name: "logoHeight",
      tab: "logo"
    }, {
      name: "logoFit",
      tab: "logo"
    }],
    tabs: [{
      name: "logo",
      index: 50
    }, {
      name: "navigation",
      index: 100
    }, {
      name: "question",
      index: 200
    }, {
      name: "pages",
      index: 250
    }, {
      name: "logic",
      index: 300
    }, {
      name: "data",
      index: 400
    }, {
      name: "validation",
      index: 500
    }, {
      name: "showOnCompleted",
      index: 600
    }, {
      name: "timer",
      index: 700
    }]
  },
  "page@survey": {
    properties: ["name", "title"]
  },
  choicesByUrl: {
    properties: ["url", "path", "valueName", "titleName", "allowEmptyResponse"]
  },
  "patternmask@maskSettings": {
    properties: ["pattern", "saveMaskedValue"]
  },
  "datetimemask@maskSettings": {
    properties: ["pattern", "min", "max", "saveMaskedValue"]
  },
  "numericmask@maskSettings": {
    properties: ["min", "max", "precision", "decimalSeparator", "thousandsSeparator", "allowNegativeValues", "saveMaskedValue"]
  },
  "currencymask@maskSettings": {
    properties: ["prefix", "suffix", "min", "max", "precision", "decimalSeparator", "thousandsSeparator", "allowNegativeValues", "saveMaskedValue"]
  },
  "patternmask": {
    properties: ["pattern"]
  },
  "datetimemask": {
    properties: ["pattern"]
  },
  "currencymask": {
    properties: ["prefix", "suffix"]
  }
};
var defaultPropertyGridDefinition = {
  autoGenerateProperties: true,
  classes: defaultProperties
};
var SurveyQuestionEditorDefinition = class {
};
SurveyQuestionEditorDefinition.definition = defaultProperties;
var SurveyQuestionEditorPropertyDefinition = class {
  get name() {
    return !!this.property ? this.property.name : "";
  }
};
var SurveyQuestionEditorTabDefinition = class {
  constructor() {
    this.visible = true;
    this.index = 0;
    this.properties = [];
  }
};
var otherTabName = "others";
var SurveyQuestionProperties = class {
  constructor(obj, options = null, className = null, showMode = null, parentObj = null, parentProperty = null, propertyGridDefinition = null) {
    this.obj = obj;
    this.options = options;
    this.parentObj = parentObj;
    this.parentProperty = parentProperty;
    this.propertyGridDefinition = propertyGridDefinition;
    this.tabs = [];
    this.unusedProperties = [];
    if (!this.propertyGridDefinition) {
      this.propertyGridDefinition = defaultPropertyGridDefinition;
    }
    this.showModeValue = showMode;
    this.properties = Serializer.getPropertiesByObj(this.obj);
    this.fillPropertiesHash();
    this.buildTabs(className);
  }
  getAllVisiblePropertiesNames(includeUnused) {
    const res = [];
    this.tabs.forEach((tab) => {
      if (tab.visible !== false) {
        tab.properties.forEach((prop) => res.push(prop.name));
      }
    });
    if (includeUnused) {
      this.unusedProperties.forEach((prop) => res.push(prop.name));
    }
    return res;
  }
  getIsPropertyVisible(prop) {
    return SurveyHelper.isPropertyVisible(this.obj, prop, this.options, this.showMode, this.parentObj, this.parentProperty);
  }
  getDynamicClassName() {
    return !!this.obj && this.obj.isQuestion && !!this.obj.getDynamicType ? this.obj.getDynamicType() : "";
  }
  getProperty(propertyName) {
    var res = this.propertiesHash[propertyName];
    return !!res && res.visible ? res.property : null;
  }
  getPropertyAsCategory(propertyName) {
    const prop = this.getProperty(propertyName);
    return prop && (!prop.category || prop.category === propertyName) ? prop : null;
  }
  get showMode() {
    return !!this.showModeValue ? this.showModeValue : "form";
  }
  get isEmpty() {
    for (var i = 0; i < this.tabs.length; i++) {
      if (this.tabs[i].visible && this.tabs[i].properties.length > 0) return false;
    }
    return true;
  }
  getClassDefintion(name) {
    if (!this.propertyGridDefinition || !this.propertyGridDefinition.classes) return void 0;
    return this.propertyGridDefinition.classes[name];
  }
  fillPropertiesHash() {
    this.propertiesHash = {};
    for (var i = 0; i < this.properties.length; i++) {
      var prop = this.properties[i];
      this.propertiesHash[prop.name] = {
        property: prop,
        visible: this.getIsPropertyVisible(prop)
      };
    }
  }
  isJSONPropertyVisible(property2) {
    var res = this.propertiesHash[property2.name];
    return !!res && res.visible;
  }
  getTabByName(tabName) {
    for (var i = 0; i < this.tabs.length; i++) {
      if (this.tabs[i].name == tabName) return this.tabs[i];
    }
    return null;
  }
  getTabs() {
    return this.tabs;
  }
  getProperties(tab) {
    var res = [];
    for (var i = 0; i < tab.properties.length; i++) {
      res.push(tab.properties[i].property);
    }
    return res;
  }
  buildTabs(className) {
    if (!className && !!this.obj) {
      className = this.obj.getType();
    }
    var definitions = this.getAllDefinitionsByClass(className);
    var addedProperties = [];
    for (var i = definitions.length - 1; i >= 0; i--) {
      var defItem = definitions[i];
      for (var j = !!defItem.tabs ? defItem.tabs.length - 1 : -1; j >= 0; j--) {
        const defTab = defItem.tabs[j];
        if (addedProperties.indexOf(defTab.name) > -1) {
          this.setTabProperties(defTab);
        } else {
          if (this.addPropertyIntoTab(defTab, true)) {
            addedProperties.push(defTab.name);
          }
        }
      }
      for (var j = !!defItem.properties ? defItem.properties.length - 1 : -1; j >= 0; j--) {
        var propertyName = defItem.properties[j]["name"] || defItem.properties[j];
        if (addedProperties.indexOf(propertyName) === -1) {
          addedProperties.push(propertyName);
          this.addPropertyIntoTab(defItem.properties[j]);
        }
      }
    }
    for (var i = this.tabs.length - 1; i >= 0; i--) {
      this.movePropertiesToNextProperties(this.tabs[i].properties);
      if (!this.tabs[i].visible) {
        this.tabs.splice(i, 1);
      } else {
        this.sortProperties(this.tabs[i].properties);
      }
    }
    this.tabs.sort(function(a, b) {
      return a.index < b.index ? -1 : a.index > b.index ? 1 : 0;
    });
    this.setParentTabs();
    this.tabs.forEach((tab) => {
      var _a;
      (_a = tab.tabs) === null || _a === void 0 ? void 0 : _a.sort((a, b) => a.index - b.index);
    });
  }
  setParentTabs() {
    for (let i = this.tabs.length - 1; i >= 0; i--) {
      const tab = this.tabs[i];
      if (tab.parentName) {
        const parent = this.getTabByName(tab.parentName);
        if (parent) {
          tab.parent = parent;
          if (!Array.isArray(parent.tabs)) {
            parent.tabs = [];
          }
          parent.tabs.push(tab);
          this.tabs.splice(i, 1);
        }
      }
    }
  }
  addPropertyIntoTab(defProperty, isTab = false) {
    if (isTab) {
      this.setTabProperties(defProperty);
    }
    var isString = typeof defProperty == "string";
    var name = !isString ? defProperty.name : defProperty;
    var propRes = this.propertiesHash[name];
    if (!propRes || isTab && !this.getPropertyAsCategory(name)) return false;
    if (!isString && defProperty.visible === false) return false;
    if (!propRes.visible && (isString || !isString && defProperty.visible !== true)) return false;
    var tabName = isTab ? defProperty.name : settings2.propertyGrid.generalTabName;
    if (!isTab && !isString && !!defProperty.tab) {
      tabName = defProperty.tab;
    }
    var propertyDefinition = new SurveyQuestionEditorPropertyDefinition();
    propertyDefinition.property = propRes.property;
    propertyDefinition.category = !isString && !!defProperty.category ? defProperty.category : "";
    propertyDefinition.title = !isString && !!defProperty.title ? defProperty.title : "";
    if (!isTab && defProperty.index !== void 0) {
      propertyDefinition.definedIndex = defProperty.index;
    }
    propertyDefinition.onSameLine = this.isPropertyOnSameLine(propRes.property.nextToProperty);
    propertyDefinition.createdFromTabName = isTab;
    let tab = this.getTabOrCreate(tabName);
    tab.properties.unshift(propertyDefinition);
    return true;
  }
  setTabProperties(defProperty) {
    let tab = this.getTabOrCreate(defProperty.name);
    if (defProperty.index > 0) {
      tab.index = defProperty.index;
    }
    tab.parentName = defProperty.parent;
    if (defProperty.visible === false) {
      tab.visible = false;
    }
    if (!!defProperty.title) {
      tab.title = defProperty.title;
    }
  }
  movePropertiesToNextProperties(properties) {
    var props = [].concat(properties);
    for (var i = 0; i < props.length; i++) {
      const nextToProperty = this.getNextToNameProperty(props[i].property);
      var newTab = this.getTabByPropertyName(nextToProperty);
      if (!!newTab) {
        var prop = this.getPropertyByNameInTab(newTab, nextToProperty);
        var index = newTab.properties.indexOf(prop);
        newTab.properties.splice(index + 1, 0, props[i]);
        properties.splice(properties.indexOf(props[i]), 1);
      }
    }
  }
  getTabByPropertyName(propName) {
    if (!propName) return null;
    if (this.isPropertyOnSameLine(propName)) propName = propName.substring(1);
    for (var i = 0; i < this.tabs.length; i++) {
      if (!!this.getPropertyByNameInTab(this.tabs[i], propName)) return this.tabs[i];
    }
    return null;
  }
  getNextToNameProperty(property2) {
    if (!property2.nextToProperty) return "";
    if (this.isPropertyOnSameLine(property2.nextToProperty)) return property2.nextToProperty.substring(1);
    return property2.nextToProperty;
  }
  isPropertyOnSameLine(nextToProperty) {
    return !!nextToProperty && nextToProperty[0] === "*";
  }
  getPropertyByNameInTab(tab, propName) {
    var props = tab.properties;
    for (var i = 0; i < props.length; i++) {
      if (props[i].name == propName) return props[i];
    }
    return null;
  }
  getTabOrCreate(tabName) {
    for (var i = 0; i < this.tabs.length; i++) {
      if (this.tabs[i].name == tabName) return this.tabs[i];
    }
    var res = new SurveyQuestionEditorTabDefinition();
    res.name = tabName;
    if (tabName == settings2.propertyGrid.generalTabName) {
      res.index = -1;
    }
    this.tabs.unshift(res);
    return res;
  }
  setUsedProperties(res, usedProperties) {
    for (let i = 0; i < res.length; i++) {
      const props = res[i].properties;
      if (!Array.isArray(props)) continue;
      for (let j = 0; j < props.length; j++) {
        const propName = !!props[j]["name"] ? props[j]["name"] : props[j];
        usedProperties[propName] = true;
      }
    }
  }
  getAllDefinitionsByClass(className) {
    var result = [];
    var usedProperties = {};
    if (className.indexOf("@") > -1 && this.getClassDefintion(className)) {
      const prefix = className.substring(0, className.indexOf("@") + 1);
      const clName = className.substring(prefix.length);
      const classes = [];
      let classInfo = Serializer.findClass(clName);
      while (!!classInfo && classInfo.name !== "question") {
        classes.unshift(prefix + classInfo.name);
        classInfo = !!classInfo.parentName ? Serializer.findClass(classInfo.parentName) : void 0;
      }
      if (classes.indexOf(className) < 0) {
        classes.unshift(className);
      }
      if (classes.indexOf(prefix + "default") < 0) {
        classes.unshift(prefix + "default");
      }
      classes.forEach((cl) => {
        const def = this.getClassDefintion(cl);
        if (def) {
          result.push(def);
        }
      });
      this.setUsedProperties(result, usedProperties);
      if (this.isColumnObj) {
        this.getAllDefinitionsByClassCore(this.obj.templateQuestion.getType(), usedProperties, result, void 0, true);
      }
      this.addNonTabProperties(result, usedProperties, true);
      return result;
    }
    let hasNonTabDynamicProperties = false;
    const dynamicClass = this.getDynamicClassName();
    if (dynamicClass) {
      hasNonTabDynamicProperties = this.getAllDefinitionsByClassCore(dynamicClass, usedProperties, result, className);
    }
    const hasNonTabProperties = this.getAllDefinitionsByClassCore(className, usedProperties, result, void 0);
    if (!hasNonTabProperties || !hasNonTabDynamicProperties) {
      this.addNonTabProperties(result, usedProperties);
    }
    return result;
  }
  getAllDefinitionsByClassCore(className, usedProperties, result, baseClass, isColumn) {
    let res = false;
    let curClassName = className;
    while (curClassName && (!baseClass || !Serializer.isDescendantOf(baseClass, curClassName))) {
      let metaClass = Serializer.findClass(curClassName);
      if (!metaClass) break;
      res = this.getAllDefinitionsByClassSingleCore(metaClass.name, usedProperties, result, isColumn);
      curClassName = metaClass.parentName;
    }
    return res;
  }
  getAllDefinitionsByClassSingleCore(className, usedProperties, result, isColumn) {
    const classRes = this.getClassDefintion(className);
    let res = false;
    if (!classRes) return res;
    let columnDef = void 0;
    if (classRes.properties) {
      var i = 0;
      while (i < classRes.properties.length) {
        const prop = classRes.properties[i];
        const propName = typeof prop == "string" ? prop : prop.name;
        let tabName = settings2.propertyGrid.generalTabName;
        if (typeof prop !== "string" && !!prop.tab) {
          tabName = prop.tab;
        }
        const jsonProp = !!this.propertiesHash[propName] ? this.propertiesHash[propName].property : null;
        if (!isColumn || (jsonProp === null || jsonProp === void 0 ? void 0 : jsonProp.availableInMatrixColumn)) {
          const jsonPropertyCategory = this.getJsonPropertyCategory(jsonProp);
          if (!!jsonPropertyCategory && jsonPropertyCategory !== tabName) {
            classRes.properties.splice(i, 1);
          } else {
            usedProperties[propName] = true;
          }
          if (isColumn) {
            if (!columnDef) {
              columnDef = {
                properties: [],
                tabs: []
              };
            }
            columnDef.properties.push(prop);
          }
        }
        i++;
      }
    }
    if (isColumn) {
      if (!!columnDef) {
        result.unshift(columnDef);
      }
      return res;
    }
    if (classRes.tabs) {
      for (let i2 = 0; i2 < classRes.tabs.length; i2++) {
        const tabName = classRes.tabs[i2].name;
        res = res || tabName === otherTabName;
        if (!!this.getPropertyAsCategory(tabName)) {
          usedProperties[tabName] = true;
        }
      }
    }
    result.unshift(classRes);
    return res;
  }
  getJsonPropertyCategory(jsonProperty) {
    if (!jsonProperty) return null;
    if (!!jsonProperty.category) return jsonProperty.category;
    return null;
  }
  get isColumnObj() {
    return this.obj.getType() === "matrixdropdowncolumn";
  }
  getUnusedProperties(usedProperties, isFormMode = false) {
    const res = [];
    const isColumn = this.isColumnObj;
    for (var i = 0; i < this.properties.length; i++) {
      const prop = this.properties[i];
      if (this.isJSONPropertyVisible(prop) && !usedProperties[prop.name] && (!isFormMode || prop.showMode === "form" || isColumn && prop.availableInMatrixColumn)) {
        res.push(prop);
      }
    }
    return res;
  }
  addNonTabProperties(tabs, usedProperties, isFormMode = false) {
    const unusedProperties = this.getUnusedProperties(usedProperties, isFormMode);
    if (!this.propertyGridDefinition.autoGenerateProperties) {
      this.unusedProperties = unusedProperties;
      return;
    }
    let classRes = {
      properties: [],
      tabs: []
    };
    let tabNames = [];
    for (var i = 0; i < unusedProperties.length; i++) {
      const prop = unusedProperties[i];
      let propCategory = this.getJsonPropertyCategory(prop);
      let tabName = !!propCategory ? propCategory : tabs.length == 0 || !!this.parentObj && this.showMode === "form" ? settings2.propertyGrid.generalTabName : otherTabName;
      if (tabNames.indexOf(tabName) < 0 && tabName != settings2.propertyGrid.generalTabName) {
        tabNames.push(tabName);
        classRes.tabs.push({
          name: tabName,
          index: tabName === otherTabName ? 1e3 : tabNames.length * 10
        });
      }
      if (prop.categoryIndex > -1 && tabNames.indexOf(tabName) > -1) {
        for (var j = 0; j < classRes.tabs.length; j++) {
          if (classRes.tabs[j].name == tabName) {
            classRes.tabs[j].index = prop.categoryIndex;
          }
        }
      }
      classRes.properties.push({
        name: prop.name,
        tab: tabName
      });
    }
    if (classRes.properties.length > 0) {
      tabs.push(classRes);
    }
  }
  sortProperties(properties) {
    if (!Array.isArray(properties)) return;
    let index = 0;
    properties.forEach((prop) => {
      prop.index = prop.definedIndex !== void 0 ? prop.definedIndex : index;
      index++;
    });
    properties.sort((prop1, prop2) => {
      if (prop1.index === prop2.index) return 0;
      return prop1.index < prop2.index ? -1 : 1;
    });
    this.insertProperteisWithVisibleIndex(properties);
  }
  insertProperteisWithVisibleIndex(properties) {
    const props = [].concat(properties);
    for (let i = 0; i < props.length; i++) {
      let index = props[i].property.visibleIndex;
      if (props[i].createdFromTabName && index < 0) {
        index = 0;
      }
      if (index < 0 || props[i].definedIndex !== void 0) continue;
      let curIndex = properties.indexOf(props[i]);
      if (curIndex > -1) {
        properties.splice(curIndex, 1);
      }
      if (index < properties.length) {
        properties.splice(index, 0, props[i]);
      } else {
        properties.push(props[i]);
      }
    }
  }
};
var DescriptionMardownParser = class _DescriptionMardownParser {
  parse(text) {
    if (!_DescriptionMardownParser.boldRegEx) {
      _DescriptionMardownParser.boldRegEx = /\*{2}(.*?)\*{2}/gm;
      _DescriptionMardownParser.italicRegEx = /\_(.*?)\_/gm;
      _DescriptionMardownParser.codeRegEx = /\`(.*?)\`/gm;
      _DescriptionMardownParser.linkRegEx = /\[(.+)\]\(([^ ]+?)( "(.+)")?\)/;
    }
    const createSpan = (text2, str, className, chars) => {
      if (!str) return text2;
      const index = text2.indexOf(str);
      if (checkIfLink(text2, index)) return text2;
      let innerStr = str.substring(chars.length, str.length);
      innerStr = innerStr.substring(0, innerStr.length - chars.length);
      const newStr = "<span class='" + className + "'>" + innerStr + "</span>";
      return text2.replace(str, newStr);
    };
    const checkIfLink = (text2, index) => {
      let isBracket = false;
      for (let i = index - 1; i > 0; i--) {
        if (text2[i] === " " || text2[i] === "\n") return false;
        if (text2[i] === "]" && isBracket) return true;
        isBracket = text2[i] === "(";
      }
      return false;
    };
    const createLink = (text2, str, className, chars) => {
      if (!str) return text2;
      const index = str.indexOf("](");
      if (index < 0) return text2;
      const contentStr = str.substring(1, index);
      const linkStr = str.substring(index + 2, str.length - 1);
      const newStr = "<a class='" + className + "' target='_blank' href='" + linkStr + "'>" + contentStr + "</a>";
      return text2.replace(str, newStr);
    };
    text = this.replace(_DescriptionMardownParser.boldRegEx, text, "spg-bold", "**", createSpan);
    text = this.replace(_DescriptionMardownParser.italicRegEx, text, "spg-italic", "_", createSpan);
    text = this.replace(_DescriptionMardownParser.codeRegEx, text, "spg-code", "`", createSpan);
    text = this.replace(_DescriptionMardownParser.linkRegEx, text, "spg-link", "", createLink);
    text = this.addLineBreaks(text);
    return text;
  }
  replace(re, text, className, chars, replaceFunc) {
    const rArray = text.match(re);
    if (!Array.isArray(rArray) || rArray.length == 0) return text;
    for (var i = 0; i < rArray.length; i++) {
      text = replaceFunc(text, rArray[i], className, chars);
    }
    return text;
  }
  addLineBreaks(text) {
    const br = "\n";
    if (text.indexOf(br) < 0) return text;
    const strs = text.split(br);
    return strs.join("<br/>");
  }
};
function parsePropertyDescription(text) {
  return new DescriptionMardownParser().parse(text);
}
function propertyVisibleIf(params) {
  if (!this.question) return false;
  const obj = this.question.obj;
  const prop = this.question.property;
  if (!obj || !prop) return false;
  if (!Serializer.hasOriginalProperty(obj, prop.name)) return false;
  return prop.isVisible("", obj);
}
function propertyEnableIf(params) {
  const prop = this.question.property;
  const obj = this.question.obj;
  if (!this.question || !obj || !prop) return false;
  if (this.question.obj[prop.overridingProperty]) return false;
  return prop.isEnable(obj);
}
FunctionFactory.Instance.register("propertyVisibleIf", propertyVisibleIf);
FunctionFactory.Instance.register("propertyEnableIf", propertyEnableIf);
function setSurveyJSONForPropertyGrid(json2, updateOnTyping = true, titleLocationLeft = true) {
  json2.showNavigationButtons = "none";
  json2.showPageTitles = false;
  json2.autoFocusFirstQuestion = false;
  json2.showQuestionNumbers = "off";
  if (titleLocationLeft) {
    json2.questionTitleLocation = "left";
  }
  json2.showProgressBar = "off";
  if (updateOnTyping) {
    json2.textUpdateMode = "onTyping";
  }
  json2.requiredMark = "";
}
var PropertyEditorSetupValue = class {
  constructor(options = null, doSetup = true) {
    this.options = options;
    if (!this.options) {
      this.options = new EmptySurveyCreatorOptions();
    }
    if (doSetup) {
      this.setupSurvey();
    }
  }
  setupSurvey() {
    this.editSurveyValue = this.createSurvey();
  }
  get editSurvey() {
    return this.editSurveyValue;
  }
  hasErrors() {
    return this.editSurvey.hasErrors(true, true);
  }
  createSurvey() {
    var json2 = this.getSurveyJSON();
    setSurveyJSONForPropertyGrid(json2, false, false);
    return this.options.createSurvey(json2, this.getSurveyCreationReason(), this);
  }
  dispose() {
    if (!!this.editSurvey) {
      this.editSurvey.dispose();
    }
  }
};
var PropertyGridEditorCollection = {
  editors: new Array(),
  fitHash: {},
  clearHash() {
    this.fitHash = {};
  },
  register(editor) {
    this.editors.push(editor);
  },
  getEditor(prop, context) {
    if (!prop) return null;
    if (!!context) {
      for (var i = this.editors.length - 1; i >= 0; i--) {
        let ed2 = this.editors[i];
        if (ed2.fit(prop, context)) return ed2;
      }
    }
    var fitEd = this.fitHash[prop.id];
    if (!!fitEd) return fitEd;
    let ed = this.isEditorFit(prop);
    return !!ed ? ed : this.isEditorFit(prop, true);
  },
  isEditorFit(prop, asDefault = false) {
    for (var i = this.editors.length - 1; i >= 0; i--) {
      let ed = this.editors[i];
      if (!asDefault && ed.fit(prop) || asDefault && ed.isDefault && ed.isDefault()) {
        this.fitHash[prop.id] = ed;
        return ed;
      }
    }
    return null;
  },
  getJSON(obj, prop, options, context, propGridDefinition) {
    var res = this.getEditor(prop, context);
    return !!res ? res.getJSON(obj, prop, options, propGridDefinition) : null;
  },
  onCreated(obj, question, prop, options, propGridDefinition) {
    var res = this.getEditor(prop);
    if (!!res && !!res.onCreated) {
      res.onCreated(obj, question, prop, options, propGridDefinition);
    }
  },
  onSetup(obj, question, prop, options) {
    var res = this.getEditor(prop);
    if (!!res && !!res.onSetup) {
      res.onSetup(obj, question, prop, options);
    }
  },
  validateValue(obj, question, prop, value) {
    var res = this.getEditor(prop);
    if (!!res && !!res.validateValue) {
      return res.validateValue(obj, question, prop, value);
    }
    return "";
  },
  onAfterRenderQuestion(obj, prop, evtOptions) {
    var res = this.getEditor(prop);
    if (!!res && !!res.onAfterRenderQuestion) {
      res.onAfterRenderQuestion(obj, prop, evtOptions);
    }
  },
  onMatrixCellCreated(obj, prop, options) {
    var res = this.getEditor(prop);
    if (!!res && !!res.onMatrixCellCreated) {
      res.onMatrixCellCreated(options.question.obj, options);
    }
  },
  onMatrixCellValueChanged(obj, prop, options) {
    var res = this.getEditor(prop);
    if (!!res && !!res.onMatrixCellValueChanged) {
      res.onMatrixCellValueChanged(obj, options);
    }
    var row = options.row;
    if (!!row) {
      const questions = row.questions;
      for (let i = 0; i < questions.length; i++) {
        if (questions[i].errors.length > 0) return;
      }
      var cellQuestion = row.getQuestionByName(options.columnName);
      if (!!cellQuestion) {
        row.runCondition({}, {
          question: cellQuestion
        });
      }
    }
  },
  onMatrixAllowRemoveRow(obj, prop, row) {
    var res = this.getEditor(prop);
    if (!!res && !!res.onMatrixAllowRemoveRow) {
      return res.onMatrixAllowRemoveRow(obj, row);
    }
    return true;
  },
  onGetMatrixRowAction(obj, prop, options, setObjFunc) {
    var res = this.getEditor(prop);
    if (!!res && !!res.onGetMatrixRowAction) {
      res.onGetMatrixRowAction(obj, options, setObjFunc);
    }
  },
  onUpdateQuestionCssClasses(obj, prop, options) {
    var res = this.getEditor(prop);
    if (!!res && !!res.onUpdateQuestionCssClasses) {
      res.onUpdateQuestionCssClasses(obj, options);
    }
  },
  onGetQuestionTitleActions(obj, prop, options, creator) {
    var res = this.getEditor(prop);
    if (!!res && !!res.onGetQuestionTitleActions) {
      res.onGetQuestionTitleActions(obj, options, creator);
    }
  },
  onValueChanged(obj, prop, question) {
    var res = this.getEditor(prop);
    if (!!res && !!res.onValueChanged) {
      res.onValueChanged(obj, prop, question);
    }
  },
  onValueChanging(obj, prop, question, options) {
    var res = this.getEditor(prop);
    if (!!res && !!res.onValueChanging) {
      res.onValueChanging(obj, prop, question, options);
    }
  },
  onMasterValueChanged(obj, prop, question) {
    var res = this.getEditor(prop);
    if (!!res && !!res.onMasterValueChanged) {
      res.onMasterValueChanged(obj, prop, question);
    }
  }
};
var PropertyGridTitleActionsCreator = class {
  constructor(obj, options) {
    this.obj = obj;
    this.options = options;
  }
  onGetQuestionTitleActions(options) {
    const question = options.question;
    const property2 = question.property;
    const editor = PropertyGridEditorCollection.getEditor(property2);
    if (!editor) return;
    const actions = [];
    let enabled = !question.isReadOnly;
    const hasClear = !!editor.clearPropertyValue && (!editor.canClearPropertyValue || editor.canClearPropertyValue(this.obj, property2, question, this.options));
    if (hasClear) {
      actions.push(this.createClearValueAction(editor, property2, question, enabled));
    }
    if (question.allowBatchEdit !== false) {
      if (!!editor.createPropertyEditorSetup) {
        if (!!editor.isPropertyEditorSetupEnabled) {
          enabled = editor.isPropertyEditorSetupEnabled(this.obj, property2, options.question, this.options);
        }
        actions.push(this.createEditorSetupAction(editor, property2, question, enabled));
      }
    }
    var helpAction = this.createPropertyHelpAction(question);
    if (!!helpAction) {
      actions.unshift(helpAction);
      question.getTitleToolbar().containerCss += " spg-title-toolbar--single-help-action";
    }
    if (actions.length > 0) {
      options.titleActions = actions;
    }
  }
  createClearValueAction(editor, property2, question, enabled) {
    return {
      id: "property-grid-clear",
      title: getLocString("pe.clear"),
      showTitle: false,
      iconName: "icon-clear",
      iconSize: "auto",
      innerCss: "spg-action-button--danger",
      enabled,
      visible: new ComputedUpdater(() => {
        const propertyValue2 = question.obj[property2.name];
        return Array.isArray(propertyValue2) ? propertyValue2.length > 0 : !!propertyValue2;
      }),
      action: () => {
        editor.clearPropertyValue(question.obj, property2, question, this.options);
      }
    };
  }
  showModalPropertyEditor(editor, property2, question) {
    return editor.showModalPropertyEditor(editor, property2, question, this.options);
  }
  createEditorSetupAction(editor, property2, question, enabled) {
    var setupAction = {
      id: "property-grid-setup",
      iconName: property2.isArray ? "icon-fast-entry" : "icon-wizard",
      iconSize: "auto",
      enabled,
      title: getLocString("pe.edit"),
      showTitle: false,
      action: () => {
        return this.showModalPropertyEditor(editor, property2, question);
      }
    };
    return setupAction;
  }
  createPropertyHelpAction(question) {
    if (!question.description) return null;
    const action = new Action({
      title: "",
      tooltip: question.description,
      id: "property-grid-help",
      iconName: this.getHelpActionIconName(question),
      iconSize: "auto",
      css: "spg-help-action",
      showTitle: false,
      disableHide: true,
      action: () => {
        question.descriptionLocation = question.descriptionLocation != "hidden" ? "hidden" : "underTitle";
        action.iconName = this.getHelpActionIconName(question);
      }
    });
    const baseOnMouseDown = action.doMouseDown;
    action.doMouseDown = (args) => {
      baseOnMouseDown.call(action);
      const evt = !!args.originalEvent ? args.originalEvent : args;
      evt.preventDefault();
      evt.stopPropagation();
    };
    return action;
  }
  getHelpActionIconName(question) {
    return question.descriptionLocation != "hidden" ? "icon-description-hide" : "icon-description";
  }
};
var PropertyJSONGenerator = class _PropertyJSONGenerator {
  static isPropertyReadOnly(prop, options, obj, parentObj, parentProperty) {
    var res = prop.readOnly;
    if (!!options && !!obj) {
      res = options.onIsPropertyReadOnlyCallback(obj, prop, res, parentObj, parentProperty);
    }
    return res;
  }
  static getClassNameProperty(obj) {
    if (!!obj && !!obj["getClassNameProperty"]) return obj["getClassNameProperty"]();
    return void 0;
  }
  constructor(obj, options = null, parentObj = null, parentProperty = null, propertyGridDefinition = null) {
    this.obj = obj;
    this.options = options;
    this.parentObj = parentObj;
    this.parentProperty = parentProperty;
    this.propertyGridDefinition = propertyGridDefinition;
  }
  toJSON(isNested = false, context = void 0) {
    return this.createJSON(isNested, context);
  }
  createColumnsJSON(className, names) {
    const res = [];
    const obj = (className ? Serializer.createClass(className) : this.obj) || this.obj;
    for (var i = 0; i < names.length; i++) {
      var columnJSON = this.getColumnPropertyJSON(obj, names[i]);
      if (!!columnJSON) {
        res.push(columnJSON);
      }
    }
    return res;
  }
  setupObjPanel(panel, isNestedObj = false, context = void 0) {
    panel.fromJSON(this.toJSON(isNestedObj, context));
    this.onQuestionsCreated(panel);
  }
  setupPages(survey) {
    const json2 = this.convertPanelsToPages(this.toJSON(false));
    const surveyJSON = survey.toJSON();
    Object.keys(json2).forEach((key) => surveyJSON[key] = json2[key]);
    survey.fromJSON(surveyJSON);
    survey.pages.forEach((page) => this.onQuestionsCreated(page));
  }
  convertPanelsToPages(json2) {
    const elements = json2.elements;
    if (!Array.isArray(elements)) return;
    elements.forEach((el) => {
      delete el.type;
    });
    json2["pages"] = elements;
    delete json2.elements;
    return json2;
  }
  onQuestionsCreated(panel) {
    var properties = Serializer.getPropertiesByObj(this.obj);
    var props = {};
    for (var i = 0; i < properties.length; i++) {
      props[properties[i].name] = properties[i];
    }
    var questions = panel.questions;
    for (var i = 0; i < questions.length; i++) {
      var q = questions[i];
      var prop = props[q.name];
      q.property = prop;
      q.obj = this.obj;
      q.creatorOptions = this.options;
      const eventVisibility = this.getVisibilityOnEvent(prop);
      q.readOnly = q.readOnly || this.isPropertyReadOnly(prop);
      q.visible = q.visible && eventVisibility;
      if (!!prop.visibleIf && eventVisibility) {
        q.visibleIf = "propertyVisibleIf() = true";
      }
      if (q.visible && (!!prop.overridingProperty || prop.enableIf)) {
        if (!q.readOnly) {
          q.enableIf = "propertyEnableIf() = true";
        }
        if (prop.overridingProperty) {
          q.onUpdateCssClassesCallback = (css) => {
            css.questionWrapper = "spg-boolean-wrapper--overriding";
          };
          const overridingQuestion = this.createOverridingQuestion(panel, q, prop.overridingProperty);
          if (!!overridingQuestion) {
            q.parent.addElement(overridingQuestion, q.parent.elements.indexOf(q) + 1);
          }
        }
      }
      q.descriptionLocation = "hidden";
      const helpText = editorLocalization.getPropertyHelpInEditor(this.obj.getType(), prop.name, prop.type);
      if (!!helpText) {
        q.description = helpText;
      }
      PropertyGridEditorCollection.onCreated(this.obj, q, prop, this.options, this.propertyGridDefinition);
      this.options.onPropertyEditorCreatedCallback(this.obj, prop, q);
    }
  }
  getVisibilityOnEvent(prop, showMode = "") {
    return this.options.onCanShowPropertyCallback(this.obj, prop, showMode, this.parentObj, this.parentProperty);
  }
  isPropertyReadOnly(prop) {
    return _PropertyJSONGenerator.isPropertyReadOnly(prop, this.options, this.obj, this.parentObj, this.parentProperty);
  }
  createOverridingQuestion(panel, question, overridingProp) {
    const linkValue = Serializer.createClass("linkvalue");
    if (!linkValue) return null;
    linkValue.name = question.name + "_overridingProperty";
    linkValue.startWithNewLine = false;
    linkValue.property = question.property;
    linkValue.obj = question.obj;
    linkValue.visibleIf = "propertyEnableIf() = false";
    let overridingQuestion = panel.getQuestionByName(overridingProp);
    if (!overridingQuestion && !!panel.survey) {
      overridingQuestion = panel.survey.getQuestionByName(overridingProp);
    }
    linkValue.linkValueText = editorLocalization.getString("pe.overridingPropertyPrefix");
    linkValue.titleLocation = "hidden";
    linkValue.onUpdateCssClassesCallback = (css) => {
      css.questionWrapper = "spg-link-wrapper--overriding";
    };
    if (!!overridingQuestion) {
      linkValue.linkClickCallback = () => {
        overridingQuestion.focus(false, true);
      };
    }
    return linkValue;
  }
  getClasPropName() {
    if (!!this.parentObj && !!this.parentProperty) return this.parentProperty.name;
    var propName = _PropertyJSONGenerator.getClassNameProperty(this.obj);
    if (!!propName && this.obj[propName]) return this.obj[propName];
    return void 0;
  }
  createJSON(isNestedObj, context = void 0) {
    var className = void 0;
    const propName = this.getClasPropName();
    if (!!propName) {
      className = this.obj.getType();
      if (className === "itemvalue") className += "[]";
      className += "@" + propName;
    }
    var properties = new SurveyQuestionProperties(this.obj, null, className, void 0, this.parentObj, this.parentProperty, this.propertyGridDefinition);
    var tabs = properties.getTabs();
    var panels = {};
    for (var i = 0; i < tabs.length; i++) {
      if (tabs[i].visible === false) continue;
      panels[tabs[i].name] = this.createPanelProps(tabs[i], context);
    }
    var json2 = {
      elements: []
    };
    for (var key in panels) {
      if (key == settings2.propertyGrid.generalTabName && isNestedObj) {
        var els = panels[key].elements;
        for (var i = 0; i < els.length; i++) {
          json2.elements.push(els[i]);
        }
      } else {
        json2.elements.push(panels[key]);
      }
    }
    return json2;
  }
  createPanelProps(tab, context, isChild = false) {
    var panel = this.createPanelJSON(tab.name, tab.title, isChild);
    for (var i = 0; i < tab.properties.length; i++) {
      var propDef = tab.properties[i];
      var propJSON = this.createQuestionJSON(this.obj, propDef.property, propDef.title, false, context);
      if (propDef.onSameLine) {
        propJSON.startWithNewLine = false;
        this.updateQuestionJSONOnSameLine(propJSON);
        if (panel.elements.length > 0) {
          this.updateQuestionJSONOnSameLine(panel.elements[panel.elements.length - 1]);
        }
      }
      if (!propJSON) continue;
      panel.elements.push(propJSON);
    }
    if (Array.isArray(tab.tabs)) {
      tab.tabs.forEach((child) => {
        const panelJSON = this.createPanelProps(child, context, true);
        if (panelJSON.title === child.name) {
          delete panelJSON.title;
        }
        if (panelJSON) {
          panel.elements.push(panelJSON);
        }
      });
    }
    return panel;
  }
  updateQuestionJSONOnSameLine(json2) {
    json2.titleLocation = "left";
    json2.minWidth = "50px";
  }
  createPanelJSON(category, title, isChild) {
    const res = {
      type: "panel",
      name: category,
      title: this.getPanelTitle(category, title),
      elements: []
    };
    if (!isChild) {
      res.state = "collapsed";
    }
    return res;
  }
  createQuestionJSON(obj, prop, title, isColumn = false, context) {
    var isVisible = this.isPropertyVisible(prop, isColumn ? "list" : "");
    if (!isVisible && isColumn) return null;
    var json2 = PropertyGridEditorCollection.getJSON(obj, prop, this.options, context, this.propertyGridDefinition);
    if (!json2) return null;
    json2.name = prop.name;
    json2.title = this.getQuestionTitle(prop, obj.getType(), title);
    if (this.isQuestionTitleHidden(prop)) {
      json2.titleLocation = "hidden";
    }
    json2.visible = prop.visible;
    json2.isReadOnly = prop.readOnly;
    json2.isRequired = prop.isRequired;
    json2.requiredErrorText = editorLocalization.getString("pe.propertyIsEmpty");
    if (["page", "panelbase"].indexOf(prop.className) && json2.name === "name") {
      json2.isRequired = true;
      json2.requiredErrorText = editorLocalization.getString("pe.propertyIsEmpty");
    }
    const placeholder = editorLocalization.getPropertyPlaceholder(obj.getType(), prop.name);
    if (!!placeholder) {
      json2.placeholder = placeholder;
    }
    return json2;
  }
  getColumnPropertyJSON(obj, propName) {
    if (!obj) return null;
    var prop = Serializer.findProperty(obj.getType(), propName);
    if (!prop) return null;
    var json2 = this.createQuestionJSON(obj, prop, "", true, void 0);
    if (!json2) return null;
    if (prop.isUnique) {
      json2.isUnique = prop.isUnique;
    }
    if (!!json2.type) {
      json2.cellType = json2.type;
      delete json2.type;
    }
    if (json2.cellType === "buttongroup") {
      json2.cellType = "dropdown";
    }
    if (json2.cellType === "fileedit") {
      json2.cellType = "text";
    }
    if (!!prop.visibleIf) {
      json2.visibleIf = "propertyVisibleIf() = true";
    }
    if (!!json2.isReadOnly) {
      json2.readOnly = json2.isReadOnly;
      delete json2.isReadOnly;
    }
    return json2;
  }
  isPropertyVisible(prop, showMode) {
    if (!prop.visible) return false;
    return !showMode || !prop.showMode || showMode == prop.showMode;
  }
  getPanelTitle(name, title) {
    if (!!title) return title;
    const res = editorLocalization.getString("pe.tabs." + name);
    if (typeof res === "object") {
      for (let key in res) {
        if (Serializer.isDescendantOf(this.obj.getType(), key)) return res[key];
      }
    }
    return res;
  }
  getQuestionTitle(prop, className, title) {
    if (!!prop.displayName) return prop.displayName;
    if (!!title && title !== prop.name) return title;
    let titleClass = className;
    if (!!this.parentProperty) {
      titleClass += "@" + this.parentProperty.name;
    }
    if (this.obj.getType() === "matrixdropdowncolumn" && this.obj.getDynamicType() !== "question") {
      if (!Serializer.findProperty(this.obj.getType(), prop.name)) {
        titleClass = this.obj.getDynamicType();
      }
    }
    return editorLocalization.getPropertyNameInEditor(titleClass, prop.name);
  }
  isQuestionTitleHidden(prop) {
    return prop.displayName === "";
  }
};
var PropertyGridModel = class {
  refresh() {
    this.setObj(this.objValue);
  }
  constructor(obj = null, options = new EmptySurveyCreatorOptions(), propertyGridDefinition = null) {
    this.showOneCategoryInPropertyGrid = false;
    this.surveyInstanceCreatedArea = "property-grid";
    this.isCellCreating = false;
    this.options = options;
    this.propertyGridDefinition = propertyGridDefinition;
    if (this.options.enableLinkFileEditor) {
      PropertyGridEditorCollection.register(new PropertyGridLinkEditor());
    }
    this.obj = obj;
  }
  get obj() {
    return this.objValue;
  }
  set obj(value) {
    if (this.objValue === value) return;
    this.setObj(value);
  }
  setPropertyGridDefinition(val) {
    if (this.propertyGridDefinition === val) return;
    this.propertyGridDefinition = val;
    if (!!this.obj) {
      this.updateCurrentSurveyWithNewDefinition();
    }
  }
  selectProperty(propertyName, focus = true) {
    if (!this.survey) return;
    var question = this.survey.getQuestionByName(propertyName);
    if (!question) return;
    var panels = this.survey.getAllPanels();
    for (var i = 0; i < panels.length; i++) {
      var panel = panels[i];
      if (panel === question.parent) {
        panel.blockAnimations();
        panel.expand();
        panel.releaseAnimations();
      } else {
        panel.collapse();
      }
    }
    if (focus) {
      question.focus();
    } else {
      if (this.showOneCategoryInPropertyGrid) {
        this.survey.currentPage = question.page;
      }
    }
  }
  setObjFromAction(value, propertyName) {
    if (this.changedFromActionCallback) {
      this.changedFromActionCallback(value, propertyName);
    } else {
      this.setObj(value);
    }
  }
  setObj(value) {
    this.objValue = value;
    if (this.onSetNewObjectCallback) {
      this.onSetNewObjectCallback();
    }
    this.classNameProperty = !!this.obj ? PropertyJSONGenerator.getClassNameProperty(this.obj) : "";
    this.classNameValue = !!this.classNameProperty ? this.obj[this.classNameProperty] : void 0;
    this.titleActionsCreator = !!this.obj ? new PropertyGridTitleActionsCreator(this.obj, this.options) : void 0;
    if (!this.surveyValue) return;
    this.clearSurveyValue();
    this.createSurveyValue();
  }
  clearSurveyValue() {
    this.surveyValue.onValidateQuestion.clear();
    this.surveyValue.onValueChanging.clear();
    this.surveyValue.onValueChanged.clear();
    this.surveyValue.onMatrixCellValueChanging.clear();
    this.surveyValue.onMatrixCellValidate.clear();
    this.surveyValue.onMatrixCellValueChanged.clear();
    this.surveyValue.editingObj = void 0;
    this.surveyValue.data = {};
    this.surveyValue.dispose();
  }
  createSurveyValue() {
    const json2 = this.getSurveyJSON();
    if (this.options.readOnly) {
      json2.mode = "display";
    }
    this.surveyValue = this.createSurvey(json2, (survey) => {
      this.onCreateSurvey(survey);
    });
    if (this.onNewSurveyCreatedCallback) {
      this.onNewSurveyCreatedCallback();
    }
    if (!this.obj) return;
    this.survey.onValueChanged.add((sender, options) => {
      this.onValueChanged(options);
    });
    this.survey.onValueChanging.add((sender, options) => {
      this.onValueChanging(options);
    });
    this.survey.onValidateQuestion.add((sender, options) => {
      if (options.errors.length === 0) {
        this.onValidateQuestion(options);
      }
    });
    this.survey.onGetQuestionTitleActions.add((sender, options) => {
      this.titleActionsCreator.onGetQuestionTitleActions(options);
      this.onGetQuestionTitleActions(options, this.options);
      const q = options.question;
      this.options.onPropertyEditorUpdateTitleActionsCallback(this.obj, q.property, q, options.titleActions);
    });
    this.survey.onGetPanelTitleActions.add((sender, options) => {
      options.titleActions.splice(0, options.titleActions.length);
    });
    this.survey.onMatrixCellCreated.add((sender, options) => {
      this.onMatrixCellCreated(options);
    });
    this.survey.onMatrixCellValueChanging.add((sender, options) => {
      this.onMatrixCellValueChanging(options);
    });
    this.survey.onMatrixCellValidate.add((sender, options) => {
      this.onMatrixCellValidate(options);
    });
    this.survey.onMatrixCellValueChanged.add((sender, options) => {
      this.onMatrixCellValueChanged(options);
    });
    this.survey.onMatrixAllowRemoveRow.add((sender, options) => {
      options.allow = this.getMatrixAllowRemoveRow(options.question, options.row);
    });
    this.survey.onMatrixRowRemoving.add((sender, options) => {
      options.allow = this.getMatrixOnRowRemoving(options.question, options.row);
    });
    this.survey.onMatrixRowAdded.add((sender, options) => {
      this.onMatrixRowAdded(options);
    });
    this.survey.onGetMatrixRowActions.add((sender, options) => {
      this.onGetMatrixRowAction(options);
    });
    this.survey.onUpdateQuestionCssClasses.add((sender, options) => {
      this.onUpdateQuestionCssClasses(options);
    });
    this.survey.onElementContentVisibilityChanged.add((sender, options) => {
      if (settings2.propertyGrid.allowExpandMultipleCategories) return;
      const el = options.element;
      if (el && el.isPanel && el.isExpanded) {
        this.collapseOtherPanels(el);
      }
    });
    this.survey.onAfterRenderQuestion.add((sender, options) => {
      this.onAfterRenderQuestion(options);
    });
    this.survey.onTextMarkdown.add((sender, options) => {
      if (options.name === "description") {
        options.html = parsePropertyDescription(options.text);
      }
    });
    this.survey.editingObj = this.obj;
    this.updateDependedPropertiesEditors();
    if (this.showOneCategoryInPropertyGrid) {
      this.survey.onCurrentPageChanged.add((sender, options) => {
        if (this.currentlySelectedPage !== options.newCurrentPage) {
          const questionToFocus = options.newCurrentPage.getFirstQuestionToFocus(false, true);
          this.currentlySelectedPage = options.newCurrentPage;
          this.currentlySelectedProperty = !!questionToFocus ? questionToFocus.name : "";
        }
      });
    } else {
      this.survey.onFocusInPanel.add((sender, options) => {
        if (this.currentlySelectedPanel !== options.panel) {
          const questionToFocus = options.panel.getFirstQuestionToFocus(false, true);
          this.currentlySelectedProperty = !!questionToFocus ? questionToFocus.name : "";
          this.currentlySelectedPanel = options.panel;
        }
      });
    }
    this.survey.onFocusInQuestion.add((sender, options) => {
      this.currentlySelectedProperty = options.question.name;
      this.currentlySelectedPanel = options.question.parent;
    });
    this.survey.onUploadFiles.add((_, options) => {
      const callback = (status, data) => options.callback(status, [{
        content: data,
        file: options.files[0]
      }]);
      const question = options.question.obj.getType() == "survey" ? void 0 : options.question.obj.getType() == "imageitemvalue" ? options.question.obj.locOwner : options.question.obj;
      const item = options.question.obj.getType() == "imageitemvalue" ? options.question.obj : void 0;
      this.options.uploadFiles(options.files, question, callback, {
        element: options.question.obj,
        item,
        elementType: options.question.obj.getType(),
        propertyName: options.name
      });
    });
    this.survey.getAllQuestions().map((q) => q.allowRootStyle = false);
    this.survey.onQuestionCreated.add((_, opt) => {
      opt.question.allowRootStyle = false;
    });
    this.options.onPropertyGridSurveyCreatedCallback(this.obj, this.survey);
  }
  onCreateSurvey(survey) {
    survey.questionErrorLocation = "bottom";
    survey.getCss().list = {};
    const surveyCss2 = Object.assign({}, propertyGridCss);
    surveyCss2.root += this.showOneCategoryInPropertyGrid ? " spg-root--one-category" : "";
    survey.css = surveyCss2;
    if (!!this.obj) {
      const jsonGenerator = new PropertyJSONGenerator(this.obj, this.options, null, null, this.propertyGridDefinition);
      if (this.showOneCategoryInPropertyGrid) {
        survey.css.page.root += " spg-panel__content";
        jsonGenerator.setupPages(survey);
      } else {
        const page = survey.createNewPage("p1");
        jsonGenerator.setupObjPanel(page, false);
        survey.addPage(page);
      }
      survey.getAllQuestions().forEach((q) => {
        PropertyGridEditorCollection.onSetup(this.obj, q, q.property, this.options);
      });
      survey.enterKeyAction = "loseFocus";
      survey.checkErrorsMode = "onValueChanging";
      survey.questionErrorComponent = "svc-question-error";
      if (survey.pages.length === 0) {
        survey.addNewPage("p1");
      }
    }
  }
  updateCurrentSurveyWithNewDefinition() {
    const newSurvey = new SurveyModel(this.getSurveyJSON());
    this.onCreateSurvey(newSurvey);
    this.updateElementsInPanel(this.survey.pages[0], newSurvey.pages[0]);
  }
  updateElementsInPanel(curPanel, newPanel) {
    for (let i = curPanel.elements.length - 1; i >= 0; i--) {
      const el = curPanel.elements[i];
      const newEl = newPanel.getElementByName(el.name);
      if (!!newEl && el.isPanel === newEl.isPanel) {
        if (el.isPanel && newEl.isPanel) {
          this.updateElementsInPanel(el, newEl);
        }
      } else {
        curPanel.removeElement(el);
      }
    }
    const elsToAdd = new Array();
    for (let i = 0; i < newPanel.elements.length; i++) {
      const newEl = newPanel.elements[i];
      let curIndex = i + elsToAdd.length;
      if (curIndex < curPanel.elements.length && curPanel.elements[curIndex].name === newEl.name) continue;
      const curEl = curPanel.getElementByName(newEl.name);
      if (!!curEl) {
        curPanel.removeElement(curEl);
        curPanel.addElement(curEl, curIndex);
      } else {
        elsToAdd.push({
          element: newEl,
          index: i
        });
      }
    }
    for (let i = 0; i < elsToAdd.length; i++) {
      curPanel.addElement(elsToAdd[i].element, elsToAdd[i].index);
    }
  }
  get options() {
    return this.optionsValue;
  }
  set options(val) {
    this.optionsValue = !!val ? val : new EmptySurveyCreatorOptions();
  }
  get survey() {
    if (!this.surveyValue) {
      this.createSurveyValue();
    }
    return this.surveyValue;
  }
  validate() {
    if (!this.survey) return;
    return !this.survey.hasErrors(true, true);
  }
  activateCategory(name) {
    if (this.showOneCategoryInPropertyGrid) {
      this.survey.currentPage = name;
    } else {
      this.expandCategory(name);
    }
  }
  collapseCategory(name) {
    var panel = this.survey.getPanelByName(name);
    if (!!panel) {
      panel.collapse();
    }
  }
  expandCategory(name) {
    if (this.showOneCategoryInPropertyGrid) {
      this.survey.currentPage = name;
      return;
    }
    var panel = this.survey.getPanelByName(name);
    if (!!panel) {
      panel.expand();
    }
  }
  collapseAllCategories() {
    this.collapseAllCategoriesExcept(null);
  }
  expandAllCategories() {
    this.survey.getAllPanels().forEach((pnl) => {
      if (!pnl.parent.isPanel) {
        pnl.expand();
      }
    });
  }
  expandCategoryIfNeeded() {
    if (!this.surveyValue) return;
    const expandedTabName = settings2.propertyGrid.defaultExpandedTabName;
    if (!!expandedTabName && !this.getPropertyGridExpandedCategory()) {
      const panel = this.survey.getPanelByName(expandedTabName);
      if (!!panel) {
        panel.blockAnimations();
        panel.expand();
        panel.releaseAnimations();
      }
    }
  }
  getPropertyGridExpandedCategory() {
    const panels = this.survey.getAllPanels();
    for (var i = 0; i < panels.length; i++) {
      if (panels[i].isExpanded) return panels[i].name;
    }
    return "";
  }
  collapseOtherPanels(panel) {
    this.collapseAllCategoriesExcept(panel);
  }
  collapseAllCategoriesExcept(panel) {
    this.survey.getAllPanels().forEach((pnl) => {
      if (pnl !== panel && !pnl.parent.isPanel) pnl.collapse();
    });
  }
  createSurvey(json2, callback) {
    return this.options.createSurvey(json2, this.surveyInstanceCreatedArea, this, callback);
  }
  getSurveyJSON() {
    var res = {
      autoGrowComment: true,
      allowResizeComment: false
    };
    setSurveyJSONForPropertyGrid(res, true, false);
    return res;
  }
  validateQuestionValue(obj, question, prop, val) {
    if (question.isRequired && (Helpers.isValueEmpty(val) || question["valueChangingEmpty"])) return this.getErrorTextOnValidate(editorLocalization.getString("pe.propertyIsEmpty"), prop.name, obj, val);
    if (this.isPropNameInValid(obj, prop, val) || question["nameHasError"]) return this.getErrorTextOnValidate(editorLocalization.getString("pe.propertyNameIsIncorrect"), prop.name, obj, val);
    const editorError = PropertyGridEditorCollection.validateValue(obj, question, prop, val);
    return this.getErrorTextOnValidate(editorError, prop.name, obj, val);
  }
  getErrorTextOnValidate(defaultError, propName, obj, val) {
    const customError = this.options.onGetErrorTextOnValidationCallback(propName, obj, val);
    return !!customError ? customError : defaultError;
  }
  onValidateQuestion(options) {
    var q = options.question;
    if (!q || !q.property) return;
    options.error = this.validateQuestionValue(q.obj || this.obj, q, q.property, options.value);
  }
  onValueChanging(options) {
    var q = options.question;
    if (!q || !q.property || !Array.isArray(options.value) && Helpers.isTwoValueEquals(options.value, options.oldValue, false, false, false)) return;
    PropertyGridEditorCollection.onValueChanging(this.obj, q.property, q, options);
    var changingOptions = {
      obj: this.obj,
      propertyName: q.property.name,
      value: options.oldValue,
      newValue: options.value,
      doValidation: false
    };
    this.options.onValueChangingCallback(changingOptions);
    options.value = changingOptions.newValue;
    if (q.property.isRequired) {
      const isEmpty = Helpers.isValueEmpty(options.value);
      q["valueChangingEmpty"] = isEmpty;
    }
    const isPropertyNameInValid = this.isPropNameInValid(this.obj, q.property, options.value);
    q["nameHasError"] = isPropertyNameInValid;
  }
  isPropNameInValid(obj, prop, val) {
    if (obj["isQuestion"] && prop.name === "name" && !!val) {
      val = val.toLowerCase();
      return ["item", "choice", "row", "panel"].indexOf(val) > -1;
    }
    return false;
  }
  onValueChanged(options) {
    var q = options.question;
    if (!q || !q.property) return;
    q["valueChangingEmpty"] = false;
    q["nameHasError"] = false;
    this.changeDependedProperties(q, (name) => {
      return this.survey.getQuestionByName(name);
    }, (name) => {
      return this.survey.getValue(name);
    });
    PropertyGridEditorCollection.onValueChanged(this.obj, q.property, q);
    if (!!this.classNameProperty && options.name === this.classNameProperty && this.classNameValue !== options.value) {
      this.setObj(this.obj);
      if (!!this.survey) {
        const question = this.survey.getQuestionByName(options.name);
        if (!!question) {
          question.focus();
        }
      }
    }
  }
  changeDependedProperties(question, dependedsQuetion, dependedsValue) {
    const prop = question.property;
    if (!prop) return;
    const properties = prop.getDependedProperties();
    if (!properties) return;
    for (var i = 0; i < properties.length; i++) {
      var name = properties[i];
      var q = dependedsQuetion(name);
      if (!q) continue;
      this.updateDependedPropertiesEditor(q);
      const objValue = dependedsValue(name);
      if (!Helpers.isTwoValueEquals(q.value, objValue, false, false, false)) {
        q.value = objValue;
      }
      PropertyGridEditorCollection.onMasterValueChanged(question.obj, q.property, q);
    }
  }
  updateDependedPropertiesEditor(editor) {
    const obj = editor.obj;
    if (!obj) return;
    const property2 = editor.property;
    if (!!property2 && property2.onPropertyEditorUpdate) {
      property2.onPropertyEditorUpdate(obj, editor);
    }
  }
  updateDependedPropertiesEditors() {
    const questions = this.survey.getAllQuestions();
    for (var i = 0; i < questions.length; i++) {
      this.updateDependedPropertiesEditor(questions[i]);
    }
  }
  onAfterRenderQuestion(options) {
    PropertyGridEditorCollection.onAfterRenderQuestion(this.obj, options.question.property, options);
  }
  onMatrixCellCreated(options) {
    this.isCellCreating = true;
    PropertyGridEditorCollection.onMatrixCellCreated(this.obj, options.question.property, options);
    this.isCellCreating = false;
    var obj = options.row.editingObj;
    if (!obj) return;
    var prop = Serializer.findProperty(obj.getType(), options.columnName);
    if (!prop) return;
    const allowEditRow = this.getMatrixAllowEditRow(options.question, options.row);
    options.cellQuestion.readOnly = !allowEditRow || PropertyJSONGenerator.isPropertyReadOnly(prop, this.options, obj, this.obj, options.question.property);
  }
  onMatrixCellValueChanging(options) {
    if (this.isCellCreating) return;
    var changingOptions = {
      obj: options.row.editingObj,
      propertyName: options.columnName,
      value: options.oldValue,
      newValue: options.value,
      doValidation: false
    };
    this.options.onValueChangingCallback(changingOptions);
    options.value = changingOptions.newValue;
  }
  onMatrixCellValidate(options) {
    if (this.isCellCreating) return;
    const q = options.row.getQuestionByColumnName(options.columnName);
    if (!q || !q.property) return;
    options.error = this.validateQuestionValue(options.row.editingObj, q, q.property, options.value);
  }
  onGetMatrixRowAction(options) {
    PropertyGridEditorCollection.onGetMatrixRowAction(this.obj, options.question.property, options, (obj) => {
      this.setObjFromAction(obj, options.question.name);
    });
  }
  onUpdateQuestionCssClasses(options) {
    PropertyGridEditorCollection.onUpdateQuestionCssClasses(this.obj, options.question.property, options);
  }
  onGetQuestionTitleActions(options, creator) {
    PropertyGridEditorCollection.onGetQuestionTitleActions(this.obj, options.question.property, options, creator);
  }
  onMatrixCellValueChanged(options) {
    if (this.isCellCreating) return;
    const cellQuestion = options.row.getQuestionByName(options.columnName);
    if (!!cellQuestion) {
      this.changeDependedProperties(cellQuestion, (name) => {
        return options.row.getQuestionByName(name);
      }, (name) => {
        return options.row.getValue(name);
      });
    }
    PropertyGridEditorCollection.onMatrixCellValueChanged(this.obj, options.question.property, options);
  }
  getMatrixAllowRemoveRow(question, row) {
    if (row.allowDeleteRow === void 0) {
      this.calculateMatrixAllowOperations(question, row);
    }
    return row.allowDeleteRow;
  }
  getMatrixOnRowRemoving(question, row) {
    return this.options.onCollectionItemDeletingCallback(this.obj, question.property, question.value, row.editingObj);
  }
  getMatrixAllowEditRow(question, row) {
    if (question.readOnly) return false;
    if (row.allowEditRow === void 0) {
      this.calculateMatrixAllowOperations(question, row);
    }
    return row.allowEditRow;
  }
  calculateMatrixAllowOperations(question, row) {
    const rowOptions = {
      allowDelete: this.onMatrixAllowRemoveRow(question, row),
      allowEdit: true,
      allowAdd: void 0
    };
    this.options.onCollectionItemAllowingCallback(this.obj, question.property, question.value, row.editingObj, rowOptions);
    row.allowDeleteRow = rowOptions.allowDelete;
    row.allowEditRow = rowOptions.allowEdit;
  }
  onMatrixAllowRemoveRow(question, row) {
    var res = PropertyGridEditorCollection.onMatrixAllowRemoveRow(this.obj, question.property, row);
    return this.options.onCanDeleteItemCallback(this.obj, row.editingObj, res);
  }
  onMatrixRowAdded(options) {
    var item = options.row.editingObj;
    if (Serializer.isDescendantOf(item.getType(), "itemvalue")) {
      this.options.onItemValueAddedCallback(this.obj, options.question.property.name, options.row.editingObj, options.question.value);
    }
    if (Serializer.isDescendantOf(item.getType(), "matrixdropdowncolumn")) {
      this.options.onMatrixDropdownColumnAddedCallback(this.obj, options.row.editingObj, options.question.value);
    }
  }
};
var PropertyGridEditor = class {
  constructor() {
  }
  showModalPropertyEditor(editor, property2, question, options, onClose) {
    const obj = question.obj;
    const surveyPropertyEditor = editor.createPropertyEditorSetup(obj, property2, question, options);
    if (!surveyPropertyEditor) return null;
    if (property2.type !== "condition") {
      surveyPropertyEditor.editSurvey.css = defaultCss;
    }
    if (question.isReadOnly) {
      surveyPropertyEditor.editSurvey.mode = "display";
    }
    if (!settings.showDialog) return surveyPropertyEditor;
    const prevCurrentLocale = surveyLocalization.currentLocale;
    const locale = editorLocalization.currentLocale;
    surveyLocalization.currentLocale = locale;
    const popupModel = settings.showDialog({
      componentName: "survey",
      data: {
        survey: surveyPropertyEditor.editSurvey,
        model: surveyPropertyEditor.editSurvey
      },
      onApply: () => {
        this.onModalPropertyEditorClosed(editor, property2, question, options, "apply");
        onClose && onClose("apply");
        return surveyPropertyEditor.apply();
      },
      onCancel: () => {
        this.onModalPropertyEditorClosed(editor, property2, question, options, "cancel");
        onClose && onClose("cancel");
      },
      cssClass: "svc-property-editor svc-creator-popup",
      title: question.title,
      displayMode: options.isMobileView ? "overlay" : "popup"
    }, options.rootElement);
    if (question.isReadOnly) {
      const applyBtn = popupModel.footerToolbar.getActionById("apply");
      if (!!applyBtn) {
        applyBtn.visible = false;
      }
    }
    popupModel.locale = locale;
    surveyLocalization.currentLocale = prevCurrentLocale;
    this.onModalPropertyEditorShown(editor, property2, question, options);
    options.onPropertyGridShowModalCallback(obj, property2, question, surveyPropertyEditor, popupModel);
    return surveyPropertyEditor;
  }
  onModalPropertyEditorShown(editor, property2, question, options) {
  }
  onModalPropertyEditorClosed(editor, property2, question, options, reason) {
  }
  isSupportGrouping() {
    return false;
  }
  hasPreviousElementForGrouping(question) {
    if (!question || !question.parent) return false;
    const index = question.parent.elements.indexOf(question);
    if (index < 1) return;
    const prevElement = question.parent.elements[index - 1];
    const prevPrevElement = question.parent.elements[index - 2];
    if (prevElement.getType() === question.getType()) return true;
    if (index > 1 && !prevElement.startWithNewLine && prevPrevElement["property"] === prevElement["property"] && prevPrevElement.getType() === question.getType()) return true;
    return false;
  }
  onUpdateQuestionCssClasses(obj, options) {
    if (!this.isSupportGrouping()) return;
    if (this.hasPreviousElementForGrouping(options.question)) {
      options.cssClasses.mainRoot += " spg-row-narrow__question";
    }
  }
};
var PropertyGridEditorBoolean = class extends PropertyGridEditor {
  fit(prop, context) {
    return prop.type == "boolean" || prop.type == "switch";
  }
  getJSON(obj, prop, options) {
    const res = {
      type: "boolean",
      default: false,
      renderAs: "checkbox",
      titleLocation: "hidden"
    };
    const choices = prop.getChoices(obj, (choices2) => {
    });
    if (Array.isArray(choices) && choices.length >= 2) {
      const jsonChoices = [];
      for (let i = 0; i < 2; i++) {
        const val = choices[i].value || choices[i];
        jsonChoices.push({
          value: val,
          text: editorLocalization.getPropertyValueInEditor(prop.name, val)
        });
      }
      const defaultValue = prop.getDefaultValue(obj) || jsonChoices[0].value;
      const indexTrue = defaultValue === choices[1].value ? 1 : 0;
      const indexFalse = indexTrue === 0 ? 1 : 0;
      res.valueTrue = jsonChoices[indexTrue].value;
      res.valueFalse = jsonChoices[indexFalse].value;
      res.labelTrue = jsonChoices[indexTrue].text;
      res.labelFalse = jsonChoices[indexFalse].text;
    }
    return res;
  }
  isSupportGrouping() {
    return true;
  }
};
var PropertyGridEditorSwitchToggle = class extends PropertyGridEditor {
  fit(prop, context) {
    return prop.type == "switchToggle";
  }
  getJSON(obj, prop, options) {
    const res = {
      type: "boolean",
      default: false
    };
    const choices = prop.getChoices(obj, (choices2) => {
    });
    if (Array.isArray(choices) && choices.length >= 2) {
      const jsonChoices = [];
      for (let i = 0; i < 2; i++) {
        const val = choices[i].value || choices[i];
        jsonChoices.push({
          value: val,
          text: editorLocalization.getPropertyValueInEditor(prop.name, val)
        });
      }
      const defaultValue = prop.getDefaultValue(obj) || jsonChoices[0].value;
      const indexTrue = defaultValue === choices[1].value ? 1 : 0;
      const indexFalse = indexTrue === 0 ? 1 : 0;
      res.valueTrue = jsonChoices[indexTrue].value;
      res.valueFalse = jsonChoices[indexFalse].value;
      res.labelTrue = jsonChoices[indexTrue].text;
      res.labelFalse = jsonChoices[indexFalse].text;
    }
    return res;
  }
};
var PropertyGridEditorUndefinedBoolean = class extends PropertyGridEditor {
  fit(prop, context) {
    return prop.type == "boolean" && !!prop.defaultValueFunc && prop.defaultValueFunc(null) === void 0;
  }
  getJSON(obj, prop, options) {
    const choices = [{
      value: "auto",
      text: editorLocalization.getString("pe.inherit")
    }, {
      value: "false",
      text: editorLocalization.getString("pe.disabled")
    }, {
      value: "true",
      text: editorLocalization.getString("pe.enabled")
    }];
    const res = {
      type: "buttongroup",
      choices,
      showOptionsCaption: false
    };
    return res;
  }
  onCreated(obj, question, prop, options, propGridDefinition) {
    question.valueFromDataCallback = (val) => {
      return val === void 0 || val === null ? "auto" : val.toString();
    };
    question.valueToDataCallback = (val) => {
      return val === "auto" ? void 0 : val === "true";
    };
  }
  onSetup(obj, question, prop, options) {
    const objValue = obj.getPropertyValue(prop.name);
    if (objValue === void 0) {
      question.value = "auto";
    } else {
      question.value = objValue === "true";
    }
  }
};
var PropertyGridEditorStringBase = class extends PropertyGridEditor {
  updateMaxLength(prop, json2) {
    if (prop.maxLength > 0) {
      json2.maxLength = prop.maxLength;
    }
    return json2;
  }
  updateType(prop, obj, json2) {
    if (!json2.maxLength && obj.hasDefaultPropertyValue(prop.name)) {
      json2.type = `${json2.type}withreset`;
      json2.renderAs = json2.type;
    }
    return json2;
  }
  onCreated(obj, question, prop, options) {
    if (question instanceof QuestionTextBase) {
      question.onKeyDownPreprocess = (event) => {
        if ((event.ctrlKey || event.metaKey) && [89, 90].indexOf(event.keyCode) !== -1) {
          if (question.isInputTextUpdate) {
            options.findSuitableShortcuts(event).forEach((shortcut) => {
              shortcut.execute(options.selectedElement);
            });
            event.preventDefault();
          } else if (event.target.value == question.value) {
            options.findSuitableShortcuts(event).forEach((shortcut) => {
              shortcut.execute(options.selectedElement);
            });
          }
        }
      };
    }
    if (prop.name === "title") {
      question.allowSpaceAsAnswer = true;
    }
    if (question.getType() == "textwithreset" || question.getType() == "commentwithreset") {
      question.resetValueAdorner.resetValueCallback = () => {
        obj.resetPropertyValue(prop.name);
      };
      question.resetValueAdorner.caption = editorLocalization.getString("pe.resetToDefaultCaption");
      const isDefaultValue = () => !prop.isDefaultValueByObj(obj, prop.getValue(obj));
      question.resetValueAdorner.allowResetValue = isDefaultValue();
      obj.registerFunctionOnPropertyValueChanged(prop.name, () => {
        question.resetValueAdorner.allowResetValue = isDefaultValue();
      });
    }
  }
};
var PropertyGridEditorString = class extends PropertyGridEditorStringBase {
  fit(prop) {
    return prop.type == "string";
  }
  isDefault() {
    return true;
  }
  getJSON(obj, prop, options) {
    const json2 = this.updateType(prop, obj, this.updateMaxLength(prop, {
      type: "text"
    }));
    if (prop.isRequired) {
      json2.textUpdateMode = "onBlur";
    }
    if (!!prop.dataList) {
      json2.dataList = prop.dataList;
    }
    return json2;
  }
  validateValue(obj, question, prop, val) {
    return validateImageItemValueProperty(obj, prop, val);
  }
};
var PropertyGridEditorDateTime = class extends PropertyGridEditor {
  fit(prop) {
    return prop.type == "datetime";
  }
  getJSON(obj, prop, options) {
    const res = {
      type: "text",
      inputType: "date"
    };
    return res;
  }
};
function validateImageItemValueProperty(obj, prop, val) {
  if (obj.getType() !== "imageitemvalue" || prop.name !== "imageLink" || !Helpers.isUrlYoutubeVideo(val)) return void 0;
  return editorLocalization.getString("ed.translationYouTubeNotSupported");
}
var PropertyGridLinkEditor = class extends PropertyGridEditor {
  fit(prop) {
    return prop.type === "url" || prop.type === "file";
  }
  getJSON(obj, prop, options) {
    const res = {
      type: "fileedit",
      storeDataAsText: false,
      placeholder: editorLocalization.getString("pe.fileInputPlaceholder")
    };
    return res;
  }
  onCreated(obj, question, prop, options) {
    if (["image", "imageitemvalue"].indexOf(obj.getType()) > -1) {
      const questionObj = obj.getType() == "imageitemvalue" ? obj.locOwner : obj;
      if (questionObj) {
        questionObj.registerFunctionOnPropertyValueChanged("contentMode", (newValue) => {
          question.acceptedTypes = getAcceptedTypesByContentMode(newValue);
        });
        question.acceptedTypes = getAcceptedTypesByContentMode(questionObj.contentMode);
      }
    } else {
      question.acceptedTypes = getAcceptedTypesByContentMode("image");
    }
    question.onChooseFilesCallback = (input, callback) => {
      options.chooseFiles(input, callback, {
        element: obj,
        elementType: obj.getType(),
        propertyName: question.name
      });
    };
  }
  validateValue(obj, question, prop, val) {
    return validateImageItemValueProperty(obj, prop, val);
  }
};
var PropertyGridEditorColor = class extends PropertyGridEditor {
  fit(prop) {
    return prop.type == "color";
  }
  getJSON(obj, prop, options) {
    const res = {
      type: "color",
      allowEmptyValue: true
    };
    return res;
  }
  onCreated(obj, question, prop) {
    question.valueFromDataCallback = function(val) {
      return val;
    };
    question.valueToDataCallback = function(val) {
      return val;
    };
  }
};
var PropertyGridEditorColorWithAlpha = class extends PropertyGridEditor {
  fit(prop) {
    return prop.type == "coloralpha";
  }
  getJSON(obj, prop, options) {
    return {
      type: "coloralpha",
      descriptionLocation: "hidden"
    };
  }
  onCreated(obj, question, prop) {
    question.valueFromDataCallback = function(val) {
      return val;
    };
    question.valueToDataCallback = function(val) {
      return val;
    };
  }
};
var PropertyGridEditorNumber = class extends PropertyGridEditor {
  fit(prop) {
    return prop.type == "number" || prop.type == "responsiveImageSize";
  }
  getJSON(obj, prop, options) {
    var res = {
      type: "text",
      inputType: "number",
      textUpdateMode: "onBlur"
    };
    if (prop.minValue !== void 0) {
      res.min = prop.minValue;
    }
    if (prop.maxValue !== void 0) {
      res.max = prop.maxValue;
    }
    return res;
  }
  onValueChanging(obj, prop, question, options) {
    if (!options.value && options.value !== 0) {
      if (prop.defaultValue !== void 0) {
        options.value = prop.defaultValue;
      } else {
        if (!prop.isRequired && options.value === "") {
          options.value = void 0;
        } else {
          options.value = prop.minValue !== void 0 && prop.minValue > 0 ? prop.minValue : 0;
        }
      }
    }
  }
};
var PropertyGridEditorSpinEdit = class extends PropertyGridEditor {
  fit(prop) {
    return prop.type == "spinedit";
  }
  getJSON(obj, prop, options) {
    const res = {
      type: "spinedit",
      descriptionLocation: "hidden"
    };
    return res;
  }
};
var PropertyGridEditorImageSize = class extends PropertyGridEditorString {
  fit(prop) {
    return prop.type == "string" && (prop.name == "imageHeight" || prop.name == "imageWidth");
  }
  isDefault() {
    return false;
  }
  onCreated(obj, question, prop, options) {
    super.onCreated(obj, question, prop, options);
    const isDefaultValue = (imageHeight, imageWidth) => {
      const imageHeightProperty = Serializer.findProperty(obj.getType(), "imageHeight");
      const imageWidthProperty = Serializer.findProperty(obj.getType(), "imageWidth");
      if (!imageHeightProperty && !imageWidthProperty) return false;
      return imageHeightProperty.isDefaultValue(imageHeight) && imageWidthProperty.isDefaultValue(imageWidth);
    };
    question.valueFromDataCallback = function(value) {
      const isDefaultSize = isDefaultValue(obj["imageHeight"], obj["imageWidth"]);
      return isDefaultSize ? void 0 : value;
    };
  }
};
var PropertyGridEditorText = class extends PropertyGridEditorStringBase {
  fit(prop) {
    return prop.type === "text";
  }
  getJSON(obj, prop, options) {
    return this.updateType(prop, obj, this.updateMaxLength(prop, {
      type: "comment",
      rows: 2
    }));
  }
};
var PropertyGridEditorHtml = class extends PropertyGridEditorStringBase {
  fit(prop) {
    return prop.type === "html";
  }
  getJSON(obj, prop, options) {
    return this.updateMaxLength(prop, {
      type: "comment",
      "allowResize": true,
      "autoGrow": false
    });
  }
};
var PropertyGridEditorStringArray = class extends PropertyGridEditor {
  fit(prop) {
    return prop.type == "string[]";
  }
  getJSON(obj, prop, options) {
    return {
      type: "comment",
      rows: 2
    };
  }
  onCreated(obj, question, prop) {
    question.valueFromDataCallback = function(val) {
      if (!Array.isArray(val)) return "";
      return val.join("\n");
    };
    question.valueToDataCallback = function(val) {
      if (!val) return [];
      if (Array.isArray(val) && !val["split"]) return val;
      return val.split("\n");
    };
  }
};
var PropertyGridEditorDropdown = class extends PropertyGridEditor {
  fit(prop) {
    return prop.type !== "boolean" && (this.isLocaleProp(prop) || prop.hasChoices);
  }
  getJSON(obj, prop, options) {
    var choices = this.getChoices(obj, prop);
    var json2 = {
      type: this.renderAsButtonGroup(prop, choices) ? "buttongroup" : "dropdown",
      choices,
      showOptionsCaption: false
    };
    this.updateObjBasedOnEmptyValueItem(prop, choices, json2);
    return json2;
  }
  getChoices(obj, prop) {
    return prop.getChoices(obj, (choices) => {
    });
  }
  updateObjBasedOnEmptyValueItem(prop, choices, objOrJson) {
    const emptyValueItem = this.getEmptyJsonItemValue(prop, choices);
    if (!!emptyValueItem) {
      objOrJson.showOptionsCaption = true;
      objOrJson.allowClear = true;
      if (emptyValueItem.text) {
        objOrJson.optionsCaption = emptyValueItem.text;
      }
    }
  }
  get canRenderAsButtonGroup() {
    return settings2.propertyGrid.useButtonGroup;
  }
  renderAsButtonGroup(prop, choices) {
    if (prop.type === "dropdown") return false;
    if (prop.type === "buttongroup") return true;
    if (this.isLocaleProp(prop)) return false;
    if (!this.canRenderAsButtonGroup || !choices || choices.length == 0 || choices.length > 4) return false;
    var charCount = 0;
    for (var i = 0; i < choices.length; i++) {
      var text = this.getLocalizedText(prop, !!choices[i].value ? choices[i].value : choices[i]);
      charCount += !!text ? text.length : 0;
    }
    return charCount < settings2.propertyGrid.maxCharsInButtonGroup;
  }
  onCreated(obj, question, prop) {
    this.setChoices(obj, question, prop);
    question.displayValueCallback = (text) => {
      return !text ? question.optionsCaption : text;
    };
  }
  onMasterValueChanged(obj, prop, question) {
    this.setChoices(obj, question, prop);
    if (!question.isEmpty()) {
      if (!ItemValue.getItemByValue(question.choices, question.value)) {
        question.clearValue();
      }
    }
  }
  setChoicesCore(question, prop, propChoices) {
    if (!propChoices || !Array.isArray(propChoices) || propChoices.length == 0) return;
    this.updateObjBasedOnEmptyValueItem(prop, propChoices, question);
    question.choices = this.choicesFromPropChoices(prop, propChoices);
  }
  isLocaleProp(prop) {
    return prop.name === "locale";
  }
  getLocalizedText(prop, value) {
    if (this.isLocaleProp(prop)) {
      let text = editorLocalization.getLocaleName(value);
      if (text) return text;
    }
    if (prop.name === "cellType") {
      let text = editorLocalization.getString("qt." + value);
      if (text) return text;
    }
    if (value === null) return null;
    return editorLocalization.getPropertyValueInEditor(prop.name, value);
  }
  choicesFromPropChoices(prop, propChoices) {
    var choices = [];
    for (var i = 0; i < propChoices.length; i++) {
      var jsonItem = this.getJsonItem(prop, propChoices[i]);
      if (!Helpers.isValueEmpty(jsonItem.value)) {
        choices.push(jsonItem);
      }
    }
    return choices;
  }
  getJsonItem(prop, item) {
    var jsonItem = {
      value: item.value !== void 0 ? item.value : item
    };
    var text = !!item.text ? item.text : "";
    if (!text) {
      text = this.getLocalizedText(prop, jsonItem.value);
    }
    if (!!text && text != jsonItem.value) {
      jsonItem.text = text;
    }
    return jsonItem;
  }
  setChoices(obj, question, prop) {
    var propChoices = prop.getChoices(obj, (choices) => {
      this.setChoicesCore(question, prop, choices);
    });
    this.setChoicesCore(question, prop, propChoices);
  }
  getEmptyJsonItemValue(prop, choices) {
    if (!choices) return null;
    for (var i = 0; i < choices.length; i++) {
      var item = choices[i];
      var value = item.value !== void 0 ? item.value : item;
      if (Helpers.isValueEmpty(value)) return this.getJsonItem(prop, item);
    }
    return null;
  }
};
var PropertyGridEditorSet = class extends PropertyGridEditorDropdown {
  fit(prop) {
    return prop.type == "set" || prop.type == "multiplevalues";
  }
  getJSON(obj, prop, options) {
    var json2 = super.getJSON(obj, prop, options);
    var hasTagbox = !!Serializer.findClass("tagbox");
    json2.type = hasTagbox ? "tagbox" : "checkbox";
    json2.hasSelectAll = !hasTagbox;
    return json2;
  }
};
var PropertyGridEditorPage = class extends PropertyGridEditorDropdown {
  fit(prop) {
    return prop.hasChoices && prop.name == "page";
  }
  get canRenderAsButtonGroup() {
    return false;
  }
  onCreated(obj, question, prop) {
    super.onCreated(obj, question, prop);
    question.valueFromDataCallback = (val) => {
      return !!val ? val.name : "";
    };
    question.valueToDataCallback = (val) => {
      if (!val || !obj || !obj.getSurvey()) return void 0;
      return obj.getSurvey().getPageByName(val);
    };
  }
};
var PropertyGridEditorQuestion = class extends PropertyGridEditor {
  fit(prop) {
    return prop.type == "question" || prop.type === "questionlist";
  }
  getJSON(obj, prop, options) {
    const result = {
      type: "dropdown",
      optionsCaption: editorLocalization.getString("pe.conditionSelectQuestion"),
      choices: this.getChoices(obj, prop, options)
    };
    if (prop.type == "question") {
      result["allowClear"] = false;
    }
    return result;
  }
  getChoices(obj, prop, options) {
    var survey = EditableObject.getSurvey(obj);
    if (!survey) return [];
    var questions = this.getQuestions(survey, obj);
    if (!questions) questions = [];
    var showTitles = !!options && (options.useElementTitles || options.showTitlesInExpressions);
    var qItems = questions.map((q) => {
      let text = showTitles ? q.locTitle.renderedHtml : q.name;
      if (!!options) text = options.getObjectDisplayName(q, "property-grid:property-editor", "property-editor", text);
      let value = this.getItemValue(q);
      return {
        value,
        text
      };
    });
    if (settings2.logic.questionSortOrder === "asc") {
      SurveyHelper.sortItems(qItems);
    }
    return qItems;
  }
  getQuestions(survey, obj) {
    return survey.getAllQuestions();
  }
  getItemValue(question) {
    return question.name;
  }
};
var PropertyGridEditorQuestionSelectBase = class extends PropertyGridEditorQuestion {
  fit(prop) {
    return prop.type == "question_selectbase";
  }
  isQuestionFit(question) {
    return Serializer.isDescendantOf(question.getType(), "selectbase");
  }
  getQuestions(survey, obj) {
    let questions = super.getQuestions(survey, obj);
    let res = [];
    for (let i = 0; i < questions.length; i++) {
      const q = questions[i];
      if (q !== obj && this.isQuestionFit(q)) {
        res.push(q);
      }
    }
    return res;
  }
};
var PropertyGridEditorQuestionCarryForward = class extends PropertyGridEditorQuestionSelectBase {
  fit(prop) {
    return prop.type == "question_carryforward";
  }
  isQuestionFit(question) {
    return question.isValueArray || super.isQuestionFit(question);
  }
};
var PropertyGridEditorQuestionValue = class extends PropertyGridEditorQuestion {
  fit(prop) {
    return prop.type === "questionvalue" || prop.type === "questionlist-savevaluename";
  }
  getItemValue(question) {
    return question.getValueName();
  }
  getQuestions(survey, obj) {
    const questions = super.getQuestions(survey, obj);
    return questions.filter((q) => {
      return !Serializer.isDescendantOf(q.getType(), "nonvalue");
    });
  }
};
PropertyGridEditorCollection.register(new PropertyGridEditorBoolean());
PropertyGridEditorCollection.register(new PropertyGridEditorString());
PropertyGridEditorCollection.register(new PropertyGridEditorNumber());
PropertyGridEditorCollection.register(new PropertyGridEditorSpinEdit());
PropertyGridEditorCollection.register(new PropertyGridEditorText());
PropertyGridEditorCollection.register(new PropertyGridEditorHtml());
PropertyGridEditorCollection.register(new PropertyGridEditorDropdown());
PropertyGridEditorCollection.register(new PropertyGridEditorSet());
PropertyGridEditorCollection.register(new PropertyGridEditorPage());
PropertyGridEditorCollection.register(new PropertyGridEditorStringArray());
PropertyGridEditorCollection.register(new PropertyGridEditorQuestion());
PropertyGridEditorCollection.register(new PropertyGridEditorQuestionValue());
PropertyGridEditorCollection.register(new PropertyGridEditorQuestionSelectBase());
PropertyGridEditorCollection.register(new PropertyGridEditorQuestionCarryForward());
PropertyGridEditorCollection.register(new PropertyGridEditorImageSize());
PropertyGridEditorCollection.register(new PropertyGridEditorColor());
PropertyGridEditorCollection.register(new PropertyGridEditorColorWithAlpha());
PropertyGridEditorCollection.register(new PropertyGridEditorDateTime());
PropertyGridEditorCollection.register(new PropertyGridEditorUndefinedBoolean());
PropertyGridEditorCollection.register(new PropertyGridEditorSwitchToggle());
QuestionFactory.Instance.registerQuestion("buttongroup", (name) => {
  return new QuestionButtonGroupModel(name);
}, false);
var translationCss = {
  root: "st-root-modern",
  container: "st-container-modern",
  header: "st-title st-container-modern__title",
  body: "st-body",
  bodyEmpty: "st-body st-body--empty",
  footer: "st-footer st-body__footer st-clearfix",
  title: "",
  description: "",
  logo: "st-logo",
  logoImage: "st-logo__image",
  headerText: "st-header__text",
  navigationButton: "",
  bodyNavigationButton: "st-navigation-btn",
  completedPage: "st-completedpage",
  navigation: {
    complete: "st-btn st-footer__complete-btn",
    prev: "st-btn st-footer__prev-btn",
    next: "st-btn st-footer__next-btn",
    start: "st-btn st-footer__start-btn",
    preview: "st-btn st-footer__preview-btn",
    edit: "st-btn st-footer__edit-btn"
  },
  panel: {
    title: "st-title st-panel__title",
    titleExpandable: "st-panel__title--expandable",
    titleOnExpand: "st-panel__title--expanded",
    titleOnError: "st-panel__title--error",
    description: "st-description st-panel__description",
    container: "st-element st-panel st-row__panel",
    content: "st-panel__content",
    icon: "st-panel__icon",
    iconExpanded: "st-panel__icon--expanded",
    footer: "st-panel__footer",
    requiredMark: "st-panel__required-text"
  },
  paneldynamic: {
    root: "st-paneldynamic",
    navigation: "st-paneldynamic__navigation",
    title: "st-title st-question__title",
    button: "st-btn",
    buttonRemove: "st-paneldynamic__remove-btn",
    buttonAdd: "st-paneldynamic__add-btn",
    progressTop: "st-paneldynamic__progress st-paneldynamic__progress--top",
    progressBottom: "st-paneldynamic__progress st-paneldynamic__progress--bottom",
    buttonPrev: "st-paneldynamic__prev-btn",
    buttonNext: "st-paneldynamic__next-btn",
    progressContainer: "st-paneldynamic__progress-container",
    progress: "st-progress",
    progressBar: "st-progress__bar",
    progressText: "st-paneldynamic__progress-text",
    separator: "st-paneldynamic__separator",
    panelWrapper: "st-paneldynamic__panel-wrapper",
    panelWrapperInRow: "st-paneldynamic__panel-wrapper--in-row"
  },
  progress: "st-progress st-body__progress",
  progressBar: "st-progress__bar",
  progressText: "st-progress__text",
  progressTextInBar: "st-hidden",
  page: {
    root: "st-page st-body__page",
    title: "st-title st-page__title",
    description: "st-description st-page__description"
  },
  pageTitle: "st-title st-page__title",
  pageDescription: "st-description st-page__description",
  row: "st-row st-clearfix",
  question: {
    mainRoot: "st-element st-question st-row__question",
    flowRoot: "st-element st-question st-row__question st-row__question--flow",
    asCell: "st-table__cell",
    header: "st-question__header",
    headerLeft: "st-question__header--location--left",
    headerTop: "st-question__header--location--top",
    headerBottom: "st-question__header--location--bottom",
    content: "st-question__content",
    contentLeft: "st-question__content--left",
    titleLeftRoot: "",
    titleOnAnswer: "st-question__title--answer",
    titleOnError: "st-question__title--error",
    title: "st-title st-question__title",
    requiredMark: "st-question__required-text",
    number: "st-question__num",
    description: "st-description st-question__description",
    descriptionUnderInput: "st-description st-question__description",
    comment: "st-comment",
    required: "st-question--required",
    titleRequired: "st-question__title--required",
    indent: 20,
    footer: "st-question__footer",
    formGroup: "st-question__form-group",
    hasError: "",
    disabled: "st-question--disabled",
    confirmDialog: "st-popup--confirm sv-popup--confirm svc-creator-popup"
  },
  image: {
    root: "st-image",
    image: "sv_image_image"
  },
  error: {
    root: "st-question__erbox",
    icon: "",
    item: "",
    locationTop: "st-question__erbox--location--top",
    locationBottom: "st-question__erbox--location--bottom"
  },
  checkbox: {
    root: "st-selectbase",
    item: "st-item st-checkbox st-selectbase__item",
    itemSelectAll: "st-checkbox--selectall",
    itemNone: "st-checkbox--none",
    itemDisabled: "st-item--disabled st-checkbox--disabled",
    itemChecked: "st-item--checked st-checkbox--checked",
    itemHover: "st-item--allowhover st-checkbox--allowhover",
    itemInline: "st-selectbase__item--inline",
    label: "st-selectbase__label",
    labelChecked: "",
    itemControl: "st-visuallyhidden st-item__control st-checkbox__control",
    itemDecorator: "st-item__svg st-checkbox__svg",
    controlLabel: "st-item__control-label",
    materialDecorator: "st-item__decorator st-checkbox__decorator",
    other: "st-comment st-question__other",
    column: "st-selectbase__column"
  },
  radiogroup: {
    root: "st-selectbase",
    item: "st-item st-radio st-selectbase__item",
    itemInline: "st-selectbase__item--inline",
    label: "st-selectbase__label",
    labelChecked: "",
    itemDisabled: "st-item--disabled st-radio--disabled",
    itemChecked: "st-item--checked st-radio--checked",
    itemHover: "st-item--allowhover st-radio--allowhover",
    itemControl: "st-visuallyhidden st-item__control st-radio__control",
    itemDecorator: "st-item__svg st-radio__svg",
    controlLabel: "st-item__control-label",
    materialDecorator: "st-item__decorator st-radio__decorator",
    other: "st-comment st-question__other",
    clearButton: "st-btn st-selectbase__clear-btn",
    column: "st-selectbase__column"
  },
  boolean: {
    mainRoot: "st-question st-row__question st-question--boolean",
    root: "",
    item: "st-boolean",
    control: "st-boolean__control st-visuallyhidden",
    itemChecked: "st-boolean--checked",
    itemIndeterminate: "st-boolean--indeterminate",
    itemDisabled: "st-boolean--disabled",
    label: "st-boolean__label",
    switch: "st-boolean__switch",
    disabledLabel: "st-checkbox__label--disabled",
    itemDecorator: "st-checkbox__hidden",
    materialDecorator: "st-checkbox__rectangle",
    sliderText: "",
    slider: "st-boolean__thumb"
  },
  text: {
    root: "st-input st-text",
    small: "st-row__question--small",
    controlDisabled: "st-input--disabled",
    onError: "st-input--error"
  },
  multipletext: {
    root: "st-multipletext",
    item: "st-multipletext__item",
    itemTitle: "st-multipletext__item-title",
    row: "st-multipletext__row",
    cell: "st-multipletext__cell"
  },
  dropdown: {
    root: "st-selectbase",
    popup: "st-dropdown-popup svc-creator-popup",
    small: "st-row__question--small",
    control: "st-input st-dropdown",
    other: "st-comment st-question__other",
    onError: "st-input--error",
    label: "st-selectbase__label",
    item: "st-item st-radio st-selectbase__item",
    itemDisabled: "st-item--disabled st-radio--disabled",
    itemChecked: "st-item--checked st-radio--checked",
    itemHover: "st-item--allowhover st-radio--allowhover",
    itemControl: "st-visuallyhidden st-item__control st-radio__control",
    itemDecorator: "st-item__svg st-radio__svg",
    controlDisabled: "st-input--disabled",
    controlLabel: "st-item__control-label",
    materialDecorator: "st-item__decorator st-radio__decorator"
  },
  imagepicker: {
    root: "st-imagepicker",
    item: "st-imagepicker__item",
    itemInline: "st-imagepicker__item--inline",
    itemChecked: "st-imagepicker__item--checked",
    itemDisabled: "st-imagepicker__item--disabled",
    itemHover: "st-imagepicker__item--allowhover",
    label: "st-imagepicker__label",
    itemControl: "st-imagepicker__control",
    image: "st-imagepicker__image",
    itemText: "st-imagepicker__text",
    clearButton: "st-btn",
    other: "st-comment st-question__other"
  },
  matrix: {
    mainRoot: "st-question st-row__question st-scrollable",
    tableWrapper: "st-matrix",
    root: "st-table",
    noHeader: "st-table--no-header",
    rowError: "st-matrix__row--error",
    cell: "st-table__cell st-matrix__cell",
    headerCell: "st-table__cell st-table__cell--header",
    rowTextCell: "st-table__cell st-table__cell--row-text",
    label: "st-item st-radio st-matrix__label",
    itemValue: "st-visuallyhidden st-item__control st-radio__control",
    itemChecked: "st-radio--checked",
    itemDisabled: "st-item--disabled st-radio--disabled",
    itemHover: "st-radio--allowhover",
    materialDecorator: "st-item__decorator st-radio__decorator",
    itemDecorator: "st-item__svg st-radio__svg",
    cellText: "st-matrix__text",
    cellTextSelected: "st-matrix__text--checked",
    cellTextDisabled: "st-matrix__text--disabled"
  },
  matrixdropdown: {
    mainRoot: "st-question st-row__question st-scrollable",
    root: "st-table",
    noHeader: "st-table--no-header",
    cell: "st-table__cell",
    headerCell: "st-table__cell st-table__cell--header",
    rowTextCell: "st-table__cell st-table__cell--row-text"
  },
  matrixdynamic: {
    mainRoot: "st-question st-row__question st-scrollable",
    root: "st-table st-matrixdynamic",
    noHeader: "st-table--no-header",
    cell: "st-table__cell",
    headerCell: "st-table__cell st-table__cell--header",
    rowTextCell: "st-table__cell st-table__cell--row-text",
    button: "st-btn",
    detailRow: "st-table__row st-table__row--detail",
    detailButton: "st-table__cell--detail-button",
    detailButtonExpanded: "st-table__cell--detail-button--expanded",
    detailIcon: "st-detail-panel__icon",
    detailIconExpanded: "st-detail-panel__icon--expanded",
    detailPanelCell: "st-table__cell--detail-panel",
    actionsCell: "st-table__cell st-table__cell--actions",
    buttonAdd: "st-matrixdynamic__add-btn",
    buttonRemove: "st-matrixdynamic__remove-btn",
    iconAdd: "",
    iconRemove: ""
  },
  rating: {
    root: "st-rating",
    item: "st-rating__item",
    itemHover: "st-rating__item--allowhover",
    selected: "st-rating__item--selected",
    minText: "st-rating__item-text st-rating__min-text",
    itemText: "st-rating__item-text",
    maxText: "st-rating__item-text st-rating__max-text",
    itemDisabled: "st-rating__item--disabled"
  },
  comment: {
    root: "st-comment",
    small: "st-row__question--small"
  },
  expression: "",
  file: {
    root: "st-file",
    other: "st-comment st-question__other",
    placeholderInput: "st-visuallyhidden",
    preview: "st-file__preview",
    fileSign: "st-hidden",
    fileSignBottom: "st-file__sign",
    fileDecorator: "st-file__decorator",
    fileInput: "st-visuallyhidden",
    noFileChosen: "st-description st-file__no-file-chosen",
    chooseFile: "st-btn st-file__choose-btn",
    disabled: "st-file__choose-btn--disabled",
    removeButton: "st-hidden",
    removeButtonBottom: "st-btn st-file__clean-btn",
    removeFile: "st-hidden",
    removeFileSvg: "st-file__remove-svg",
    wrapper: "st-file__wrapper"
  },
  signaturepad: {
    root: "st-signaturepad sjs_sp_container",
    small: "st-row__question--small",
    controls: "sjs_sp_controls",
    placeholder: "sjs_sp_placeholder",
    clearButton: "sjs_sp_clear"
  },
  saveData: {
    root: "",
    saving: "",
    error: "",
    success: "",
    saveAgainButton: ""
  },
  window: {
    root: "sv_window",
    body: "sv_window_content",
    header: {
      root: "sv_window_title",
      title: "",
      button: "",
      buttonExpanded: "",
      buttonCollapsed: ""
    }
  }
};
function findAction(actions, id) {
  if (!Array.isArray(actions)) return null;
  for (var i = 0; i < actions.length; i++) {
    if (actions[i].id === id) return actions[i];
  }
  return null;
}
function updateMatrixLogicExpandAction(question, actions, row) {
  const action = findAction(actions, "show-detail");
  if (!action) return;
  action.component = "sv-action-bar-item";
  action.iconName = "icon-logic-expand";
  action.innerCss = "sl-table__action-button sl-table__detail-button";
  action.iconSize = "auto";
  action.showTitle = false;
  action.action = () => {
    row.showHideDetailPanelClick();
  };
  const updateIcon = () => {
    action.iconName = row.isDetailPanelShowing ? "icon-logic-collapse" : "icon-logic-expand";
  };
  question.registerFunctionOnPropertyValueChanged("isRowShowing" + row.id, updateIcon);
  updateIcon();
}
function updateMatrixLogicRemoveAction(question, actions, row) {
  updateMatrixRemoveAction(question, actions, row);
  const action = findAction(actions, "remove-row");
  if (!action) return;
  action.iconSize = "auto";
  action.css = "sl-table__action-button sl-table__remove-button";
}
function updateMatrixRemoveAction(question, actions, row) {
  const action = findAction(actions, "remove-row");
  if (!action) return;
  action.component = "sv-action-bar-item";
  action.iconName = "icon-delete";
  action.iconSize = "auto";
  action.innerCss = "spg-action-button spg-action-button--danger";
  action.title = question.removeRowText;
  action.showTitle = false;
  action.visibleIndex = 10;
  action.action = () => {
    question.removeRowUI(row);
  };
}
function updateMatixActionsClasses(actions) {
  actions.forEach((action) => {
    action.innerCss = `${action.innerCss || ""} spg-action-button--muted`;
  });
}
var MenuButton = class extends Action {
  get buttonClassName() {
    return new CssClassBuilder().append("svc-menu-action__button").append("svc-menu-action__button--with-subtitle", this.contentType === "text-description-vertical").append("svc-menu-action__button--pressed", this.pressed).append("svc-menu-action__button--selected", !!this.active).toString();
  }
};
__decorate2([property({
  defaultValue: "icon"
})], MenuButton.prototype, "contentType", void 0);
function calculateIsEdge(dropTargetNode, clientY) {
  const rect = dropTargetNode.getBoundingClientRect();
  return clientY - rect.top <= DragDropSurveyElements.edgeHeight || rect.bottom - clientY <= DragDropSurveyElements.edgeHeight;
}
function calculateIsSide(dropTargetNode, clientX) {
  const rect = dropTargetNode.getBoundingClientRect();
  return clientX - rect.left <= DragDropSurveyElements.edgeHeight || rect.right - clientX <= DragDropSurveyElements.edgeHeight;
}
function calculateDragOverLocation(clientX, clientY, rect, direction = null) {
  const tg = rect.height / rect.width;
  const dx = clientX - rect.x;
  const dy = clientY - rect.y;
  if (direction == "top-bottom") {
    if (dy >= rect.height / 2) {
      return DragTypeOverMeEnum.Bottom;
    } else {
      return DragTypeOverMeEnum.Top;
    }
  }
  if (direction == "left-right") {
    if (dx >= rect.width / 2) {
      return DragTypeOverMeEnum.Right;
    } else {
      return DragTypeOverMeEnum.Left;
    }
  }
  if (dy >= tg * dx) {
    if (dy >= -tg * dx + rect.height) {
      return DragTypeOverMeEnum.Bottom;
    } else {
      return DragTypeOverMeEnum.Left;
    }
  } else {
    if (dy >= -tg * dx + rect.height) {
      return DragTypeOverMeEnum.Right;
    } else {
      return DragTypeOverMeEnum.Top;
    }
  }
}
function isPanelDynamic(element) {
  return element instanceof QuestionPanelDynamicModel;
}
var DragDropSurveyElements = class _DragDropSurveyElements extends DragDropCore {
  constructor() {
    super(...arguments);
    this.insideContainer = null;
    this.prevIsEdge = null;
    this.dragOverIndicatorElement = null;
    this.isDraggedElementSelected = false;
    this.doBanDropHere = () => {
      this.removeDragOverMarker(this.dragOverIndicatorElement);
      this.removeDragOverMarker(this.dropTarget);
    };
    this.doDrop = () => {
      var _a;
      if (!this.dropTarget) return;
      const page = this.parentElement;
      const dragged = this.draggedElement;
      const src = this.draggedElement;
      if (dragged.isPage && dragged instanceof PageModel) {
        const survey = dragged.survey;
        const indexOfDraggedPage = survey.pages.indexOf(dragged);
        survey.pages.splice(indexOfDraggedPage, 1);
        const indexOfDropTarget = survey.pages.indexOf(this.dropTarget) + (this.dragOverLocation === DragTypeOverMeEnum.Top ? 0 : 1);
        survey.pages.splice(indexOfDropTarget, 0, dragged);
        if (indexOfDraggedPage !== indexOfDropTarget) {
          dragged["draggedFrom"] = indexOfDraggedPage < indexOfDropTarget ? indexOfDraggedPage : indexOfDraggedPage + 1;
        }
        return dragged;
      }
      const convertLocation = () => {
        switch (this.dragOverLocation) {
          case 4:
            return "top";
          case 5:
            return "right";
          case 6:
            return "bottom";
          case 7:
            return "left";
          default:
            return "bottom";
        }
      };
      const srcContainer = src.parent || src.page;
      if (!!srcContainer) {
        page.survey.startMovingQuestion();
        srcContainer.removeElement(src);
      }
      let dest = ((_a = this.dragOverIndicatorElement) === null || _a === void 0 ? void 0 : _a.isPanel) ? this.dragOverIndicatorElement : this.dropTarget;
      if (isPanelDynamic(dest) && this.insideContainer) dest = dest.template;
      if (dest.isPage && dest.elements.length > 0 && !this.insideContainer) return;
      const isTargetIsContainer = dest.isPanel || dest.isPage;
      if (isTargetIsContainer && this.insideContainer) {
        dest.insertElement(src);
      } else {
        const destParent = dest.parent || dest.page;
        if (destParent) destParent.insertElement(src, dest, convertLocation());
      }
      page.survey.stopMovingQuestion();
      return dragged;
    };
  }
  get draggedElementType() {
    if (!!this.draggedElement && this.draggedElement.isPage) {
      return "survey-page";
    }
    return "survey-element";
  }
  get maxNestedPanels() {
    return this.onGetMaxNestedPanels ? this.onGetMaxNestedPanels() : -1;
  }
  // private isRight: boolean;
  // protected prevIsRight: boolean;
  startDragToolboxItem(event, draggedElementJson, toolboxItemModel) {
    const draggedElement = this.createElementFromJson(draggedElementJson);
    draggedElement.toolboxItemTitle = toolboxItemModel.title;
    draggedElement.toolboxItemIconName = toolboxItemModel.iconName;
    this.startDrag(event, draggedElement);
  }
  startDragSurveyElement(event, draggedElement, isElementSelected) {
    this.isDraggedElementSelected = isElementSelected;
    this.startDrag(event, draggedElement);
  }
  getShortcutText(draggedElement) {
    return draggedElement.toolboxItemTitle || super.getShortcutText(draggedElement);
  }
  createDraggedElementShortcut(text, draggedElementNode, event) {
    const draggedElementShortcut = document.createElement("div");
    draggedElementShortcut.style.display = "flex";
    const textSpan = document.createElement("span");
    textSpan.className = "svc-dragged-element-shortcut__text";
    textSpan.innerText = text;
    if (this.draggedElement.toolboxItemIconName) {
      draggedElementShortcut.appendChild(this.createDraggedElementIcon());
    }
    draggedElementShortcut.appendChild(textSpan);
    draggedElementShortcut.className = this.getDraggedElementClass();
    return draggedElementShortcut;
  }
  createDraggedElementIcon() {
    const span = document.createElement("span");
    span.className = "svc-dragged-element-shortcut__icon";
    const iconName = getIconNameFromProxy(this.draggedElement.toolboxItemIconName);
    const svgString = `<svg class="sv-svg-icon" role="img"><use xlink:href="#${iconName}"></use></svg>`;
    span.innerHTML = svgString;
    return span;
  }
  getDraggedElementClass() {
    let result = "svc-dragged-element-shortcut";
    if (!!this.draggedElement.toolboxItemIconName) result += " svc-dragged-element-shortcut--has-icon";
    if (this.isDraggedElementSelected) result += " svc-dragged-element-shortcut--selected";
    return result;
  }
  createElementFromJson(json2) {
    const element = this.createNewElement(json2);
    if (element["setSurveyImpl"]) {
      element["setSurveyImpl"](this.survey);
    } else {
      element["setData"](this.survey);
    }
    element.renderWidth = "100%";
    return element;
  }
  createNewElement(json2) {
    var newElement = Serializer.createClass(json2["type"]);
    new JsonObject().toObject(json2, newElement);
    return newElement;
  }
  findDropTargetNodeByDragOverNode(dragOverNode) {
    const ghostRow = dragOverNode.closest(".svc-row--ghost");
    if (!!ghostRow) {
      const ghostDataAttrSelector = "[data-sv-drop-target-survey-element='sv-drag-drop-ghost-survey-element-name']";
      const ghostNode = dragOverNode.closest(ghostDataAttrSelector) || dragOverNode.querySelector(ghostDataAttrSelector);
      if (!!ghostNode) {
        return ghostNode;
      }
    }
    const dropTargetNode = dragOverNode.closest(this.dropTargetDataAttributeName);
    return dropTargetNode;
  }
  getDropTargetByDataAttributeValue(dataAttributeValue, dropTargetNode, event) {
    const oldDragOverIndicatorElement = this.dragOverIndicatorElement;
    if (!dataAttributeValue) {
      const nearestDropTargetElement = dropTargetNode.parentElement.closest(this.dropTargetDataAttributeName);
      dataAttributeValue = this.getDataAttributeValueByNode(nearestDropTargetElement);
    }
    if (!dataAttributeValue) {
      throw new Error("Can't find drop target survey element name");
    }
    if (dataAttributeValue === _DragDropSurveyElements.ghostSurveyElementName) {
      return this.prevDropTarget;
    }
    if (dataAttributeValue === "newGhostPage") {
      return _DragDropSurveyElements.newGhostPage;
    }
    let page = this.survey.getPageByName(dataAttributeValue);
    if (page) {
      return page;
    }
    let dropTarget;
    let dragOverElement;
    this.survey.pages.forEach((page2) => {
      const question = page2.getElementByName(dataAttributeValue);
      if (question) {
        dropTarget = question;
        dragOverElement = question;
      }
    });
    if ((dropTarget.getType() === "matrixdropdown" || dropTarget.getType() === "matrixdynamic") && dropTarget.detailPanelMode !== "none" && this.insideContainer) {
      dropTarget = dropTarget.detailPanel;
    }
    if (!dropTarget.page) {
      const nearestDropTargetPageElement = dropTargetNode.parentElement.closest("[data-sv-drop-target-page]");
      dataAttributeValue = nearestDropTargetPageElement.dataset.svDropTargetPage;
      let page2 = this.survey.getPageByName(dataAttributeValue);
      dropTarget.__page = page2;
    }
    this.dragOverIndicatorElement = dragOverElement;
    if (this.dragOverIndicatorElement != oldDragOverIndicatorElement) {
      this.removeDragOverMarker(oldDragOverIndicatorElement);
    }
    return dropTarget;
  }
  isDropTargetValid(dropTarget, dropTargetNode, dragOverLocation = DragTypeOverMeEnum.Top) {
    if (!dropTarget) return false;
    if (dropTarget === this.draggedElement) return false;
    if (this.draggedElement.getType() === "paneldynamic" && dropTarget === this.draggedElement.template) {
      return false;
    }
    if (this.maxNestedPanels >= 0 && this.draggedElement.isPanel) {
      const pnl = this.draggedElement;
      if (pnl.deepNested === void 0) {
        pnl.deepNested = this.getMaximumNestedPanelCount(pnl, 0);
      }
      let len = SurveyHelper.getElementDeepLength(dropTarget);
      if (dragOverLocation !== DragTypeOverMeEnum.InsideEmptyPanel && dropTarget.isPanel) len--;
      if (this.maxNestedPanels < len + pnl.deepNested) return false;
    }
    if (_DragDropSurveyElements.restrictDragQuestionBetweenPages && this.shouldRestricDragQuestionBetweenPages(dropTarget)) {
      return false;
    }
    return true;
  }
  getMaximumNestedPanelCount(panel, deep) {
    let max2 = deep;
    panel.elements.forEach((el) => {
      if (el.isPanel) {
        const pDeep = this.getMaximumNestedPanelCount(el, deep + 1);
        if (pDeep > max2) {
          max2 = pDeep;
        }
      }
    });
    return max2;
  }
  shouldRestricDragQuestionBetweenPages(dropTarget) {
    const oldPage = this.draggedElement["page"];
    const newPage = dropTarget.isPage ? dropTarget : dropTarget["page"];
    return oldPage && oldPage !== newPage;
  }
  findDeepestDropTargetChild(parent) {
    const selector = this.dropTargetDataAttributeName;
    let result = parent;
    while (!!parent) {
      result = parent;
      parent = parent.querySelector(selector);
    }
    return result;
  }
  isAllowDragOver(dropTarget, dragOverLocation) {
    if (!this.survey || this.survey.onDragDropAllow.isEmpty) return true;
    const allowOptions = {
      allow: true,
      parent: this.parentElement,
      source: this.draggedElement,
      toElement: dropTarget,
      draggedElement: this.draggedElement,
      fromElement: this.draggedElement.parent,
      target: dropTarget,
      insertAfter: void 0,
      insertBefore: void 0,
      allowDropNextToAnother: true
    };
    if (dragOverLocation === DragTypeOverMeEnum.Bottom || dragOverLocation === DragTypeOverMeEnum.Right) {
      allowOptions.insertAfter = dropTarget;
    }
    if (dragOverLocation === DragTypeOverMeEnum.Top || dragOverLocation === DragTypeOverMeEnum.Left) {
      allowOptions.insertBefore = dropTarget;
    }
    this.survey.onDragDropAllow.fire(this.survey, allowOptions);
    if (!allowOptions.allowDropNextToAnother) {
      if (dragOverLocation === DragTypeOverMeEnum.Left) {
        this.dragOverLocation = DragTypeOverMeEnum.Top;
      }
      if (dragOverLocation === DragTypeOverMeEnum.Right) {
        this.dragOverLocation = DragTypeOverMeEnum.Bottom;
      }
    }
    return allowOptions.allow;
  }
  dragOverCore(dropTarget, dragOverLocation) {
    const oldDragOverIndicatorElement = this.dragOverIndicatorElement;
    const oldDropTarget = this.dropTarget;
    if (this.isSameElement(dropTarget)) {
      this.allowDropHere = false;
      return;
    }
    this.dropTarget = dropTarget;
    this.dragOverLocation = dragOverLocation;
    this.parentElement = this.dropTarget.isPage ? this.dropTarget : this.dropTarget.page || this.dropTarget.__page;
    if (!this.isAllowDragOver(dropTarget, dragOverLocation)) {
      this.allowDropHere = false;
      return;
    }
    if (dragOverLocation == DragTypeOverMeEnum.InsideEmptyPanel) {
      this.dragOverIndicatorElement = this.dropTarget;
      this.dragOverIndicatorElement.dragTypeOverMe = DragTypeOverMeEnum.InsideEmptyPanel;
    } else {
      const row = this.parentElement.dragDropFindRow(this.dropTarget);
      if (!!row && row.elements.length > 1 && (this.dragOverLocation === DragTypeOverMeEnum.Top || this.dragOverLocation === DragTypeOverMeEnum.Bottom)) {
        row.dragTypeOverMe = this.dragOverLocation;
        this.dragOverIndicatorElement = row;
      } else {
        this.dropTarget.dragTypeOverMe = this.dragOverLocation;
        this.dragOverIndicatorElement = this.dropTarget;
      }
    }
    if (this.dragOverIndicatorElement != oldDragOverIndicatorElement) this.removeDragOverMarker(oldDragOverIndicatorElement);
    if (this.dropTarget != oldDropTarget) this.removeDragOverMarker(oldDropTarget);
  }
  isSameElement(target) {
    while (!!target) {
      if (target === this.draggedElement) return true;
      target = target.parent;
    }
    return false;
  }
  isDragInsideItself(dragOverNodes) {
    let result = false;
    dragOverNodes.forEach((node) => {
      if (node.classList.contains("svc-question__content--dragged")) {
        result = true;
      }
    });
    return result;
  }
  dragOver(event) {
    const dropTargetNode = this.findDropTargetNodeFromPoint(event.clientX, event.clientY);
    if (!dropTargetNode) {
      this.banDropHere();
      return;
    }
    if (document && document.elementsFromPoint && this.isDragInsideItself(document.elementsFromPoint(event.clientX, event.clientY))) {
      this.banDropHere();
      return null;
    }
    const oldInsideContainer = this.insideContainer;
    this.insideContainer = !calculateIsEdge(dropTargetNode, event.clientY) && !calculateIsSide(dropTargetNode, event.clientX);
    const dropTarget = this.getDropTargetByNode(dropTargetNode, event);
    if (!!oldInsideContainer != !!this.insideContainer) dropTarget.dragTypeOverMe = null;
    const dropTargetRect = dropTargetNode.getBoundingClientRect();
    const calcDirection = !settings2.dragDrop.allowDragToTheSameLine || !!this.draggedElement && this.draggedElement.isPage ? "top-bottom" : null;
    let dragOverLocation = calculateDragOverLocation(event.clientX, event.clientY, dropTargetRect, calcDirection);
    if (!this.draggedElement.isPage && dropTarget && ((dropTarget.isPanel || dropTarget.isPage) && dropTarget.elements.length === 0 || isPanelDynamic(dropTarget) && dropTarget.template.elements.length == 0)) {
      if (dropTarget.isPage || this.insideContainer) {
        dragOverLocation = DragTypeOverMeEnum.InsideEmptyPanel;
      }
    }
    const options = {
      survey: this.survey,
      draggedSurveyElement: this.draggedElement,
      dragOverSurveyElement: dropTarget,
      clientX: event.clientX,
      clientY: event.clientY,
      dragOverRect: dropTargetRect,
      insideContainer: this.insideContainer,
      dragOverLocation
    };
    if (this.onDragOverLocationCalculating) {
      this.onDragOverLocationCalculating(options);
      dragOverLocation = options.dragOverLocation;
      this.insideContainer = options.insideContainer;
    }
    const isDropTargetValid = this.isDropTargetValid(dropTarget, dropTargetNode, dragOverLocation);
    if (!isDropTargetValid) {
      this.banDropHere();
      return;
    }
    this.allowDropHere = true;
    this.dragOverCore(dropTarget, dragOverLocation);
  }
  onStartDrag() {
    this.draggedElement.isDragMe = true;
  }
  moveElementInPanel(panel, src, target, targetIndex) {
    var srcIndex = src.parent.elements.indexOf(src);
    if (targetIndex > srcIndex) {
      targetIndex--;
    }
    if (src === target && srcIndex === targetIndex) {
      return;
    }
    panel.removeElement(src);
    panel.addElement(target, targetIndex);
  }
  removeDragOverMarker(dropTarget) {
    if (!!dropTarget) {
      dropTarget.dragTypeOverMe = null;
    }
  }
  clear() {
    this.insideContainer = null;
    this.removeDragOverMarker(this.prevDropTarget);
    this.removeDragOverMarker(this.dropTarget);
    this.removeDragOverMarker(this.dragOverIndicatorElement);
    if (!!this.draggedElement) {
      this.draggedElement.isDragMe = false;
    }
    super.clear();
  }
  getTargetParent(dropTarget) {
    let targetParent = dropTarget.isPage || dropTarget.isPanel ? dropTarget : dropTarget.parent;
    if (dropTarget.getType() === "paneldynamic") {
      targetParent = dropTarget.templateValue;
    }
    return targetParent;
  }
  getTargetRow(dropTarget) {
    const targetParent = this.getTargetParent(dropTarget);
    let targetRow;
    targetParent.rows.forEach((row) => {
      if (row.elements.indexOf(dropTarget) !== -1) {
        targetRow = row;
      }
    });
    return targetRow;
  }
};
DragDropSurveyElements.newGhostPage = null;
DragDropSurveyElements.restrictDragQuestionBetweenPages = false;
DragDropSurveyElements.edgeHeight = 30;
DragDropSurveyElements.nestedPanelDepth = -1;
DragDropSurveyElements.ghostSurveyElementName = "sv-drag-drop-ghost-survey-element-name";
var SurveyElementActionContainer = class extends AdaptiveActionContainer {
  needToShrink(item, shrinkTypeConverterAction) {
    return item.innerItem.location == "start" && shrinkTypeConverterAction || item.innerItem.location != "start";
  }
  setModeForActions(shrinkTypeConverterAction, exclude = []) {
    this.visibleActions.forEach((item) => {
      if (exclude.indexOf(item.id) != -1) {
        item.mode = "removed";
        return;
      }
      if (this.needToShrink(item, shrinkTypeConverterAction)) {
        item.mode = item.canShrink ? "small" : "removed";
        return;
      }
      item.mode = "large";
    });
  }
  calcItemSize(item, shrinkTypeConverterAction, exclude = []) {
    if (exclude.indexOf(item.id) != -1) return 0;
    if (this.needToShrink(item, shrinkTypeConverterAction)) {
      if (!item.canShrink) return 0;
      return item.minDimension;
    }
    return item.maxDimension;
  }
  constructor() {
    super();
    this.alwaysShrink = false;
    this.dotsItem.iconSize = "auto";
    this.dotsItem.popupModel.cssClass += " svc-creator-popup";
    this.hiddenItemsListModel.cssClasses = listComponentCss;
  }
  fit(options) {
    if (options.availableSpace <= 0) return;
    this.dotsItem.visible = false;
    const items = this.visibleActions;
    if (!this.alwaysShrink) {
      if (options.availableSpace >= items.reduce((sum2, i) => sum2 += i.maxDimension, 0)) {
        items.forEach((i) => i.mode = "large");
        return;
      }
      if (options.availableSpace >= items.reduce((sum2, i) => sum2 += this.calcItemSize(i, false), 0)) {
        this.setModeForActions(false);
        return;
      }
      if (options.availableSpace >= items.reduce((sum2, i) => sum2 += this.calcItemSize(i, false, ["convertInputType"]), 0)) {
        this.setModeForActions(false, ["convertInputType"]);
        return;
      }
    }
    if (options.availableSpace >= items.reduce((sum2, i) => sum2 += this.calcItemSize(i, true), 0)) {
      this.setModeForActions(true);
      return;
    }
    this.visibleActions.forEach((item) => {
      if (item.id == "convertTo") {
        item.mode = "small";
        return;
      }
      if (item.id == "convertInputType") {
        item.mode = "removed";
        return;
      }
      item.mode = "popup";
    });
    this.dotsItem.visible = true;
    this.hiddenItemsListModel.setItems(items.filter((i) => i.mode == "popup").map((i) => i.innerItem));
  }
};
var SurveyElementAdornerBase = class _SurveyElementAdornerBase extends Base {
  get dragInsideCollapsedContainer() {
    return this.collapsed && this.creator.dragDropSurveyElements.insideContainer;
  }
  getAnimatedElement() {
    return null;
  }
  getInnerAnimatedElements() {
    return [];
  }
  getCollapsingCssClassName() {
    return "svc-question--leave";
  }
  getExpandingCssClassName() {
    return "svc-question--enter";
  }
  get hoverDelay() {
    return this.creator.pageHoverDelay;
  }
  hover(e, element) {
    const processedFlagName = "__svc_question_processed";
    if (!e[processedFlagName] && e.type === "mouseover") {
      if (!this.hoverTimeout) {
        this.hoverTimeout = setTimeout(() => {
          this.isHovered = true;
          this.hoverTimeout = void 0;
        }, this.hoverDelay);
      }
      e[processedFlagName] = true;
    } else {
      clearTimeout(this.hoverTimeout);
      this.hoverTimeout = void 0;
      this.isHovered = false;
    }
  }
  getExpandCollapseAnimationOptions() {
    const beforeRunAnimation = (el, animatingClassName) => {
      prepareElementForVerticalAnimation(el);
      const innerAnimatedElements = this.getInnerAnimatedElements();
      innerAnimatedElements.forEach((elem) => {
        prepareElementForVerticalAnimation(elem);
      });
      innerAnimatedElements.forEach((elem) => {
        elem.classList.add(animatingClassName);
      });
    };
    const afterRunAnimation = (el, animatingClassName) => {
      this.expandCollapseAnimationRunning = false;
      if (this.surveyElement) {
        cleanHtmlElementAfterAnimation(el);
        const innerAnimatedElements = this.getInnerAnimatedElements();
        innerAnimatedElements.forEach((elem) => {
          cleanHtmlElementAfterAnimation(elem);
        });
        innerAnimatedElements.forEach((elem) => {
          elem.classList.remove(animatingClassName);
        });
      }
    };
    return {
      getRerenderEvent: () => this.onElementRerendered,
      getEnterOptions: () => {
        const className = this.getExpandingCssClassName();
        return {
          cssClass: className,
          onBeforeRunAnimation: (el) => {
            beforeRunAnimation(el, className);
          },
          onAfterRunAnimation: (el) => {
            afterRunAnimation(el, className);
          }
        };
      },
      getLeaveOptions: () => {
        const className = this.getCollapsingCssClassName();
        return {
          cssClass: className,
          onBeforeRunAnimation: (el) => {
            beforeRunAnimation(el, className);
          },
          onAfterRunAnimation: (el) => {
            afterRunAnimation(el, className);
          }
        };
      },
      getAnimatedElement: () => this.getAnimatedElement(),
      isAnimationEnabled: () => this.animationAllowed
    };
  }
  set renderedCollapsed(val) {
    if (this.animationAllowed && val !== this.renderedCollapsed) this.expandCollapseAnimationRunning = true;
    this.animationCollapsed.sync(!val);
  }
  get renderedCollapsed() {
    return !!this._renderedCollapsed;
  }
  createTopActionContainer() {
    const actionContainer = new ActionContainer();
    actionContainer.sizeMode = "small";
    if (this.creator.expandCollapseButtonVisibility != "never") {
      actionContainer.setItems([this.expandCollapseAction]);
      actionContainer.cssClasses = {
        root: "svc-survey-element-top-toolbar sv-action-bar",
        item: "svc-survey-element-top-toolbar__item",
        itemIcon: "svc-survey-element-toolbar-item__icon",
        itemTitle: "svc-survey-element-toolbar-item__title",
        itemTitleWithIcon: "svc-survey-element-toolbar-item__title--with-icon"
      };
    }
    return actionContainer;
  }
  createActionContainer() {
    const actionContainer = new SurveyElementActionContainer();
    actionContainer.dotsItem.popupModel.horizontalPosition = "center";
    return actionContainer;
  }
  get canExpandOnDrag() {
    return this.surveyElement.isPanel || this.surveyElement.isPage || isPanelDynamic(this.surveyElement);
  }
  dragIn() {
    if (!this.draggedIn) {
      if (this.canExpandOnDrag && this.collapsed) {
        this.draggedIn = true;
        this.dragCollapsedTimer = setTimeout(() => {
          this.expandWithDragIn();
        }, this.creator.expandOnDragTimeOut);
      }
    }
  }
  expandWithDragIn() {
    this.collapsed = false;
    this.dragCollapsedTimer = void 0;
  }
  dragOut() {
    if (this.draggedIn) {
      clearTimeout(this.dragCollapsedTimer);
      this.draggedIn = false;
    }
  }
  allowExpandCollapseByDblClick(element) {
    return true;
  }
  dblclick(event) {
    if (this.allowExpandCollapseByDblClick(event.target)) {
      if (this.allowExpandCollapse) this.collapsed = !this.collapsed;
    }
    event.stopPropagation();
  }
  get element() {
    return this.surveyElement;
  }
  constructor(creator, surveyElement) {
    super();
    this.creator = creator;
    this.animationCollapsed = new AnimationBoolean(this.getExpandCollapseAnimationOptions(), (val) => {
      this._renderedCollapsed = !val;
    }, () => !this.renderedCollapsed);
    this.draggedIn = false;
    this.sidebarFlyoutModeChangedFunc = (_, options) => {
      if (options.name === "flyoutMode") {
        this.updateActionsProperties();
      }
    };
    this.creatorOnLocaleChanged = (_, options) => {
      if (this.surveyElement) {
        this.updateActionsContainer(this.surveyElement);
        this.updateActionsProperties();
      }
    };
    this.actionVisibilityCache = {};
    this.expandCollapseAction = this.getExpandCollapseAction();
    this.attachToUI(surveyElement);
  }
  get isActionContainerCreated() {
    return !!this.actionContainerValue;
  }
  get actionContainer() {
    if (!this.actionContainerValue) {
      this.actionContainerValue = this.createActionContainer();
      if (this.surveyElement) {
        this.updateActionsContainer(this.surveyElement);
        this.updateActionsVisibility(false);
      }
    }
    return this.actionContainerValue;
  }
  get topActionContainer() {
    if (!this.topActionContainerValue) {
      this.topActionContainerValue = this.createTopActionContainer();
      if (this.surveyElement) {
        this.updateActionsVisibility(true);
      }
    }
    return this.topActionContainerValue;
  }
  static GetAdorner(surveyElement) {
    return surveyElement.getPropertyValue(_SurveyElementAdornerBase.AdornerValueName);
  }
  static RestoreStateFor(surveyElement) {
    const adorner = _SurveyElementAdornerBase.GetAdorner(surveyElement);
    if (!!adorner) {
      adorner.restoreState();
    }
  }
  restoreState() {
    var _a;
    if (!!this.surveyElement) {
      const state = (_a = this.creator.designerStateManager) === null || _a === void 0 ? void 0 : _a.getElementState(this.surveyElement);
      this.collapsed = state.collapsed;
    }
    if (!this.surveyElement || this.surveyElement.isInteractiveDesignElement) {
      this.needToRenderContent = !this.collapsed;
    }
  }
  detachElement(surveyElement) {
    if (surveyElement) {
      surveyElement.setPropertyValue(_SurveyElementAdornerBase.AdornerValueName, null);
      surveyElement.unRegisterFunctionOnPropertyValueChanged("isSelectedInDesigner", "questionSelected");
      this.cleanActionsContainer();
    }
  }
  attachElement(surveyElement) {
    var _a, _b;
    if (surveyElement) {
      (_b = (_a = this.creator) === null || _a === void 0 ? void 0 : _a.designerStateManager) === null || _b === void 0 ? void 0 : _b.initForElement(surveyElement);
      surveyElement.registerFunctionOnPropertyValueChanged("isSelectedInDesigner", (newValue) => {
        this.onElementSelectedChanged(newValue);
      }, "questionSelected");
      this.restoreState();
      this.updateActionsContainer(surveyElement);
      this.updateActionsProperties();
      surveyElement.setPropertyValue(_SurveyElementAdornerBase.AdornerValueName, this);
    }
  }
  setSurveyElement(surveyElement) {
    this.detachOnlyMyElement();
    this.surveyElement = surveyElement;
    this.attachElement(this.surveyElement);
  }
  checkActionProperties() {
    if (this.creator.isElementSelected(this.surveyElement)) {
      this.updateActionsProperties();
    }
  }
  attachToUI(surveyElement, rootElement) {
    if (!!rootElement) {
      this.rootElement = rootElement;
    }
    if (this.surveyElement != surveyElement) {
      this.setSurveyElement(surveyElement);
      this.creator.onLocaleChanded.add(this.creatorOnLocaleChanged);
      this.creator.sidebar.onPropertyChanged.add(this.sidebarFlyoutModeChangedFunc);
      this.creator.expandCollapseManager.add(this);
    }
  }
  detachOnlyMyElement() {
    if (this.surveyElement && this.surveyElement.getPropertyValue(_SurveyElementAdornerBase.AdornerValueName) === this && !this.surveyElement.isDisposed) {
      this.detachElement(this.surveyElement);
    }
  }
  detachFromUI() {
    this.rootElement = void 0;
    this.detachOnlyMyElement();
    this.surveyElement = void 0;
    this.creator.onLocaleChanded.remove(this.creatorOnLocaleChanged);
    this.creator.sidebar.onPropertyChanged.remove(this.sidebarFlyoutModeChangedFunc);
    this.creator.expandCollapseManager.remove(this);
  }
  dispose() {
    this.detachFromUI();
    this.disposeActions(this.actionContainerValue);
    this.disposeActions(this.topActionContainerValue);
    super.dispose();
    this.sidebarFlyoutModeChangedFunc = void 0;
    this.animationCollapsed = void 0;
  }
  disposeActions(container) {
    if (!!container && !container.isDisposed) {
      container.dispose();
    }
  }
  onElementSelectedChanged(isSelected) {
    if (!isSelected) return;
    this.updateActionsProperties();
  }
  getExpandCollapseAction() {
    const collapseIcon = "icon-collapsepanel-16x16";
    const expandIcon = "icon-expandpanel-16x16";
    return {
      id: "collapse",
      css: "sv-action-bar-item--collapse",
      locTooltipName: new ComputedUpdater(() => this.collapsed ? "ed.expandTooltip" : "ed.collapseTooltip"),
      iconName: new ComputedUpdater(() => this.collapsed ? expandIcon : collapseIcon),
      iconSize: "auto",
      action: () => {
        this.collapsed = !this.collapsed;
      }
    };
  }
  cleanActionsContainer() {
    const container = this.actionContainerValue;
    if (!container) return;
    const actions = container.actions;
    container.setItems([]);
    actions.forEach((action) => action.dispose && action.dispose());
  }
  updateActionsContainer(surveyElement) {
    if (!this.actionContainerValue) return;
    const actions = [];
    this.buildActions(actions);
    this.creator.onElementMenuItemsChanged(surveyElement, actions);
    this.actionContainerValue.setItems(actions);
  }
  updateActionsProperties() {
    if (this.isDisposed) return;
    this.updateActionsPropertiesCore();
  }
  updateActionsPropertiesCore() {
    this.updateElementAllowOptions(this.creator.getElementAllowOperations(this.surveyElement), this.isOperationsAllow());
  }
  getAllowDragging(options) {
    return options.allowDragging;
  }
  getAllowExpandCollapse(options) {
    return this.creator.expandCollapseButtonVisibility != "never" && (options.allowExpandCollapse == void 0 || !!options.allowExpandCollapse);
  }
  updateElementAllowOptions(options, operationsAllow) {
    this.allowDragging = operationsAllow && this.getAllowDragging(options);
    this.allowExpandCollapse = this.getAllowExpandCollapse(options);
    this.allowEditOption = options.allowEdit == void 0 || !!options.allowEdit;
    this.updateActionVisibility("delete", operationsAllow && options.allowDelete);
    this.updateActionVisibility("duplicate", operationsAllow && options.allowCopy);
    this.updateActionVisibility("collapse", this.allowExpandCollapse);
    if (options.allowShowSettings === void 0) {
      const settingsVisibility = options.allowEdit !== void 0 ? operationsAllow && options.allowEdit : this.creator.sidebar.flyoutMode;
      this.updateActionVisibility("settings", settingsVisibility);
    } else {
      this.updateActionVisibility("settings", options.allowShowSettings);
    }
    this.setShowAddQuestionButton(options.allowEdit !== false);
  }
  isOperationsAllow() {
    return !this.creator.readOnly;
  }
  updateActionVisibility(id, isVisible) {
    var _a, _b;
    var action = ((_a = this.actionContainerValue) === null || _a === void 0 ? void 0 : _a.getActionById(id)) || ((_b = this.topActionContainerValue) === null || _b === void 0 ? void 0 : _b.getActionById(id));
    if (!action) {
      this.actionVisibilityCache[id] = isVisible;
    } else {
      if (action.visible !== isVisible) {
        action.visible = isVisible;
      }
    }
  }
  updateActionsVisibility(isTop) {
    for (var key in this.actionVisibilityCache) {
      this.updateActionVisibility(key, this.actionVisibilityCache[key]);
    }
  }
  getActionById(id) {
    return this.actionContainer.getActionById(id) || this.topActionContainer.getActionById(id);
  }
  buildActions(items) {
    items.push(new Action({
      id: "duplicate",
      iconName: "icon-duplicate_16x16",
      css: "svc-action-bar-item--right",
      title: this.creator.getLocString("survey.duplicate"),
      visibleIndex: 10,
      iconSize: "auto",
      action: () => this.duplicate(),
      onFocus: (isMouse, event) => this.disableActionFocusing(isMouse, event)
    }));
    items.push(new Action({
      id: "settings",
      iconName: "icon-settings_16x16",
      css: "svc-action-bar-item--right",
      title: this.creator.getLocString("ed.settings"),
      locTooltipName: "ed.settingsTooltip",
      visibleIndex: 20,
      iconSize: "auto",
      action: () => {
        this.creator.setShowSidebar(true, true);
        if (!this.creator.isMobileView) {
          this.creator.sidebar.executeOnExpand(() => {
            this.creator.propertyGrid.getAllQuestions()[0].focus();
          });
        }
      }
    }));
    items.push(new Action({
      id: "delete",
      iconName: "icon-delete_16x16",
      css: "svc-action-bar-item--right",
      //needSeparator: items.length > 0,
      title: this.creator.getLocString("pe.delete"),
      visibleIndex: 30,
      iconSize: "auto",
      action: () => {
        this.delete();
      },
      onFocus: (isMouse, event) => this.disableActionFocusing(isMouse, event)
    }));
  }
  disableActionFocusing(isMouse, event) {
    this.isDisableSelecting = isMouse;
  }
  canSelectElement() {
    const res = !this.isDisableSelecting;
    this.isDisableSelecting = false;
    return res;
  }
  get allowEdit() {
    return !!this.creator && !this.creator.readOnly && this.allowEditOption;
  }
  get showAddQuestionButton() {
    return this.getPropertyValue("showAddQuestionButton");
  }
  setShowAddQuestionButton(val) {
    this.setPropertyValue("showAddQuestionButton", val && this.allowEdit && !!this.creator && this.creator.showAddQuestionButton);
  }
  duplicate() {
  }
  delete() {
    this.creator.deleteElement(this.surveyElement);
  }
  getCss() {
    return new CssClassBuilder().append("svc-hovered svc-hovered-ready", this.isHovered).toString();
  }
};
SurveyElementAdornerBase.AdornerValueName = "__sjs_creator_adorner";
__decorate2([property({
  defaultValue: true
})], SurveyElementAdornerBase.prototype, "allowDragging", void 0);
__decorate2([property({
  defaultValue: false
})], SurveyElementAdornerBase.prototype, "expandCollapseAnimationRunning", void 0);
__decorate2([property({
  defaultValue: true
})], SurveyElementAdornerBase.prototype, "needToRenderContent", void 0);
__decorate2([property({
  defaultValue: true
})], SurveyElementAdornerBase.prototype, "allowExpandCollapse", void 0);
__decorate2([property({
  onSet: (val, target) => {
    target.renderedCollapsed = val;
    if (!val) target.needToRenderContent = true;
    if (target.creator.designerStateManager && !target.creator.designerStateManager.isSuspended && target.surveyElement) {
      target.creator.designerStateManager.getElementState(target.surveyElement).collapsed = val;
    }
    setTimeout(() => {
      target.creator.survey.pages.forEach((p) => p.ensureRowsVisibility());
      target.creator.survey.getAllPanels().forEach((p) => p.ensureRowsVisibility());
    }, 50);
  }
})], SurveyElementAdornerBase.prototype, "collapsed", void 0);
__decorate2([property()], SurveyElementAdornerBase.prototype, "_renderedCollapsed", void 0);
__decorate2([property()], SurveyElementAdornerBase.prototype, "isAnimationRunningCollapsed", void 0);
__decorate2([property({
  defaultValue: false
})], SurveyElementAdornerBase.prototype, "isHovered", void 0);
var isLocaleEnableIfExecuting;
function localeEnableIf(params) {
  if (isLocaleEnableIfExecuting || !this.question || !this.row) return false;
  const matrix = this.question.parentQuestion;
  if (!matrix) return false;
  isLocaleEnableIfExecuting = true;
  const index = matrix.visibleRows.indexOf(this.row);
  isLocaleEnableIfExecuting = false;
  if (index <= 0) return false;
  const val = matrix.value;
  if (!Array.isArray(val)) return true;
  const rowVal = val[index];
  if (!rowVal || rowVal.isSelected) return true;
  let selectedCounter = 0;
  for (let i = 1; i < val.length; i++) {
    if (val[i].isSelected) selectedCounter++;
  }
  return selectedCounter < settings2.translation.maximumSelectedLocales;
}
FunctionFactory.Instance.register("localeEnableIf", localeEnableIf);
var TranslationItemBase = class extends Base {
  constructor(name, translation) {
    super();
    this.name = name;
    this.translation = translation;
  }
  get isGroup() {
    return false;
  }
  fillLocales(locales) {
  }
  mergeLocaleWithDefault(loc) {
  }
  makeObservable() {
    this.fireOnObjCreating();
  }
  deleteLocaleStrings(locale) {
  }
  applyEditLocale(locale) {
  }
  fireOnObjCreating(obj = null) {
    if (this.translation) {
      if (!obj) obj = this;
      this.translation.fireOnObjCreating(obj);
    }
  }
};
var TranslationItemString = class extends Base {
  constructor(locString, locale) {
    super();
    this.locString = locString;
    this.locale = locale;
    this.text = this.locString.getLocaleText(this.locale);
  }
  onPropertyValueChanged(name, oldValue, newValue) {
    super.onPropertyValueChanged(name, oldValue, newValue);
    if (!this.isReadOnly && name === "text") {
      this.locString.setLocaleText(this.locale, newValue);
    }
  }
  getType() {
    return "translationitemstring";
  }
};
__decorate2([property()], TranslationItemString.prototype, "text", void 0);
__decorate2([property()], TranslationItemString.prototype, "placeholder", void 0);
var TranslationItem = class extends TranslationItemBase {
  constructor(name, locString, defaultValue = "", translation, context, property2 = null) {
    super(name, translation);
    this.name = name;
    this.locString = locString;
    this.defaultValue = defaultValue;
    this.context = context;
    this.property = property2;
    if (!!this.translation) {
      this.readOnly = this.translation.readOnly;
    }
    this.hashValues = {};
    var self2 = this;
    this.afterRender = function(el, data) {
      if (!!self2.translation) {
        self2.translation.translateItemAfterRender(self2, el, data.locale);
      }
    };
    this.fireOnObjCreating();
  }
  get maxLength() {
    return !!this.property ? this.property.maxLength : -1;
  }
  makeObservable() {
    super.makeObservable();
    for (var loc in this.hashValues) {
      this.fireOnObjCreating(this.hashValues[loc]);
    }
  }
  getType() {
    return "translationitem";
  }
  get text() {
    return !!this.customText ? this.customText : this.localizableName;
  }
  get localizableName() {
    const type = this.context && this.context.getType && this.context.getType();
    return editorLocalization.getPropertyNameInEditor(type, this.name);
  }
  getLocText(loc) {
    return this.locString.getLocaleText(loc);
  }
  setLocText(loc, newValue) {
    this.locString.setLocaleText(loc, newValue);
    !!this.translation.tranlationChangedCallback && this.translation.tranlationChangedCallback(loc, this.name, newValue, this.context);
  }
  applyEditLocale(locale) {
    const itemStr = this.values(locale);
    if (!!itemStr && !!itemStr.text) {
      this.setLocText(locale, itemStr.text);
    }
  }
  values(loc) {
    var _a;
    if (!this.hashValues[loc]) {
      var val = new TranslationItemString(this.locString, loc);
      val.isReadOnly = !!((_a = this.translation) === null || _a === void 0 ? void 0 : _a.getEditLocale());
      if (!loc) {
        val.placeholder = this.defaultValue;
      }
      this.hashValues[loc] = val;
      this.fireOnObjCreating(val);
    }
    return this.hashValues[loc];
  }
  fillLocales(locales) {
    var keys = this.getKeys();
    for (var i = 0; i < keys.length; i++) {
      let key = keys[i];
      if (!!key && locales.indexOf(key) < 0 && key !== LocalizableString.defaultLocale) {
        locales.push(key);
      }
    }
  }
  toJSON() {
    var json2 = this.locString.getJson();
    const keys = Object.keys(this.hashValues);
    if (keys.length > 0) {
      keys.forEach((loc) => {
        const text = this.hashValues[loc].text;
        if (!!text) {
          if (!json2) json2 = {};
          if (typeof json2 === "string") {
            json2 = {
              default: json2
            };
          }
          json2[loc] = text;
        }
      });
    }
    json2 = this.correctJSON(json2);
    if (!json2 || typeof json2 === "string") return {
      default: json2
    };
    return json2;
  }
  correctJSON(json2) {
    if (!json2 || typeof json2 === "string") return json2;
    if (Array.isArray(json2)) return json2.join("\n");
    for (let key in json2) {
      if (Array.isArray(json2[key])) {
        json2[key] = json2[key].join("\n");
      }
    }
    return json2;
  }
  getKeys() {
    return this.locString.getLocales();
  }
  mergeLocaleWithDefault(loc) {
    var locText = this.locString.getLocaleText(loc);
    if (!locText) return;
    this.locString.setLocaleText("", locText);
    this.locString.setLocaleText(loc, null);
  }
  deleteLocaleStrings(locale) {
    this.setLocText(locale, void 0);
  }
  getDefaultLocaleText(ignorePlaceHolder = false) {
    let res = this.locString.getLocaleText("");
    if (!res) {
      res = this.getPlaceholder("", ignorePlaceHolder);
    }
    return res;
  }
  getPlaceholder(locale, ignorePlaceHolder = false) {
    const textLocale = !!locale && locale !== "default" ? locale : surveyLocalization.defaultLocale;
    const placeholderText = !ignorePlaceHolder ? editorLocalization.getString("ed.translationPlaceHolder", textLocale) : "";
    if (this.context instanceof SurveyModel) {
      return surveyLocalization.getString(this.name, locale) || placeholderText;
    }
    if (!(this.context instanceof PageModel) && this.name === "title") {
      return this.getPlaceholderText(locale) || this.context.name;
    }
    if (this.context.ownerPropertyName === "choices" && this.context.getType() === "itemvalue") {
      return this.getPlaceholderText(locale) || this.getItemValuePlaceholderText() || placeholderText;
    }
    return placeholderText;
  }
  getTextForExport(loc) {
    const res = this.locString.getLocaleText(loc);
    if (!!res) return res;
    const index = loc.indexOf("-");
    if (index < 0) return "";
    return this.getPlaceholderText(loc);
  }
  getPlaceholderText(loc) {
    if (!loc || loc === "default") return "";
    const root = this.getRootDialect(loc);
    return this.locString.getLocaleText(root);
  }
  getRootDialect(loc) {
    const index = loc.indexOf("-");
    if (index < 0) return "";
    loc = loc.substring(0, index);
    return loc === surveyLocalization.defaultLocale ? "" : loc;
  }
  getItemValuePlaceholderText() {
    const val = this.context.value;
    return !Helpers.isValueEmpty(val) ? val.toString() : "";
  }
};
__decorate2([property({
  defaultValue: false
})], TranslationItem.prototype, "readOnly", void 0);
var TranslationGroup = class _TranslationGroup extends TranslationItemBase {
  constructor(name, obj, translation = null, text = "", hasIndent = false) {
    super(name, translation);
    this.name = name;
    this.obj = obj;
    this.text = text;
    this.hasIndent = hasIndent;
    this.isRootValue = false;
    this.removeLocale = (loc) => {
      this.translation && this.translation.removeLocale(loc);
    };
    if (!this.text) {
      this.text = name;
    }
    this.reset();
    this.fireOnObjCreating();
  }
  getType() {
    return "translationgroup";
  }
  get items() {
    return this.itemValues;
  }
  get locItems() {
    return this.itemValues.filter((item) => item instanceof TranslationItem);
  }
  get allLocItems() {
    const res = new Array();
    this.fillLocItems(res);
    return res;
  }
  fillLocItems(items) {
    this.itemValues.forEach((item) => {
      if (item.isGroup) {
        item.fillLocItems(items);
      } else {
        items.push(item);
      }
    });
  }
  get isRoot() {
    return this.isRootValue;
  }
  setAsRoot() {
    this.isRootValue = true;
  }
  setParent(parent) {
    this.parentValue = parent;
  }
  get parent() {
    return this.parentValue;
  }
  get fullName() {
    const propsName = this.obj.name === this.name || this.isRoot ? "_props" : "";
    const name = this.name + propsName;
    if (this.isRoot || !this.parent) return name;
    const parentName = this.parent.getNameForChild();
    return (!!parentName ? parentName + "_" : "") + name;
  }
  getNameForChild() {
    if (this.isRoot) return "";
    return this.isFinalNameObj ? this.name : this.fullName;
  }
  get isFinalNameObj() {
    return this.obj.isQuestion || this.obj.isPage || this.obj.isPanel;
  }
  getItemByName(name) {
    for (var i = 0; i < this.itemValues.length; i++) {
      if (this.itemValues[i].name == name) return this.itemValues[i];
    }
    return null;
  }
  get groups() {
    return this.itemValues.filter((item) => item instanceof _TranslationGroup);
  }
  get isGroup() {
    return true;
  }
  get locales() {
    return !!this.translation ? this.translation.locales : null;
  }
  get removeLocaleText() {
    return editorLocalization.getString("pe.remove");
  }
  get localeCount() {
    return !!Array.isArray(this.locales) ? this.locales.length : 0;
  }
  get locWidth() {
    var count2 = this.localeCount;
    if (count2 < 2) return "100%";
    return Math.floor(100 / count2).toString() + "%";
  }
  getLocaleName(loc) {
    return this.translation ? this.translation.getLocaleName(loc) : editorLocalization.getLocaleName(loc);
  }
  reset() {
    this.itemValues = [];
    this.fillItems();
  }
  fillLocales(locales) {
    for (var i = 0; i < this.items.length; i++) {
      this.items[i].fillLocales(locales);
    }
  }
  makeObservable() {
    super.makeObservable();
    for (var i = 0; i < this.items.length; i++) {
      this.items[i].makeObservable();
    }
  }
  get showAllStrings() {
    return !!this.translation ? this.translation.showAllStrings : true;
  }
  get hasItems() {
    if (this.locItems.length > 0) return true;
    var groups = this.groups;
    for (var i = 0; i < groups.length; i++) {
      if (groups[i].hasItems) return true;
    }
    return false;
  }
  mergeLocaleWithDefault(loc) {
    this.itemValues.forEach((item) => item.mergeLocaleWithDefault(loc));
  }
  deleteLocaleStrings(locale) {
    this.items.forEach((item) => item.deleteLocaleStrings(locale));
  }
  applyEditLocale(locale) {
    this.items.forEach((item) => item.applyEditLocale(locale));
  }
  fillItems() {
    if (this.isItemValueArray(this.obj)) {
      this.createItemValuesLocale();
      return;
    }
    if (!this.obj || !this.obj.getType) return;
    var properties = this.getLocalizedProperties(this.obj);
    for (var i = 0; i < properties.length; i++) {
      var property2 = properties[i];
      var item = this.createTranslationItem(this.obj, properties[i]);
      if (!!item) {
        this.itemValues.push(item);
      }
    }
    properties = this.getArrayProperties(this.obj);
    for (var i = 0; i < properties.length; i++) {
      var property2 = properties[i];
      var value = this.obj[property2.name];
      if (this.isItemValueArray(value)) {
        if (this.canShowProperty(property2, Array.isArray(value) && value.length > 0)) {
          this.addNewGroup(new _TranslationGroup(property2.name, value, this.translation, editorLocalization.getPropertyName(property2.name), true));
        }
      } else {
        this.createGroups(value, property2);
      }
    }
    this.createMatrixCellsGroup();
    this.sortItems();
  }
  createMatrixCellsGroup() {
    Serializer.getPropertiesByObj(this.obj).forEach((prop) => {
      if (prop.type === "cells" && this.canShowProperty(prop, true)) {
        this.createMatrixCellsGroupCore(prop);
      }
    });
  }
  createMatrixCellsGroupCore(prop) {
    const cells = this.obj[prop.name];
    if (cells.isEmpty) return;
    const matrix = this.obj;
    const root = new _TranslationGroup(prop.name, cells, this.translation, editorLocalization.getPropertyName(prop.name));
    const defaultName = settings.matrix.defaultRowName;
    const rows = [{
      value: defaultName,
      text: editorLocalization.getString("qt.default")
    }];
    matrix.rows.forEach((row) => rows.push({
      value: row.value,
      text: row.text
    }));
    rows.forEach((row) => {
      matrix.columns.forEach((col) => {
        const locStr = cells.getCellDisplayLocText(row.value, col);
        if (!!locStr) {
          const name = editorLocalization.getPropertyName(row.text, "") + ", " + editorLocalization.getPropertyName(col.title);
          const item = new TranslationItem(name, locStr, "", this.translation, locStr);
          root.items.push(item);
        }
      });
    });
    this.addNewGroup(root);
  }
  sortItems() {
    if (!settings2.translation.sortByName) return;
    this.itemValues.sort(function(a, b) {
      if (!a.name) return -1;
      if (!b.name) return 1;
      return a.name.localeCompare(b.name);
    });
  }
  getLocalizedProperties(obj) {
    const res = [];
    const properties = Serializer.getPropertiesByObj(obj);
    for (let i = 0; i < properties.length; i++) {
      const property2 = properties[i];
      if (property2.readOnly || !property2.visible || !property2.isSerializable || !property2.isLocalizable) continue;
      const isShowing = ["url", "file"].indexOf(property2.type) < 0;
      if (this.canShowProperty(property2, !!obj[property2.name], isShowing)) {
        res.push(property2);
      }
    }
    return res;
  }
  getArrayProperties(obj) {
    var res = [];
    var properties = Serializer.getPropertiesByObj(obj);
    for (var i = 0; i < properties.length; i++) {
      var property2 = properties[i];
      if (property2.isSerializable === false) continue;
      var value = obj[property2.name];
      if (!!value && Array.isArray(value) && value.length > 0) {
        res.push(property2);
      }
    }
    return res;
  }
  canShowProperty(property2, isEmpty, isShowing = true) {
    const obj = Array.isArray(this.obj) ? this.obj.length > 0 ? this.obj[0] : void 0 : this.obj;
    if (!obj) return false;
    if (!!this.translation) return this.translation.canShowProperty(obj, property2, isEmpty, isShowing);
    return isShowing;
  }
  createTranslationItem(obj, property2) {
    var _a;
    const defaultValue = this.getDefaultValue(obj, property2);
    const locStr = obj[property2.serializationProperty];
    if (!locStr) return null;
    if (!this.showAllStrings && !defaultValue && locStr.isEmpty) return null;
    const editLocale = (_a = this.translation) === null || _a === void 0 ? void 0 : _a.getEditLocale();
    if (!!editLocale && !!locStr.getLocaleText(editLocale)) return null;
    if (!this.canShowProperty(property2, locStr.isEmpty)) return null;
    return new TranslationItem(property2.name, locStr, defaultValue, this.translation, obj, property2);
  }
  getDefaultValue(obj, property2) {
    if (property2.name == "title" && property2.isLocalizable && !!property2.serializationProperty) {
      var locStr = obj[property2.serializationProperty];
      if (!!locStr && !obj.isPage && !obj.isPanel && (!!locStr.onGetTextCallback || locStr["onRenderedHtmlCallback"])) return obj["name"];
    }
    return "";
  }
  isItemValueArray(val) {
    return !!val && Array.isArray(val) && val.length > 0 && !!val[0] && !!val[0]["getType"] && !!val[0]["setData"] && !!val[0]["setLocText"];
  }
  createGroups(value, property2) {
    for (let i = 0; i < value.length; i++) {
      const obj = value[i];
      if (!!obj && obj.getType) {
        let name = obj["name"];
        let text = name;
        if (!name) {
          const index = "[" + i.toString() + "]";
          name = property2.name + index;
          text = editorLocalization.getPropertyName(property2.name) + index;
        }
        this.addNewGroup(new _TranslationGroup(name, obj, this.translation, text));
      }
    }
  }
  addNewGroup(group) {
    group.setParent(this);
    if (group.hasItems) {
      this.itemValues.push(group);
    }
  }
  createItemValuesLocale() {
    var _a;
    const editMode = (_a = this.translation) === null || _a === void 0 ? void 0 : _a.getEditLocale();
    for (var i = 0; i < this.obj.length; i++) {
      var val = this.obj[i];
      var canAdd = this.showAllStrings || !val.locText.isEmpty || isNaN(val.value);
      if (!!editMode && val.locText.getLocaleText(editMode)) {
        canAdd = false;
      }
      if (!canAdd) continue;
      var item = new TranslationItem(val.value, val.locText, val.value, this.translation, val);
      this.itemValues.push(item);
      this.addCustomPropertiesForItemValue(this.obj[i], item);
    }
  }
  addCustomPropertiesForItemValue(itemValue, textItem) {
    var locProperties = this.getLocalizedProperties(itemValue);
    for (var i = 0; i < locProperties.length; i++) {
      if (locProperties[i].name == "text") continue;
      var item = this.createTranslationItem(itemValue, locProperties[i]);
      if (!!item) {
        item.customText = textItem.text + " (" + item.localizableName + ")";
        item.name = itemValue.value + "." + item.name;
        this.itemValues.push(item);
      }
    }
  }
};
__decorate2([property({
  defaultValue: true
})], TranslationGroup.prototype, "showHeader", void 0);
var Translation = class _Translation extends Base {
  constructor(survey, options = null, hasUI = true) {
    super();
    this.options = options;
    this.hasUI = hasUI;
    this.chooseLanguageActions = [];
    if (!this.options) this.options = new EmptySurveyCreatorOptions();
    var self2 = this;
    this.exportToCSVFileUI = function() {
      self2.exportToSCVFile(settings2.translation.exportFileName);
    };
    this.importFromCSVFileUI = function(el) {
      if (el.files.length < 1) return;
      self2.importFromCSVFile(el.files[0]);
      el.value = "";
    };
    this.settingsSurveyValue = this.createSettingsSurvey();
    this.surveyValue = survey;
    this.setupToolbarItems();
    this.updateChooseLanguageActions();
  }
  getProcessedTranslationItemText(locale, locString, newText, context) {
    return this.options.getProcessedTranslationItemText(locale, locString, newText, context);
  }
  getType() {
    return "translation";
  }
  getEditLocale() {
    return this.editLocale;
  }
  setEditMode(locale) {
    this.editLocale = locale;
    this.addLocale(locale);
  }
  get isEditMode() {
    return !!this.editLocale;
  }
  applyEditLocale() {
    if (!this.isEditMode || !this.root) return;
    this.root.applyEditLocale(this.editLocale);
  }
  makeObservable(onBaseObjCreating) {
    this.onBaseObjCreatingCallback = onBaseObjCreating;
    this.fireOnObjCreating(this);
    this.root.makeObservable();
  }
  fireOnObjCreating(obj) {
    if (!this.onBaseObjCreatingCallback) return;
    this.onBaseObjCreatingCallback(obj);
  }
  get settingsSurvey() {
    return this.settingsSurveyValue;
  }
  get localesQuestion() {
    return this.settingsSurvey.getQuestionByName("locales");
  }
  deleteLocaleStrings(locale) {
    if (!this.root) {
      this.reset();
    }
    if (!this.root) return;
    this.options.startUndoRedoTransaction("Delete strings for locale: " + locale);
    this.root.deleteLocaleStrings(locale);
    this.removeLocale(locale);
    this.reset();
    this.options.stopUndoRedoTransaction();
  }
  createSettingsSurvey() {
    const json2 = this.getSettingsSurveyJSON();
    setSurveyJSONForPropertyGrid(json2);
    const res = this.options.createSurvey(json2, "translation_settings", this, (survey) => {
      survey.css = propertyGridCss;
      survey.css.root += " st-properties";
      survey.rootCss += " st-properties";
    });
    res.onValueChanged.add((sender, options) => {
      if (options.name == "locales") {
        this.updateLocales();
      }
    });
    res.getQuestionByName("locales").lockedRowCount = 1;
    res.onMatrixRowRemoving.add((sender, options) => {
      this.removingLocale = options.question.value[options.rowIndex].name;
    });
    res.onMatrixRowRemoved.add((sender, options) => {
      if (!!this.removingLocale) {
        this.deleteLocaleStrings(this.removingLocale);
      }
    });
    res.onGetQuestionTitleActions.add((sender, options) => {
      options.titleActions = [this.addLanguageAction];
    });
    res.onGetMatrixRowActions.add((sender, options) => {
      updateMatrixRemoveAction(options.question, options.actions, options.row);
      if (this.options.getHasMachineTranslation() && findAction(options.actions, "remove-row") && Array.isArray(options.question.value)) {
        const q = options.question;
        const rowIndex = q.visibleRows.indexOf(options.row);
        if (rowIndex >= 0 && rowIndex < q.value.length) {
          const locale = q.value[rowIndex].name;
          options.actions.splice(0, 0, new Action({
            iconName: "icon-language",
            iconSize: "auto",
            locTooltipName: "ed.translateUsigAI",
            visibleIndex: 5,
            location: "end",
            action: () => this.showTranslationEditor(locale)
          }));
        }
      }
      updateMatixActionsClasses(options.actions);
    });
    return res;
  }
  calcIsChooseLanguageEnabled() {
    this.isChooseLanguageEnabled = this.chooseLanguageActions.filter((item) => item.visible).length > 0;
  }
  refreshAddLanguageActionListModel() {
    const listModel = this.addLanguageAction.data;
    if (listModel) {
      listModel.refresh();
    }
  }
  updateLocales() {
    var res = [""];
    var val = this.getSelectedLocales();
    if (!Array.isArray(val)) val = [];
    this.options.translationLocalesOrder = val;
    val.forEach((lc) => res.push(lc));
    this.locales = res;
    this.canMergeLocaleWithDefault = this.hasLocale(this.defaultLocale);
    this.localesQuestion.allowRowReorder = res.length > 2;
  }
  getSettingsSurveyJSON() {
    return {
      elements: [{
        type: "matrixdynamic",
        name: "locales",
        title: editorLocalization.getString("ed.translationLanguages"),
        confirmDelete: true,
        titleLocation: "top",
        confirmDeleteText: editorLocalization.getString("ed.translationDeleteLanguage"),
        columns: [{
          name: "isSelected",
          cellType: "boolean",
          renderAs: "checkbox",
          enableIf: "localeEnableIf()"
        }, {
          name: "displayName",
          cellType: "expression",
          expression: "{row.displayName}"
        }],
        showHeader: false,
        allowAddRows: false,
        rowCount: 0
      }]
    };
  }
  getSurveyLocales() {
    const usedLocales = new Array();
    var sLocales = surveyLocalization.supportedLocales;
    var locales = Array.isArray(sLocales) && sLocales.length > 0 ? sLocales : surveyLocalization.getLocales();
    var addedLocales = {};
    for (var i = 0; i < locales.length; i++) {
      this.addLocaleIntoChoices(locales[i], usedLocales, addedLocales);
    }
    locales = this.getVisibleLocales();
    for (var i = 0; i < locales.length; i++) {
      this.addLocaleIntoChoices(locales[i], usedLocales, addedLocales);
    }
    return [usedLocales, locales];
  }
  importFromCSVFileDOM() {
    if (!document) return;
    if (!this.inputFileElement) {
      this.inputFileElement = document.createElement("input");
      this.inputFileElement.type = "file";
      this.inputFileElement.style.display = "none";
      this.inputFileElement.onchange = () => {
        this.importFromCSVFileUI(this.inputFileElement);
      };
    }
    this.inputFileElement.click();
  }
  updateSettingsSurveyLocales() {
    let [choices, locales] = this.getSurveyLocales();
    const selectedLocales = [];
    if (!locales) locales = [];
    for (var i = 0; i < locales.length; i++) {
      if (!!this.localeInitialVisibleCallback && !this.localeInitialVisibleCallback(locales[i])) continue;
      selectedLocales.push(locales[i]);
    }
    const maxLocales = settings2.translation.maximumSelectedLocales;
    if (maxLocales > 0 && selectedLocales.length > maxLocales) {
      selectedLocales.splice(maxLocales);
    }
    this.setSelectedLocales(selectedLocales);
  }
  resetStringsSurvey() {
    if (!this.hasUI) return;
    this.stringsSurvey = this.createStringsSurvey();
    this.stringsHeaderSurvey = this.createStringsHeaderSurvey();
    this.updateReadOnly();
  }
  getSurveyStringsArea() {
    return void 0;
  }
  getSurveyStringsHeaderArea() {
    return void 0;
  }
  onSurveyStringsCreated(survey) {
  }
  onSurveyStringsHeaderCreated(survey) {
  }
  createStringsSurvey() {
    var json2 = {
      autoGrowComment: true,
      allowResizeComment: false
    };
    setSurveyJSONForPropertyGrid(json2, false);
    const survey = this.options.createSurvey(json2, "translation_strings", this, (survey2) => {
      survey2.lazyRenderEnabled = true;
      survey2.skeletonComponentName = "sd-translation-line-skeleton";
      survey2.startLoadingFromJson();
      survey2.css = translationCss;
      survey2.addNewPage("page");
      this.addTranslationGroupIntoStringsSurvey(survey2.pages[0], this.root);
      survey2.data = this.getStringsSurveyData(survey2);
      survey2.endLoadingFromJson();
      this.onSurveyStringsCreated(survey2);
    }, this.getSurveyStringsArea());
    const getTransationItem = (question, rowName) => {
      var itemValue = ItemValue.getItemByValue(question.rows, rowName);
      return !!itemValue ? itemValue["translationData"] : null;
    };
    survey.onMatrixCellCreated.add((sender, options) => {
      if (options.cell.question instanceof QuestionCommentModel) {
        const cellQuestion = options.cell.question;
        const item = getTransationItem(options.question, options.row.name);
        this.setPlaceHolder(cellQuestion, item, options.columnName);
        let isMultiLine = false;
        if (!!item) {
          cellQuestion.maxLength = item.maxLength;
          const loc = item.locString;
          isMultiLine = loc.getIsMultiple();
          cellQuestion.acceptCarriageReturn = isMultiLine || loc.allowLineBreaks;
        }
        if (!isMultiLine) {
          cellQuestion.rows = 1;
        }
      }
    });
    survey.onMatrixCellValueChanging.add((_, options) => {
      const item = getTransationItem(options.question, options.row.name);
      if (!!item) {
        options.value = this.getProcessedTranslationItemText(options.columnName, item.locString, options.value, item.context);
      }
    });
    survey.onMatrixCellValueChanged.add((sender, options) => {
      const item = getTransationItem(options.question, options.row.name);
      if (!!item) {
        item.setLocText(options.columnName, options.value);
        const colName = options.columnName;
        options.row.cells.forEach((cell) => {
          if (colName === "default" || cell.column.name.indexOf(colName + "-") === 0) this.setPlaceHolder(cell.question, item, cell.column.name);
        });
      }
    });
    survey.onUpdatePanelCssClasses.add((sender, options) => {
      if (options.panel["__translationHasIndent"]) {
        options.cssClasses.panel.content += " st-panel-indent";
      }
    });
    survey.currentPage = survey.pages[0];
    return survey;
  }
  setPlaceHolder(cellQuestion, item, locale) {
    cellQuestion.placeholder = item.getPlaceholder(locale);
  }
  createStringsHeaderSurvey() {
    let json2 = {};
    setSurveyJSONForPropertyGrid(json2, false);
    const survey = this.options.createSurvey(json2, "translation_strings_header", this, (survey2) => {
      survey2.css = translationCss;
      const newPage = survey2.addNewPage("page");
      const matrix = Serializer.createClass("matrixdropdown");
      matrix.name = "stringsHeader";
      matrix.titleLocation = "hidden";
      this.addLocaleColumns(matrix);
      newPage.addQuestion(matrix, 0);
      survey2.currentPage = survey2.pages[0];
      this.onSurveyStringsHeaderCreated(survey2);
    }, this.getSurveyStringsHeaderArea());
    return survey;
  }
  addTranslationGroupIntoStringsSurvey(panel, group) {
    for (var i = 0; i < group.items.length; i++) {
      if (group.items[i].isGroup) continue;
      let item = group.items[i];
      let matrix = Serializer.createClass("matrixdropdown");
      matrix.cellType = "comment";
      matrix.titleLocation = "hidden";
      matrix.name = group.fullName + i;
      matrix.showHeader = false;
      panel.addQuestion(matrix);
      this.addLocaleColumns(matrix);
      var itemValue = new ItemValue(item.name, item.text);
      itemValue["translationData"] = item;
      matrix.rows.push(itemValue);
    }
    for (var i = 0; i < group.items.length; i++) {
      if (!group.items[i].isGroup) continue;
      let item = group.items[i];
      var pnl = Serializer.createClass("panel");
      pnl.name = item.name;
      panel.addElement(pnl);
      pnl.title = item.text;
      if (item.hasIndent) {
        pnl["__translationHasIndent"] = true;
      }
      this.addTranslationGroupIntoStringsSurvey(pnl, item);
    }
  }
  addLocaleColumns(matrix) {
    var locs = this.getSelectedLocales();
    matrix.addColumn("default", this.getLocaleName("")).readOnly = this.isEditMode;
    for (var i = 0; i < locs.length; i++) {
      matrix.addColumn(locs[i], this.getLocaleName(locs[i]));
    }
  }
  getStringsSurveyData(survey) {
    var res = {};
    var questions = survey.getAllQuestions();
    for (var i = 0; i < questions.length; i++) {
      res[questions[i].name] = this.getStringsQuestionData(questions[i]);
    }
    return res;
  }
  updateStringsSurveyData() {
    const survey = this.stringsSurvey;
    if (survey) {
      survey.data = this.getStringsSurveyData(survey);
    }
  }
  getStringsQuestionData(matrix) {
    var res = {};
    for (var i = 0; i < matrix.rows.length; i++) {
      var itemValue = matrix.rows[i];
      var item = itemValue["translationData"];
      var value = item.toJSON();
      if (!Helpers.isValueEmpty(value)) {
        res[itemValue.value] = value;
      }
    }
    return res;
  }
  updateHeaderStringsSurveyColumns() {
    if (!this.stringsHeaderSurvey) return;
    let matrix = this.stringsHeaderSurvey.getQuestionByName("stringsHeader");
    matrix.columns = [];
    this.addLocaleColumns(matrix);
  }
  updateStringsSurveyColumns() {
    if (!this.stringsSurvey) return;
    var questions = this.stringsSurvey.getAllQuestions();
    for (var i = 0; i < questions.length; i++) {
      var matrix = questions[i];
      matrix.beginUpdate();
      matrix.columns = [];
      this.addLocaleColumns(matrix);
      matrix.endUpdate();
    }
  }
  addLocaleIntoChoices(loc, choices, addedLocales) {
    if (!loc || addedLocales[loc]) return;
    addedLocales[loc] = true;
    choices.push(new ItemValue(loc, this.getLocaleName(loc)));
  }
  addLocaleIntoValue(loc, updateValue) {
    const visLocs = this.getVisibleLocales();
    if (visLocs.indexOf(loc) < 0) {
      visLocs.push(loc);
      this.setVisibleLocales(visLocs);
    }
    if (updateValue) {
      const selLocs = this.getSelectedLocales();
      if (selLocs.indexOf(loc) < 0 && selLocs.length < settings2.translation.maximumSelectedLocales) {
        selLocs.push(loc);
        this.setSelectedLocales(selLocs);
      }
    }
  }
  isLocaleVisible(locales, locale) {
    return locale !== surveyLocalization.defaultLocale && locales.indexOf(locale) < 0;
  }
  setupToolbarItems() {
    this.chooseLanguageActions = this.getSurveyLocales()[0].map((locale) => new Action({
      id: locale.value,
      title: this.getLocaleName(locale.value),
      data: locale
    }));
    this.addLanguageAction = createDropdownActionModel({
      id: "svc-translation-choose-language",
      iconName: "icon-add",
      iconSize: "auto",
      tooltip: editorLocalization.getString("ed.addLanguageTooltip"),
      enabled: new ComputedUpdater(() => this.isChooseLanguageEnabled && !this.readOnly)
    }, {
      items: this.chooseLanguageActions,
      allowSelection: false,
      cssClass: "svc-creator-popup",
      cssClasses: listComponentCss,
      onSelectionChanged: (item) => {
        this.addLocale(item.id);
      }
    });
  }
  onPropertyValueChanged(name, oldValue, newValue) {
    super.onPropertyValueChanged(name, oldValue, newValue);
    if (name === "canMergeLocaleWithDefault") {
      this.mergeLocaleWithDefaultText = this.getMergeLocaleWithDefaultText();
    }
    if (name === "locales") {
      this.updateHeaderStringsSurveyColumns();
      this.updateStringsSurveyColumns();
    }
  }
  getMergeLocaleWithDefaultText() {
    if (!this.canMergeLocaleWithDefault) return "";
    const locText = this.getLocaleName(this.defaultLocale);
    return editorLocalization.getString("ed.translationMergeLocaleWithDefault")["format"](locText);
  }
  get survey() {
    return this.surveyValue;
  }
  set survey(val) {
    this.surveyValue = val;
    this.setVisibleLocales([]);
    this.reset();
  }
  reset(alwaysReset = true) {
    if (!alwaysReset && !!this.root) return;
    var rootObj = !!this.filteredPage ? this.filteredPage : this.survey;
    var rootName = !!this.filteredPage ? rootObj["name"] : "survey";
    this.root = new TranslationGroup(rootName, rootObj, this);
    this.root.setAsRoot();
    this.root.reset();
    this.resetLocales();
    this.isEmpty = !this.root.hasItems;
    this.updateSettingsSurveyLocales();
    this.updateLocales();
    this.resetStringsSurvey();
    this.updateChooseLanguageActions();
  }
  updateReadOnly() {
    if (this.stringsSurvey) {
      const mode = this.readOnly ? "display" : "edit";
      this.stringsSurvey.mode = mode;
      this.settingsSurvey.mode = mode;
    }
  }
  canShowProperty(obj, prop, isEmpty, isShowing = true) {
    const result = isShowing && (!isEmpty || SurveyHelper.isPropertyVisible(obj, prop, this.options));
    return this.translationStringVisibilityCallback ? this.translationStringVisibilityCallback(obj, prop.name, result) : result;
  }
  get defaultLocale() {
    return surveyLocalization.defaultLocale;
  }
  getLocaleName(loc, inEnglish) {
    return editorLocalization.getLocaleName(loc, this.defaultLocale, inEnglish);
  }
  removeLocale(locale) {
    if (this.hasLocale(locale)) {
      const index = this.locales.indexOf(locale);
      const locales = this.locales;
      locales.splice(index, 1);
      this.locales = locales;
      this.canMergeLocaleWithDefault = this.hasLocale(this.defaultLocale);
    }
  }
  hasLocale(locale) {
    return this.locales.indexOf(locale) > -1;
  }
  addLocale(locale) {
    if (!this.hasLocale(locale)) {
      this.addLocaleIntoValue(locale, true);
    }
    this.updateChooseLanguageActions();
  }
  updateChooseLanguageActions() {
    const actions = this.chooseLanguageActions;
    let locales = this.getVisibleLocales();
    if (Array.isArray(actions)) {
      actions.forEach((item) => item.visible = this.isLocaleVisible(locales, item.data.value));
    }
    this.refreshAddLanguageActionListModel();
    this.calcIsChooseLanguageEnabled();
  }
  resetLocales() {
    var locales = [""];
    this.root.fillLocales(locales);
    const sortedLocales = this.options.translationLocalesOrder;
    if (Array.isArray(sortedLocales) && sortedLocales.length > 0) {
      const sortFunc = (a, b, arr) => {
        let i1 = arr.indexOf(a);
        let i2 = arr.indexOf(b);
        if (i1 < 0) i1 = 100;
        if (i2 < 0) i2 = 100;
        return i1 < i2 ? -1 : i1 > i2 ? 1 : 0;
      };
      locales.sort((a, b) => {
        const res = sortFunc(a, b, sortedLocales);
        return res === 0 ? sortFunc(a, b, locales) : res;
      });
    }
    this.setSelectedAndVisibleLocales(locales, this.getSelectedLocales(), true);
  }
  getSelectedLocales() {
    return this.getSelectedLocalesCore(true);
  }
  setSelectedLocales(selectedLocales) {
    this.setSelectedAndVisibleLocales(this.getVisibleLocales(), selectedLocales, true);
  }
  getVisibleLocales() {
    return this.getSelectedLocalesCore(false);
  }
  setVisibleLocales(locales) {
    this.setSelectedAndVisibleLocales(locales, this.getSelectedLocales(), false);
  }
  getSelectedLocalesCore(isSelected) {
    if (!this.localesQuestion) return [];
    const val = this.localesQuestion.value;
    if (!Array.isArray(val) || val.length === 0) return [];
    const res = [];
    val.forEach((item) => {
      if (!!item.name && (!isSelected || item.isSelected)) res.push(item.name);
    });
    return res;
  }
  setSelectedAndVisibleLocales(locales, selectedLocales, includeSelected) {
    if (!this.localesQuestion) return;
    if (!Array.isArray(selectedLocales)) selectedLocales = [];
    const val = [];
    if (includeSelected && selectedLocales.length > 0) {
      const res = [].concat(selectedLocales);
      locales.forEach((loc) => {
        if (res.indexOf(loc) < 0) res.push(loc);
      });
      locales = res;
    }
    const locDefault = this.defaultLocale;
    val.push({
      isSelected: true,
      name: "",
      displayName: this.getLocaleName("")
    });
    if (this.getEditLocale()) {
      val.push({
        isSelected: true,
        name: this.getEditLocale()
      });
    } else {
      locales.forEach((loc) => {
        if (!!loc) {
          val.push({
            isSelected: loc === locDefault || selectedLocales.indexOf(loc) > -1,
            name: loc,
            displayName: this.getLocaleName(loc)
          });
        }
      });
    }
    this.localesQuestion.value = val;
  }
  get noStringsText() {
    return editorLocalization.getString("ed.translationNoStrings");
  }
  get placeholderTitleText() {
    if (this.options.isMobileView) return getLocString("ed.translationsPlaceholderTitleMobile");
    return getLocString("ed.translationsPlaceholderTitle");
  }
  get placeholderDescriptionText() {
    if (this.options.isMobileView) return getLocString("ed.translationsPlaceholderDescriptionMobile");
    return getLocString("ed.translationsPlaceholderDescription");
  }
  exportToCSV() {
    if (!this.root) {
      this.reset();
    }
    let res = [];
    let headerRow = [];
    let visibleLocales = this.locales;
    headerRow.push("description  - language ");
    for (let i = 0; i < visibleLocales.length; i++) {
      headerRow.push(!!visibleLocales[i] ? visibleLocales[i] : "default");
    }
    res.push(headerRow);
    let itemsHash = {};
    this.fillItemsHash("", this.root, itemsHash);
    for (let key in itemsHash) {
      let row = [key];
      let item = itemsHash[key];
      for (let i = 0; i < visibleLocales.length; i++) {
        const loc = visibleLocales[i];
        let val = item.getTextForExport(loc);
        val = !val && i == 0 ? item.defaultValue : val;
        val = this.options.getTranslationExportedText(item.context, item.name, item.locString, loc, val);
        row.push(!val && i == 0 ? item.defaultValue : val);
      }
      res.push(row);
    }
    let prefix = settings2.translation.exportPrefix;
    if (!prefix) prefix = "";
    return prefix + papaparse_minExports.unparse(res, {
      quoteChar: '"',
      escapeChar: '"',
      delimiter: _Translation.csvDelimiter,
      header: true,
      newline: _Translation.newLineDelimiter,
      skipEmptyLines: false,
      //or 'greedy',
      columns: null
      //or array of strings
    });
  }
  importFromNestedArray(rows) {
    let locales = rows.shift().slice(1);
    if (locales[0] === "default") {
      locales[0] = "";
    }
    let translation = new _Translation(this.survey, this.options, false);
    translation.showAllStrings = true;
    let itemsHash = {};
    this.fillItemsHash("", translation.root, itemsHash);
    rows.forEach((row) => {
      let name = row.shift().trim();
      if (!name) return;
      let item = itemsHash[name];
      if (!item) return;
      this.updateItemWithStrings(name, item, row, locales);
    });
    this.reset();
    if (this.importFinishedCallback) this.importFinishedCallback();
  }
  exportToSCVFile(fileName) {
    if (!window) return;
    var data = this.exportToCSV();
    var blob = new Blob([data], {
      type: "text/csv"
    });
    if (window.navigator["msSaveOrOpenBlob"]) {
      window.navigator["msSaveBlob"](blob, fileName);
    } else {
      var elem = window.document.createElement("a");
      elem.href = window.URL.createObjectURL(blob);
      elem.download = fileName;
      document.body.appendChild(elem);
      elem.click();
      document.body.removeChild(elem);
    }
  }
  importFromCSVFile(file) {
    var self2 = this;
    papaparse_minExports.parse(file, {
      complete: function(results, file2) {
        self2.importFromNestedArray(results.data);
      }
    });
  }
  mergeLocaleWithDefault() {
    this.reset(false);
    if (!this.hasLocale(this.defaultLocale)) return;
    this.root.mergeLocaleWithDefault(this.defaultLocale);
    this.setVisibleLocales([]);
    this.setSelectedLocales([]);
    this.reset();
  }
  createTranslationEditor(locale) {
    const res = new TranslationEditor(this.survey, locale, this.options);
    res.onApply = () => {
      this.reset();
    };
    return res;
  }
  showTranslationEditor(locale) {
    this.createTranslationEditor(locale).showDialog();
  }
  translateItemAfterRender(item, el, locale) {
    if (!this.translateItemAfterRenderCallback) return;
    if (Array.isArray(el)) {
      for (var i = 0; i < el.length; i++) {
        if (el[i].tagName == "TEXTAREA") {
          el = el[i];
          break;
        }
      }
    }
    this.translateItemAfterRenderCallback(item, el, locale);
  }
  /**
   * Update a translation item with given values
   */
  updateItemWithStrings(name, item, values, locales) {
    for (let i = 0; i < values.length && i < locales.length; i++) {
      let val = values[i].trim();
      if (!val) continue;
      if (this.importItemCallback) {
        val = this.importItemCallback(name, locales[i], val);
      }
      if (!!val) {
        item.values(locales[i]).text = val;
      }
    }
  }
  fillItemsHash(parentName, group, itemsHash) {
    let name = parentName ? parentName + "." + group.name : group.name;
    group.locItems.forEach((item) => {
      itemsHash[name + "." + item.name] = item;
    });
    group.groups.forEach((group2) => this.fillItemsHash(name, group2, itemsHash));
  }
  dispose() {
    this.isEmpty = true;
    if (!!this.stringsSurvey) {
      this.stringsSurvey.dispose();
      this.stringsSurvey = void 0;
    }
    if (!!this.stringsHeaderSurvey) {
      this.stringsHeaderSurvey.dispose();
      this.stringsHeaderSurvey = void 0;
    }
    if (!!this.settingsSurveyValue) {
      this.settingsSurveyValue.dispose();
      this.settingsSurveyValue = void 0;
    }
    this.importFinishedCallback = void 0;
    this.availableTranlationsChangedCallback = void 0;
    this.tranlationChangedCallback = void 0;
    super.dispose();
  }
};
Translation.csvDelimiter = ",";
Translation.newLineDelimiter = "\n";
__decorate2([propertyArray()], Translation.prototype, "locales", void 0);
__decorate2([property()], Translation.prototype, "canMergeLocaleWithDefault", void 0);
__decorate2([property()], Translation.prototype, "mergeLocaleWithDefaultText", void 0);
__decorate2([property({
  defaultValue: false,
  onSet: (_, target) => {
    target.updateReadOnly();
  }
})], Translation.prototype, "readOnly", void 0);
__decorate2([property()], Translation.prototype, "root", void 0);
__decorate2([property({
  defaultValue: false,
  onSet: (_, target) => {
    target.reset();
  }
})], Translation.prototype, "showAllStrings", void 0);
__decorate2([property({
  onSet: (_, target) => {
    target.reset();
  }
})], Translation.prototype, "filteredPage", void 0);
__decorate2([property()], Translation.prototype, "stringsSurvey", void 0);
__decorate2([property()], Translation.prototype, "stringsHeaderSurvey", void 0);
__decorate2([property({
  defaultValue: true
})], Translation.prototype, "isEmpty", void 0);
__decorate2([property({
  defaultValue: true
})], Translation.prototype, "isChooseLanguageEnabled", void 0);
var TranslationForEditor = class extends Translation {
  constructor(survey, options, surveyStringsHeaderCreatedCallback) {
    super(survey, options, true);
    this.surveyStringsHeaderCreatedCallback = surveyStringsHeaderCreatedCallback;
  }
  getSurveyStringsArea() {
    return "translation-tab:table-popup-editor";
  }
  getSurveyStringsHeaderArea() {
    return "translation-tab:table-header-popup-editor";
  }
  onSurveyStringsHeaderCreated(survey) {
    this.surveyStringsHeaderCreatedCallback(survey);
  }
};
var TranslationEditor = class {
  constructor(survey, locale, options) {
    this.fromLocales = [];
    this.survey = survey;
    this.options = options;
    this.locale = locale;
    this.translationValue = new TranslationForEditor(this.survey, this.options, (survey2) => {
      this.setupNavigationButtons(survey2);
    });
    this.translation.setEditMode(this.locale);
    this.translation.reset();
    this.fillFromLocales();
    this.updateFromLocaleAction();
    this.updateMatricesColumns();
  }
  get translation() {
    return this.translationValue;
  }
  showDialog() {
    const dialogTitle = editorLocalization.getString("ed.translationDialogTitle") + " (" + this.translation.getLocaleName(this.locale) + ")";
    if (this.translation.stringsSurvey.getAllQuestions(true).length === 0) {
      const locStr = new LocalizableString(this.translation.stringsSurvey);
      locStr.text = editorLocalization.getString("ed.translationNoStrings");
      const popup = settings.showDialog({
        componentName: "sv-string-viewer",
        data: {
          locStr,
          locString: locStr,
          model: locStr
        },
        onApply: () => {
          return true;
        },
        cssClass: "svc-creator-popup",
        cssClasses: listComponentCss,
        title: dialogTitle,
        displayMode: "popup"
      }, this.options.rootElement);
      const actions = popup.footerToolbar.actions;
      actions.splice(1, actions.length - 1);
      actions[0].title = "OK";
      return;
    }
    const popupModel = settings.showDialog({
      componentName: "svc-tab-translation",
      data: {
        model: this.translation
      },
      onApply: () => {
        this.apply();
        return true;
      },
      onHide: () => {
        this.dispose();
      },
      cssClass: "svc-property-editor st-translation-dialog svc-creator-popup",
      title: dialogTitle,
      displayMode: this.options.isMobileView ? "overlay" : "popup"
    }, this.options.rootElement);
    popupModel.locale = editorLocalization.currentLocale;
  }
  doMachineTranslation() {
    let fromLocale = this.fromLocale || this.translation.defaultLocale;
    if (!fromLocale) fromLocale = "en";
    const items = this.createStringsToTranslate();
    const strings = [];
    items.forEach((item) => {
      strings.push(this.getTextToTranslate(item));
    });
    const callback = (translatedStrings) => {
      if (!Array.isArray(translatedStrings)) return;
      for (let i = 0; i < Math.min(items.length, translatedStrings.length); i++) {
        items[i].values(this.locale).text = translatedStrings[i];
      }
      this.translation.updateStringsSurveyData();
    };
    this.options.doMachineTranslation(fromLocale, this.locale, strings, callback);
  }
  apply() {
    this.translation.applyEditLocale();
    if (this.onApply) {
      this.onApply();
    }
  }
  cancel() {
    this.dispose();
  }
  dispose() {
    this.translationValue.dispose();
  }
  setFromLocale(locale) {
    if (this.fromLocale === locale) return;
    this.fromLocale = locale;
    this.updateMatricesColumns();
  }
  updateMatricesColumns() {
    this.translation.stringsHeaderSurvey.getAllQuestions().forEach((q) => {
      this.updateMatrixColumns(q);
      this.updateHeaderMatrixColumns(q);
    });
    const questions = this.translation.stringsSurvey.getAllQuestions();
    for (let i = 0; i < questions.length; i++) {
      this.updateMatrixColumns(questions[i]);
    }
  }
  updateHeaderMatrixColumns(matrix) {
    const cols = matrix.columns;
    cols[0].title = this.translation.getLocaleName("");
    if (cols.length > 2) {
      cols[1].title = this.getHeaderTitle("translationSource", cols[1].name);
      cols[2].title = this.getHeaderTitle("translationTarget", cols[2].name);
    } else {
      cols[1].title = this.getHeaderTitle("translationTarget", cols[1].name);
    }
  }
  updateMatrixColumns(matrix) {
    const colIndex = 1;
    if (matrix.columns.length === 3) {
      matrix.columns.splice(colIndex, 1);
    }
    const loc = this.fromLocale;
    if (loc) {
      const column = new MatrixDropdownColumn(loc, this.translation.getLocaleName(loc));
      column.readOnly = true;
      matrix.columns.splice(colIndex, 0, column);
    }
  }
  getHeaderTitle(strName, locale) {
    return editorLocalization.getString("ed." + strName) + this.translation.getLocaleName(locale);
  }
  fillFromLocales() {
    this.fromLocales = [];
    const items = this.createStringsToTranslate();
    items.forEach((item) => {
      item.fillLocales(this.fromLocales);
    });
  }
  setupNavigationButtons(survey) {
    const navigationBar = new SurveyElementActionContainer();
    survey["navigationBarValue"] = navigationBar;
    survey.findLayoutElement("buttons-navigation").data = navigationBar;
    navigationBar.locOwner = survey;
    navigationBar.cssClasses = survey.css.actionBar;
    navigationBar.containerCss = survey.css.footer;
    survey.addNavigationItem(this.createLocaleFromAction());
    const actionCss = "svc-action-bar-item--right";
    if (this.options.getHasMachineTranslation()) {
      survey.addNavigationItem(new Action({
        id: "svc-translation-machine",
        iconName: "icon-language",
        iconSize: "auto",
        css: actionCss,
        locTitleName: "ed.translateUsigAI",
        component: "sv-action-bar-item",
        action: () => {
          this.doMachineTranslation();
        }
      }));
    }
    const importAction = createImportCSVAction(() => {
      this.translation.importFromCSVFileDOM();
    }, false, true);
    importAction.css = actionCss;
    const exportAction = createExportCSVAction(() => {
      this.translation.exportToCSVFileUI();
    }, true);
    exportAction.css = actionCss;
    survey.addNavigationItem(importAction);
    survey.addNavigationItem(exportAction);
    survey.showNavigationButtons = "top";
  }
  createStringsToTranslate() {
    const res = new Array();
    this.fromLocale || "";
    this.translation.root.allLocItems.forEach((item) => {
      if (this.getTextToTranslate(item)) {
        res.push(item);
      }
    });
    return res;
  }
  getTextToTranslate(item) {
    const loc = this.fromLocale || "";
    let res = item.getLocText(loc);
    if (!res && !loc) {
      res = item.getDefaultLocaleText(true);
    }
    return res;
  }
  createLocaleFromAction() {
    const defaultLocaleTitle = this.getActionTranslateFromText("");
    const onActionTypesPopupShow = () => {
      const items = [{
        id: null,
        title: defaultLocaleTitle
      }];
      this.fromLocales.forEach((locale) => {
        items.push({
          id: locale,
          title: this.getActionTranslateFromText(locale)
        });
      });
      const listModel = action.popupModel.contentComponentData.model;
      listModel.setItems(items);
    };
    const actionTypesPopupModel = createPopupModelWithListModel({
      items: [{
        id: null,
        title: defaultLocaleTitle
      }],
      onSelectionChanged: (item) => {
        const id = item.id || "";
        this.setFromLocale(id);
        action.title = this.getActionTranslateFromText(id);
      },
      cssClasses: listComponentCss,
      allowSelection: true
    }, {
      verticalPosition: "bottom",
      horizontalPosition: "center",
      cssClass: "svc-creator-popup",
      onShow: onActionTypesPopupShow
    });
    const action = new Action({
      id: "svc-translation-fromlocale",
      component: "svc-translate-from-action",
      css: "st-translation-machine-from",
      location: "start",
      title: defaultLocaleTitle,
      innerCss: "st-translation-machine-from__btn",
      data: {
        additionalTitleCss: "st-translation-machine-from__title",
        additionalTitle: editorLocalization.getString("ed.translateUsigAIFrom")
      },
      popupModel: actionTypesPopupModel,
      action: () => {
        actionTypesPopupModel.toggleVisibility();
      }
    });
    return action;
  }
  updateFromLocaleAction() {
    const action = this.translation.stringsHeaderSurvey.findLayoutElement("buttons-navigation").data.getActionById("svc-translation-fromlocale");
    if (!!action) {
      action.enabled = this.fromLocales.length > 0;
      action.iconName = action.enabled ? "icon-chevron_16x16" : void 0;
      action.iconSize = "auto";
      action.data.containerCss = new CssClassBuilder().append("st-translation-machine-from__container").append("st-translation-machine-from__container--disabled", !action.enabled).toString();
    }
  }
  getActionTranslateFromText(loc) {
    loc = loc || "";
    return this.translation.getLocaleName(loc);
  }
};
function createImportCSVAction(action, needSeparator, isInEditor = false) {
  return new Action({
    id: "svc-translation-import",
    iconName: "icon-load",
    iconSize: "auto",
    locTitleName: "ed.translationImportFromSCVButton",
    locTooltipName: "ed.translationImportFromSCVButton",
    mode: isInEditor ? "large" : "small",
    component: "sv-action-bar-item",
    needSeparator,
    action
  });
}
function createExportCSVAction(action, isInEditor = false) {
  return new Action({
    id: "svc-translation-export",
    iconName: "icon-download",
    iconSize: "auto",
    locTitleName: "ed.translationExportToSCVButton",
    locTooltipName: "ed.translationExportToSCVButton",
    mode: isInEditor ? "large" : "small",
    component: "sv-action-bar-item",
    action
  });
}
var TabControlModel = class extends Base {
  updateExpandCollapseAction() {
    this.expandCollapseAction.iconName = this.sidePanel.visible ? "icon-collapse-panel" : "icon-expand-panel";
    this.expandCollapseAction.css = this.sidePanel.visible ? "svd-grid-hide" : "svd-grid-expand";
    this.expandCollapseAction.locTooltipName = this.sidePanel.visible ? "ed.hidePanel" : "ed.showPanel";
  }
  createToggleAction() {
    this.expandCollapseAction = new MenuButton({
      id: "svd-grid-hide",
      showTitle: false,
      visible: true,
      pressed: false,
      action: () => {
        if (this.sidePanel.visible) {
          this.sidePanel.collapseSidebar();
        } else {
          this.sidePanel.expandSidebar();
        }
      }
    });
  }
  constructor(sidePanel) {
    super();
    this.sidePanel = sidePanel;
    this.bottomToolbar = new ActionContainer();
    this.createToggleAction();
    this.updateExpandCollapseAction();
    this.sidePanel.registerFunctionOnPropertyValueChanged("_visible", () => {
      this.updateExpandCollapseAction();
    });
  }
  get isTopToolbarCreated() {
    return !!this.topToolbarValue;
  }
  get topToolbar() {
    if (!this.topToolbarValue) {
      this.topToolbarValue = new ActionContainer();
      if (!!this.onTopToolbarItemCreated) {
        this.onTopToolbarItemCreated(this.topToolbarValue);
      }
    }
    return this.topToolbarValue;
  }
  get sideBarClassName() {
    return new CssClassBuilder().append("svc-sidebar-tabs").append("svc-sidebar-tabs--collapsed", !this.sidePanel.renderedIsVisible).toString();
  }
};
var TabTranslationPlugin = class {
  get showOneCategoryInPropertyGrid() {
    return this._showOneCategoryInPropertyGrid;
  }
  set showOneCategoryInPropertyGrid(newValue) {
    if (this._showOneCategoryInPropertyGrid !== newValue) {
      this._showOneCategoryInPropertyGrid = newValue;
      this.creator.sidebar.hideSideBarVisibilityControlActions = newValue;
      if (this.creator.activeTab === "translation") {
        this.updateTabControl();
      }
    }
  }
  updateSettingsSurvey() {
    this.model.settingsSurvey.locale = this.creator.locale;
    this.model.settingsSurvey.css.root += this.showOneCategoryInPropertyGrid ? " spg-root--one-category" : "";
    this.model.settingsSurvey.rootCss += this.showOneCategoryInPropertyGrid ? " spg-root--one-category" : "";
  }
  constructor(creator) {
    this.creator = creator;
    this._showOneCategoryInPropertyGrid = true;
    creator.addTab({
      name: "translation",
      plugin: this,
      iconName: "icon-language"
    });
    this.showOneCategoryInPropertyGrid = creator.showOneCategoryInPropertyGrid;
    this.tabControlModel = new TabControlModel(this.creator.sidebar);
    this.sidebarTab = this.creator.sidebar.addPage("translation");
    this.sidebarTab.caption = editorLocalization.getString("ed.translationPropertyGridTitle");
    this.createActions().forEach((action) => creator.toolbar.actions.push(action));
  }
  activate() {
    this.model = new Translation(this.creator.survey, this.creator);
    this.updateSettingsSurvey();
    this.model.readOnly = this.creator.readOnly;
    this.model.translationStringVisibilityCallback = (obj, propertyName, visible) => {
      const options = {
        obj,
        element: obj,
        propertyName,
        visible
      };
      !this.creator.onTranslationStringVisibility.isEmpty && this.creator.onTranslationStringVisibility.fire(this.creator, options);
      return options.visible;
    };
    this.model.localeInitialVisibleCallback = (locale) => {
      let options = {
        locale,
        isSelected: true
      };
      this.creator.onTranslationLocaleInitiallySelected.fire(this.creator, options);
      return options.isSelected;
    };
    this.model.importItemCallback = (name, locale, text) => {
      const options = {
        locale,
        name,
        text
      };
      this.creator.onTranslationImportItem.fire(this.creator, options);
      return options.text;
    };
    this.model.importFinishedCallback = () => {
      this.creator.onTranslationImported.fire(this.creator, {});
    };
    this.sidebarTab.componentData = this.model.settingsSurvey;
    this.sidebarTab.componentName = "survey-widget";
    this.creator.sidebar.activePage = this.sidebarTab.id;
    this.mergeLocaleWithDefaultAction.title = this.createMergeLocaleWithDefaultActionTitleUpdater();
    this.mergeLocaleWithDefaultAction.tooltip = this.createMergeLocaleWithDefaultActionTitleUpdater();
    this.mergeLocaleWithDefaultAction.visible = this.model.canMergeLocaleWithDefault;
    this.filterPageAction.visible = this.creator.survey.pageCount > 1;
    this.updateFilterPageAction(true);
    this.filterStringsAction.visible = true;
    this.updateFilterStrigsAction(true);
    this.importCsvAction.visible = true;
    this.exportCsvAction.visible = true;
    this.filterPageAction.data.setItems([{
      id: null,
      title: this.showAllPagesText
    }].concat(this.creator.survey.pages.map((page) => ({
      id: page.name,
      title: this.getPageDisplayText(page)
    }))), false);
    this.model.onPropertyChanged.add((sender, options) => {
      if (options.name === "filteredPage") {
        this.updateFilterPageAction();
      }
      if (options.name === "showAllStrings") {
        this.updateFilterStrigsAction();
      }
      if (options.name === "canMergeLocaleWithDefault") {
        this.mergeLocaleWithDefaultAction.visible = this.model.canMergeLocaleWithDefault;
      }
      if (options.name === "mergeLocaleWithDefaultText") {
        this.mergeLocaleWithDefaultAction.title = this.model.mergeLocaleWithDefaultText;
        this.mergeLocaleWithDefaultAction.tooltip = this.model.mergeLocaleWithDefaultText;
      }
    });
    this.model.reset();
    this.creator.sidebar.hideSideBarVisibilityControlActions = this.showOneCategoryInPropertyGrid;
    this.updateTabControl();
  }
  update() {
    if (!this.model) return;
    this.model.survey = this.creator.survey;
    this.model.filteredPage = null;
    this.updateFilterPageAction(true);
    this.updateTabControl();
  }
  deactivate() {
    if (!!this.model) {
      this.model.dispose();
    }
    this.model = void 0;
    this.sidebarTab.visible = false;
    this.filterStringsAction.visible = false;
    this.filterPageAction.visible = false;
    this.mergeLocaleWithDefaultAction.title = void 0;
    this.mergeLocaleWithDefaultAction.tooltip = void 0;
    this.mergeLocaleWithDefaultAction.visible = false;
    this.importCsvAction.visible = false;
    this.exportCsvAction.visible = false;
    this.creator.sidebar.hideSideBarVisibilityControlActions = false;
    this.creator.sidebar.header.reset();
    return true;
  }
  updateTabControl() {
    if (this.showOneCategoryInPropertyGrid) {
      this.updateTabControlActions();
      this.creator.sidebar.sideAreaComponentName = "svc-tab-control";
      this.creator.sidebar.sideAreaComponentData = this.tabControlModel;
      this.creator.sidebar.header.componentName = "svc-side-bar-header";
      this.creator.sidebar.header.componentData = this.creator.sidebar.header;
    } else {
      this.creator.sidebar.sideAreaComponentName = "";
      this.creator.sidebar.sideAreaComponentData = void 0;
      this.creator.sidebar.header.componentName = "";
      this.creator.sidebar.header.componentData = void 0;
    }
  }
  updateTabControlActions() {
    if (this.showOneCategoryInPropertyGrid) {
      const languagesString = editorLocalization.getString("ed.translationLanguages");
      const action = new MenuButton({
        id: "pg-languages",
        tooltip: languagesString,
        iconName: "pg-general-24x24",
        active: true,
        pressed: false,
        action: () => {
          this.creator.sidebar.expandSidebar();
          this.creator.sidebar.header.title = languagesString;
          action.active = true;
        }
      });
      this.tabControlModel.topToolbar.setItems([action]);
      this.creator.sidebar.header.title = languagesString;
      this.creator.sidebar.header.subTitle = this.sidebarTab.caption;
    }
  }
  createMergeLocaleWithDefaultActionTitleUpdater() {
    return new ComputedUpdater(() => {
      this.creator.locale;
      return editorLocalization.getString("ed.translationMergeLocaleWithDefault")["format"](surveyLocalization.defaultLocale);
    });
  }
  get selectLanguageOptionsCaption() {
    return editorLocalization.getString("ed.translationAddLanguage");
  }
  get showAllStringsText() {
    return editorLocalization.getString("ed.translationShowAllStrings");
  }
  get showUsedStringsOnlyText() {
    return editorLocalization.getString("ed.translationShowUsedStringsOnly");
  }
  get showAllPagesText() {
    return editorLocalization.getString("ed.translationShowAllPages");
  }
  get exportToCSVText() {
    return editorLocalization.getString("ed.translationExportToSCVButton");
  }
  get importFromCSVText() {
    return editorLocalization.getString("ed.translationImportFromSCVButton");
  }
  createActions() {
    const items = [];
    this.createFilterPageAction();
    items.push(this.filterPageAction);
    this.createFilterStringsAction();
    items.push(this.filterStringsAction);
    this.mergeLocaleWithDefaultAction = new Action({
      id: "svd-translation-merge_locale_withdefault",
      visible: false,
      component: "sv-action-bar-item",
      mode: "small",
      needSeparator: true,
      action: () => {
        this.model.mergeLocaleWithDefault();
      }
    });
    items.push(this.mergeLocaleWithDefaultAction);
    this.importCsvAction = createImportCSVAction(() => {
      this.model.importFromCSVFileDOM();
    }, true);
    this.importCsvAction.enabled = new ComputedUpdater(() => !this.creator.readOnly);
    this.importCsvAction.visible = false;
    items.push(this.importCsvAction);
    this.exportCsvAction = createExportCSVAction(() => {
      this.model.exportToCSVFileUI();
    });
    this.exportCsvAction.visible = false;
    items.push(this.exportCsvAction);
    return items;
  }
  createFilterPageAction() {
    this.filterPageAction = createDropdownActionModel({
      id: "svc-translation-filter-page",
      title: this.getFilterPageActionTitle(),
      visible: false,
      mode: "small"
    }, {
      items: [{
        id: null,
        title: this.showAllPagesText
      }],
      allowSelection: true,
      onSelectionChanged: (item) => {
        this.model.filteredPage = !!item.id ? this.creator.survey.getPageByName(item.id) : null;
      },
      horizontalPosition: "center",
      cssClass: "svc-creator-popup",
      cssClasses: listComponentCss
    });
  }
  createFilterStringsAction() {
    this.filterStringsAction = createDropdownActionModel({
      id: "svc-translation-show-all-strings",
      title: this.getFilterStringsActionTitle(),
      visible: false,
      mode: "small"
    }, {
      items: [{
        id: "show-all-strings",
        locTitleName: "ed.translationShowAllStrings"
      }, {
        id: "show-used-strings-only",
        locTitleName: "ed.translationShowUsedStringsOnly"
      }],
      allowSelection: true,
      onSelectionChanged: (item) => {
        this.model.showAllStrings = item.id === "show-all-strings";
      },
      horizontalPosition: "center",
      cssClass: "svc-creator-popup",
      cssClasses: listComponentCss
    });
  }
  updateFilterStrigsAction(updateSelectedItem = false) {
    const title = this.getFilterStringsActionTitle();
    this.filterStringsAction.title = title;
    if (updateSelectedItem) {
      this.filterStringsAction.needSeparator = this.filterPageAction.visible;
      const list = this.filterStringsAction.data;
      list.selectedItem = list.actions.filter((el) => el.title === title)[0];
    }
  }
  updateFilterPageAction(updateSelectedItem = false) {
    this.filterPageAction.title = this.getFilterPageActionTitle();
    if (updateSelectedItem) {
      const list = this.filterPageAction.data;
      const id = this.model.filteredPage ? this.model.filteredPage.name : null;
      list.selectedItem = list.actions.filter((el) => el.id === id)[0];
    }
  }
  getFilterPageActionTitle() {
    const pageDisplayName = this.model && this.model.filteredPage && this.getPageDisplayText(this.model.filteredPage);
    return pageDisplayName || this.showAllPagesText;
  }
  getFilterStringsActionTitle() {
    return this.model && !this.model.showAllStrings ? this.showUsedStringsOnlyText : this.showAllStringsText;
  }
  getPageDisplayText(page) {
    return this.creator.getObjectDisplayName(page, "translation-tab", "survey-translation", page.title);
  }
};
var logicCss = {
  root: "",
  container: "",
  header: "",
  body: "sl-body",
  bodyEmpty: "",
  footer: "",
  title: "",
  description: "",
  logo: "",
  logoImage: "",
  headerText: "",
  navigationButton: "",
  completedPage: "",
  navigation: {
    complete: "",
    prev: "",
    next: "",
    start: "",
    preview: "",
    edit: ""
  },
  panel: {
    enter: "sl-element-wrapper--enter",
    leave: "sl-element-wrapper--leave",
    title: "",
    titleExpandable: "",
    titleOnExpand: "",
    titleOnError: "",
    description: "",
    container: "sl-panel",
    content: "",
    icon: "",
    iconExpanded: "",
    footer: "sl-panel__footer",
    requiredMark: "sl-panel__required-text"
  },
  paneldynamic: {
    mainRoot: "",
    root: "",
    navigation: "",
    title: "",
    button: "",
    buttonRemove: "",
    buttonAdd: "svc-logic-operator sl-paneldynamic__add-btn",
    progressTop: "",
    progressBottom: "",
    buttonPrev: "",
    buttonNext: "",
    progressContainer: "",
    progress: "",
    progressBar: "",
    progressText: "",
    separator: "sv-hidden",
    panelWrapper: "sl-panel-wrapper",
    content: "sl-paneldynamic__content",
    panelsContainer: "",
    panelWrapperList: "sl-panel-wrapper--list",
    panelWrapperInRow: "sl-panel-wrapper--in-row",
    panelWrapperEnter: "sl-panel-wrapper--enter",
    panelWrapperLeave: "sl-panel-wrapper--leave"
  },
  progress: "",
  progressBar: "",
  progressText: "",
  progressTextInBar: "",
  page: {
    root: "",
    title: "",
    description: ""
  },
  pageTitle: "",
  pageDescription: "",
  row: "sl-row",
  rowEnter: "sl-row--enter",
  rowLeave: "sl-row--leave",
  rowDelayedEnter: "sl-row--delayed-enter",
  rowMultiple: "sl-row--multiple",
  question: {
    mainRoot: "sl-question",
    flowRoot: "",
    asCell: "",
    header: "sl-question__header",
    headerLeft: "sl-question__header--left",
    headerTop: "",
    headerBottom: "",
    content: "",
    contentLeft: "",
    titleLeftRoot: "",
    titleOnAnswer: "",
    titleOnError: "",
    enter: "sl-element-wrapper--enter",
    leave: "sl-element-wrapper--leave",
    title: "sl-question__title",
    requiredMark: "sl-question__required-text",
    number: "",
    description: "",
    descriptionUnderInput: "",
    comment: "",
    required: "",
    titleRequired: "",
    indent: 0,
    footer: "",
    formGroup: "",
    hasError: "",
    disabled: "",
    confirmDialog: "sl-popup--confirm sv-popup--confirm svc-creator-popup"
  },
  image: {
    root: ""
  },
  error: {
    root: "",
    icon: "",
    item: "",
    locationTop: "",
    locationBottom: ""
  },
  checkbox: {
    root: "",
    item: "",
    itemSelectAll: "",
    itemNone: "",
    itemDisabled: "",
    itemChecked: "",
    itemHover: "",
    itemInline: "",
    label: "",
    labelChecked: "",
    itemControl: "",
    itemDecorator: "",
    controlLabel: "",
    materialDecorator: "",
    other: "",
    column: ""
  },
  radiogroup: {
    root: "",
    item: "",
    itemInline: "",
    label: "",
    labelChecked: "",
    itemDisabled: "",
    itemChecked: "",
    itemHover: "",
    itemControl: "",
    itemDecorator: "",
    controlLabel: "",
    materialDecorator: "",
    other: "",
    clearButton: "",
    column: ""
  },
  boolean: {
    mainRoot: "",
    root: "",
    item: "",
    control: "",
    itemChecked: "",
    itemIndeterminate: "",
    itemDisabled: "",
    label: "",
    switch: "",
    disabledLabel: "",
    itemDecorator: "",
    materialDecorator: "",
    sliderText: "",
    slider: ""
  },
  text: {
    root: "",
    small: "",
    controlDisabled: "",
    onError: ""
  },
  multipletext: {
    root: "",
    item: "",
    itemTitle: "",
    row: "",
    cell: ""
  },
  dropdown: {
    root: "",
    popup: "svc-creator-popup",
    small: "",
    control: "sl-dropdown",
    selectWrapper: "",
    other: "",
    onError: "",
    label: "",
    item: "",
    itemDisabled: "",
    itemChecked: "",
    itemHover: "",
    itemControl: "",
    itemDecorator: "",
    controlDisabled: "",
    controlLabel: "",
    materialDecorator: "",
    controlValue: "sl-dropdown__value",
    chevronButton: "",
    chevronButtonSvg: "",
    chevronButtonIconId: ""
  },
  imagepicker: {
    root: "",
    item: "",
    itemInline: "",
    itemChecked: "",
    itemDisabled: "",
    itemHover: "",
    label: "",
    itemControl: "",
    image: "",
    itemText: "",
    clearButton: "",
    other: ""
  },
  matrix: {
    mainRoot: "",
    tableWrapper: "",
    root: "",
    row: "",
    rowAdditional: "",
    rowError: "",
    cell: "",
    headerCell: "",
    label: "",
    itemValue: "",
    itemChecked: "",
    itemDisabled: "",
    itemHover: "",
    materialDecorator: "",
    itemDecorator: "",
    cellText: "",
    cellTextSelected: "",
    cellTextDisabled: ""
  },
  matrixdropdown: {
    tableWrapper: "",
    mainRoot: "",
    root: "",
    row: "",
    rowAdditional: "",
    cell: "",
    headerCell: ""
  },
  matrixdynamic: {
    tableWrapper: "",
    mainRoot: "sl-question st-row__question st-scrollable",
    root: "sl-table st-matrixdynamic",
    noHeader: "",
    row: "sl-table__row",
    rowAdditional: "sl-table__row--additional",
    cell: "sl-table__cell",
    headerCell: "sl-table__cell st-table__cell--header",
    button: "sl-btn",
    detailRow: "sl-table__row sl-table__row--detail st-table__row--detail",
    rowEnter: "sl-table__row--enter",
    rowLeave: "sl-table__row--leave",
    detailButton: "sl-table__cell--detail-button",
    detailButtonExpanded: "sl-table__cell--detail-button--expanded",
    detailIcon: "sl-detail-panel__icon",
    detailIconExpanded: "sl-detail-panel__icon--expanded",
    detailPanelCell: "sl-table__cell--detail-panel",
    actionsCell: "sl-table__cell sl-table__cell--actions st-table__cell--actions",
    buttonAdd: "sl-matrixdynamic__add-btn",
    buttonRemove: "sl-matrixdynamic__remove-btn",
    iconAdd: "",
    iconRemove: ""
  },
  rating: {
    root: "",
    item: "",
    itemHover: "",
    selected: "",
    minText: "",
    itemText: "",
    maxText: "",
    itemDisabled: ""
  },
  comment: {
    mainRoot: "",
    root: "spg-input spg-comment sl-comment",
    small: ""
  },
  expression: "",
  file: {
    root: "",
    other: "",
    placeholderInput: "",
    preview: "",
    fileSign: "",
    fileSignBottom: "",
    fileDecorator: "",
    fileInput: "",
    noFileChosen: "",
    chooseFile: "",
    disabled: "",
    removeButton: "",
    removeButtonBottom: "",
    removeFile: "",
    removeFileSvg: "",
    wrapper: ""
  },
  signaturepad: {
    root: "",
    small: "",
    controls: "",
    placeholder: "",
    clearButton: ""
  },
  saveData: {
    root: "",
    saving: "",
    error: "",
    success: "",
    saveAgainButton: ""
  },
  window: {
    root: "",
    body: "",
    header: {
      root: "",
      title: "",
      button: "",
      buttonExpanded: "",
      buttonCollapsed: ""
    }
  },
  list: JSON.parse(JSON.stringify(listComponentCss)),
  embeddedsurvey: {
    mainRoot: "sl-embedded-survey"
  },
  actionBar: defaultActionBarCss
};
var ConditionEditorItem = class {
  constructor() {
    this.conjunction = "and";
    this.operator = settings2.logic.defaultOperators.default;
  }
};
var SurveyConditionEditorItem = class extends ConditionEditorItem {
  constructor(survey) {
    super();
    this.survey = survey;
  }
  getOperatorText() {
    const op = this.operator;
    if (op == "equal") return "=";
    if (op == "notequal") return "<>";
    if (op == "greater") return ">";
    if (op == "less") return "<";
    if (op == "greaterorequal") return ">=";
    if (op == "lessorequal") return "<=";
    return op;
  }
  getValueText() {
    const val = this.value;
    if (!val) return val;
    if (!Array.isArray(val)) return this.valToText(val);
    let res = "[";
    for (let i = 0; i < val.length; i++) {
      res += this.valToText(val[i]);
      if (i < val.length - 1) res += ", ";
    }
    res += "]";
    return res;
  }
  get isValueRequired() {
    return this.operator !== "empty" && this.operator !== "notempty";
  }
  get isReady() {
    return !!this.questionName && (!this.isValueRequired || !Helpers.isValueEmpty(this.value));
  }
  toExpression() {
    let text = wrapTextByCurlyBraces(this.getQuestionValueByName()) + " " + this.getOperatorText();
    if (this.isValueRequired) {
      text += " " + this.getValueText();
    }
    return text;
  }
  getQuestionValueByName() {
    const question = this.survey.getQuestionByName(this.questionName);
    if (question && question.name != question.getValueName() && this.questionName != question.getValueName()) {
      return this.questionName.replace(question.name, question.getValueName());
    }
    return this.questionName;
  }
  valToText(val) {
    if (val == "true" || val == "false") return val;
    if (this.isNumeric(val)) return val;
    if (val[0] == "[") return val.replace(/(?!^)(['])(?!$)/g, "\\$1");
    if (!this.isQuote(val[0])) val = "'" + val;
    if (!this.isQuote(val[val.length - 1])) val = val + "'";
    return val.replace(/(?!^)(['"])(?!$)/g, "\\$1");
  }
  isNumeric(val) {
    if (typeof val === "string" && val.length > 1 && val[0] === "0" && val[1] !== "x") return false;
    return !isNaN(val);
  }
  isQuote(ch) {
    return ch == "'" || ch == '"';
  }
};
var ConditionEditorItemsBuilder = class {
  constructor(hasValue = null) {
    this.hasValue = hasValue;
  }
  build(text) {
    if (!text) return [];
    let operand = null;
    operand = new ConditionsParser().parseExpression(text);
    if (!operand) return [];
    return this.buildEditorItems(operand);
  }
  buildEditorItems(operand) {
    let res = [];
    if (!this.buildEditorItemsCore(operand, res, "")) {
      res = [];
    }
    return res;
  }
  buildEditorItemsCore(operand, res, parentConjunction) {
    if (operand.getType() == "unary") return this.buildEditorItemsAddUnaryOperand(operand, res);
    if (operand.getType() !== "binary") return false;
    const op = operand;
    if (op.isArithmetic && !op.isConjunction) return false;
    if (op.isConjunction) return this.buildEditorItemsAddConjunction(op, res, parentConjunction);
    return this.buildEditorItemsAddBinaryOperand(op, res);
  }
  buildEditorItemsAddConjunction(op, res, parentConjunction) {
    const conjunction = op.conjunction;
    if (conjunction == "or" && !!parentConjunction && parentConjunction != conjunction) return false;
    if (!this.buildEditorItemsCore(op.leftOperand, res, conjunction)) return false;
    const conjunctionIndex = res.length;
    if (!this.buildEditorItemsCore(op.rightOperand, res, conjunction)) return false;
    res[conjunctionIndex].conjunction = op.conjunction;
    return true;
  }
  buildEditorItemsAddBinaryOperand(op, res) {
    const variableOperand = this.getOperandByType(op, "variable");
    const arrayValue = this.getArrayValueFromOperand(op);
    const constOperand = !arrayValue ? this.getOperandByType(op, "const") : null;
    if (!variableOperand || !constOperand && !arrayValue && this.canShowValueByOperator(op.operator)) return false;
    if (!this.isVariableInSurvey(variableOperand.variable)) return false;
    const item = new ConditionEditorItem();
    item.questionName = variableOperand.variable;
    item.operator = op.leftOperand !== variableOperand ? this.getOppositeOperator(op.operator) : op.operator;
    if (!!arrayValue) {
      item.value = arrayValue;
    }
    if (!!constOperand) {
      item.value = constOperand.correctValue;
    }
    res.push(item);
    return true;
  }
  isVariableInSurvey(variable) {
    return !!this.hasValue ? this.hasValue(variable) : true;
  }
  getArrayValueFromOperand(op) {
    const arrayOperand = this.getOperandByType(op, "array");
    if (!arrayOperand || !arrayOperand.values) return null;
    const valuesOperand = arrayOperand.values;
    if (!Array.isArray(valuesOperand) || valuesOperand.length == 0) return null;
    const res = [];
    for (let i = 0; i < valuesOperand.length; i++) {
      const opConst = valuesOperand[i];
      if (!opConst) continue;
      if (opConst.getType() != "const") return null;
      res.push(opConst.correctValue);
    }
    if (res.length == 0) return null;
    return res;
  }
  buildEditorItemsAddUnaryOperand(op, res) {
    const operator = op.operator;
    if (operator !== "empty" && operator != "notempty") return false;
    const operand = op.expression;
    if (operand == null || operand.getType() != "variable") return false;
    const questionName = operand.variable;
    if (!this.isVariableInSurvey(questionName)) return false;
    const item = new ConditionEditorItem();
    item.questionName = questionName;
    item.operator = operator;
    res.push(item);
    return true;
  }
  getOppositeOperator(operator) {
    if (operator == "less") return "greater";
    if (operator == "greater") return "less";
    if (operator == "lessorequal") return "greaterorequal";
    if (operator == "greaterorequal") return "lessorequal";
    return operator;
  }
  getOperandByType(op, opType) {
    if (!op.rightOperand) return null;
    if (op.leftOperand.getType() !== opType && op.rightOperand.getType() !== opType) return null;
    if (op.leftOperand.getType() == opType && op.rightOperand.getType() == opType) return null;
    return op.leftOperand.getType() == opType ? op.leftOperand : op.rightOperand;
  }
  canShowValueByOperator(operator) {
    return operator != "empty" && operator != "notempty";
  }
};
function questionValueVisibleIf(params) {
  if (params.length !== 2) return false;
  if (Helpers.isValueEmpty(params[0]) || !params[1]) return false;
  return params[1] !== "empty" && params[1] !== "notempty";
}
FunctionFactory.Instance.register("questionValueVisibleIf", questionValueVisibleIf);
var ConditionEditor = class _ConditionEditor extends PropertyEditorSetupValue {
  static canParseExpression(text) {
    if (!text) return true;
    return !!new ConditionsParser().parseExpression(text);
  }
  static canBuildExpression(text) {
    if (!text) return true;
    if (!_ConditionEditor.canParseExpression(text)) return false;
    return new ConditionEditorItemsBuilder().build(text).length > 0;
  }
  static isOperatorEnabled(qType, operatorTypes) {
    if (!qType) return true;
    if (!operatorTypes || operatorTypes.length == 0) return true;
    const contains = [];
    const notContains = [];
    for (let i = 0; i < operatorTypes.length; i++) {
      let name = operatorTypes[i];
      if (name[0] == "!") {
        notContains.push(name.substring(1));
      } else {
        contains.push(name);
      }
    }
    return _ConditionEditor.isClassContains(qType, contains, notContains);
  }
  static isClassContains(qType, contains, notContains) {
    let classInfo = Serializer.findClass(qType);
    while (!!classInfo) {
      if (contains.indexOf(classInfo.name) > -1) return true;
      if (notContains.indexOf(classInfo.name) > -1) return false;
      classInfo = !!classInfo.parentName ? Serializer.findClass(classInfo.parentName) : null;
    }
    return contains.length == 0;
  }
  constructor(survey, object = null, options = null, propertyName = "") {
    super(options);
    this.propertyName = propertyName;
    this.addConditionQuestionsHash = {};
    this.isModalValue = true;
    this.isSettingPanelValues = false;
    this.calculatedValueQuestion = null;
    this.surveyValue = survey;
    this.objectValue = object;
    this.panelValue = this.editSurvey.getQuestionByName("panel");
    this.textEditorValue = this.editSurvey.getQuestionByName("textEditor");
    if (!!this.options.maxLogicItemsInCondition) {
      this.panel.maxPanelCount = this.options.maxLogicItemsInCondition;
    }
    this.allConditionQuestions = this.createAllConditionQuestions();
    this.editSurvey.onValueChanged.add((sender, options2) => {
      this.onValueChanged(options2);
    });
    this.editSurvey.onDynamicPanelAdded.add((sender, options2) => {
      this.onPanelAdded();
    });
    this.editSurvey.onDynamicPanelRemoved.add((sender, options2) => {
      if (options2.question.panelCount == 0) {
        options2.question.addPanel();
      }
      if (this.panel.panelCount > 0) this.panel.panels[0].getQuestionByName("questionName").titleLocation = "left";
    });
    this.editSurvey.onDynamicPanelItemValueChanged.add((sender, options2) => {
      this.onPanelValueChanged(options2.panel, options2.name);
    });
    this.editSurvey.css = logicCss;
    this.editSurvey.onUpdateQuestionCssClasses.add((sender, options2) => {
      this.onUpdateQuestionCssClasses(options2);
    });
    this.text = !!this.object && this.propertyName ? this.object[this.propertyName] : "";
    this.updatePlaceholderVisibileIf();
  }
  get title() {
    return this.panel.title;
  }
  set title(val) {
    this.panel.title = val;
    this.textEditor.title = val;
  }
  get isModal() {
    return this.isModalValue;
  }
  set isModal(val) {
    if (val === this.isModalValue) return;
    this.isModalValue = val;
    this.updatePlaceholderVisibileIf();
  }
  updatePlaceholderVisibileIf() {
    if (!!this.panel) {
      let expression = "";
      if (this.isModal && !this.options["animationEnabled"]) {
        expression = "{panel.questionName} empty and {panelIndex} == 0";
      }
      this.panel.template.getQuestionByName("placeholder").visibleIf = expression;
    }
  }
  getSurveyJSON() {
    return {
      elements: [{
        type: "paneldynamic",
        titleLocation: "hidden",
        name: "panel",
        removePanelButtonLocation: "right",
        addPanelText: editorLocalization.getString("pe.addCondition"),
        minPanelCount: 1,
        maxPanelCount: 1,
        startWithNewLine: false,
        templateElements: [{
          name: "conjunction",
          type: "dropdown",
          renderAs: "logicoperator",
          searchEnabled: false,
          titleLocation: "hidden",
          showOptionsCaption: false,
          visibleIf: "{panelIndex} > 0",
          choices: [{
            value: "and",
            text: editorLocalization.getString("pe.and")
          }, {
            value: "or",
            text: editorLocalization.getString("pe.or")
          }]
        }, {
          name: "questionName",
          type: "dropdown",
          renderAs: "logicoperator",
          title: editorLocalization.getString("pe.if"),
          titleLocation: "left",
          showOptionsCaption: false,
          startWithNewLine: false,
          isRequired: true
        }, {
          name: "operator",
          type: "dropdown",
          renderAs: "logicoperator",
          searchEnabled: false,
          titleLocation: "hidden",
          startWithNewLine: false,
          showOptionsCaption: false,
          isRequired: true,
          enableIf: "{panel.questionName} notempty"
        }, {
          name: "removeAction",
          type: "linkvalue",
          titleLocation: "hidden",
          showOptionsCaption: false,
          visible: false,
          startWithNewLine: false,
          showValueInLink: false,
          allowClear: false,
          showClear: false,
          iconName: "icon-delete_24x24"
        }, {
          name: "questionValue",
          type: "text",
          visible: false
        }, {
          name: "placeholder",
          type: "html",
          visible: false,
          html: `<div class='svc-logic-placeholder'><span class="svc-logic-placeholder__text">${editorLocalization.getString("pe.emptyLogicPopupMessage")}<span></div>`
        }]
      }, {
        type: "comment",
        titleLocation: "hidden",
        name: "textEditor",
        textUpdateMode: "onTyping",
        placeholder: editorLocalization.getString("pe.emptyExpressionPlaceHolder"),
        visible: false
      }]
    };
  }
  getSurveyCreationReason() {
    return "condition-builder";
  }
  get text() {
    return this.getText();
  }
  set text(val) {
    if (!this.isModal && !_ConditionEditor.canBuildExpression(val)) {
      this.panel.panelCount = 0;
      this.showTextEditor(val);
    } else {
      this.textEditor.value = val;
      this.showBuilder(val);
    }
  }
  isModified(prevText) {
    if (this.textEditor.visible) return prevText != this.text;
    const items = this.getEditorItems();
    const prevOp = !!prevText ? new ConditionsParser().parseExpression(prevText) : null;
    if (!prevOp) return !(items.length == 1 && !items[0].questionName);
    if (!this.isReady) return true;
    const curOp = new ConditionsParser().parseExpression(this.text);
    return !prevOp.isEqual(curOp);
  }
  get context() {
    return this.contextValue;
  }
  set context(val) {
    if (val === this.context) return;
    this.contextValue = val;
    this.updateNamesOnContextChanged();
    if (this.onContextChanged) {
      this.onContextChanged(val);
    }
  }
  processText(val) {
    this.panel.panelCount = 0;
    const items = new ConditionEditorItemsBuilder().build(val);
    this.buildPanels(items);
  }
  get survey() {
    return this.surveyValue;
  }
  get object() {
    return this.objectValue;
  }
  get panel() {
    return this.panelValue;
  }
  get textEditor() {
    return this.textEditorValue;
  }
  get isReady() {
    if (this.textEditor.visible) {
      return _ConditionEditor.canParseExpression(this.textEditor.value);
    }
    for (let i = 0; i < this.panel.panels.length; i++) {
      if (!this.createEditorItemFromPanel(this.panel.panels[i]).isReady) return false;
    }
    return true;
  }
  isEmpty() {
    if (this.panel.panels.length === 0) return true;
    if (this.panel.panels.length > 1) return false;
    const item = this.createEditorItemFromPanel(this.panel.panels[0]);
    return !item.questionName;
  }
  hasErrorInUI() {
    const creator = this.survey.creator;
    if (!this.isReady) {
      this.hasErrors();
      this.errorText = getLogicString("expressionInvalid");
      !!creator && creator.notify(this.errorText, "error");
      return true;
    }
    return false;
  }
  apply() {
    if (this.hasErrorInUI()) {
      return false;
    }
    if (!this.object || !this.propertyName) return;
    this.object[this.propertyName] = this.text;
    return true;
  }
  setIsFastEntry(showTextEdit) {
    if (showTextEdit) {
      this.showTextEditor(this.text);
    } else {
      if (!this.panel.visible) {
        this.showBuilder(this.text);
      }
    }
  }
  buildPanels(items) {
    this.panel.panelCount = items.length;
    for (let i = 0; i < items.length; i++) {
      this.setItemToPanel(items[i], this.panel.panels[i]);
    }
    if (this.panel.panelCount == 0) {
      this.panel.addPanel();
    }
  }
  getIsOperatorEnabled(qName, qType, op, condQuestion, isContainer) {
    if (isContainer) return op === "empty" || op === "notempty";
    let isOperatorEnabled = _ConditionEditor.isOperatorEnabled(qType, settings2.operators[op]);
    return !!condQuestion ? this.options.isConditionOperatorEnabled(qName, condQuestion, op, isOperatorEnabled) : isOperatorEnabled;
  }
  isContainerQuestion(questionName) {
    if (!settings2.logic.includeComplexQuestions || !questionName) return false;
    for (let key in this.addConditionQuestionsHash) {
      if (key.indexOf(questionName + ".") === 0 || key.indexOf(questionName + "[") === 0) return true;
    }
    return false;
  }
  setupConditionOperator(item, panel) {
    const questionOperator = panel.getQuestionByName("operator");
    questionOperator.choices = this.getOperators();
    questionOperator.value = item.operator;
    questionOperator.onOpened.add((_, opt) => {
      this.updateConditionChoices(panel, opt.choices);
    });
  }
  updateConditionChoices(panel, choices, questionOperator) {
    let isCurrentOperatorEnabled = true;
    const op = questionOperator === null || questionOperator === void 0 ? void 0 : questionOperator.value;
    const questionName = panel.getQuestionByName("questionName").value;
    const json2 = this.getQuestionConditionJson(questionName);
    const qType = !!json2 ? json2.type : null;
    const isContainer = this.isContainerQuestion(questionName);
    const condQuestion = this.getConditionQuestion(questionName);
    choices.forEach((choice) => {
      const isOperatorEnabled = this.getIsOperatorEnabled(questionName, qType, choice.value, condQuestion, isContainer);
      choice.setIsEnabled(isOperatorEnabled);
      choice.setIsVisible(isOperatorEnabled);
      if (!!questionOperator && choice.value == op) {
        isCurrentOperatorEnabled = isOperatorEnabled;
      }
    });
    if (!isCurrentOperatorEnabled) {
      questionOperator.value = this.getFirstEnabledOperator(choices);
    }
  }
  setupConditionQuestionName(item, panel) {
    const panelQuestionName = panel.getQuestionByName("questionName");
    panelQuestionName.choices = this.getConditionQuestions();
    panelQuestionName.titleLocation = this.panel.panels.indexOf(panel) == 0 ? "left" : "hidden";
    const questionName = this.getQuestionNameToPanel(item.questionName);
    if (!!this.getConditionQuestion(questionName)) {
      panelQuestionName.value = questionName;
    }
  }
  setupRemoveQuestion(panel) {
    const dynamicPanel = panel.getQuestionByName("removeAction").parentQuestion;
    const removeQuestionQuestion = panel.getQuestionByName("removeAction");
    removeQuestionQuestion.linkClickCallback = () => {
      if (!!dynamicPanel) {
        dynamicPanel.removePanelUI(panel);
      }
    };
    removeQuestionQuestion.linkSetButtonCssClasses = "svc-logic-condition-remove svc-icon-remove";
    removeQuestionQuestion.linkValueText = "";
  }
  setItemToPanel(item, panel) {
    this.isSettingPanelValues = true;
    panel.getQuestionByName("conjunction").value = item.conjunction;
    this.setupConditionOperator(item, panel);
    this.setupConditionQuestionName(item, panel);
    if (!!panel.getQuestionByName("questionValue")) {
      panel.getQuestionByName("questionValue").value = item.value;
      this.updateSurveyVariable(item);
    }
    this.setupRemoveQuestion(panel);
    this.isSettingPanelValues = false;
  }
  updateSurveyVariable(item) {
    this.editSurvey.setVariable(item.questionName, item.value);
  }
  getConditionQuestions() {
    if (!this.context) return this.allConditionQuestions;
    const res = [];
    for (var i = 0; i < this.allConditionQuestions.length; i++) {
      const item = this.allConditionQuestions[i];
      if (!item.context || item.context === this.context) {
        res.push(item);
      }
    }
    return res;
  }
  getText() {
    if (this.textEditor.visible) return this.textEditor.value;
    let res = "";
    const items = this.getEditorItems();
    for (let i = 0; i < items.length; i++) {
      if (!items[i].isReady) break;
      if (!!res) {
        res += " " + items[i].conjunction + " ";
      }
      res += items[i].toExpression();
    }
    return res;
  }
  getEditorItems() {
    const res = [];
    for (let i = 0; i < this.panel.panels.length; i++) {
      res.push(this.createEditorItemFromPanel(this.panel.panels[i]));
    }
    return res;
  }
  createEditorItemFromPanel(panel) {
    const item = new SurveyConditionEditorItem(this.survey);
    item.conjunction = panel.getQuestionByName("conjunction").value;
    item.questionName = this.getQuestionNameFromPanel(panel.getQuestionByName("questionName").value);
    item.operator = panel.getQuestionByName("operator").value;
    if (!!panel.getQuestionByName("questionValue")) {
      item.value = panel.getQuestionByName("questionValue").value;
      this.updateSurveyVariable(item);
    }
    return item;
  }
  getQuestionNameFromPanel(name) {
    if (!this.context || !name) return name;
    const prefix = this.context.getValueName() + ".";
    return name.replace(prefix, "");
  }
  getContextIndexInfo(name, prefix = "") {
    return SurveyHelper.getQuestionContextIndexInfo(name, prefix);
  }
  getQuestionNameToPanel(name) {
    if (!this.context || !name) return name;
    const indexInfo = this.getContextIndexInfo(name);
    if (!indexInfo || indexInfo.index !== 0) return name;
    return this.context.getValueName() + "." + name;
  }
  getContextFromPanels() {
    if (!!this.object) return null;
    for (var i = 0; i < this.panel.panels.length; i++) {
      const questionName = this.panel.panels[i].getQuestionByName("questionName").value;
      const context = this.getContextByQuestionName(questionName);
      if (!!context) return context;
    }
    return null;
  }
  updateNamesOnContextChanged() {
    for (var i = 0; i < this.panel.panels.length; i++) {
      this.panel.panels[i].getQuestionByName("questionName").choices = this.getConditionQuestions();
    }
  }
  getContextByQuestionName(name) {
    if (!name) return null;
    const indexInfo = this.getContextIndexInfo(name, ".");
    if (!indexInfo) return null;
    name = name.substring(0, indexInfo.index);
    return this.survey.getQuestionByValueName(name);
  }
  getConditionQuestionText(question, name) {
    return this.options.getObjectDisplayName(question, "condition-editor", "condition", name);
  }
  createAllConditionQuestions() {
    if (!this.survey) return [];
    const res = [];
    const questions = this.survey.getAllQuestions();
    const contextObject = this.getContextObject();
    let sortOrder = settings2.logic.questionSortOrder;
    if (questions.length > 0) {
      for (let i = 0; i < questions.length; i++) {
        const question = questions[i];
        if (contextObject == question) continue;
        const context = contextObject ? contextObject : !this.context || this.context === question;
        if (settings2.logic.includeComplexQuestions && question.isContainer) {
          res.push({
            question,
            name: question.name,
            text: question.title
          });
        }
        question.addConditionObjectsByContext(res, context);
      }
    }
    const variableNames = this.survey.getVariableNames();
    this.addSurveyCalculatedValues(variableNames);
    sortOrder = this.options.onConditionQuestionsGetListCallback(this.propertyName, this.object, this, res, variableNames);
    for (let i = 0; i < res.length; i++) {
      res[i].value = res[i].name;
      let question = !!res[i].question ? res[i].question : res[i];
      if (!(this.options.useElementTitles || this.options.showTitlesInExpressions)) {
        let name = res[i].name;
        let valueName = question.valueName;
        if (!!valueName && name.indexOf(valueName) == 0) {
          name = name.replace(valueName, question.name);
        }
        const unwrappedValueText = "-unwrapped";
        name = name.replace(unwrappedValueText, "");
        res[i].text = this.getConditionQuestionText(question, name);
      }
      this.addConditionQuestionsHash[res[i].name] = question;
    }
    this.addValuesIntoConditionQuestions(variableNames, res);
    if (sortOrder === "asc") {
      SurveyHelper.sortItems(res);
    }
    return res;
  }
  getContextObject() {
    if (this.object && this.object.isDescendantOf("itemvalue")) {
      const res = this.object.locOwner;
      if (!!res && res.getType) {
        if (!!res.locOwner && res.locOwner.isDescendantOf("matrixdropdowncolumn")) return res.locOwner;
        return res;
      }
    }
    return this.object;
  }
  addValuesIntoConditionQuestions(values, res) {
    for (let i = 0; i < values.length; i++) {
      let name = !!values[i].name ? values[i].name : values[i];
      this.addConditionQuestionsHash[name] = this.getCalculatedValueQuestion();
      res.push({
        value: name,
        text: name,
        question: this.getCalculatedValueQuestion()
      });
    }
  }
  addSurveyCalculatedValues(names) {
    this.survey.calculatedValues.forEach((item) => {
      const index = names.indexOf(item.name.toLowerCase());
      if (index > -1) {
        names.splice(index, 1);
      }
      names.push(item.name);
    });
  }
  getCalculatedValueQuestion() {
    if (!this.calculatedValueQuestion) {
      this.calculatedValueQuestion = Serializer.createClass("text");
      this.calculatedValueQuestion.name = "question";
    }
    return this.calculatedValueQuestion;
  }
  getOperators() {
    const res = [];
    const ops = settings2.operators;
    for (const name in ops) {
      res.push(new ItemValue(name, editorLocalization.getString("op." + name)));
    }
    return res;
  }
  rebuildQuestionValue(panel) {
    if (!!panel.getQuestionByName("questionValue")) {
      panel.getQuestionByName("questionValue").clearValue();
    }
    const qName = panel.getQuestionByName("questionName").value;
    let json2 = this.getQuestionConditionJson(qName, panel.getQuestionByName("operator").value);
    if (!json2) {
      json2 = {
        type: "text"
      };
    }
    json2.isRequired = true;
    SurveyHelper.updateQuestionJson(json2);
    json2.enableIf = "{panel.questionName} notempty and {panel.operator} != 'empty' and {panel.operator} != 'notempty'";
    let newQuestion = Serializer.createClass(json2.type);
    delete json2.type;
    new JsonObject().toObject(json2, newQuestion);
    if (!newQuestion) {
      newQuestion = Serializer.createClass("text", json2);
    }
    const oldQuestion = panel.getQuestionByName("questionValue");
    if (!!oldQuestion) {
      panel.removeElement(oldQuestion);
    }
    if (this.canShowQuestionValue(panel)) {
      const title = newQuestion.title;
      newQuestion.name = "questionValue";
      newQuestion.visibleIf = "questionValueVisibleIf({panel.questionName}, {panel.operator})";
      newQuestion.title = title;
      newQuestion.description = "";
      newQuestion.titleLocation = "top";
      newQuestion.hasComment = false;
      if (newQuestion.showOtherItem) {
        const question = this.getConditionQuestion(qName);
        if (question && question.getStoreOthersAsComment && question.getStoreOthersAsComment()) {
          const other = newQuestion.otherItem;
          newQuestion.choices.push(new ItemValue(other.value, other.title));
          other.value = "#" + other.value + "#";
          newQuestion.showOtherItem = false;
        }
      }
      panel.addElement(newQuestion);
    }
  }
  rebuildQuestionValueOnOperandChanging(panel) {
    const json2 = this.getQuestionConditionJson(panel.getQuestionByName("questionName").value, panel.getQuestionByName("operator").value);
    const question = panel.getQuestionByName("questionValue");
    if (!!question && (question.isReadOnly || !question.isVisible)) {
      question.clearValue();
    }
    if (!question || !!json2 && json2.type == question.getType()) return;
    this.rebuildQuestionValue(panel);
  }
  canShowQuestionValue(panel) {
    const questionOperator = panel.getQuestionByName("operator");
    if (!questionOperator) return false;
    this.updateOperatorEnables(panel);
    const choices = questionOperator.choices;
    for (let i = 0; i < choices.length; i++) {
      if (!choices[i].isEnabled) continue;
      const val = choices[i].value;
      if (val !== "empty" && val != "notempty") return true;
    }
    return false;
  }
  getConditionQuestion(name) {
    return this.addConditionQuestionsHash[name];
  }
  getQuestionConditionJson(questionName, operator) {
    let path = "";
    const question = this.getConditionQuestion(questionName);
    if (!question) return null;
    if (!operator) {
      operator = this.getDefaultOperatorByQuestion(question);
    }
    if (questionName.indexOf(question.getValueName()) == 0) {
      path = questionName.substring(question.getValueName().length);
    }
    const indexInfo = this.getContextIndexInfo(questionName);
    if (!!indexInfo && indexInfo.index == 0) {
      path = questionName.substring(indexInfo.name.length);
    }
    if (!path) {
      path = questionName;
    }
    if (!!path && path[0] == ".") {
      path = path.substring(1);
    }
    const json2 = question && question.getConditionJson ? question.getConditionJson(operator, path) : null;
    if (!json2) return null;
    if (!!json2.choicesFromQuestion) {
      this.updateChoicesFromQuestion(json2);
    }
    if (json2.type == "expression") {
      json2.type = "text";
    }
    if (operator == "anyof") {
      if (!_ConditionEditor.isClassContains(json2.type, ["checkbox"], [])) {
        json2.type = "checkbox";
      }
    }
    return json2;
  }
  updateChoicesFromQuestion(json2) {
    const question = this.getConditionQuestion(json2.choicesFromQuestion);
    if (!question) return;
    delete json2.choicesFromQuestion;
    const questionJSON = question.toJSON();
    if (!!questionJSON.choices) {
      json2.choices = questionJSON.choices;
    }
    if (!!questionJSON.choicesByUrl) {
      json2.choicesByUrl = questionJSON.choicesByUrl;
    }
  }
  updateOperatorEnables(panel) {
    const questionOperator = panel.getQuestionByName("operator");
    if (!questionOperator) return;
    this.updateConditionChoices(panel, questionOperator.choices, questionOperator);
  }
  updateQuestionsWidth(panel) {
    const valueQuestion = panel.getQuestionByName("questionValue");
    const conjunctionQuestion = panel.getQuestionByName("conjunction");
    const nameQuestion = panel.getQuestionByName("questionName");
    const operatorQuestion = panel.getQuestionByName("operator");
    const isValueSameLine = !!valueQuestion && !valueQuestion.startWithNewLine;
    const isFirst = !conjunctionQuestion || !conjunctionQuestion.isVisible;
    if (!isFirst) {
      conjunctionQuestion.minWidth = "50px";
      conjunctionQuestion.width = "15%";
    }
    nameQuestion.minWidth = "50px";
    nameQuestion.width = isFirst ? "40%" : "25%";
    operatorQuestion.minWidth = "50px";
    operatorQuestion.width = isValueSameLine ? "25%" : "60%";
    if (!!valueQuestion) {
      valueQuestion.minWidth = "50px";
      valueQuestion.width = isValueSameLine ? "35%" : "";
    }
  }
  get defaultOperator() {
    return settings2.logic.defaultOperators.default;
  }
  getDefaultOperatorByQuestionName(questionName) {
    return this.getDefaultOperatorByQuestion(this.getConditionQuestion(questionName));
  }
  getDefaultOperatorByQuestion(question) {
    if (!!question) {
      const defOps = settings2.logic.defaultOperators;
      if (!!defOps[question.getType()]) return defOps[question.getType()];
    }
    return this.defaultOperator;
  }
  getFirstEnabledOperator(choices) {
    for (let i = 0; i < choices.length; i++) {
      if (choices[i].isEnabled) {
        return choices[i].value;
      }
    }
    return this.defaultOperator;
  }
  onPanelAdded() {
    this.setItemToPanel(new ConditionEditorItem(), this.panel.panels[this.panel.panels.length - 1]);
  }
  onPanelValueChanged(panel, name) {
    if (name == "questionName") {
      this.context = this.getContextFromPanels();
      this.rebuildQuestionValue(panel);
      if (!this.isSettingPanelValues) {
        panel.getQuestionByName("operator").value = this.getDefaultOperatorByQuestionName(panel.getQuestionByName("questionName").value);
      }
    }
    if (name == "operator") {
      this.rebuildQuestionValueOnOperandChanging(panel);
    }
    this.updateOperatorEnables(panel);
    this.updateQuestionsWidth(panel);
  }
  onUpdateQuestionCssClasses(options) {
    const cssClasses = options.cssClasses;
    const question = options.question;
    if (question.getType() !== "paneldynamic") {
      cssClasses.answered = "svc-logic-question--answered";
    }
    if (question.name === "textEditor") {
      cssClasses.root += " svc-logic-question-text-editor";
    }
    if (question.name === "conjunction") {
      question.allowRootStyle = false;
      cssClasses.control += " svc-logic-operator svc-logic-operator--conjunction ";
    }
    if (question.name === "questionName") {
      question.allowRootStyle = false;
      cssClasses.control += " svc-logic-operator svc-logic-operator--question";
      cssClasses.error.root = "svc-logic-operator__error";
      cssClasses.onError = "svc-logic-operator--error";
    }
    if (question.name === "operator") {
      question.allowRootStyle = false;
      cssClasses.control += " svc-logic-operator svc-logic-operator--operator";
    }
    if (question.name === "removeAction") {
      question.allowRootStyle = false;
      cssClasses.mainRoot += " svc-logic-condition-remove-question";
    }
    if (question.name === "questionValue" || question.isContentElement) {
      assignDefaultClasses(cssClasses, question.getType());
      cssClasses.mainRoot += " svc-logic-question-value sd-element--with-frame";
      cssClasses.error.root = "svc-logic-operator__error";
    }
    if (question.name === "panel") {
      cssClasses.root += " svc-logic-paneldynamic";
      cssClasses.buttonAdd += " svc-logic-operator--operator";
      cssClasses.iconRemove = "svc-icon-remove";
      cssClasses.buttonRemove = "svc-logic-paneldynamic__button svc-logic-paneldynamic__remove-btn";
      cssClasses.buttonRemoveRight = "svc-logic-paneldynamic__remove-btn--right";
      cssClasses.buttonRemoveText = "svc-logic-paneldynamic__button-remove-text";
    }
  }
  onValueChanged(options) {
    if (options.question.name === "panel" && options.value.length > 0) {
      const maxLogicItems = this.options.maxLogicItemsInCondition > 0 ? this.options.maxLogicItemsInCondition : 100;
      options.question.maxPanelCount = options.value.length === 1 && !options.value[0].questionName ? 1 : maxLogicItems;
      this.panel.panels.forEach((panel) => {
        panel.getQuestionByName("removeAction").visible = options.value.length !== 1;
      });
    }
    this.title = this.isReady ? this.text : editorLocalization.getString("pe.ruleIsNotSet");
  }
  showTextEditor(expression) {
    this.panel.visible = false;
    this.textEditor.value = expression;
    this.textEditor.visible = true;
  }
  showBuilder(expression) {
    if (!this.isModal && !this.getCanShowBuilder(expression)) return;
    this.textEditor.visible = false;
    this.processText(expression);
    this.panel.visible = true;
  }
  getCanShowBuilder(expression) {
    return _ConditionEditor.canBuildExpression(expression);
  }
};
var LogicActionModelBase = class {
  static createActionModel(panel, logicAction, logicType, selectorElementsHash) {
    if (!!logicType && logicType.hasSelectorChoices) {
      if (logicType.name.indexOf("_setValue") > -1) return new LogicActionSetValueModel(panel, logicAction, logicType, selectorElementsHash);
      return new LogicActionModel(panel, logicAction, logicType, selectorElementsHash);
    } else {
      return new LogicActionTriggerModel(panel, logicAction, logicType);
    }
  }
  constructor(panel, initialLogicAction, logicType) {
    this.panel = panel;
    this.initialLogicAction = initialLogicAction;
    this.logicType = logicType;
  }
  updateCurrentLogicAction(survey) {
    return false;
  }
  afterUpdateInitialLogicAction() {
  }
  resetElements() {
  }
  getSelectedElement() {
    return null;
  }
  updateInitialLogicAction() {
    this.initialLogicAction = this.currentLogicAction;
    if (this.afterUpdateInitialLogicAction) {
      this.afterUpdateInitialLogicAction();
    }
  }
  setInitialElementValue(question, action, selectedQuestion) {
    if (!!selectedQuestion && question.choices.filter((ch) => ch.value === selectedQuestion).length !== 0) {
      question.value = selectedQuestion;
    } else {
      question.value = !!action && action.logicType == this.logicType ? action.elementName : void 0;
    }
  }
};
var LogicActionModel = class extends LogicActionModelBase {
  getSelectorOptionsText(logicType) {
    const elementType = logicType.baseClass;
    const optionsCaptionName = elementType == "page" ? "pe.conditionSelectPage" : elementType == "panel" ? "pe.conditionSelectPanel" : "pe.conditionSelectQuestion";
    return editorLocalization.getString(optionsCaptionName);
  }
  getElementBySelectorName(panel) {
    const value = panel.getQuestionByName("elementSelector").value;
    if (!value) return null;
    return this.selectorElementsHash[value];
  }
  constructor(panel, logicAction, logicType, selectorElementsHash) {
    super(panel, logicAction, logicType);
    this.selectorElementsHash = selectorElementsHash;
  }
  updateCurrentLogicAction(survey) {
    const selectedElement = this.getElementBySelectorName(this.panel);
    const createNewAction = !this.initialLogicAction || this.initialLogicAction.logicType != this.logicType || !!selectedElement && this.initialLogicAction.element != selectedElement;
    if (!createNewAction) {
      return false;
    }
    this.currentLogicAction = new SurveyLogicAction(this.logicType, selectedElement, survey);
    return true;
  }
  resetElements() {
    const question = this.panel.getQuestionByName("elementSelector");
    question.visible = false;
  }
  updatePanelElements(selectedElement, choices) {
    const question = this.panel.getQuestionByName("elementSelector");
    question.visible = true;
    question.choices = choices;
    question.allowClear = false;
    question.optionsCaption = this.getSelectorOptionsText(this.logicType);
    this.setInitialElementValue(question, this.initialLogicAction, selectedElement);
  }
  getSelectedElement() {
    const question = this.panel.getQuestionByName("elementSelector");
    return question.value;
  }
};
var LogicActionSetValueModel = class extends LogicActionModel {
  updatePanelElements(selectedElement, choices) {
    super.updatePanelElements(selectedElement, choices);
    this.getValueIfQuestion().placeholder = editorLocalization.getString("ed.lg.setValueExpressionPlaceholder");
    this.getValueIfPanel().visible = true;
    this.setValueExpressionValue();
  }
  afterUpdateInitialLogicAction() {
    const selectedElement = this.getElementBySelectorName(this.panel);
    if (!!selectedElement) {
      selectedElement.setValueExpression = this.panel.getQuestionByName("setValueExpression").value;
    }
  }
  setValueExpressionValue() {
    const selectedElement = this.getElementBySelectorName(this.panel);
    if (!!selectedElement) {
      this.getValueIfQuestion().value = selectedElement.setValueExpression;
    }
  }
  getValueIfPanel() {
    return this.panel.getElementByName("setValueIfPanel");
  }
  getValueIfQuestion() {
    return this.panel.getQuestionByName("setValueExpression");
  }
  resetElements() {
    super.resetElements();
    this.getValueIfPanel().visible = false;
    this.getValueIfQuestion().clearValue();
  }
};
var LogicActionTriggerModel = class extends LogicActionModelBase {
  recreateQuestion(panel, obj, name, options) {
    const oldQuestion = !!name ? panel.getQuestionByName(name) : null;
    if (!oldQuestion) return;
    const triggerEditorPanel = panel.getElementByName("triggerEditorPanel");
    const tempPanel = Serializer.createClass("panel");
    const propGenerator = new PropertyJSONGenerator(obj, options);
    propGenerator.setupObjPanel(tempPanel, true, "logic");
    let newQuestion = tempPanel.getQuestionByName(name);
    if (!!newQuestion) {
      if (!Helpers.isTwoValueEquals(newQuestion.toJSON(), oldQuestion.toJSON())) {
        let index = triggerEditorPanel.elements.indexOf(oldQuestion);
        triggerEditorPanel.blockAnimations();
        triggerEditorPanel.addElement(newQuestion, index);
        oldQuestion.delete();
        triggerEditorPanel.releaseAnimations();
      } else {
        newQuestion = oldQuestion;
      }
      if (newQuestion.name === "setValue") {
        this.updateSetValueQuestion(newQuestion);
      }
    }
    this.updateVisibilityPanel(triggerEditorPanel);
    tempPanel.dispose();
  }
  updateSetValueQuestion(question) {
    const obj = question.obj;
    let survey = obj.getSurvey();
    if (!survey) {
      survey = obj["owner"];
    }
    if (!obj["setToName"] || !survey) return;
    const originalQuestion = survey.getQuestionByValueName(obj["setToName"]);
    question.title = originalQuestion.title;
    question.titleLocation = "top";
  }
  updateRunExpressionQuestion(question) {
    question.titleLocation = "hidden";
    question.placeholder = editorLocalization.getString("pe.emptyExpressionPlaceHolder");
  }
  createElementPanelObj() {
    const action = this.initialLogicAction;
    const srcElement = !!action && action.logicType == this.logicType ? action.element : null;
    const newObj = this.logicType.createNewObj(srcElement);
    this.setPanelObj(newObj);
    return newObj;
  }
  getQuestions() {
    const triggerQuestionsPanel = this.panel.getElementByName("triggerQuestionsPanel");
    if (triggerQuestionsPanel.elements.length === 0 || !this.logicType.questionNames) {
      return null;
    }
    return triggerQuestionsPanel.elements.filter((el) => this.logicType.questionNames.indexOf(el.name) !== -1);
  }
  resetPanel(panelName) {
    const panel = this.panel.getElementByName(panelName);
    panel.questions.forEach((q) => {
      q.clearValue();
    });
    panel.elements.splice(0, panel.elements.length);
    panel.visible = false;
  }
  updateVisibilityPanel(panel) {
    if (panel.elements.length > 0) {
      panel.visible = panel.elements.filter((el) => el.visible).length > 0;
    } else {
      panel.visible = false;
    }
  }
  onPanelQuestionValueChanged(panel, qName) {
    if (this.panelObj) {
      const prop = Serializer.findProperty(this.panelObj.getType(), qName);
      const depProps = prop === null || prop === void 0 ? void 0 : prop.getDependedProperties();
      if (Array.isArray(depProps) && depProps.length > 0) {
        depProps.forEach((dp) => {
          const dQ = panel.getQuestionByName(dp);
          const dProp = Serializer.findProperty(this.panelObj.getType(), dp);
          if (!!dQ && !!dProp) {
            PropertyGridEditorCollection.onMasterValueChanged(this.panelObj, dProp, dQ);
          }
        });
      }
    }
  }
  updatePanelQuestionsValue(panel) {
    panel.onSurveyLoad();
    panel.questions.forEach((q) => {
      if (!Helpers.isValueEmpty(this.panelObj[q.getValueName()])) {
        q.value = this.panelObj[q.getValueName()];
      }
    });
  }
  constructor(panel, logicAction, logicType) {
    super(panel, logicAction, logicType);
    this.isTrigger = true;
  }
  afterUpdateInitialLogicAction() {
    this.setPanelObj(this.initialLogicAction.element);
    if (!!this.panelObj) {
      this.logicType.saveNewElement(this.panelObj);
    }
  }
  updateCurrentLogicAction(survey) {
    const createNewAction = !this.initialLogicAction || this.initialLogicAction.logicType != this.logicType;
    if (!createNewAction) {
      const el = this.initialLogicAction.element;
      const srcJson = this.panelObj.toJSON();
      const destJson = el.toJSON();
      const srcKeys = Object.keys(srcJson);
      const destKeys = Object.keys(destJson);
      const propsToDelete = [];
      const propsToSet = [];
      destKeys.forEach((key) => {
        if (srcKeys.indexOf(key) < 0) {
          propsToDelete.push(key);
        }
      });
      srcKeys.forEach((key) => {
        if (!Helpers.isTwoValueEquals(srcJson[key], destJson[key])) {
          propsToSet.push(key);
        }
      });
      propsToDelete.forEach((prop) => el.resetPropertyValue(prop));
      propsToSet.forEach((prop) => el[prop] = srcJson[prop]);
      this.currentLogicAction = this.initialLogicAction;
      return false;
    }
    this.currentLogicAction = new SurveyLogicAction(this.logicType, this.panelObj, survey);
    return true;
  }
  updatePanel(propertyName, newValue, options, survey) {
    if (!this.panelObj) return;
    this.panelObj[propertyName] = newValue;
    if (!!this.logicType && this.logicType.dependedOnPropertyName === propertyName) {
      this.recreateQuestion(this.panel, this.panelObj, this.logicType.dynamicPropertyName, options);
    }
    this.panel.runCondition(survey.getAllValues(), {
      survey
    });
  }
  setPanelObj(obj) {
    const oldPanelObj = this.panelObj;
    if (!!oldPanelObj) {
      oldPanelObj.onPropertyValueChangedCallback = void 0;
    }
    this.panelObj = obj;
    if (!!obj) {
      obj.onPropertyValueChangedCallback = (name, oldValue, newValue, sender, arrayChanges) => {
        if (!this.panel || this.panel.isDisposed) {
          oldPanelObj.onPropertyValueChangedCallback = void 0;
          return;
        }
        const q = this.panel.getQuestionByName(name);
        if (!!q) {
          q.value = newValue;
        }
      };
    }
  }
  resetElements() {
    this.setPanelObj(null);
    this.resetPanel("triggerQuestionsPanel");
    this.resetPanel("triggerEditorPanel");
  }
  updatePanelElements(selectedElement, options) {
    const triggerEditorPanel = this.panel.getElementByName("triggerEditorPanel");
    const triggerQuestionsPanel = this.panel.getElementByName("triggerQuestionsPanel");
    const obj = this.createElementPanelObj();
    const propGenerator = new PropertyJSONGenerator(obj, options);
    propGenerator.setupObjPanel(triggerEditorPanel, true, "logic");
    triggerEditorPanel.title = "";
    const runExpressionQuestion = triggerEditorPanel.getQuestionByName("runExpression");
    runExpressionQuestion && this.updateRunExpressionQuestion(runExpressionQuestion);
    if (!!this.logicType.questionNames) {
      const questionsToMove = triggerEditorPanel.elements.filter((el) => this.logicType.questionNames.indexOf(el.name) !== -1);
      questionsToMove.forEach((q) => {
        const question = q;
        if (question.getType() === "dropdown") {
          question.allowClear = false;
          question.renderAs = "logicoperator";
        }
        triggerQuestionsPanel.addQuestion(question);
      });
    }
    triggerEditorPanel.getElementByName(this.logicType.propertyName).visible = false;
    this.updateVisibilityPanel(triggerQuestionsPanel);
    this.updatePanelQuestionsValue(triggerQuestionsPanel);
    this.updateVisibilityPanel(triggerEditorPanel);
    this.updatePanelQuestionsValue(triggerEditorPanel);
    const questions = this.getQuestions();
    if (!!questions && !!selectedElement) {
      questions.forEach((question) => {
        this.setInitialElementValue(question, this.initialLogicAction, selectedElement);
        selectedElement = null;
      });
    }
  }
  getSelectedElement() {
    const questions = this.getQuestions();
    if (!questions) return;
    const question = questions[0];
    return !!question && question.value;
  }
};
function logicTypeVisibleIf(params) {
  if (!this.question || !this.question.parentQuestion || params.length != 1) return true;
  const panels = this.question.parentQuestion.panels;
  if (panels.length < 2) return true;
  for (let i = 0; i < panels.length; i++) {
    const q = panels[i].getQuestionByName("logicTypeName");
    if (q == this.question) continue;
    if (q.value == params[0]) return false;
  }
  return true;
}
FunctionFactory.Instance.register("logicTypeVisibleIf", logicTypeVisibleIf);
var LogicItemEditor = class extends PropertyEditorSetupValue {
  constructor(editableItem, options = null) {
    super(options);
    this.options = options;
    this.initialSelectedElements = {};
    this.isModifiedValue = false;
    this.selectorElementsHash = {};
    if (!this.options) {
      this.options = new EmptySurveyCreatorOptions();
    }
    this.editSurvey.onDynamicPanelItemValueChanged.add((sender, options2) => {
      if (options2.name == "logicTypeName") {
        this.onLogicTypeChanged(options2.panel);
      }
      const actionModel = this.getActionModelByPanel(options2.panel);
      if (actionModel.isTrigger) {
        actionModel.updatePanel(options2.name, options2.value, this.options, this.editSurvey);
      }
    });
    this.editSurvey.onDynamicPanelRemoved.add((sender, options2) => {
      if (this.isBuildingPanels) return;
      const actionModel = this.getActionModelByPanel(options2.panel);
      if (!!actionModel && !!actionModel.initialLogicAction) {
        this.editableItem.removeAction(actionModel.initialLogicAction);
      }
      if (this.panel.panelCount == 0) {
        this.panel.addPanel();
      }
      if (this.panel.panelCount > 0) this.panels[0].getQuestionByName("logicTypeName").title = editorLocalization.getString("pe.then");
    });
    this.editSurvey.onDynamicPanelAdded.add((sender, options2) => {
      if (this.isBuildingPanels) return;
      const panel = this.panels[this.panel.panelCount - 1];
      this.onPanelAdded(panel, null);
    });
    this.editSurvey.css = logicCss;
    this.editSurvey.onUpdateQuestionCssClasses.add((sender, options2) => {
      this.onUpdateQuestionCssClasses(options2);
    });
    this.editSurvey.onUpdatePanelCssClasses.add((sender, options2) => {
      this.onUpdatePanelCssClasses(options2);
    });
    this.editSurvey.onQuestionAdded.add((sender, options2) => {
      this.onQuestionAdded(options2);
    });
    this.editSurvey.onGetQuestionTitleActions.add((sender, options2) => {
      this.onGetQuestionTitleActions(options2);
    });
    this.editSurvey.onValueChanged.add((sender, options2) => {
      this.onValueChanged(options2);
    });
    this.editSurvey.onDynamicPanelItemValueChanged.add((sender, options2) => {
      var _a;
      const q = options2.panel.getQuestionByName(options2.name);
      if (!!q && ((_a = q.parent) === null || _a === void 0 ? void 0 : _a.name) === "triggerEditorPanel") {
        const action = this.getActionModelByPanel(options2.panel);
        if (action) {
          action.onPanelQuestionValueChanged(q.parent, options2.name);
        }
      }
    });
    this.setEditableItem(editableItem);
  }
  get editableItem() {
    return this.editableItemValue;
  }
  setEditableItem(val) {
    this.editableItemValue = val;
    this.buildInitialSelectedElements();
    this.buildPanels();
    this.resetModified();
  }
  get survey() {
    return this.editableItem.survey;
  }
  get isModified() {
    return this.isModifiedValue;
  }
  get panel() {
    return this.editSurvey.getQuestionByName("panel");
  }
  get panels() {
    return this.panel.panels;
  }
  getActionModelByPanel(panel) {
    return panel["actionModel"];
  }
  setActionModelByPanel(panel, actionModel) {
    panel["actionModel"] = actionModel;
  }
  get context() {
    return this.contextValue;
  }
  set context(val) {
    if (val === this.context) return;
    this.contextValue = val;
    this.updatePanelsOnContextChanged();
  }
  getLogicTypeByPanel(panel) {
    return this.getLogicTypeByName(panel.getQuestionByName("logicTypeName").value);
  }
  getSurveyJSON() {
    return {
      clearInvisibleValues: "onHidden",
      elements: [{
        type: "paneldynamic",
        name: "panel",
        title: getLogicString("actionsEditorTitle"),
        titleLocation: "hidden",
        addPanelText: getLogicString("addNewAction"),
        removePanelButtonLocation: "right",
        panelCount: 0,
        minPanelCount: 1,
        maxPanelCount: 1,
        templateElements: [{
          name: "logicTypeName",
          type: "dropdown",
          renderAs: "logicoperator",
          searchEnabled: false,
          allowClear: false,
          title: editorLocalization.getString("pe.then"),
          titleLocation: "left",
          isRequired: true,
          optionsCaption: getLogicString("selectedActionCaption"),
          requiredErrorText: this.getLocString("pe.conditionActionEmpty")
        }, {
          name: "logicTypeDescription",
          type: "html",
          startWithNewLine: false,
          visible: false
          // TODO we do not show description by the new design
        }, {
          name: "elementSelector",
          type: "dropdown",
          renderAs: "logicoperator",
          allowClear: false,
          titleLocation: "hidden",
          isRequired: true,
          startWithNewLine: false,
          visible: false
        }, {
          name: "triggerQuestionsPanel",
          type: "panel",
          startWithNewLine: false,
          visible: false
        }, {
          name: "removeAction",
          type: "linkvalue",
          titleLocation: "hidden",
          showOptionsCaption: false,
          visible: false,
          startWithNewLine: false,
          showValueInLink: false,
          allowClear: false,
          showClear: false,
          iconName: "icon-delete_24x24"
        }, {
          name: "triggerEditorPanel",
          type: "panel",
          visible: false
        }, {
          name: "setValueIfPanel",
          visible: false,
          type: "panel",
          elements: [{
            name: "setValueExpression",
            type: "comment",
            titleLocation: "hidden"
          }]
        }]
      }]
    };
  }
  getSurveyCreationReason() {
    return "logic-item-editor";
  }
  resetModified() {
    this.isModifiedValue = false;
  }
  isEmpty() {
    if (this.panels.length === 0) return true;
    if (this.panels.length > 1) return false;
    const modelAction = this.getActionModelByPanel(this.panels[0]);
    return !modelAction;
  }
  apply() {
    if (this.editSurvey.hasErrors()) return false;
    for (let i = 0; i < this.panels.length; i++) {
      this.applyPanel(this.panels[i]);
    }
    this.resetModified();
    return true;
  }
  getEditingActions() {
    return this.panels.map((panel) => {
      const modelAction = this.getActionModelByPanel(panel);
      modelAction.updateCurrentLogicAction(this.survey);
      return modelAction.currentLogicAction || modelAction.initialLogicAction;
    }).filter((action) => !!action);
  }
  onUpdateQuestionCssClasses(options) {
    var _a;
    const cssClasses = options.cssClasses;
    const question = options.question;
    if (question.getType() !== "paneldynamic") {
      cssClasses.answered = "svc-logic-question--answered";
    }
    if (question.name === "logicTypeName") {
      question.allowRootStyle = false;
      cssClasses.control += " svc-logic-operator svc-logic-operator--action";
      cssClasses.error.root = "svc-logic-operator__error";
      cssClasses.onError = "svc-logic-operator--error";
    }
    const selectorsNames = ["elementSelector", "setToName", "fromName", "gotoName"];
    if (selectorsNames.indexOf(question.name) > -1) {
      question.allowRootStyle = false;
      if (question.name === "setToName" || question.name === "fromName") {
        question.titleLocation = "left";
        question.startWithNewLine = false;
      }
      cssClasses.control += " svc-logic-operator svc-logic-operator--question";
      cssClasses.error.root = "svc-logic-operator__error";
      cssClasses.onError = "svc-logic-operator--error";
    }
    if (question.isContentElement || this.isSetValueInternalQuestion(question)) {
      assignDefaultClasses(cssClasses, question.getType());
      cssClasses.mainRoot += " svc-logic-question-value sd-element--with-frame";
    }
    const parentName = (_a = question.parent) === null || _a === void 0 ? void 0 : _a.name;
    if (selectorsNames.indexOf(question.name) < 0 && (parentName === "triggerEditorPanel" || parentName === "setValueIfPanel")) {
      const qType = question.getType();
      assignDefaultClasses(cssClasses, qType);
      if (!defaultCss[qType] && propertyGridCss[qType]) {
        copyCssClasses(cssClasses, propertyGridCss.question);
        copyCssClasses(cssClasses, propertyGridCss[qType]);
      }
      const els = question.parent.elements.filter((el) => selectorsNames.indexOf(el.name) < 0 && el.name !== "expression");
      if (question.name !== "runExpression" && qType !== "comment" || Array.isArray(els) && els.length > 1) {
        cssClasses.mainRoot += " svc-logic-question-value sd-element--with-frame";
      }
    }
    if (question.name === "removeAction") {
      question.allowRootStyle = false;
      cssClasses.mainRoot += " svc-logic-condition-remove-question";
    }
    if (question.name === "panel") {
      cssClasses.root += " svc-logic-paneldynamic";
      cssClasses.buttonAdd += " svc-logic-operator--action ";
      cssClasses.iconRemove = "svc-icon-remove";
      cssClasses.buttonRemove = "svc-logic-paneldynamic__button svc-logic-paneldynamic__remove-btn";
      cssClasses.buttonRemoveRight = "svc-logic-paneldynamic__remove-btn--right";
      cssClasses.buttonRemoveText = "svc-logic-paneldynamic__button-remove-text";
    }
  }
  isSetValueInternalQuestion(question) {
    if (this.isSetValueInternalQuestionCore(question)) return true;
    if (this.isSetValueInternalQuestionCore(question.parentQuestion)) return true;
    const parent = question.parent;
    return parent && this.isSetValueInternalQuestionCore(parent.parentQuestion);
  }
  isSetValueInternalQuestionCore(question) {
    const setValueName = "setValue";
    return (question === null || question === void 0 ? void 0 : question.name) === setValueName;
  }
  onUpdatePanelCssClasses(options) {
    const panel = options.panel;
    const cssClasses = options.cssClasses;
    const name = panel.name;
    if (name === "triggerEditorPanel" || name === "setValueIfPanel") {
      cssClasses.panel.container += " svc-logic_trigger-editor";
    }
    if (name === "triggerQuestionsPanel") {
      panel.allowRootStyle = false;
      cssClasses.panel.container += " svc-logic_trigger-questions";
    }
    if (this.isSetValueInternalQuestionCore(panel.parentQuestion)) {
      assignDefaultClasses(cssClasses, panel.getType());
    }
  }
  onValueChanged(options) {
    this.isModifiedValue = true;
    options.question.maxPanelCount = options.value.length === 1 && !options.value[0].logicTypeName ? 1 : 100;
    this.panels.forEach((panel) => {
      panel.getQuestionByName("removeAction").visible = options.value.length !== 1;
    });
  }
  onQuestionAdded(options) {
    if (options.question.name === "setToName" || options.question.name === "fromName") {
      options.question.titleLocation = "left";
      options.question.startWithNewLine = false;
    }
  }
  onGetQuestionTitleActions(options) {
    if (options.question.name === "setValue") {
      options.titleActions = [];
    }
  }
  applyPanel(panel) {
    const actionModel = this.getActionModelByPanel(panel);
    if (!actionModel.updateCurrentLogicAction(this.survey)) {
      return;
    }
    this.editableItem.replaceAction(actionModel.currentLogicAction, actionModel.initialLogicAction);
    actionModel.updateInitialLogicAction();
  }
  buildInitialSelectedElements() {
    this.initialSelectedElements = {};
    if (!this.editableItem) return;
    for (let i = 0; i < this.editableItem.actions.length; i++) {
      const action = this.editableItem.actions[i];
      if (this.isElementSelectorVisible(action.logicType)) {
        const lgName = action.logicTypeName;
        if (!this.initialSelectedElements[lgName]) {
          this.initialSelectedElements[lgName] = [];
        }
        this.initialSelectedElements[lgName].push(action.element);
      }
    }
  }
  buildPanels() {
    this.panel.panelCount = 0;
    if (!this.editableItem) return;
    this.logicTypeChoices = this.getLogicTypeChoices();
    for (let i = 0; i < this.editableItem.actions.length; i++) {
      this.onPanelAdded(this.panel.addPanel(), this.editableItem.actions[i]);
    }
    if (this.panel.panelCount == 0) {
      this.onPanelAdded(this.panel.addPanel(), null);
    }
  }
  onPanelAdded(panel, action) {
    const ltQuestion = panel.getQuestionByName("logicTypeName");
    ltQuestion.title = this.panel.panelCount > 1 ? editorLocalization.getString("pe.and") : editorLocalization.getString("pe.then");
    ltQuestion.choices = this.logicTypeChoices;
    ltQuestion.allowClear = false;
    if (!!action) {
      const newActionModel = LogicActionModelBase.createActionModel(panel, action, this.getLogicTypeByName(action.logicTypeName), this.selectorElementsHash);
      this.setActionModelByPanel(panel, newActionModel);
      ltQuestion.value = action.logicTypeName;
    }
    const removeActionLinkQuestion = panel.getQuestionByName("removeAction");
    const dynamicPanel = removeActionLinkQuestion.parentQuestion;
    removeActionLinkQuestion.linkClickCallback = () => {
      if (!!dynamicPanel) {
        dynamicPanel.removePanelUI(panel);
      }
    };
    removeActionLinkQuestion.linkSetButtonCssClasses = "svc-logic-condition-remove svc-icon-remove";
    removeActionLinkQuestion.linkValueText = "";
    return panel;
  }
  updatePanelsOnContextChanged() {
    this.logicTypeChoices = this.getLogicTypeChoices();
    if (!!this.context) {
      for (let i = this.panels.length - 1; i >= 0; i--) {
        const panel = this.panels[i];
        if (this.isPanelSupportContext(panel)) continue;
        if (i === 0 && this.panels.length === 1) {
          panel.getQuestionByName("logicTypeName").clearValue();
        } else {
          this.panel.removePanel(i);
        }
      }
    }
    for (let i = 0; i < this.panels.length; i++) {
      this.updateSelectorOnContextChanged(this.panels[i]);
    }
  }
  isPanelSupportContext(panel) {
    const logicType = this.getLogicTypeByPanel(panel);
    return !!logicType ? logicType.supportContext(this.context) : false;
  }
  updateSelectorOnContextChanged(panel) {
    const logicTypeQuestion = panel.getQuestionByName("logicTypeName");
    logicTypeQuestion.choices = this.logicTypeChoices;
    logicTypeQuestion.allowClear = false;
    const logicType = this.getLogicTypeByPanel(panel);
    if (!this.isElementSelectorVisible(logicType)) return;
    const selectorQuestion = panel.getQuestionByName("elementSelector");
    selectorQuestion.choices = this.getSelectorChoices(logicType);
    selectorQuestion.allowClear = false;
  }
  getLogicTypeChoices() {
    const res = [];
    const logicTypes = this.editableItem.getVisibleLogicTypes();
    for (let i = 0; i < logicTypes.length; i++) {
      const lt = logicTypes[i];
      if (!!this.context && !lt.supportContext(this.context)) continue;
      let item = new ItemValue(lt.name, lt.displayName);
      if (lt.isUniqueItem) {
        item.visibleIf = "logicTypeVisibleIf({item})";
      }
      res.push(item);
    }
    return res;
  }
  onLogicTypeChanged(panel) {
    const logicType = this.getLogicTypeByPanel(panel);
    const qTypeDescription = panel.getQuestionByName("logicTypeDescription");
    qTypeDescription.html = !!logicType ? logicType.description : "";
    const oldActionModel = this.getActionModelByPanel(panel);
    let prevSelectedQuestion;
    if (!!oldActionModel) {
      prevSelectedQuestion = oldActionModel.getSelectedElement();
      oldActionModel.resetElements();
    }
    if (!logicType) return;
    const newActionModel = LogicActionModelBase.createActionModel(panel, oldActionModel ? oldActionModel.initialLogicAction : null, logicType, this.selectorElementsHash);
    this.setActionModelByPanel(panel, newActionModel);
    if (newActionModel.isTrigger) {
      newActionModel.updatePanelElements(prevSelectedQuestion, this.options);
    } else {
      newActionModel.updatePanelElements(prevSelectedQuestion, this.getSelectorChoices(newActionModel.logicType));
    }
  }
  getLogicTypeByName(ltName) {
    if (!ltName) return null;
    const logicTypes = this.editableItem.getVisibleLogicTypes();
    for (let i = 0; i < logicTypes.length; i++) {
      if (logicTypes[i].name == ltName) return logicTypes[i];
    }
    return null;
  }
  isElementSelectorVisible(logicType) {
    return !!logicType && logicType.hasSelectorChoices;
  }
  getLocString(name) {
    return editorLocalization.getString(name);
  }
  getElementText(el, showTitles) {
    let text = "";
    if (showTitles) {
      text = el.locTitle.renderedHtml;
    }
    if (!text) text = el.name;
    if (el.isQuestion) {
      text = this.options.getObjectDisplayName(el, "logic-tab:question-selector", "condition", text);
    }
    return text;
  }
  getSelectorChoices(logicType) {
    if (!logicType.hasSelectorChoices) return [];
    const elements = logicType.getSelectorChoices(this.survey, this.context);
    const res = [];
    const showTitles = this.options.useElementTitles || this.options.showTitlesInExpressions;
    for (let i = 0; i < elements.length; i++) {
      let namePrefix = "";
      let textPrefix = "";
      const el = elements[i];
      const owner = logicType.getParentElement(el);
      if (owner) {
        namePrefix = owner.name + ".";
        textPrefix = this.getElementText(owner, showTitles) + ".";
      }
      const text = this.getElementText(el, showTitles);
      const value = namePrefix + el.name;
      let itemValue = new ItemValue(value, textPrefix + text);
      this.selectorElementsHash[value] = el;
      if (!!el[logicType.propertyName] && !this.isElementInInitialSelection(logicType.name, el)) {
        itemValue.enableIf = "1=2";
        itemValue.visibleIf = "1=2";
      }
      res.push(itemValue);
    }
    if (settings2.logic.questionSortOrder === "asc") {
      SurveyHelper.sortItems(res);
    }
    return res;
  }
  isElementInInitialSelection(logicTypeName, el) {
    if (!this.initialSelectedElements[logicTypeName]) return false;
    return this.initialSelectedElements[logicTypeName].indexOf(el) > -1;
  }
};
var SurveyLogicUI = class extends SurveyLogic {
  constructor(survey, options = null) {
    super(survey, options);
    this.survey = survey;
    this.options = options;
    this.itemUIHash = {};
    if (!this.options) this.options = new EmptySurveyCreatorOptions();
    this.setupToolbarItems();
  }
  update(survey = null, options = null) {
    super.update(survey, options);
    const newItemsSurveyValue = this.options.createSurvey(this.getLogicItemSurveyJSON(), "logic-items", this, (survey2) => {
      survey2.css = logicCss;
    });
    this.itemsSurveyValue = newItemsSurveyValue;
    this.itemsSurvey.onMatrixRowRemoving.add((sender, options2) => {
      const item = this.visibleItems[options2.rowIndex];
      options2.allow = this.canRemoveItem(item);
    });
    this.itemsSurvey.onMatrixRowRemoved.add((sender, options2) => {
      const item = this.visibleItems[options2.rowIndex];
      const isDeleteEditable = item === this.editableItem;
      this.removeItem(item, false);
      if (isDeleteEditable) {
        this.mode = "view";
        this.updateNewActionState();
      }
      this.expressionEditorCanShowBuilder = !!this.editableItem;
    });
    this.itemsSurvey.onGetMatrixRowActions.add((sender, options2) => {
      updateMatrixLogicExpandAction(options2.question, options2.actions, options2.row);
      updateMatrixLogicRemoveAction(options2.question, options2.actions, options2.row);
    });
    this.updateItemsSurveyData();
    this.onReadOnlyChanged();
  }
  dispose() {
    super.dispose();
    for (let key in this.itemUIHash) {
      const itemUI = this.itemUIHash[key];
      itemUI.expressionEditor.dispose();
      itemUI.itemEditor.dispose();
    }
    this.itemUIHash = {};
  }
  addNewUI() {
    if (this.items.length == 0 || !this.items[this.items.length - 1].isNew) {
      this.matrixItems["lockResetRenderedTable"] = true;
      this.addNew();
      this.matrixItems["lockResetRenderedTable"] = false;
    }
    const rows = this.matrixItems.visibleRows;
    rows[rows.length - 1].showDetailPanel();
  }
  toggleExpressionEditorIsFastEntry() {
    this.expressionEditorIsFastEntry = !this.expressionEditorIsFastEntry;
    if (!!this.expressionEditor) {
      this.expressionEditor.setIsFastEntry(this.expressionEditorIsFastEntry);
    }
  }
  updateEditableItemIsModifiedState() {
    if (!!this.editableItem) {
      this.editableItem.isModified = !!this.itemEditor && !!this.expressionEditor && (this.itemEditor.isModified || this.expressionEditor.isModified(this.editableItem.expression));
    }
  }
  getUnsavedItems() {
    const res = [];
    for (var i = 0; i < this.visibleItems.length; i++) {
      const item = this.visibleItems[i];
      const itemUI = this.findLogicItemUI(item);
      if (!itemUI) continue;
      if (item.isNew) {
        if (!itemUI.expressionEditor.isEmpty() || !itemUI.itemEditor.isEmpty()) {
          res.push(item);
        }
      } else {
        if (item.isModified) {
          res.push(item);
        }
      }
    }
    return res;
  }
  getErroredItem(items) {
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      if (this.isErroredItem(item)) return item;
    }
    return null;
  }
  isErroredItem(item) {
    const itemUI = this.findLogicItemUI(item);
    if (!itemUI) return false;
    return itemUI.expressionEditor.hasErrors() || itemUI.itemEditor.hasErrors();
  }
  showErroredItem(item) {
    const index = this.visibleItems.indexOf(item);
    const rows = this.matrixItems.visibleRows;
    const row = index > -1 && index < rows.length ? rows[index] : null;
    if (!!row) {
      rows.forEach((r) => r.hideDetailPanel());
      this.mode = "view";
      row.showDetailPanel();
      this.hasErrorInUI();
    }
  }
  saveItem(item) {
    if (this.isErroredItem(item)) return;
    !!this.options && this.options.startUndoRedoTransaction();
    this.doItemApply(item);
    !!this.options && this.options.stopUndoRedoTransaction();
  }
  tryLeaveUI(resultFunc) {
    this.updateEditableItemIsModifiedState();
    const unsavedItems = this.getUnsavedItems();
    if (unsavedItems.length === 0) {
      !!resultFunc && resultFunc(true);
      return true;
    }
    const erroredItem = this.getErroredItem(unsavedItems);
    const onLeavingFunc = () => {
      unsavedItems.forEach((item) => this.saveItem(item));
      !!resultFunc && resultFunc(true);
    };
    if (!erroredItem) {
      onLeavingFunc();
      return true;
    }
    const onStayingFunc = () => {
      this.showErroredItem(erroredItem);
      !!resultFunc && resultFunc(false);
    };
    if (this.confirmLeavingOnError(onLeavingFunc, onStayingFunc)) {
      return void 0;
    }
    onStayingFunc();
    return false;
  }
  confirmLeavingOnError(onLeaving, onStaying) {
    if (!settings.showDialog) return false;
    const locStr = new LocalizableString(void 0);
    locStr.text = this.getLocString("ed.lg.uncompletedRule_text");
    const popupModel = settings.showDialog({
      componentName: "sv-string-viewer",
      data: {
        locStr,
        locString: locStr,
        model: locStr
      },
      //TODO fix in library
      onApply: () => {
        onLeaving();
        return true;
      },
      onCancel: () => {
        onStaying();
        return true;
      },
      cssClass: "svc-creator-popup",
      title: this.getLocString("ed.lg.uncompletedRule_title"),
      displayMode: "popup"
    }, this.options.rootElement);
    const toolbar = popupModel.footerToolbar;
    const applyBtn = toolbar.getActionById("apply");
    const cancelBtn = toolbar.getActionById("cancel");
    cancelBtn.title = this.getLocString("ed.lg.uncompletedRule_cancel");
    applyBtn.title = this.getLocString("ed.lg.uncompletedRule_apply");
    applyBtn.innerCss += " svc-logic-tab__leave-apply-button";
    popupModel.width = "800px";
    return true;
  }
  onPropertyValueChanged(name, oldValue, newValue) {
    super.onPropertyValueChanged(name, oldValue, newValue);
    if (name === "items") {
      this.updateItemsSurveyData();
    }
  }
  onReadOnlyChanged() {
    if (!this.itemsSurvey) return;
    this.itemsSurvey.mode = this.readOnly ? "display" : "edit";
    Object.keys(this.itemUIHash || {}).forEach((id) => {
      this.updateEditModeLogicItem(this.itemUIHash[id]);
    });
  }
  get expressionEditor() {
    return this.expressionEditorValue;
  }
  get itemEditor() {
    return this.itemEditorValue;
  }
  getExpressionEditor(item) {
    return this.getLogicItemUI(item).expressionEditor;
  }
  getLogicItemEditor(item) {
    return this.getLogicItemUI(item).itemEditor;
  }
  updateEditModeLogicItem(item) {
    if (!item) return;
    item.expressionEditor.editSurvey.mode = this.readOnly ? "display" : "edit";
    item.itemEditor.editSurvey.mode = this.readOnly ? "display" : "edit";
  }
  getLogicItemUI(item) {
    let res = this.findLogicItemUI(item);
    if (!res) {
      const context = item.getContext();
      res = {
        expressionEditor: this.createExpressionPropertyEditor(),
        itemEditor: new LogicItemEditor(item, this.options)
      };
      this.updateEditModeLogicItem(res);
      res.expressionEditor.context = context;
      res.itemEditor.context = context;
      res.expressionEditor.text = item.expression;
      res.expressionEditor.onContextChanged = (context2) => {
        res.itemEditor.context = context2;
      };
      this.itemUIHash[item.id] = res;
    }
    return res;
  }
  findLogicItemUI(item) {
    return this.itemUIHash[item.id];
  }
  get expressionSurvey() {
    return this.expressionEditor.editSurvey;
  }
  get itemEditorSurvey() {
    return this.itemEditor.editSurvey;
  }
  get itemsSurvey() {
    return this.itemsSurveyValue;
  }
  get hasItems() {
    return this.items.length > 0;
  }
  get matrixItems() {
    return this.itemsSurvey.getQuestionByName("items");
  }
  onStartEditing() {
    super.onStartEditing();
    this.expressionEditorValue = this.getExpressionEditor(this.editableItem);
    this.itemEditorValue = this.getLogicItemEditor(this.editableItem);
    this.expressionEditorIsFastEntry = false;
    this.expressionEditor.setIsFastEntry(this.expressionEditorIsFastEntry);
    this.expressionEditorCanShowBuilder = ConditionEditor.canBuildExpression(this.expressionEditor.text);
  }
  onEndEditing() {
    this.updateEditableItemIsModifiedState();
    super.onEndEditing();
    this.expressionEditorValue = null;
    this.itemEditorValue = null;
  }
  onEditableItemApply() {
    this.doItemApply(this.editableItem);
    if (!this.editableItem.isSuitable(this.questionFilter, this.actionTypeFilter)) {
      this.questionFilter = "";
      this.actionTypeFilter = "";
    } else {
      this.updateItemsSurveyData();
    }
  }
  doItemApply(item) {
    const itemUI = this.findLogicItemUI(item);
    if (!itemUI) return;
    itemUI.expressionEditor.apply();
    itemUI.itemEditor.apply();
    item.apply(itemUI.expressionEditor.text);
    if (item.actions.length != itemUI.itemEditor.panels.length) {
      itemUI.itemEditor.setEditableItem(item);
    }
    itemUI.itemEditor.resetModified();
    item.isNew = false;
  }
  hasErrorInUI() {
    const creator = this.survey.creator;
    if (this.expressionEditor.hasErrorInUI()) {
      this.errorText = this.expressionEditor.errorText;
      return true;
    }
    if (this.itemEditor.hasErrors()) {
      this.errorText = getLogicString("actionInvalid");
      !!creator && creator.notify(this.errorText, "error");
      return true;
    }
    return false;
  }
  getExpressionText() {
    return this.expressionEditor.text;
  }
  getEditingActions() {
    return this.itemEditor.getEditingActions();
  }
  getLogicItemSurveyJSON() {
    const creator = this.survey.creator;
    const json2 = creator && creator.useTableViewInLogicTab ? this.getTwoColumnsLayout() : this.getOneColumnLayout();
    setSurveyJSONForPropertyGrid(json2);
    return json2;
  }
  getTwoColumnsLayout() {
    return {
      elements: [{
        type: "matrixdynamic",
        name: "items",
        titleLocation: "hidden",
        detailPanelMode: "underRowSingle",
        allowAddRows: false,
        allowAdaptiveActions: false,
        rowCount: 0,
        columns: [{
          cellType: "linkvalue",
          name: "conditions",
          title: this.getLocString("ed.lg.conditions")
        }, {
          cellType: "linkvalue",
          name: "actions",
          title: this.getLocString("ed.lg.actions")
        }]
      }]
    };
  }
  getOneColumnLayout() {
    return {
      elements: [{
        type: "matrixdynamic",
        name: "items",
        titleLocation: "hidden",
        showColumnHeader: false,
        detailPanelMode: "underRowSingle",
        allowAddRows: false,
        allowAdaptiveActions: false,
        rowCount: 0,
        showHeader: false,
        columns: [{
          cellType: "linkvalue",
          name: "rules",
          showTooltip: true,
          width: "100%"
        }]
      }]
    };
  }
  createExpressionPropertyEditor() {
    const res = new ConditionEditor(this.survey, null, this.options);
    res.isModal = false;
    res.editSurvey.onValueChanged.add((sender, options) => {
      if (options.name === "textEditor") {
        this.expressionEditorCanShowBuilder = ConditionEditor.canBuildExpression(options.value);
      }
    });
    return res;
  }
  getVisibleItems() {
    return this.items.filter((item) => item.isNew || item.isSuitable(this.questionFilter, this.actionTypeFilter));
  }
  getDataFromItem(item) {
    const creator = this.survey.creator;
    if (creator && creator.useTableViewInLogicTab) {
      return {
        conditions: item.expressionText,
        actions: item.actionsText
      };
    } else {
      return {
        rules: this.getLogicItemDisplayText(item)
      };
    }
  }
  getLogicItemDisplayText(item) {
    const text = item.getDisplayText();
    if (!this.options) return text;
    return this.options.onLogicGetTitleCallback(item.expression, item.expressionText, text, item);
  }
  updateItemsSurveyData() {
    if (!this.itemsSurvey) return;
    var data = [];
    this.visibleItems = this.getVisibleItems();
    this.visibleItems.forEach((item) => {
      data.push(this.getDataFromItem(item));
    });
    this.matrixItems.onHasDetailPanelCallback = (row) => {
      return true;
    };
    this.matrixItems.onCreateDetailPanelCallback = (row, panel) => {
      row.onDetailPanelShowingChanged = () => {
        this.expressionEditorCanShowBuilder = row.isDetailPanelShowing;
        if (row.isDetailPanelShowing) {
          if (this.mode === "view") {
            const logicItem = this.visibleItems[row.rowIndex - 1];
            this.editItem(logicItem);
          }
          const condQuestion = panel.getQuestionByName("conditions");
          const actionsQuestion = panel.getQuestionByName("actions");
          condQuestion.embeddedSurvey = this.expressionEditor.editSurvey;
          actionsQuestion.embeddedSurvey = this.itemEditorValue.editSurvey;
          this.updateRowIsAdditionalClasses(row.rowIndex - 1, false);
        } else {
          this.mode = "view";
          this.updateRenderedRows();
        }
        this.updateNewActionState();
      };
      panel.addNewQuestion("embeddedsurvey", "conditions");
      panel.addNewQuestion("embeddedsurvey", "actions");
      panel.footerActions.push({
        id: "saveDetailPanel",
        innerCss: "sl-panel__done-button",
        title: this.getLocString("pe.doneEditing"),
        action: () => {
          if (this.saveEditableItem()) {
            row.hideDetailPanel(true);
          }
        }
      });
    };
    this.matrixItems.onCellCreatedCallback = (options) => {
      options.cell.question.linkClickCallback = () => {
        if (options.row.isDetailPanelShowing) {
          options.row.hideDetailPanel();
        } else {
          options.row.showDetailPanel();
        }
      };
      options.cell.question.showClear = false;
      options.cell.question.allowClear = false;
    };
    this.matrixItems.value = data;
    this.updateRenderedRows();
  }
  updateRenderedRows() {
    this.visibleItems.forEach((_, index) => {
      this.updateRowIsAdditionalClasses(index, this.visibleItems[index].isModified || this.visibleItems[index].isNew);
    });
  }
  updateRowIsAdditionalClasses(index, isAdditionalClasses) {
    if (!!this.matrixItems.renderedTable) {
      const visibleRows = this.matrixItems.renderedTable.rows.filter((row) => row.visible);
      visibleRows[index].isAdditionalClasses = isAdditionalClasses;
    }
  }
  updateNewActionState() {
    this.addNewButton.enabled = this.mode !== "new";
  }
  setupToolbarItems() {
    this.addNewButton = new Action({
      id: "svd-logic-addNew",
      title: this.addNewText,
      tooltip: this.addNewText,
      component: "sv-action-bar-item",
      enabled: true,
      action: () => {
        this.addNewUI();
      }
    });
  }
  get addNewText() {
    return getLogicString("addNewItem");
  }
  get emptyTabPlaceholder() {
    return getLogicString("empty_tab");
  }
  get placeholderTitleText() {
    if (this.options.isMobileView) return getLogicString("logicPlaceholderTitleMobile");
    return getLogicString("logicPlaceholderTitle");
  }
  get placeholderDescriptionText() {
    if (this.options.isMobileView) return getLogicString("logicPlaceholderDescriptionMobile");
    return getLogicString("logicPlaceholderDescription");
  }
};
__decorate2([property()], SurveyLogicUI.prototype, "itemsSurveyValue", void 0);
__decorate2([property()], SurveyLogicUI.prototype, "expressionEditorIsFastEntry", void 0);
__decorate2([property()], SurveyLogicUI.prototype, "expressionEditorCanShowBuilder", void 0);
__decorate2([property({
  onSet: (value, target) => {
    target.updateItemsSurveyData();
  }
})], SurveyLogicUI.prototype, "questionFilter", void 0);
__decorate2([property({
  onSet: (value, target) => {
    target.updateItemsSurveyData();
  }
})], SurveyLogicUI.prototype, "actionTypeFilter", void 0);
var TabLogicPlugin = class {
  constructor(creator) {
    this.creator = creator;
    creator.addTab({
      name: "logic",
      plugin: this,
      iconName: "icon-logic-24x24"
    });
    this.createActions().forEach((action) => creator.toolbar.actions.push(action));
  }
  activate() {
    this.model = new SurveyLogicUI(this.creator.survey, this.creator);
    this.filterQuestionAction.title = this.createFilterQuestionTitleUpdater();
    this.filterQuestionAction.visible = true;
    this.filterActionTypeAction.title = this.createFilterTypeTitleUpdater();
    this.filterActionTypeAction.visible = true;
    if (this.fastEntryAction) {
      this.fastEntryAction.visible = true;
      this.fastEntryAction.active = this.model.expressionEditorIsFastEntry;
      this.fastEntryAction.enabled = false;
    }
    this.model.onPropertyChanged.add((sender, options) => {
      if (!!this.fastEntryAction && options.name === "expressionEditorIsFastEntry") {
        this.fastEntryAction.active = this.model.expressionEditorIsFastEntry;
      }
      if (!!this.fastEntryAction && options.name === "expressionEditorCanShowBuilder") {
        this.fastEntryAction.enabled = this.model.expressionEditorCanShowBuilder;
      }
    });
  }
  createFilterTypeTitleUpdater() {
    return new ComputedUpdater(() => {
      this.creator.locale;
      const type = this.model.actionTypeFilter;
      const allType = this.showAllActionTypesText;
      return !!type ? this.model.getTypeByName(type).displayName : allType;
    });
  }
  createFilterQuestionTitleUpdater() {
    return new ComputedUpdater(() => {
      this.creator.locale;
      const questionFilter = this.model.questionFilter;
      const allQuestions = this.showAllQuestionsText;
      return !!questionFilter ? questionFilter : allQuestions;
    });
  }
  update() {
    if (!this.model) return;
    this.model.update(this.creator.survey);
  }
  canDeactivateAsync(onSuccess) {
    if (!!this.model) {
      this.model.tryLeaveUI((res) => {
        if (!res) {
          this.creator.notify(editorLocalization.getString("ed.lg.expressionInvalid"), "error");
        } else {
          onSuccess();
        }
      });
      return;
    }
    onSuccess();
  }
  deactivate() {
    this.disposeObjs();
    return true;
  }
  dispose() {
    this.disposeObjs();
  }
  disposeObjs() {
    this.filterActionTypeAction.title = void 0;
    this.filterQuestionAction.title = void 0;
    if (this.model) {
      this.model.dispose();
      this.model = void 0;
    }
    this.filterQuestionAction.visible = false;
    this.filterActionTypeAction.visible = false;
    this.fastEntryAction && (this.fastEntryAction.visible = false);
  }
  createActions() {
    const items = [];
    const onQuestionPopupShow = () => {
      const items2 = this.model.getUsedQuestions().map((question) => {
        return {
          id: question.name,
          title: this.creator.getObjectDisplayName(question, "logic-tab:question-filter", "condition", question.name)
        };
      });
      SurveyHelper.sortItems(items2, "title");
      const listModel = this.filterQuestionAction.popupModel.contentComponentData.model;
      listModel.setItems([{
        id: null,
        title: this.showAllQuestionsText
      }].concat(items2));
    };
    this.filterQuestionAction = createDropdownActionModelAdvanced({
      id: "svc-logic-filter-question",
      visible: false
    }, {
      items: [{
        id: null,
        title: this.showAllQuestionsText
      }],
      onSelectionChanged: (item) => {
        this.model.questionFilter = !!item.id ? item.id : "";
      },
      allowSelection: true,
      cssClasses: listComponentCss,
      locOwner: this.creator
    }, {
      verticalPosition: "bottom",
      horizontalPosition: "center",
      cssClass: "svc-creator-popup",
      onShow: onQuestionPopupShow
    });
    items.push(this.filterQuestionAction);
    const onActionTypesPopupShow = () => {
      const items2 = this.model.getUsedActionTypes().map((type) => {
        return {
          id: type.name,
          title: type.displayName
        };
      });
      SurveyHelper.sortItems(items2, "title");
      const listModel = this.filterActionTypeAction.popupModel.contentComponentData.model;
      listModel.setItems([{
        id: null,
        title: this.showAllActionTypesText
      }].concat(items2));
    };
    this.filterActionTypeAction = createDropdownActionModelAdvanced({
      id: "svc-logic-filter-actiontype",
      visible: false
    }, {
      items: [{
        id: null,
        title: this.showAllActionTypesText
      }],
      onSelectionChanged: (item) => {
        this.model.actionTypeFilter = !!item.id ? item.id : "";
      },
      allowSelection: true,
      cssClasses: listComponentCss,
      locOwner: this.creator
    }, {
      verticalPosition: "bottom",
      horizontalPosition: "center",
      cssClass: "svc-creator-popup",
      onShow: onActionTypesPopupShow
    });
    items.push(this.filterActionTypeAction);
    if (this.creator.allowEditExpressionsInTextEditor) {
      this.fastEntryAction = new Action({
        id: "svc-logic-fast-entry",
        iconName: "icon-fast-entry",
        iconSize: "auto",
        locTitleName: "pe.fastEntry",
        visible: false,
        component: "sv-action-bar-item",
        action: () => {
          this.model.toggleExpressionEditorIsFastEntry();
        }
      });
      items.push(this.fastEntryAction);
    }
    return items;
  }
  get showAllQuestionsText() {
    return getLogicString("showAllQuestions");
  }
  get showAllActionTypesText() {
    return getLogicString("showAllActionTypes");
  }
};
var UndoRedoController = class extends Base {
  onSurveyPropertyValueChangedCallback(name, oldValue, newValue, sender, arrayChanges) {
    if (!this.undoRedoManager || !this.undoRedoManager.isCorrectProperty(sender, name)) {
      return;
    }
    const canUndoRedoMerge = this.undoRedoManager.tryMergeTransaction(sender, name, newValue);
    if (!canUndoRedoMerge) {
      this.undoRedoManager.startTransaction(name + " changed");
      this.undoRedoManager.onPropertyValueChanged(name, oldValue, newValue, sender, arrayChanges);
      this.creator.updateElementsOnLocaleChanged(sender, name);
      this.creator.updateConditionsOnNameChanged(sender, name, oldValue);
      this.undoRedoManager.stopTransaction();
    } else {
      this.creator.notifySurveyPropertyChanged({
        name,
        target: sender,
        oldValue,
        newValue
      });
    }
  }
  constructor(creator) {
    super();
    this.creator = creator;
    this.undoRedoManager = void 0;
    this.onBeforeUndo = new EventBase();
    this.onBeforeRedo = new EventBase();
    this.updateSurvey();
  }
  updateSurvey() {
    const surveyModel = this.creator.survey;
    if (!!surveyModel) {
      surveyModel.onPropertyValueChangedCallback = (name, oldValue, newValue, sender, arrayChanges) => {
        this.onSurveyPropertyValueChangedCallback(name, oldValue, newValue, sender, arrayChanges);
      };
    }
    this.undoRedoManager = new UndoRedoManager();
    this.undoRedoManager.changesFinishedCallback = (actions, isUndo) => {
      if (this.notifySurveyMoveItem(actions, isUndo)) return;
      for (let i = actions.length - 1; i >= 0; i--) {
        const action = actions[i];
        if (!!action) {
          const changes = action.getChanges(isUndo);
          this.creator.notifySurveyPropertyChanged({
            name: changes.propertyName,
            target: changes.object,
            oldValue: changes.oldValue,
            newValue: changes.newValue
          });
        }
      }
    };
    this.undoRedoManager.canUndoRedoCallback = () => {
      this.updateUndeRedoActions();
    };
    this.updateUndeRedoActions();
  }
  notifySurveyMoveItem(actions, isUndo) {
    if (actions.length !== 2) ;
    const act1 = actions[0];
    const act2 = actions[1];
    if (!act1 || !act2) return false;
    const changes1 = act1.getChanges(isUndo);
    const changes2 = act2.getChanges(isUndo);
    if (changes1.object !== changes2.object || changes1.propertyName !== changes2.propertyName) return false;
    const act1Del = act1.getDeletedElement(isUndo);
    const act1Ins = act1.getInsertedElement(isUndo);
    const act2Del = act2.getDeletedElement(isUndo);
    const act2Ins = act2.getInsertedElement(isUndo);
    if (act1Del === act1Ins || act1Del !== act2Ins && act1Ins !== act2Del) return false;
    const indexFrom = act1Del ? act1.getIndex() : act2.getIndex();
    const indexTo = act1Ins ? act1.getIndex() : act2.getIndex();
    if (indexFrom === indexTo && !!act1Del && !!act2Ins && !act1Ins && !act2Del) {
      this.creator.notifySurveyItemConverted(!isUndo ? act2Ins : act1Del, !isUndo ? act1Del : act2Ins);
    } else {
      this.creator.notifySurveyItemMoved({
        arrayName: changes1.propertyName,
        parent: changes1.object,
        element: act1Del ? act1Del : act1Ins,
        indexFrom: !isUndo ? indexFrom : indexTo,
        indexTo: !isUndo ? indexTo : indexFrom
      });
    }
    return true;
  }
  selectElementAfterUndo() {
    this.selectElementAfterUndoCore(this.creator.selectedElement);
  }
  selectElementAfterUndoCore(obj) {
    if (!!obj && !obj.isDisposed && !!obj.getSurvey() && (!this.creator.isObjQuestion(obj) || !!obj["parent"])) {
      this.creator.selectElement(obj);
      return;
    }
    this.creator.selectElement(this.creator.survey);
  }
  undo() {
    if (!this.undoRedoManager) return;
    this.undoRedoManager.suspend();
    const canUndo = this.undoRedoManager.canUndo();
    var options = {
      canUndo,
      allow: canUndo
    };
    this.onBeforeUndo.fire(this.creator, options);
    this.creator.onBeforeUndo.fire(this.creator, options);
    if (options.canUndo) {
      this.undoRedoManager.undo();
      this.selectElementAfterUndo();
    }
    this.undoRedoManager.resume();
  }
  redo() {
    if (!this.undoRedoManager) return;
    const canRedo = this.undoRedoManager.canRedo();
    const options = {
      canRedo,
      allow: canRedo
    };
    this.onBeforeRedo.fire(this.creator, options);
    this.creator.onBeforeRedo.fire(this.creator, options);
    if (options.canRedo) {
      this.undoRedoManager.redo();
      this.selectElementAfterUndo();
    }
  }
  startTransaction(name = "") {
    this.undoRedoManager && this.undoRedoManager.startTransaction(name);
  }
  stopTransaction() {
    this.undoRedoManager && this.undoRedoManager.stopTransaction();
  }
  createActions() {
    const items = [];
    this.undoAction = new Action({
      id: "action-undo",
      iconName: "icon-undo",
      iconSize: "auto",
      locTitleName: "ed.undo",
      showTitle: false,
      visible: new ComputedUpdater(() => this.creator.activeTab === "designer"),
      needSeparator: new ComputedUpdater(() => {
        return this.creator.isMobileView;
      }),
      action: () => this.undo()
    });
    this.redoAction = new Action({
      id: "action-redo",
      iconName: "icon-redo",
      iconSize: "auto",
      locTitleName: "ed.redo",
      showTitle: false,
      visible: new ComputedUpdater(() => this.creator.activeTab === "designer"),
      action: () => this.redo()
    });
    items.push(this.undoAction);
    items.push(this.redoAction);
    this.updateUndeRedoActions();
    return items;
  }
  updateUndeRedoActions() {
    if (!!this.undoAction) {
      this.undoAction.enabled = this.undoRedoManager.canUndo();
      this.redoAction.enabled = this.undoRedoManager.canRedo();
    }
  }
};
__decorate2([property()], UndoRedoController.prototype, "undoRedoManager", void 0);
var UndoRedoPlugin = class {
  constructor(creator) {
    this.creator = creator;
    this.model = void 0;
    this.model = new UndoRedoController(creator);
    this.model.createActions().forEach((action) => creator.toolbar.actions.push(action));
    creator.registerShortcut("undo", {
      affectedTab: "designer",
      hotKey: {
        ctrlKey: true,
        keyCode: 90
      },
      macOsHotkey: {
        keyCode: 90
      },
      execute: () => this.model.undo()
    });
    creator.registerShortcut("redo", {
      affectedTab: "designer",
      hotKey: {
        ctrlKey: true,
        keyCode: 89
      },
      macOsHotkey: {
        keyCode: 89
      },
      execute: () => this.model.redo()
    });
  }
  activate() {
  }
  deactivate() {
    return true;
  }
  update() {
  }
  addFooterActions() {
    this.model.undoAction && this.creator.footerToolbar.actions.splice(2, 0, this.model.undoAction);
    this.model.redoAction && this.creator.footerToolbar.actions.splice(3, 0, this.model.redoAction);
  }
};
function undoRedoTransaction(transactionName, undoRedoManagerProperty = "undoRedoManager") {
  return function(target, propertyKey, descriptor) {
    const wrappedFunction = descriptor.value;
    descriptor.value = function(...args) {
      const undoRedoManager = this[undoRedoManagerProperty];
      try {
        undoRedoManager && undoRedoManager.startTransaction(transactionName || propertyKey);
        const result = wrappedFunction.apply(this, args);
        return result;
      } finally {
        undoRedoManager && undoRedoManager.stopTransaction();
      }
    };
    return descriptor;
  };
}
function ignoreUndoRedo(undoRedoManagerProperty = "undoRedoManager") {
  return function(target, propertyKey, descriptor) {
    const wrappedFunction = descriptor.value;
    descriptor.value = function(...args) {
      const undoRedoManager = this[undoRedoManagerProperty];
      try {
        undoRedoManager && undoRedoManager.suspend();
        const result = wrappedFunction.apply(this, args);
        return result;
      } finally {
        undoRedoManager && undoRedoManager.resume();
      }
    };
    return descriptor;
  };
}
var ObjectSelectorItem = class extends Action {
  constructor(id, data, title, level) {
    super({
      id: "sv_item_selector_" + id.toString(),
      title
    });
    this.data = data;
    this.level = level;
  }
  hasText(filteredTextInLow) {
    if (!filteredTextInLow) return true;
    if (!this.textInLow) {
      this.textInLow = this.title.toLocaleLowerCase();
    }
    return this.textInLow.indexOf(filteredTextInLow) > -1;
  }
};
var ObjectSelector = class _ObjectSelector {
  constructor(creator, survey, getObjectDisplayName = void 0) {
    this.creator = creator;
    this.getObjectDisplayName = getObjectDisplayName;
    this.surveyValue = survey;
    this.rebuild();
  }
  get survey() {
    return this.surveyValue;
  }
  get items() {
    return this.itemsValue;
  }
  getItemByObj(obj) {
    var items = this.items;
    for (var i = 0; i < items.length; i++) {
      if (items[i].data === obj) return items[i];
    }
    return null;
  }
  filterByText(filteredText) {
    this.filteredTextInLow = !!filteredText ? filteredText.toLocaleLowerCase() : "";
    this.updateItemsVisibility();
  }
  rebuild() {
    var objs = [];
    this.deepestLevel = 0;
    var root = this.createItem(this.survey, null);
    objs.push(root);
    for (var i = 0; i < this.survey.pages.length; i++) {
      var page = this.survey.pages[i];
      var itemsParent = root;
      if (!this.creator || this.creator.pageEditMode !== "single") {
        var pageItem = this.createItem(page, root);
        objs.push(pageItem);
        itemsParent = pageItem;
      }
      this.buildElements(objs, this.getElements(page), itemsParent);
    }
    this.itemsValue = objs;
  }
  updateItemsVisibility() {
    for (var i = this.deepestLevel; i >= 0; i--) {
      this.updateItemsLevelVisibility(i);
    }
  }
  updateItemsLevelVisibility(level) {
    for (var i = 0; i < this.items.length; i++) {
      var item = this.items[i];
      if (item.level !== level) continue;
      item.visible = this.hasVisibleChildren(i) || item.hasText(this.filteredTextInLow);
    }
  }
  hasVisibleChildren(index) {
    var level = this.items[index].level;
    for (var i = index + 1; i < this.items.length; i++) {
      if (this.items[i].level <= level) return false;
      if (this.items[i].visible) return true;
    }
    return false;
  }
  getElements(element) {
    return SurveyHelper.getElements(element);
  }
  buildElements(objs, elements, parentItem) {
    for (var i = 0; i < elements.length; i++) {
      var el = elements[i];
      var item = this.createItem(el, parentItem);
      objs.push(item);
      this.buildElements(objs, this.getElements(el), item);
    }
  }
  createItem(obj, parent) {
    var item = new ObjectSelectorItem(_ObjectSelector.uniqueId++, obj, this.getText(obj), parent != null ? parent.level + 1 : 0);
    if (item.level > this.deepestLevel) {
      this.deepestLevel = item.level;
    }
    return item;
  }
  getText(obj) {
    var text = !!this.getObjectDisplayName ? this.getObjectDisplayName(obj, "property-grid-header:element-list", "property-grid", void 0) : SurveyHelper.getObjectName(obj, false);
    return text;
  }
};
ObjectSelector.uniqueId = 0;
var ObjectSelectorModel = class extends Base {
  constructor(creator, getObjectDisplayName = void 0) {
    super();
    this.creator = creator;
    this.getObjectDisplayName = getObjectDisplayName;
  }
  get list() {
    return this.listModelValue;
  }
  show(survey, selectedObj, onClose) {
    this.selector = new ObjectSelector(this.creator, survey, this.getObjectDisplayName);
    const selectedItem = this.selector.getItemByObj(selectedObj);
    if (!this.listModelValue) {
      this.listModelValue = new ListModel({
        items: this.selector.items,
        onSelectionChanged: (item) => {
          onClose(item.data);
        },
        allowSelection: true,
        cssClasses: listComponentCss,
        selectedItem
      });
      this.listModelValue.setOnFilterStringChangedCallback((text) => {
        this.selector.filterByText(text);
      });
    } else {
      this.listModelValue.setItems(this.selector.items);
      this.listModelValue.selectedItem = selectedItem;
    }
    this.isVisible = true;
  }
  refresh() {
    this.listModelValue.refresh();
  }
};
__decorate2([property()], ObjectSelectorModel.prototype, "isVisible", void 0);
var SearchManagerPropertyGrid = class extends SearchManager {
  getFilterStringPlaceholder() {
    return getLocString("ed.propertyGridFilteredTextPlaceholder");
  }
  get propertyGridNoResultsFound() {
    return getLocString("ed.propertyGridNoResultsFound");
  }
  expandAllParents(element) {
    if (!element) return;
    if (element.page && element.survey) {
      element.survey.currentPage = element.page;
    }
    if (element.isCollapsed) {
      this.lastCollapsedElement = element;
      element.expand(false);
    }
    this.expandAllParents(element.parent);
    this.expandAllParents(element.parentQuestion);
  }
  switchHighlightedEditor(index) {
    this.currentMatchIndex = index;
    const prevMatch = this.currentMatch;
    this.currentMatch = this.allMatches[index];
    prevMatch === null || prevMatch === void 0 ? void 0 : prevMatch.updateElementCss(true);
    if (!!this.currentMatch && prevMatch !== this.currentMatch) {
      this.currentMatch.updateElementCss(true);
      const lastCollapsedElement = this.lastCollapsedElement;
      this.expandAllParents(this.currentMatch);
      const newPanelExpanded = this.lastCollapsedElement != lastCollapsedElement;
      setTimeout(() => {
        var _a;
        const elementId = (_a = this.currentMatch) === null || _a === void 0 ? void 0 : _a.id;
        scrollElementIntoView(elementId);
      }, newPanelExpanded ? 400 : 10);
    }
    this.updatedMatchCounterText(index);
  }
  updatedMatchCounterText(index) {
    const count2 = this.allMatches.length;
    if (count2 === 1) {
      this.matchCounterText = "";
    } else if (this.currentMatch) {
      const value = index + 1;
      this.matchCounterText = [value, count2].join("/");
    } else {
      this.matchCounterText = !!this.filterString ? this.propertyGridNoResultsFound : "";
    }
  }
  navigateToEditor(index) {
    if (index < 0) {
      index = this.allMatches.length - 1;
    }
    if (index >= this.allMatches.length) {
      index = 0;
    }
    this.switchHighlightedEditor(index);
  }
  getAllMatches(newFilter) {
    const normalize = settings.comparator.normalizeTextCallback;
    let newValueInLow = normalize(newFilter, "search");
    newValueInLow = newValueInLow.toLocaleLowerCase().trim();
    const visibleQuestions = this.survey.getAllQuestions().filter((q) => q.isVisible);
    return visibleQuestions.filter((q) => {
      let srcString = q.name + "|" + q.title + "|" + q.description;
      if (!!srcString) {
        srcString = normalize(srcString, "search");
        srcString = srcString.toLocaleLowerCase().trim();
      }
      return srcString.indexOf(newValueInLow) !== -1;
    });
  }
  setFiterString(newValue, oldValue) {
    if (!newValue) {
      this.reset();
      return;
    }
    this.allMatches = this.getAllMatches(newValue);
    if (this.allMatches.length === 0) {
      this.reset();
      return;
    }
    const newCurrentIndex = this.allMatches.indexOf(this.currentMatch);
    this.switchHighlightedEditor(newCurrentIndex === -1 ? 0 : newCurrentIndex);
  }
  reset() {
    this.allMatches = [];
    this.currentMatchIndex = -1;
    const prevMatch = this.currentMatch;
    this.currentMatch = void 0;
    prevMatch === null || prevMatch === void 0 ? void 0 : prevMatch.updateElementCss(true);
    this.updatedMatchCounterText(-1);
  }
  getSearchActions() {
    const searchActions = super.getSearchActions();
    searchActions.unshift(new Action({
      id: "svd-grid-search-next",
      iconName: "icon-next_16x16",
      component: "sv-action-bar-item",
      title: getLocString("ed.nextFocus"),
      showTitle: false,
      iconSize: "auto",
      innerCss: "svc-search__bar-item",
      visible: new ComputedUpdater(() => this.allMatches.length > 1),
      action: () => {
        if (this.allMatches.length > 0) {
          this.navigateToEditor(this.currentMatchIndex + 1);
        }
      }
    }));
    searchActions.unshift(new Action({
      id: "svd-grid-search-prev",
      iconName: "icon-previous_16x16",
      component: "sv-action-bar-item",
      title: getLocString("ed.prevFocus"),
      showTitle: false,
      iconSize: "auto",
      innerCss: "svc-search__bar-item",
      visible: new ComputedUpdater(() => this.allMatches.length > 1),
      action: () => {
        if (this.allMatches.length > 0) {
          this.navigateToEditor(this.currentMatchIndex - 1);
        }
      }
    }));
    return searchActions;
  }
  constructor() {
    super();
    this.highlightedEditorClass = " spg-question--highlighted";
    this.initActionBar();
  }
  setSurvey(newSurvey) {
    this.clearFilterString();
    this.survey = newSurvey;
    if (!!this.survey) {
      const _self = this;
      this.survey.onUpdateQuestionCssClasses.add(function(_, options) {
        const classes = options.cssClasses;
        if (options.question === _self.currentMatch) {
          classes.mainRoot += _self.highlightedEditorClass;
        }
      });
    }
  }
};
__decorate2([property()], SearchManagerPropertyGrid.prototype, "survey", void 0);
__decorate2([property({
  defaultValue: []
})], SearchManagerPropertyGrid.prototype, "allMatches", void 0);
var PropertyGridViewModel = class extends Base {
  constructor(propertyGridModel, creator) {
    super();
    this.propertyGridModel = propertyGridModel;
    this.creator = creator;
    this.searchManager = new SearchManagerPropertyGrid();
    this.searchEnabled = settings2.propertyGrid.enableSearch;
    this.selectedElementName = this.getTitle();
    this.propertyGridModel.onSetNewObjectCallback = () => {
      this.onSurveyObjChanged();
    };
    this.propertyGridModel.onNewSurveyCreatedCallback = () => {
      this.onNewSurveyCreated();
    };
    this.propertyGridModel.changedFromActionCallback = (obj, propertyName) => {
      if (!!this.selectionController) {
        this.selectionController.selectFromAction(obj, propertyName);
      }
    };
    this.initActions();
    this.creator.onPropertyChanged.add((sender, options) => {
      if (options.name === "sidebarLocation") {
        this.selectorPopupModel.horizontalPosition = this.creator.sidebarLocation == "right" ? "left" : "right";
      }
    });
    this.onSurveyObjChanged();
  }
  get survey() {
    return this.getPropertyValue("survey", void 0, () => this.propertyGridModel.survey);
  }
  set survey(val) {
    this.setPropertyValue("survey", val);
  }
  get rootCss() {
    return new CssClassBuilder().append("spg-container").append("spg-container_search", this.searchEnabled).toString();
  }
  onPropertyValueChanged(name, oldValue, newValue) {
    super.onPropertyValueChanged(name, oldValue, newValue);
    if (!!this.nextSelectionAction && name === "hasNext") {
      this.nextSelectionAction.enabled = this.hasNext;
    }
    if (!!this.prevSelectionAction && name === "hasPrev") {
      this.prevSelectionAction.enabled = this.hasPrev;
    }
  }
  get selectionController() {
    return this.creator.selectionHistoryController;
  }
  onSurveyObjChanged() {
    this.updateTitle();
    if (this.selectionController) {
      this.hasPrev = this.selectionController.hasPrev;
      this.hasNext = this.selectionController.hasNext;
    }
  }
  onNewSurveyCreated() {
    this.survey = this.propertyGridModel.survey;
    this.searchManager.setSurvey(this.survey);
    if (!!this.survey) {
      this.survey.onValueChanged.add((sender, options) => {
        if (options.name == "name" || options.name == "title") {
          this.updateTitle();
        }
      });
    }
    if (this.onNewSurveyCreatedCallback) {
      this.onNewSurveyCreatedCallback();
    }
  }
  updateTitle() {
    let titleName = this.getTitle();
    this.selectedElementName = titleName;
    this.objectSelectionAction.tooltip = titleName;
    this.objectSelectionAction.title = this.propertyGridModel.showOneCategoryInPropertyGrid ? "" : titleName;
  }
  getTitle() {
    var obj = this.getSelectedObj();
    if (!obj) return "";
    var displayName = SurveyHelper.getObjectName(obj, this.propertyGridModel.options.useElementTitles || this.propertyGridModel.options.showObjectTitles);
    return this.propertyGridModel.options.getObjectDisplayName(obj, "property-grid-header:selected-element", "property-grid-title", displayName);
  }
  getSelectedObj() {
    return this.propertyGridModel.obj;
  }
  initActions() {
    if (settings2.propertyGrid.showNavigationButtons) {
      this.prevSelectionAction = new Action({
        id: "svd-grid-history-prev",
        iconName: "icon-arrow-left",
        component: "sv-action-bar-item",
        title: getLocString("ed.prevSelected"),
        showTitle: false,
        enabled: this.hasPrev,
        action: () => {
          this.selectionController.prev();
        }
      });
      this.nextSelectionAction = new Action({
        id: "svd-grid-history-next",
        iconName: "icon-arrow-right",
        component: "sv-action-bar-item",
        title: getLocString("ed.nextSelected"),
        showTitle: false,
        enabled: this.hasNext,
        action: () => {
          this.selectionController.next();
        }
      });
    }
    this.createObjectSwitcherAction();
  }
  createObjectSwitcherAction() {
    const selectorModel = new ObjectSelectorModel(this.creator, (obj, area, reason, displayName) => {
      return this.propertyGridModel.options.getObjectDisplayName(obj, area, reason, displayName);
    });
    this.selectorPopupModel = new PopupModel("svc-object-selector", {
      model: selectorModel
    }, {
      verticalPosition: "bottom",
      horizontalPosition: "center",
      cssClass: "svc-creator-popup"
    });
    this.selectorPopupModel.cssClass += " svc-object-selector";
    this.selectorPopupModel.displayMode = this.creator.isTouch ? "overlay" : "popup";
    this.selectorPopupModel.getTargetCallback = getActionDropdownButtonTarget;
    this.selectorPopupModel.registerPropertyChangedHandlers(["isVisible"], () => {
      if (!this.selectorPopupModel.isVisible) {
        this.objectSelectionAction.pressed = false;
      } else {
        this.objectSelectionAction.pressed = true;
      }
    });
    this.objectSelectionAction = new MenuButton({
      id: "svd-grid-object-selector",
      title: this.selectedElementName,
      css: "sv-action--object-selector",
      component: "sv-action-bar-item-dropdown",
      disableHide: true,
      pressed: false,
      action: () => {
        selectorModel.show(this.selectionController.creator.survey, this.propertyGridModel.obj, (obj) => {
          this.selectionController.selectFromAction(obj, "name");
          this.selectorPopupModel.hide();
        });
        this.selectorPopupModel.show();
        selectorModel.list.scrollToSelectedItem();
      },
      popupModel: this.selectorPopupModel
    });
    this.objectSelectionAction.contentType = "text-description-vertical";
  }
  dispose() {
    this.searchManager.dispose();
    this.nextSelectionAction.dispose();
    this.prevSelectionAction.dispose();
    this.objectSelectionAction.dispose();
    this.selectorPopupModel.dispose();
    super.dispose();
  }
};
__decorate2([property()], PropertyGridViewModel.prototype, "hasPrev", void 0);
__decorate2([property()], PropertyGridViewModel.prototype, "hasNext", void 0);
__decorate2([property()], PropertyGridViewModel.prototype, "selectedElementName", void 0);
__decorate2([property({
  onSet: (newValue, target) => {
    target.searchManager.isVisible = newValue;
  }
})], PropertyGridViewModel.prototype, "searchEnabled", void 0);
__decorate2([property()], PropertyGridViewModel.prototype, "showPlaceholder", void 0);
var PagesController = class extends Base {
  constructor(creator) {
    super();
    this.creator = creator;
    this.onPagesChanged = this.addEvent();
    this.onCurrentPageChanged = this.addEvent();
    this.currentPageChangedFunc = (sender, options) => {
      this.page2Display = this.survey.currentPage;
      this.onCurrentPageChanged.fire(this, {});
    };
    this.onSurveyChanged();
  }
  get survey() {
    return this.creator.survey;
  }
  get pages() {
    return this.survey.pages;
  }
  get currentPage() {
    return this.survey.currentPage;
  }
  set currentPage(value) {
    this.survey.currentPage = value;
    this.page2Display = value;
  }
  selectPage(value) {
    this.currentPage = value;
    this.creator.selectElement(value);
  }
  getDisplayName(page) {
    if (!page) return "";
    return this.creator.getObjectDisplayName(page, "page-selector");
  }
  raisePagesChanged() {
    this.page2Display = this.survey.currentPage;
    this.onPagesChanged.fire(this, {});
  }
  onSurveyChanged() {
    this.removeFunctions();
    this.surveyValue = this.creator.survey;
    if (!this.surveyValue) return;
    this.raisePagesChanged();
    this.page2Display = this.survey.currentPage;
    this.surveyValue.onCurrentPageChanged.add(this.currentPageChangedFunc);
  }
  dispose() {
    super.dispose();
    this.removeFunctions();
  }
  removeFunctions() {
    if (!!this.surveyValue && !this.surveyValue.isDisposed) {
      this.surveyValue.onCurrentPageChanged.remove(this.currentPageChangedFunc);
    }
  }
};
__decorate2([property()], PagesController.prototype, "page2Display", void 0);
var designTabSurveyThemeJSON = {
  "cssVariables": {
    "--sjs-base-unit": "var(--ctr-surface-base-unit)",
    "--sjs-font-size": "calc(2 * var(--ctr-surface-base-unit))",
    "--sjs-primary-backcolor": "var(--sjs-primary-background-500, #19B394)",
    "--sjs-primary-backcolor-light": "var(--sjs-primary-background-10, #19B3941A)",
    "--sjs-primary-backcolor-dark": "var(--sjs-primary-background-400, #14A48B)",
    "--sjs-primary-forecolor": "var(--sjs-primary-foreground-100, #FFFFFF)",
    "--sjs-primary-forecolor-light": "var(--sjs-primary-foreground-25, #FFFFFF40)",
    "--sjs-secondary-backcolor": "var(--sjs-secondary-background-500, #19B394)",
    "--sjs-secondary-backcolor-light": "var(--sjs-secondary-background-10, #19B3941A)",
    "--sjs-secondary-backcolor-semi-light": "var(--sjs-secondary-background-25, #19B39440)",
    "--sjs-secondary-forecolor": "var(--sjs-secondary-foreground-100, #FFFFFF)",
    "--sjs-secondary-forecolor-light": "var(--sjs-secondary-forecolor-25, #FFFFFF40)",
    "--sjs-general-backcolor": "var(--sjs-layer-1-background-500, #FFFFFF)",
    "--sjs-general-backcolor-dark": "var(--sjs-layer-1-background-400, #F5F5F5)",
    "--sjs-general-forecolor": "var(--sjs-layer-1-foreground-100, #000000E6)",
    "--sjs-general-forecolor-light": "var(--sjs-layer-1-foreground-50, #00000080)",
    "--sjs-general-backcolor-dim": "var(--sjs-layer-3-background-500, #F4F4F4)",
    "--sjs-general-dim-forecolor": "var(--sjs-layer-3-foreground-100, #000000E6)",
    "--sjs-general-dim-forecolor-light": "var(--sjs-layer-3-foreground-50, #00000080)",
    "--sjs-general-backcolor-dim-light": "var(--sjs-layer-2-background-500, #F8F8F8)",
    "--sjs-general-backcolor-dim-dark": "var(--sjs-layer-2-background-400, #EEEEEE)",
    "--sjs-border-default": "var(--sjs-border-25, #D4D4D4)",
    "--sjs-border-light": "var(--sjs-border-10, #DCDCDC)",
    "--sjs-border-inside": "var(--sjs-border-25, #D4D4D4)",
    "--sjs-special-red": "var(--sjs-semantic-red-background-500, #E50A3E)",
    "--sjs-special-red-light": "var(--sjs-semantic-red-background-10, #E50A3E1A)",
    "--sjs-special-red-forecolor": "var(--sjs-semantic-red-foreground-100, #FFFFFF)",
    "--sjs-special-green": "var(--sjs-semantic-green-background-500, #19B394)",
    "--sjs-special-green-light": "var(--sjs-semantic-green-background-10, #19B3941A)",
    "--sjs-special-green-forecolor": "var(--sjs-semantic-green-foreground-100, #FFFFFF)",
    "--sjs-special-blue": "var(--sjs-semantic-blue-background-500, #437FD9)",
    "--sjs-special-blue-light": "var(--sjs-semantic-blue-background-10, #437FD91A)",
    "--sjs-special-blue-forecolor": "var(--sjs-semantic-blue-foreground-100, #FFFFFF)",
    "--sjs-special-yellow": "var(--sjs-semantic-yellow-background-500, #FF9814)",
    "--sjs-special-yellow-light": "var(--sjs-semantic-yellow-background-10, #FF98141A)",
    "--sjs-special-yellow-forecolor": "var(--sjs-semantic-yellow-foreground-100, #FFFFFF)",
    "--sjs-special-white": "var(--sjs-semantic-white-background-500, #FFFFFF)",
    "--sjs-general-haze-background": "var(--sjs-special-haze, #CCEEEE59)",
    "--sjs-shadow-large-offset-x": "var(--lbr-shadow-large-offset-x)",
    "--sjs-shadow-large-offset-y": "var(--lbr-shadow-large-offset-y)",
    "--sjs-shadow-large-blur": "var(--lbr-shadow-large-blur)",
    "--sjs-shadow-large-spread": "var(--lbr-shadow-large-spread)",
    "--sjs-shadow-large-color": "var(--lbr-shadow-large-color)",
    "--sjs-shadow-medium-offset-x": "var(--lbr-shadow-medium-offset-x)",
    "--sjs-shadow-medium-offset-y": "var(--lbr-shadow-medium-offset-y)",
    "--sjs-shadow-medium-blur": "var(--lbr-shadow-medium-blur)",
    "--sjs-shadow-medium-spread": "var(--lbr-shadow-medium-spread)",
    "--sjs-shadow-medium-color": "var(--lbr-shadow-medium-color)",
    "--sjs-shadow-small-offset-x": "var(--lbr-shadow-small-offset-x)",
    "--sjs-shadow-small-offset-y": "var(--lbr-shadow-small-offset-y)",
    "--sjs-shadow-small-blur": "var(--lbr-shadow-small-blur)",
    "--sjs-shadow-small-spread": "var(--lbr-shadow-small-spread)",
    "--sjs-shadow-small-color": "var(--lbr-shadow-small-color)",
    "--sjs-shadow-inner-offset-x": "var(--lbr-shadow-inner-offset-x)",
    "--sjs-shadow-inner-offset-y": "var(--lbr-shadow-inner-offset-y)",
    "--sjs-shadow-inner-blur": "var(--lbr-shadow-inner-blur)",
    "--sjs-shadow-inner-spread": "var(--lbr-shadow-inner-spread)",
    "--sjs-shadow-inner-color": "var(--lbr-shadow-inner-color)"
  }
};
var initialSettingsAllowShowEmptyTitleInDesignMode = settings.allowShowEmptyTitleInDesignMode;
var TabDesignerViewModel = class extends Base {
  get displayPageDropTarget() {
    return this.pagesController.page2Display === this.newPage ? "newGhostPage" : this.pagesController.page2Display.name;
  }
  createNewPage() {
    if (!this.creator.canAddPage()) {
      return null;
    }
    const newPage = this.survey.createNewPage("");
    newPage["ignoreUndoRedo"] = true;
    this.creator.setNewNames(newPage);
    newPage.onFirstRendering();
    newPage.updateCustomWidgets();
    newPage.setWasShown(true);
    newPage.setSurveyImpl(this.survey);
    newPage.updateElementCss(true);
    var checkNewElementHandler = (sender, options) => {
      if (options.name === "elements" && newPage.elements.length > 0) {
        this.creator.addPage(newPage, true, () => {
          newPage.onPropertyChanged.remove(checkNewElementHandler);
          newPage.showTitle = true;
          newPage.showDescription = true;
          delete newPage["ignoreUndoRedo"];
          return !(this.survey.pages.indexOf(newPage) > -1);
        });
      }
    };
    newPage.num = this.getNewPageNum();
    newPage.onPropertyChanged.add(checkNewElementHandler);
    DragDropSurveyElements.newGhostPage = newPage;
    delete newPage["ignoreUndoRedo"];
    return newPage;
  }
  getNewPageNum() {
    const pages = this.survey.pages;
    const num = pages.length + (this.survey.firstPageIsStarted ? 0 : 1);
    return num > 0 ? num : 1;
  }
  get canShowNewPage() {
    if (!this.survey || this.creator.pageEditMode === "single" || !this.creator.allowModifyPages) return false;
    return true;
  }
  isModifiedPage(page) {
    return Object.keys(page.toJSON()).filter((key) => key !== "name").length > 0;
  }
  constructor(creator) {
    super();
    this.minSurfaceScaling = 20;
    this.maxSurfaceScaling = 100;
    this.stepSurfaceScaling = 10;
    this.unitDictionary = {
      "--ctr-surface-base-unit": 8,
      "--lbr-font-unit": 8,
      "--lbr-line-height-unit": 8,
      "--lbr-size-unit": 8,
      "--lbr-spacing-unit": 8,
      "--lbr-corner-radius-unit": 8,
      "--lbr-stroke-unit": 1
    };
    this.surfaceScale = 100;
    this.surfaceCssVariables = {};
    this.scaleCssVariables = {};
    this._pages = [];
    this.pagesAnimation = new AnimationGroup(this.getPagesAnimationOptions(), (val) => {
      this._pages = val;
      this._pages.forEach((page) => delete page["draggedFrom"]);
    }, () => this._pages);
    this.creator = creator;
    this.pagesControllerValue = new PagesController(creator);
    this.creator.dragDropChoices.onShortcutCreated = (shortcut) => {
      var _a;
      const cssVariables = {};
      if ((_a = this.creator.dragDropChoices["parentElement"]) === null || _a === void 0 ? void 0 : _a.survey["isPopupEditorContent"]) {
        assign(cssVariables, designTabSurveyThemeJSON.cssVariables);
      } else {
        shortcut.classList.add("svc-surface-drag-drop-choices-shortcut");
        assign(cssVariables, this.surfaceCssVariables);
      }
      Object.keys(cssVariables).forEach((key) => {
        shortcut.style.setProperty(key, cssVariables[key]);
      });
    };
    this.initSurfaceToolbar();
    this.initSurvey();
    this.updateSurfaceCssVariables();
  }
  updateSurfaceCssVariables() {
    var _a;
    const cssVariables = {};
    assign(cssVariables, designTabSurveyThemeJSON.cssVariables, ((_a = this.creator.creatorTheme) === null || _a === void 0 ? void 0 : _a.cssVariables) || {}, this.scaleCssVariables);
    this.surfaceCssVariables = cssVariables;
  }
  initSurfaceToolbar() {
    this.surfaceToolbar = new ActionContainer();
    let defaultActionBarCss2 = {
      root: "sv-action-bar svc-tab-designer__surface-toolbar",
      defaultSizeMode: "",
      smallSizeMode: "",
      item: "svc-page-navigator__button",
      itemWithTitle: "",
      itemAsIcon: "",
      itemActive: "svc-page-navigator__button--active",
      itemPressed: "",
      itemIcon: "svc-page-navigator__button-icon",
      itemTitleWithIcon: ""
    };
    this.surfaceToolbar.cssClasses = defaultActionBarCss2;
    const surfaceToolbarItems = [];
    surfaceToolbarItems.push({
      id: "zoomIn",
      locTooltipName: "ed.zoomInTooltip",
      iconName: "icon-zoomin-24x24",
      iconSize: "auto",
      enabled: new ComputedUpdater(() => this.surfaceScale < this.maxSurfaceScaling),
      visible: new ComputedUpdater(() => this.creator.allowZoom),
      action: () => {
        this.scaleSurface(this.surfaceScale + this.stepSurfaceScaling);
      }
    });
    surfaceToolbarItems.push({
      id: "zoom100",
      locTooltipName: "ed.zoom100Tooltip",
      iconName: "icon-actual-size-24x24",
      iconSize: "auto",
      enabled: new ComputedUpdater(() => this.surfaceScale !== 100),
      visible: new ComputedUpdater(() => this.creator.allowZoom),
      action: () => {
        this.scaleSurface(100);
      }
    });
    surfaceToolbarItems.push({
      id: "zoomOut",
      locTooltipName: "ed.zoomOutTooltip",
      iconName: "icon-zoomout-24x24",
      iconSize: "auto",
      enabled: new ComputedUpdater(() => this.surfaceScale > this.minSurfaceScaling),
      visible: new ComputedUpdater(() => this.creator.allowZoom),
      action: () => {
        this.scaleSurface(this.surfaceScale - this.stepSurfaceScaling);
        this.forceLazyRendering();
      }
    });
    surfaceToolbarItems.push({
      id: "collapseAll",
      locTooltipName: "ed.collapseAllTooltip",
      iconName: "icon-collapseall-24x24",
      iconSize: "auto",
      needSeparator: new ComputedUpdater(() => this.creator.allowZoom),
      visible: new ComputedUpdater(() => this.creator.expandCollapseButtonVisibility != "never"),
      action: () => this.creator.expandCollapseManager.expandCollapseElements("collapse-all", true)
    });
    surfaceToolbarItems.push({
      id: "expandAll",
      locTooltipName: "ed.expandAllTooltip",
      iconName: "icon-expandall-24x24",
      iconSize: "auto",
      visible: new ComputedUpdater(() => this.creator.expandCollapseButtonVisibility != "never"),
      action: () => this.creator.expandCollapseManager.expandCollapseElements("expand-all", false)
    });
    surfaceToolbarItems.push({
      id: "lockQuestions",
      locTooltipName: "ed.lockQuestionsTooltip",
      iconName: "icon-questionlock-24x24",
      iconSize: "auto",
      active: this.creator.expandCollapseManager.questionsLocked,
      visible: new ComputedUpdater(() => this.creator.expandCollapseButtonVisibility != "never"),
      action: (action) => {
        action.active = !action.active;
        this.creator.expandCollapseManager.lockQuestions(action.active);
      }
    });
    this.surfaceToolbar.setItems(surfaceToolbarItems);
  }
  forceLazyRendering() {
    this.creator.survey.pages.forEach((page) => activateLazyRenderingChecks(page.id));
  }
  scaleSurface(scaleFactor) {
    var _a;
    if (scaleFactor < this.minSurfaceScaling || scaleFactor > this.maxSurfaceScaling) return;
    this.surfaceScale = scaleFactor;
    if (!this.creator.survey.responsiveStartWidth) {
      (_a = this.creator.responsivityManager) === null || _a === void 0 ? void 0 : _a.updateSurveyActualWidth();
    }
    this.creator.survey.widthScale = scaleFactor;
    Object.keys(this.unitDictionary).forEach((key) => {
      this.scaleCssVariables[key] = this.unitDictionary[key] * scaleFactor / 100 + "px";
    });
    this.updateSurfaceCssVariables();
  }
  get survey() {
    return this.creator.survey;
  }
  get pagesController() {
    return this.pagesControllerValue;
  }
  get isToolboxVisible() {
    return this.creator.showToolbox && (this.creator.toolboxLocation === "right" || this.creator.toolboxLocation === "left");
  }
  get placeholderText() {
    if (this.creator.isMobileView) return getLocString("ed.surveyPlaceHolderMobile");
    return getLocString("ed.surveyPlaceHolder");
  }
  get placeholderTitleText() {
    if (this.creator.isMobileView) return getLocString("ed.surveyPlaceholderTitleMobile");
    return getLocString("ed.surveyPlaceholderTitle");
  }
  get placeholderDescriptionText() {
    if (this.creator.isMobileView) return getLocString("ed.surveyPlaceholderDescriptionMobile");
    return getLocString("ed.surveyPlaceholderDescription");
  }
  get showSurfaceToolbar() {
    const hasVisibleItems = this.surfaceToolbar.actions.some((action) => action.visible);
    return this.creator.allowShowSurfaceToolbar && hasVisibleItems;
  }
  get showSurfaceTools() {
    return !this.creator.isMobileView && (this.showSurfaceToolbar || this.creator.showPageNavigator && (this.survey.pageCount > 1 || this.creator.pageEditMode === "bypage"));
  }
  onDesignerSurveyPropertyChanged(obj, propName) {
    if (!obj || this.isUpdatingNewPage) return;
    this.isUpdatingNewPage = true;
    if (propName === "elements" && obj.isDescendantOf("page")) {
      let updatePageController = false;
      if (obj.elements.length === 0) {
        updatePageController = this.checkLastPageToDelete();
      }
      this.checkNewPage(updatePageController);
    }
    if (propName === "firstPageIsStartPage") {
      this.checkNewPage(true);
    }
    this.isUpdatingNewPage = false;
  }
  calculateDesignerCss() {
    return new CssClassBuilder().append("svc-designer-surface").append(this.survey.css.container).append(this.survey.css.container + "--" + this.survey.calculatedWidthMode).toString();
  }
  initSurvey() {
    if (!this.survey) return;
    this.showNewPage = false;
    this.newPage = void 0;
    this.checkNewPage(false);
    this.updatePages();
    this.cssUpdater && this.cssUpdater.dispose();
    this.cssUpdater = new ComputedUpdater(() => {
      return this.calculateDesignerCss();
    });
    this.survey.registerFunctionOnPropertyValueChanged("pages", () => {
      this.checkNewPage(true);
      this.updatePages();
    }, "__designer_tab_model__");
    this.survey.registerFunctionOnPropertiesValueChanged(["widthMode", "calculatedWidthMode"], () => {
      this.updateSurveyScaleStartDimensions();
    }, "__designer_tab_model__");
    this.designerCss = this.cssUpdater;
    this.pagesController.onSurveyChanged();
  }
  updateSurveyScaleStartDimensions() {
    this.survey.staticStartWidth = void 0;
    this.survey.responsiveStartWidth = void 0;
    setTimeout(() => this.scaleSurface(this.surfaceScale), 1);
  }
  checkNewPage(updatePageController) {
    const showPlaceholder = this.survey.getAllQuestions().length === 0 && this.survey.pageCount === 0;
    this.showPlaceholder = showPlaceholder;
    this.pageCount = this.survey.pageCount;
    if (this.showPlaceholder || this.canShowNewPage) {
      const pages = this.survey.pages;
      if (!this.newPage || pages.length > 0 && this.newPage === pages[pages.length - 1]) {
        this.newPage = this.createNewPage();
        this.showNewPage = !!this.newPage;
      }
      if (this.newPage) {
        this.newPage.showTitle = !showPlaceholder;
        this.newPage.showDescription = !showPlaceholder;
      }
    } else {
      this.showNewPage = false;
      this.newPage = void 0;
    }
    if (updatePageController) {
      if (this.newPage) {
        this.newPage.num = this.getNewPageNum();
        this.newPage.startLoadingFromJson();
        this.newPage.name = SurveyHelper.getNewPageName(this.survey.pages);
        this.newPage.endLoadingFromJson();
      }
      this.pagesController.raisePagesChanged();
    }
  }
  updatePages() {
    this.pages = this.survey.pages.concat(this.showNewPage ? [this.newPage] : []);
  }
  dispose() {
    super.dispose();
    this.cssUpdater && this.cssUpdater.dispose();
    this.survey.unRegisterFunctionOnPropertyValueChanged("pages", "__designer_tab_model__");
    this.survey.unRegisterFunctionOnPropertiesValueChanged(["widthMode", "calculatedWidthMode"], "__designer_tab_model__");
  }
  checkLastPageToDelete() {
    if (this.survey.pageCount === 0 || this.survey.isQuestionDragging) return false;
    const lastPage = this.survey.pages[this.survey.pageCount - 1];
    if (lastPage.elements.length > 0 || lastPage.isConverting) return false;
    if (SurveyHelper.isPagePropertiesAreModified(lastPage)) return false;
    lastPage.delete();
    if (this.survey.pageCount === 0) {
      this.creator.selectElement(this.survey);
    }
    return true;
  }
  get pages() {
    return this._pages;
  }
  set pages(val) {
    this.pagesAnimation.sync(val);
  }
  getPagesAnimationOptions() {
    return {
      getEnterOptions: (item, info) => {
        return {
          onBeforeRunAnimation: prepareElementForVerticalAnimation,
          cssClass: "svc-page--enter",
          onAfterRunAnimation: cleanHtmlElementAfterAnimation
        };
      },
      getLeaveOptions: (item, info) => {
        return {
          onBeforeRunAnimation: prepareElementForVerticalAnimation,
          cssClass: "svc-page--leave",
          onAfterRunAnimation: cleanHtmlElementAfterAnimation
        };
      },
      isAnimationEnabled: () => {
        return this.animationAllowed;
      },
      getKey(page) {
        return page.id;
      },
      getAnimatedElement: (item) => {
        var _a, _b;
        return (_b = (_a = SurveyElementAdornerBase.GetAdorner(item)) === null || _a === void 0 ? void 0 : _a.rootElement) === null || _b === void 0 ? void 0 : _b.parentElement;
      },
      getRerenderEvent: () => this.onElementRerendered,
      onCompareArrays(options) {
        const droppedPage = options.mergedItems.filter((page) => page["draggedFrom"] !== void 0)[0];
        if (droppedPage) {
          options.reorderedItems = [];
          options.addedItems = [droppedPage];
          const ghostPage = new PageModel();
          ghostPage.setSurveyImpl(droppedPage.survey);
          ghostPage.title = droppedPage.title;
          ghostPage.num = droppedPage.num;
          ghostPage["isGhost"] = true;
          options.deletedItems = [ghostPage];
          options.mergedItems.splice(droppedPage["draggedFrom"], 0, ghostPage);
        }
      }
    };
  }
  clickDesigner() {
    this.creator.selectedElement = this.creator.survey;
  }
  getRootCss() {
    let rootCss = this.survey.css.root;
    if (this.showSurfaceTools) {
      rootCss += " svc-tab-designer--with-surface-tools";
    }
    if (this.showPlaceholder) {
      rootCss += " svc-tab-designer--with-placeholder";
    }
    rootCss += " svc-tab-designer--" + this.creator.pageEditMode + "-mode";
    return rootCss;
  }
};
__decorate2([property()], TabDesignerViewModel.prototype, "newPage", void 0);
__decorate2([property({
  defaultValue: false
})], TabDesignerViewModel.prototype, "showNewPage", void 0);
__decorate2([property()], TabDesignerViewModel.prototype, "pageCount", void 0);
__decorate2([property()], TabDesignerViewModel.prototype, "designerCss", void 0);
__decorate2([property({
  onSet: (val, objectInstance, prevVal) => {
    objectInstance.updateSurveyScaleStartDimensions();
  }
})], TabDesignerViewModel.prototype, "showPlaceholder", void 0);
__decorate2([property()], TabDesignerViewModel.prototype, "surfaceScale", void 0);
__decorate2([property()], TabDesignerViewModel.prototype, "surfaceCssVariables", void 0);
__decorate2([propertyArray()], TabDesignerViewModel.prototype, "_pages", void 0);
var ElementState = class {
  constructor() {
    this.collapsed = false;
  }
};
var DesignerStateManager = class {
  constructor() {
    this.elementState = {};
    this.pageState = {};
    this.onQuestionAddedHandler = (sender, opts) => {
      this.createElementState(opts.question, this.isSuspended);
    };
    this.onPageAddedHandler = (sender, opts) => {
      this.createElementState(opts.page, this.isSuspended);
    };
    this.onPanelAddedHandler = (sender, opts) => {
      this.createElementState(opts.panel, this.isSuspended);
    };
    this._suspendCounter = 0;
  }
  getStateMapForElement(element) {
    return element && element.isPage ? this.pageState : this.elementState;
  }
  initForSurvey(survey) {
    survey.onQuestionAdded.add(this.onQuestionAddedHandler);
    survey.onPageAdded.add(this.onPageAddedHandler);
    survey.onPanelAdded.add(this.onPanelAddedHandler);
  }
  initForElement(element) {
    if (!element) return;
    const stateMap = this.getStateMapForElement(element);
    element.registerFunctionOnPropertyValueChanged("name", (newName) => {
      delete stateMap[element.name];
      stateMap[newName] = new ElementState();
    }, "designerStateManager");
  }
  getElementState(element) {
    return this.createElementState(element, true);
  }
  createElementState(element, checkIfExists) {
    const stateMap = this.getStateMapForElement(element);
    const name = element.name;
    if (checkIfExists) {
      const state = stateMap[name];
      if (state) return state;
    }
    const res = new ElementState();
    stateMap[name] = res;
    if (this.onInitElementStateCallback) {
      this.onInitElementStateCallback(element, res);
    }
    return res;
  }
  suspend() {
    this._suspendCounter++;
  }
  release() {
    this._suspendCounter--;
  }
  get isSuspended() {
    return this._suspendCounter > 0;
  }
};
var pgTabIcons = {
  "appearance": "icon-pg-appearance-24x24",
  "background": "icon-pg-background-24x24",
  "columns": "icon-pg-columns-24x24",
  "logic": "icon-pg-conditions-24x24",
  "data": "icon-pg-data-24x24",
  "design": "icon-pg-design-24x24",
  "general": "icon-pg-general-24x24",
  "header": "icon-pg-header-24x24",
  "language": "icon-pg-language-24x24",
  "layout": "icon-pg-design-24x24",
  "logo": "icon-pg-logo-24x24",
  "navigation": "icon-pg-navigation-24x24",
  "pages": "icon-pg-pages-24x24",
  "question": "icon-pg-questiondesign-24x24",
  "questionSettings": "icon-pg-questiondesign-24x24",
  "timer": "icon-pg-quiz-24x24",
  "rows": "icon-pg-rows-24x24",
  "specific": "icon-pg-specific-24x24",
  "showOnCompleted": "icon-pg-thankyyoupage-24x24",
  "themes": "icon-pg-themes-24x24",
  "totals": "icon-pg-totals-24x24",
  "validation": "icon-pg-validation-24x24",
  "cells": "icon-pg-specific-24x24",
  "items": "icon-pg-specific-24x24",
  "mask": "icon-pg-specific-24x24",
  "rateValues": "icon-pg-specific-24x24",
  "choices": "icon-pg-specific-24x24",
  "choicesByUrl": "icon-pg-webservice-24x24",
  "undefined": "icon-pg-undefined-24x24"
};
var creatorThemeModelProperties = {
  "creatortheme": {
    properties: [{
      name: "themeName",
      index: 1
    }, {
      name: "--sjs-primary-background-500",
      index: 10,
      tab: "accentColors"
    }, {
      name: "--sjs-secondary-background-500",
      index: 20,
      tab: "accentColors"
    }, {
      name: "--sjs-special-background",
      index: 30,
      tab: "surfaceBackground"
    }, {
      name: "fontScale",
      index: 40,
      tab: "scaling"
    }, {
      name: "scale",
      index: 50,
      tab: "scaling"
    }],
    tabs: [{
      name: "accentColors",
      "parent": "general",
      index: 20
    }, {
      name: "surfaceBackground",
      "parent": "general",
      index: 30
    }, {
      name: "scaling",
      "parent": "general",
      index: 40
    }]
  }
};
var creatorThemeModelPropertyGridDefinition = {
  autoGenerateProperties: true,
  classes: creatorThemeModelProperties
};
var creatorThemeModelEditorDefinition = class {
};
creatorThemeModelEditorDefinition.definition = creatorThemeModelProperties;
var DomDocumentHelper2 = class _DomDocumentHelper {
  static isAvailable() {
    return "undefined" !== typeof document;
  }
  static getBody() {
    if (!_DomDocumentHelper.isAvailable()) return;
    return document.body;
  }
  static getDocumentElement() {
    if (!_DomDocumentHelper.isAvailable()) return;
    return document.documentElement;
  }
  static getDocument() {
    if (!_DomDocumentHelper.isAvailable()) return;
    return document;
  }
  static getCookie() {
    if (!_DomDocumentHelper.isAvailable()) return;
    return document.cookie;
  }
  static setCookie(newCookie) {
    if (!_DomDocumentHelper.isAvailable()) return;
    document.cookie = newCookie;
  }
  static activeElementBlur() {
    if (!_DomDocumentHelper.isAvailable()) return;
    const activeElement = document.activeElement;
    if (!!activeElement && !!activeElement.blur) {
      activeElement.blur();
    }
  }
  static createElement(tagName) {
    if (!_DomDocumentHelper.isAvailable()) return;
    return document.createElement(tagName);
  }
  static getComputedStyle(elt) {
    if (!_DomDocumentHelper.isAvailable()) return new CSSStyleDeclaration();
    return document.defaultView.getComputedStyle(elt);
  }
  static addEventListener(type, listener) {
    if (!_DomDocumentHelper.isAvailable()) return;
    document.addEventListener(type, listener);
  }
  static removeEventListener(type, listener) {
    if (!_DomDocumentHelper.isAvailable()) return;
    document.removeEventListener(type, listener);
  }
};
var CreatorStylesManager = class _CreatorStylesManager {
  static findSheet(styleSheetId) {
    if (typeof document === "undefined") return null;
    for (let i = 0; i < document.styleSheets.length; i++) {
      if (!!document.styleSheets[i].ownerNode && document.styleSheets[i].ownerNode["id"] === styleSheetId) {
        return document.styleSheets[i];
      }
    }
    return null;
  }
  static createSheet(styleSheetId) {
    let style = DomDocumentHelper2.createElement("style");
    style.id = styleSheetId;
    style.appendChild(new Text(""));
    document.head.appendChild(style);
    return style.sheet;
  }
  static insertStylesRulesIntoDocument(rules) {
    if (_CreatorStylesManager.Enabled) {
      let sheet = _CreatorStylesManager.findSheet(_CreatorStylesManager.SurveyJSCreatorStylesSheetId);
      if (!sheet) {
        sheet = _CreatorStylesManager.createSheet(_CreatorStylesManager.SurveyJSCreatorStylesSheetId);
      }
      if (Object.keys(rules).length) {
        rules.forEach((rule) => {
          try {
            sheet.insertRule(`${rule.selector} { ${rule.styles} }`, 0);
          } catch (e) {
          }
        });
      }
    }
  }
};
CreatorStylesManager.SurveyJSCreatorStylesSheetId = "surveyjs-creator-styles";
CreatorStylesManager.Enabled = true;
var DefaultLightColorCssVariables = {
  "--sjs-primary-background-400-deltaAlpha": 0,
  "--sjs-primary-background-400-deltaH": -1.66,
  "--sjs-primary-background-400-deltaS": -2.77,
  "--sjs-primary-background-400-deltaL": 3.92,
  "--sjs-primary-background-400": "hsl(from var(--sjs-primary-background-500) calc(h - var(--sjs-primary-background-400-deltaH)) calc(s - var(--sjs-primary-background-400-deltaS)) calc(l - var(--sjs-primary-background-400-deltaL)) / calc(1 - var(--sjs-primary-background-400-deltaAlpha)))",
  "--sjs-primary-background-10-deltaAlpha": 0.9,
  "--sjs-primary-background-10-deltaH": 0,
  "--sjs-primary-background-10-deltaS": 0,
  "--sjs-primary-background-10-deltaL": 0,
  "--sjs-primary-background-10": "hsl(from var(--sjs-primary-background-500) calc(h - var(--sjs-primary-background-10-deltaH)) calc(s - var(--sjs-primary-background-10-deltaS)) calc(l - var(--sjs-primary-background-10-deltaL)) / calc(1 - var(--sjs-primary-background-10-deltaAlpha)))",
  "--sjs-secondary-background-400-deltaAlpha": 0,
  "--sjs-secondary-background-400-deltaH": -1.66,
  "--sjs-secondary-background-400-deltaS": -2.77,
  "--sjs-secondary-background-400-deltaL": 3.92,
  "--sjs-secondary-background-400": "hsl(from var(--sjs-secondary-background-500) calc(h - var(--sjs-secondary-background-400-deltaH)) calc(s - var(--sjs-secondary-background-400-deltaS)) calc(l - var(--sjs-secondary-background-400-deltaL)) / calc(1 - var(--sjs-secondary-background-400-deltaAlpha)))",
  "--sjs-secondary-background-25-deltaAlpha": 0.75,
  "--sjs-secondary-background-25-deltaH": 0,
  "--sjs-secondary-background-25-deltaS": 0,
  "--sjs-secondary-background-25-deltaL": 0,
  "--sjs-secondary-background-25": "hsl(from var(--sjs-secondary-background-500) calc(h - var(--sjs-secondary-background-25-deltaH)) calc(s - var(--sjs-secondary-background-25-deltaS)) calc(l - var(--sjs-secondary-background-25-deltaL)) / calc(1 - var(--sjs-secondary-background-25-deltaAlpha)))",
  "--sjs-secondary-background-10-deltaAlpha": 0.9,
  "--sjs-secondary-background-10-deltaH": 0,
  "--sjs-secondary-background-10-deltaS": 0,
  "--sjs-secondary-background-10-deltaL": 0,
  "--sjs-secondary-background-10": "hsl(from var(--sjs-secondary-background-500) calc(h - var(--sjs-secondary-background-10-deltaH)) calc(s - var(--sjs-secondary-background-10-deltaS)) calc(l - var(--sjs-secondary-background-10-deltaL)) / calc(1 - var(--sjs-secondary-background-10-deltaAlpha)))",
  "--sjs-special-haze-deltaAlpha": 0.65,
  "--sjs-special-haze-deltaH": -10,
  "--sjs-special-haze-deltaS": 0,
  "--sjs-special-haze-deltaL": 8.62,
  "--sjs-special-haze": "hsl(from var(--sjs-special-background) calc(h - var(--sjs-special-haze-deltaH)) calc(s - var(--sjs-special-haze-deltaS)) calc(l - var(--sjs-special-haze-deltaL)) / calc(1 - var(--sjs-special-haze-deltaAlpha)))",
  "--sjs-special-glow-deltaAlpha": 0.9,
  "--sjs-special-glow-deltaH": -3.68,
  "--sjs-special-glow-deltaS": -50,
  "--sjs-special-glow-deltaL": 80.39,
  "--sjs-special-glow": "hsl(from var(--sjs-special-background) calc(h - var(--sjs-special-glow-deltaH)) calc(s - var(--sjs-special-glow-deltaS)) calc(l - var(--sjs-special-glow-deltaL)) / calc(1 - var(--sjs-special-glow-deltaAlpha)))"
};
var PredefinedCreatorThemes = ["default-light"];
var defaultCreatorThemesOrder = ["default-light", "default-contrast", "default-dark", "sc2020"];
function registerCreatorTheme(...themes) {
  const importedThemeNames = [];
  registerTheme((theme) => {
    CreatorThemes[theme.themeName] = theme;
    importedThemeNames.push(theme.themeName);
  }, ...themes);
  sortDefaultThemes(defaultCreatorThemesOrder, importedThemeNames, PredefinedCreatorThemes);
}
var defaultVariables = {
  "--sjs-special-background": "#EDF9F7",
  "--sjs-primary-background-500": "#19B394",
  "--sjs-secondary-background-500": "#19B394"
};
var CreatorThemes = {
  "default-light": {
    themeName: "default-light",
    cssVariables: defaultVariables,
    iconSet: "v2"
  }
};
var stylesStr = "";
if (Object.keys(DefaultLightColorCssVariables).length) {
  Object.keys(DefaultLightColorCssVariables).forEach((varName) => {
    try {
      stylesStr += `${varName}: ${DefaultLightColorCssVariables[varName]};`;
    } catch (e) {
    }
  });
}
CreatorStylesManager.insertStylesRulesIntoDocument([{
  selector: "survey-creator,.svc-creator",
  styles: stylesStr
}]);
var CreatorThemeModel = class _CreatorThemeModel extends Base {
  isSpecialBackgroundFromCurrentTheme() {
    const currentTheme = CreatorThemes[this.themeName];
    return colorsAreEqual(currentTheme && currentTheme.cssVariables && currentTheme.cssVariables["--sjs-special-background"], this["--sjs-special-background"]);
  }
  findAppropriateSpecialBackground(primaryColorValue) {
    let primaryColorName;
    const colorsDict = PredefinedColors["light"];
    Object.keys(colorsDict).forEach((colorName) => {
      if (colorsAreEqual(colorsDict[colorName], primaryColorValue)) {
        primaryColorName = colorName;
      }
    });
    return PredefinedBackgroundColors["light"][primaryColorName];
  }
  updateBackgroundColor(primaryColorNewValue, primaryColorOldValue) {
    if (!this.isLight) {
      return;
    }
    const canCalculateSpecialBackgroundColor = this.isSpecialBackgroundFromCurrentTheme() || colorsAreEqual(this.findAppropriateSpecialBackground(primaryColorOldValue), this["--sjs-special-background"]);
    if (canCalculateSpecialBackgroundColor) {
      const newSpecialBackgroundColor = this.findAppropriateSpecialBackground(primaryColorNewValue);
      this["--sjs-special-background"] = newSpecialBackgroundColor || PredefinedBackgroundColors["light"]["gray"];
    }
  }
  constructor() {
    super();
    this.initialCssVariables = {};
    this.themeCssVariablesChanges = {};
    this.unitDictionary = {
      "--ctr-font-unit": 8,
      "--ctr-line-height-unit": 8,
      "--ctr-size-unit": 8,
      "--ctr-spacing-unit": 8,
      "--ctr-corner-radius-unit": 8,
      "--ctr-stroke-unit": 1
    };
    this.themeName = _CreatorThemeModel.defaultThemeName;
    this.isLight = true;
    this.onThemeSelected = new EventBase();
    this.onThemePropertyChanged = new EventBase();
    this.blockThemeChangedNotifications = 0;
    this.onPropertyValueChangedCallback = (name, oldValue, newValue, sender, arrayChanges) => {
      this.onThemePropertyValueChangedCallback(name, oldValue, newValue, sender, arrayChanges);
    };
  }
  getType() {
    return "creatortheme";
  }
  get cssVariables() {
    return this.toJSON()["cssVariables"] || {};
  }
  cssVariableChangedHandler() {
    if (this.themeName === _CreatorThemeModel.defaultThemeName && Object.keys(this.cssVariables).length === 0) {
      this.loadTheme({
        themeName: _CreatorThemeModel.defaultThemeName
      });
    }
  }
  setThemeCssVariablesChanges(name, value) {
    if (this.themeCssVariablesChanges[name] !== value) {
      this.cssVariableChangedHandler();
      this.themeCssVariablesChanges[name] = value;
      this.onThemePropertyChanged.fire(this, {
        name,
        value
      });
    }
  }
  resetColorThemeCssVariablesChanges() {
    Object.keys(this.themeCssVariablesChanges).forEach((key) => {
      if (key.indexOf("--sjs-") === 0) {
        delete this.themeCssVariablesChanges[key];
      }
    });
  }
  onThemePropertyValueChangedCallback(name, oldValue, newValue, sender, arrayChanges) {
    if (this.blockThemeChangedNotifications > 0) return;
    if (name === "themeName") {
      this.resetColorThemeCssVariablesChanges();
      this.loadTheme({
        themeName: newValue
      });
      this.onThemeSelected.fire(this, {
        theme: this.toJSON()
      });
    } else if (name === "--sjs-primary-background-500") {
      this.setThemeCssVariablesChanges(name, newValue);
      this.setPropertyValue(name, newValue);
      this.updateBackgroundColor(newValue, oldValue);
    } else if (name === "--sjs-secondary-background-500" || name === "--sjs-special-background") {
      this.setThemeCssVariablesChanges(name, newValue);
      this.setPropertyValue(name, newValue);
    } else if (name.indexOf("--") === 0) {
      this.setThemeCssVariablesChanges(name, newValue);
    } else if (name == "fontScale" || name == "scale") {
      this.scalePropertiesChanged(name, newValue);
    }
  }
  scalePropertiesChanged(propertyName, newValue) {
    if (propertyName == "fontScale") {
      this.scalingProperties("--ctr-font-unit", newValue);
      this.scalingProperties("--ctr-line-height-unit", newValue);
    } else if (propertyName == "scale") {
      this.scalingProperties("--ctr-size-unit", newValue);
      this.scalingProperties("--ctr-spacing-unit", newValue);
      this.scalingProperties("--ctr-corner-radius-unit", newValue);
    }
  }
  scalingProperties(cssName, newValue) {
    const baseUnit = this.unitDictionary[cssName];
    this.setThemeCssVariablesChanges(cssName, newValue * baseUnit / 100 + "px");
  }
  scaleValue(cssName, scale) {
    const baseUnit = this.unitDictionary[cssName];
    this[cssName] = scale * baseUnit / 100 + "px";
  }
  scaleCssVariables() {
    if (this.fontScale !== void 0) {
      this.scaleValue("--ctr-font-unit", this.fontScale);
      this.scaleValue("--ctr-line-height-unit", this.fontScale);
    }
    if (this.scale !== void 0) {
      this.scaleValue("--ctr-size-unit", this.scale);
      this.scaleValue("--ctr-spacing-unit", this.scale);
      this.scaleValue("--ctr-corner-radius-unit", this.scale);
    }
  }
  getScaleFactor(cssName) {
    return !!this[cssName] ? roundTo2Decimals(parseFloat(this[cssName]) * 100 / this.unitDictionary[cssName]) : void 0;
  }
  updateScaleProperties() {
    this.blockThemeChangedNotifications += 1;
    try {
      this.fontScale = this.getScaleFactor("--ctr-font-unit");
      this.scale = this.getScaleFactor("--ctr-size-unit");
    } finally {
      this.blockThemeChangedNotifications -= 1;
    }
  }
  loadTheme(theme = {}) {
    this.blockThemeChangedNotifications += 1;
    try {
      const baseTheme = CreatorThemes[theme.themeName] || {};
      this.themeName = theme.themeName || baseTheme.themeName || _CreatorThemeModel.defaultThemeName;
      const effectiveThemeCssVariables = {};
      assign(effectiveThemeCssVariables, baseTheme.cssVariables || {});
      assign(effectiveThemeCssVariables, theme.cssVariables || {}, this.themeCssVariablesChanges);
      const effectiveTheme = {};
      assign(effectiveTheme, baseTheme, theme, {
        cssVariables: effectiveThemeCssVariables,
        themeName: this.themeName
      });
      this.fromJSON(effectiveTheme);
    } finally {
      this.blockThemeChangedNotifications -= 1;
    }
  }
  setTheme(theme) {
    this.themeCssVariablesChanges = {};
    try {
      this.blockThemeChangedNotifications += 1;
      this.iteratePropertiesHash((hash, key) => {
        this.setPropertyValue(key, void 0);
      });
    } finally {
      this.blockThemeChangedNotifications -= 1;
    }
    this.loadTheme(theme);
    this.onThemeSelected.fire(this, {
      theme: this.toJSON()
    });
  }
  fromJSON(json2, options) {
    if (!json2) return;
    const _json = {};
    assign(_json, json2);
    delete _json["cssVariables"];
    super.fromJSON(_json, options);
    this.isLight = json2.isLight !== void 0 ? json2.isLight : true;
    if (json2.cssVariables) {
      super.fromJSON(json2.cssVariables, options);
      this.initialCssVariables = {};
      assign(this.initialCssVariables, json2.cssVariables);
      this.updateScaleProperties();
    }
  }
  toJSON(options) {
    this.scaleCssVariables();
    const result = super.toJSON(options);
    if (!this.isLight) {
      result.isLight = false;
    }
    const cssVariables = {};
    assign(cssVariables, this.initialCssVariables, this.themeCssVariablesChanges);
    result.cssVariables = cssVariables;
    Object.keys(result).forEach((key) => {
      if (key.indexOf("--") == 0) {
        delete result[key];
      }
    });
    if (Object.keys(result.cssVariables).length === 0) {
      delete result.cssVariables;
    }
    return result;
  }
};
CreatorThemeModel.legacyThemeName = "sc2020";
CreatorThemeModel.defaultThemeName = "default-light";
__decorate2([property()], CreatorThemeModel.prototype, "themeName", void 0);
__decorate2([property()], CreatorThemeModel.prototype, "scale", void 0);
__decorate2([property()], CreatorThemeModel.prototype, "fontScale", void 0);
__decorate2([property()], CreatorThemeModel.prototype, "isLight", void 0);
Serializer.addClass("creatortheme", [{
  type: "dropdown",
  name: "themeName",
  choices: PredefinedCreatorThemes.map((theme) => ({
    value: theme,
    text: getLocString("creatortheme.names." + theme)
  }))
}, {
  type: "string",
  visible: false,
  name: "iconSet",
  default: "v2"
}], (json2) => {
  return new CreatorThemeModel();
});
Serializer.addProperties("creatortheme", [{
  type: "color",
  name: "--sjs-special-background",
  default: "#EDF9F7",
  enableIf: (obj) => {
    return !obj || obj.themeName !== CreatorThemeModel.legacyThemeName;
  },
  onPropertyEditorUpdate: function(obj, editor) {
    if (!!editor) {
      editor.titleLocation = "hidden";
    }
  }
}, {
  type: "color",
  name: "--sjs-primary-background-500",
  default: "#19B394",
  onPropertyEditorUpdate: function(obj, editor) {
    if (!!editor) {
      editor.titleLocation = "left";
      editor.title = getLocString("creatortheme.--sjs-primary-background-500");
    }
  }
}, {
  type: "color",
  name: "--sjs-secondary-background-500",
  default: "#19B394",
  displayName: "",
  onPropertyEditorUpdate: function(obj, editor) {
    if (!!editor) {
      editor.titleLocation = "left";
      editor.title = getLocString("creatortheme.--sjs-secondary-background-500");
    }
  }
}, {
  name: "--ctr-font-unit",
  default: "8px",
  visible: false
}, {
  name: "--ctr-line-height-unit",
  default: "8px",
  visible: false
}, {
  type: "spinedit",
  name: "fontScale",
  isSerializable: false,
  default: 100,
  enableIf: (obj) => {
    return !obj || obj.themeName !== CreatorThemeModel.legacyThemeName;
  },
  onPropertyEditorUpdate: function(obj, editor) {
    if (!!editor) {
      editor.unit = "%";
      editor.min = 50;
      editor.max = 200;
      editor.step = 5;
      editor.title = getLocString("creatortheme.fontScale");
      editor.titleLocation = "left";
      editor.descriptionLocation = "hidden";
      editor.changeValueOnPressing = false;
    }
  }
}, {
  name: "--ctr-spacing-unit",
  default: "8px",
  visible: false
}, {
  name: "--ctr-size-unit",
  default: "8px",
  visible: false
}, {
  name: "--ctr-corner-radius-unit",
  default: "8px",
  visible: false
}, {
  name: "--lbr-font-unit",
  default: "8px",
  visible: false
}, {
  name: "--lbr-line-height-unit",
  default: "8px",
  visible: false
}, {
  name: "--lbr-size-unit",
  default: "8px",
  visible: false
}, {
  name: "--lbr-spacing-unit",
  default: "8px",
  visible: false
}, {
  name: "--lbr-corner-radius-unit",
  default: "8px",
  visible: false
}, {
  name: "--lbr-size-unit",
  default: "8px",
  visible: false
}, {
  type: "spinedit",
  name: "scale",
  isSerializable: false,
  default: 100,
  enableIf: (obj) => {
    return !obj || obj.themeName !== CreatorThemeModel.legacyThemeName;
  },
  onPropertyEditorUpdate: function(obj, editor) {
    if (!!editor) {
      editor.unit = "%";
      editor.min = 25;
      editor.max = 200;
      editor.step = 5;
      editor.title = getLocString("creatortheme.userInterfaceBaseUnit");
      editor.titleLocation = "left";
      editor.descriptionLocation = "hidden";
      editor.changeValueOnPressing = false;
    }
  }
}, {
  name: "isLight:boolean",
  visible: false,
  isSerializable: false
}, {
  name: "--sjs-primary-background-400",
  visible: false
}, {
  name: "--sjs-primary-background-10",
  visible: false
}, {
  name: "--sjs-secondary-background-25",
  visible: false
}, {
  name: "--sjs-secondary-background-10",
  visible: false
}, {
  name: "--sjs-special-haze",
  visible: false
}, {
  name: "--sjs-special-glow",
  visible: false
}]);
var TabDesignerPlugin = class {
  get isSurveySelected() {
    return this.creator.isElementSelected(this.creator.survey);
  }
  get isSettingsActive() {
    const activePage = this.creator.sidebar.activePage;
    return notShortCircuitAnd(this.creator.showSidebar, this.isSurveySelected, activePage !== this.propertyGridPlaceholderPage.id);
  }
  get activePageIsPropertyGrid() {
    return this.creator.sidebar.activePage === this.propertyGridTab.id;
  }
  createSelectedUpdater() {
    return new ComputedUpdater(() => {
      return this.isSettingsActive;
    });
  }
  createVisibleUpdater() {
    return new ComputedUpdater(() => {
      return this.creator.activeTab === "designer";
    });
  }
  updateTabControl() {
    if (this.showOneCategoryInPropertyGrid) {
      this.creator.sidebar.sideAreaComponentName = "svc-tab-control";
      this.creator.sidebar.sideAreaComponentData = this.tabControlModel;
    } else {
      this.propertyGridViewModel.objectSelectionAction.tooltip = "";
      this.creator.sidebar.sideAreaComponentName = "";
      this.creator.sidebar.sideAreaComponentData = void 0;
    }
  }
  updateHeaderComponent() {
    const activePage = this.creator.sidebar.activePage;
    if (this.showOneCategoryInPropertyGrid && this.activePageIsPropertyGrid) {
      this.creator.sidebar.header.componentName = "svc-side-bar-property-grid-header";
      this.creator.sidebar.header.componentData = this.propertyGridViewModel.objectSelectionAction;
    } else if (this.showOneCategoryInPropertyGrid && (activePage === this.propertyGridPlaceholderPage.id || activePage === this.themePropertyGridTab.id)) {
      this.creator.sidebar.header.componentName = "svc-side-bar-header";
      this.creator.sidebar.header.componentData = this.creator.sidebar.header;
    } else {
      this.creator.sidebar.header.componentName = "";
      this.creator.sidebar.header.componentData = void 0;
    }
  }
  updateActivePage() {
    if (this.showOneCategoryInPropertyGrid) {
      this.setActivePage(this.creator.survey.pageCount ? this.propertyGridTab.id : this.propertyGridPlaceholderPage.id);
    } else {
      this.setPropertyGridIsActivePage();
    }
  }
  setPropertyGridIsActivePage() {
    this.setActivePage(this.propertyGridTab.id);
  }
  setActivePage(id) {
    this.creator.sidebar.activePage = id;
    this.updateHeaderComponent();
  }
  get showOneCategoryInPropertyGrid() {
    return this._showOneCategoryInPropertyGrid;
  }
  set showOneCategoryInPropertyGrid(newValue) {
    if (this._showOneCategoryInPropertyGrid !== newValue) {
      this._showOneCategoryInPropertyGrid = newValue;
      this.creator.sidebar.hideSideBarVisibilityControlActions = newValue;
      this.propertyGrid.showOneCategoryInPropertyGrid = newValue;
      this.propertyGrid["setObj"](this.creator.selectedElement);
      if (this.creator.activeTab === "designer") {
        this.updateActivePage();
        this.updateTabControl();
      }
    }
  }
  syncTheme(theme) {
    const newTheme = theme || this.themeModel.toJSON();
    this.creator.syncTheme(newTheme, this.themeModel.isLight);
  }
  updatePredefinedColorChoices() {
    this.themePropertyGrid.survey.getAllQuestions().forEach((question) => {
      if (question.name === "--sjs-special-background") {
        question.choices = this.themeModel && this.themeModel.isLight ? getPredefinedBackgoundColorsChoices() : [];
      }
      if (question.name === "--sjs-primary-background-500" || question.name === "--sjs-secondary-background-500") {
        question.choices = getPredefinedColorsItemValues(this.themeModel.isLight === false ? "dark" : "light");
      }
    });
  }
  updateThemeSettings() {
    if (this.creator.showCreatorThemeSettings) {
      this.themeModel.loadTheme(this.creator.creatorTheme);
      this.themePropertyGrid.obj = this.themeModel;
    }
  }
  setTheme() {
    if (this.creator.showCreatorThemeSettings) {
      this.themeModel.setTheme(this.creator.creatorTheme);
    }
  }
  createCreatorThemeSettingsPage(creator) {
    this.themeModel = new CreatorThemeModel();
    this.themePropertyGrid = new PropertyGridModel(void 0, creator, creatorThemeModelPropertyGridDefinition);
    this.themePropertyGrid.showOneCategoryInPropertyGrid = true;
    this.themePropertyGrid.surveyInstanceCreatedArea = "designer-tab:creator-settings";
    const themePropertyGridViewModel = new PropertyGridViewModel(this.themePropertyGrid, creator);
    themePropertyGridViewModel.onNewSurveyCreatedCallback = () => {
      this.onThemePropertyGridSurveyCreated();
    };
    themePropertyGridViewModel.searchEnabled = false;
    this.themePropertyGridTab = this.creator.sidebar.addPage("creatorTheme", "svc-property-grid", themePropertyGridViewModel);
    this.themePropertyGridTab.caption = editorLocalization.getString("ed.creatorSettingTitle");
    this.themePropertyGridTab.activateCallback = () => {
      settingsAction.active = true;
    };
    this.themePropertyGridTab.deactivateCallback = () => {
      settingsAction.active = false;
    };
    this.themeModel.onThemeSelected.add((sender, options) => {
      this.syncTheme(options.theme);
      this.themePropertyGrid.survey.editingObj = void 0;
      this.themePropertyGrid.survey.editingObj = sender;
      this.updatePredefinedColorChoices();
      this.creator.onCreatorThemeSelected.fire(this.creator, options);
    });
    this.themeModel.onThemePropertyChanged.add((sender, options) => {
      this.syncTheme();
      this.creator.onCreatorThemePropertyChanged.fire(this.creator, options);
    });
    const settingsAction = new MenuButton({
      id: "theme-settings",
      locTooltipName: "ed.creatorSettingTitle",
      iconName: "gear-24x24",
      iconSize: "auto",
      pressed: false,
      action: () => {
        if (settingsAction.active) {
          this.closeCreatorThemeSettings();
        } else {
          this.openCreatorThemeSettings();
        }
      }
    });
    this.tabControlModel.bottomToolbar.setItems([settingsAction]);
  }
  onThemePropertyGridSurveyCreated() {
    const survey = this.themePropertyGrid.survey;
    survey.css.root += " svc-creator-theme-settings";
    survey.onUpdatePanelCssClasses.add((_, options) => {
      options.cssClasses.panel.container += " spg-panel--group";
    });
    const themeChooser = survey.getQuestionByName("themeName");
    if (!!themeChooser) {
      themeChooser.choices = PredefinedCreatorThemes.map((theme) => ({
        value: theme,
        text: getLocString("creatortheme.names." + theme)
      }));
    }
    survey.runExpressions();
    this.updatePredefinedColorChoices();
  }
  constructor(creator) {
    this.creator = creator;
    this._showOneCategoryInPropertyGrid = true;
    creator.addTab({
      name: "designer",
      plugin: this,
      iconName: "icon-config"
    });
    this.tabControlModel = new TabControlModel(this.creator.sidebar);
    this.tabControlModel.onTopToolbarItemCreated = (bar) => {
      this.setupPropertyGridTabActions(bar);
    };
    this.propertyGrid = new PropertyGridModel(void 0, creator, creator.getPropertyGridDefinition());
    this.showOneCategoryInPropertyGrid = creator.showOneCategoryInPropertyGrid;
    this.propertyGrid.showOneCategoryInPropertyGrid = this.showOneCategoryInPropertyGrid;
    this.propertyGrid.obj = creator.survey;
    this.propertyGridViewModel = new PropertyGridViewModel(this.propertyGrid, creator);
    this.propertyGridViewModel.onNewSurveyCreatedCallback = () => {
      this.updateTabControlActions();
    };
    this.propertyGridPlaceholderPage = this.creator.sidebar.addPage("propertyGridPlaceholder", "svc-property-grid-placeholder", this.propertyGridViewModel);
    this.propertyGridPlaceholderPage.caption = editorLocalization.getString("ed.surveySettings");
    this.propertyGridTab = this.creator.sidebar.addPage("propertyGrid", "svc-property-grid", this.propertyGridViewModel, () => {
      const result = [];
      if (!!this.propertyGridViewModel.prevSelectionAction) {
        this.propertyGridViewModel.prevSelectionAction.visible = this.createVisibleUpdater();
        result.push(this.propertyGridViewModel.prevSelectionAction);
      }
      if (!!this.propertyGridViewModel.nextSelectionAction) {
        this.propertyGridViewModel.nextSelectionAction.visible = this.createVisibleUpdater();
        result.push(this.propertyGridViewModel.nextSelectionAction);
      }
      if (!!this.propertyGridViewModel.objectSelectionAction) {
        this.propertyGridViewModel.objectSelectionAction.visible = this.createVisibleUpdater();
        result.push(this.propertyGridViewModel.objectSelectionAction);
      }
      return result;
    });
    creator.onElementSelected.add((sender, options) => {
      if (this.showOneCategoryInPropertyGrid && this.creator.activeTab === "designer") {
        this.setPropertyGridIsActivePage();
        this.updateTabControlActions();
      }
    });
    this.toolboxTab = this.creator.sidebar.addPage("toolbox", "svc-toolbox", creator);
    if (this.creator.showCreatorThemeSettings) {
      this.createCreatorThemeSettingsPage(creator);
    }
    this.designerStateManager = new DesignerStateManager();
    this.designerStateManager.initForSurvey(this.creator.survey);
    this.creator.onSurveyInstanceCreated.add((s, o) => {
      if (o.reason == "designer") {
        this.designerStateManager.initForSurvey(o.survey);
      }
    });
    this.creator.onPropertyChanged.add((sender, options) => {
      if (options.name === "toolboxLocation") {
        if (this.toolboxTab.visible && options.newVal !== "sidebar") {
          this.propertyGridTab.visible = true;
        }
        this.toolboxTab.visible = options.newVal === "sidebar";
      }
    });
    this.createActions().forEach((action) => creator.toolbar.actions.push(action));
    creator.registerShortcut("delete", {
      affectedTab: "designer",
      hotKey: {
        keyCode: 46
      },
      macOsHotkey: {
        keyCode: 46
      },
      execute: () => {
        if (!this.creator.readOnly) {
          this.creator.deleteCurrentElement();
        }
      }
    });
  }
  updateTabControlActions() {
    var _a;
    if (this.showOneCategoryInPropertyGrid) {
      if (this.tabControlModel.isTopToolbarCreated) {
        this.setupPropertyGridTabActions(this.tabControlModel.topToolbar);
      }
      this.propertyGrid.survey.onCurrentPageChanged.add((sender, options) => {
        const pgTabs = this.tabControlModel.topToolbar.actions;
        pgTabs.forEach((action) => {
          action.active = action.id === options.newCurrentPage.name;
        });
        this.propertyGridViewModel.objectSelectionAction.title = options.newCurrentPage.title;
      });
      this.propertyGrid.survey.onPageVisibleChanged.add((sender, options) => {
        const action = this.tabControlModel.topToolbar.getActionById(options.page.name);
        if (!!action) {
          action.visible = options.page.isVisible;
        }
      });
      this.propertyGridViewModel.objectSelectionAction.title = (_a = this.propertyGrid.survey.currentPage) === null || _a === void 0 ? void 0 : _a.title;
    }
  }
  setupPropertyGridTabActions(topToolbar) {
    const pgTabs = this.getPropertyGridTabActions();
    topToolbar.setItems(pgTabs);
    this.propertyGridTab.activateCallback = () => {
      if (!this.propertyGrid.survey.currentPage) return;
      pgTabs.forEach((action) => {
        action.active = action.id === this.propertyGrid.survey.currentPage.name;
      });
    };
    this.propertyGridTab.deactivateCallback = () => {
      pgTabs.forEach((tab) => tab.active = false);
    };
  }
  getPropertyGridTabActions() {
    const pgTabs = [];
    this.propertyGrid.survey.pages.forEach((p) => {
      if (p.elements.length === 0) return;
      const action = new MenuButton({
        id: p.name,
        tooltip: p.title,
        iconName: pgTabIcons[p.name] || pgTabIcons["undefined"],
        iconSize: "auto",
        active: this.activePageIsPropertyGrid && p.name === this.propertyGrid.survey.currentPage.name,
        pressed: false,
        visible: p.isVisible,
        action: () => {
          this.creator.sidebar.expandSidebar();
          this.setPropertyGridIsActivePage();
          this.propertyGrid.survey.currentPage = p;
          pgTabs.forEach((i) => i.active = false);
          action.active = true;
        }
      });
      pgTabs.push(action);
    });
    return pgTabs;
  }
  activate() {
    this.model = new TabDesignerViewModel(this.creator);
    this.model.surfaceScale = this.creator.survey.widthScale;
    this.creator.sidebar.hideSideBarVisibilityControlActions = this.showOneCategoryInPropertyGrid;
    this.updateActivePage();
    this.updateTabControl();
    this.updateThemeSettings();
    this.creator.focusElement(void 0, true);
  }
  deactivate() {
    if (this.model) {
      this.model.dispose();
    }
    this.model = void 0;
    this.propertyGridTab.visible = false;
    this.propertyGridPlaceholderPage.visible = false;
    if (!!this.themePropertyGridTab) this.themePropertyGridTab.visible = false;
    this.toolboxTab.visible = false;
    this.creator.sidebar.hideSideBarVisibilityControlActions = false;
    this.creator.sidebar.sideAreaComponentName = void 0;
    this.creator.sidebar.sideAreaComponentData = void 0;
    this.creator.sidebar.onPropertyChanged.clear();
    this.creator.sidebar.header.reset();
    this.creator.expandCollapseManager.clear();
    return true;
  }
  onDesignerSurveyPropertyChanged(obj, propName) {
    if (!!this.model) {
      this.model.onDesignerSurveyPropertyChanged(obj, propName);
    }
  }
  update() {
    if (!this.model) return;
    this.updateActivePage();
    this.model.initSurvey();
  }
  createActions() {
    const items = [];
    const toolboxAction = new Action({
      id: "svd-toolbox",
      iconName: "icon-toolbox",
      iconSize: "auto",
      needSeparator: true,
      action: () => {
        if (!this.creator.showSidebar) {
          this.creator.setShowSidebar(true, true);
        }
        this.setActivePage("toolbox");
      },
      active: new ComputedUpdater(() => this.creator.sidebar.activePage === "toolbox"),
      visible: new ComputedUpdater(() => {
        return notShortCircuitAnd(this.creator.activeTab === "designer", this.creator.showToolbox, this.creator.toolboxLocation === "sidebar");
      }),
      title: "Toolbox",
      showTitle: false
    });
    this.surveySettingsAction = new Action({
      id: "svd-settings",
      iconName: "icon-settings",
      iconSize: "auto",
      needSeparator: new ComputedUpdater(() => {
        return notShortCircuitAnd(this.creator.toolboxLocation !== "sidebar", !this.creator.isMobileView);
      }),
      action: () => {
        this.selectSurvey();
        if (!this.creator.isMobileView) {
          this.creator.sidebar.executeOnExpand(() => {
            this.creator.propertyGrid.getAllQuestions()[0].focus();
          });
        }
      },
      active: this.createSelectedUpdater(),
      visible: this.createVisibleUpdater(),
      locTitleName: "ed.surveySettings",
      locTooltipName: "ed.surveySettingsTooltip",
      showTitle: false
    });
    this.saveSurveyAction = new Action({
      id: "svd-save",
      iconName: "icon-save",
      iconSize: "auto",
      action: () => this.creator.saveSurveyActionHandler(),
      active: false,
      enabled: false,
      visible: new ComputedUpdater(() => {
        return notShortCircuitAnd(this.creator.activeTab === "designer", this.creator.showSaveButton);
      }),
      locTitleName: "ed.saveSurvey",
      locTooltipName: "ed.saveSurveyTooltip",
      showTitle: false
    });
    this.designerAction = new Action({
      id: "svd-designer",
      iconName: "icon-config",
      iconSize: "auto",
      visible: this.createVisibleUpdater(),
      active: true,
      locTitleName: "ed.designer",
      showTitle: false,
      action: () => {
      }
    });
    this.previewAction = new Action({
      id: "svd-preview",
      iconName: "icon-preview",
      iconSize: "auto",
      action: () => {
        this.creator.switchTab(this.creator.showThemeTab ? "theme" : "preview");
      },
      visible: this.createVisibleUpdater(),
      locTitleName: "tabs.preview",
      showTitle: false
    });
    items.push(this.saveSurveyAction);
    items.push(toolboxAction);
    items.push(this.surveySettingsAction);
    this.creator.onElementSelected.add((sender, options) => {
      this.surveySettingsAction.active = this.isSettingsActive;
    });
    this.creator.onShowSidebarVisibilityChanged.add((sender, options) => {
      this.surveySettingsAction.active = this.isSettingsActive;
    });
    return items;
  }
  selectSurvey() {
    if (!this.creator.showSidebar) {
      this.creator.setShowSidebar(true, true);
    }
    this.creator.selectElement(this.creator.survey);
    this.setPropertyGridIsActivePage();
  }
  addFooterActions() {
    this.creator.footerToolbar.actions.push(this.designerAction);
    this.creator.footerToolbar.actions.push(this.previewAction);
    this.creator.footerToolbar.actions.push(this.surveySettingsAction);
  }
  openCreatorThemeSettings() {
    this.creator.sidebar.expandSidebar();
    this.prevActivePage = this.creator.sidebar.activePage;
    this.setActivePage(this.themePropertyGridTab.id);
  }
  closeCreatorThemeSettings() {
    this.setActivePage(this.prevActivePage || this.propertyGridTab.id);
  }
};
var CreatorResponsivityManager = class _CreatorResponsivityManager {
  getScreenWidth() {
    let res;
    Object.keys(_CreatorResponsivityManager.screenSizeBreakpoints).forEach((mode) => {
      const breakpoint = _CreatorResponsivityManager.screenSizeBreakpoints[mode];
      if (!res && this.container && !!breakpoint && this.container.offsetWidth >= breakpoint) {
        res = mode;
      }
    });
    return res || "xs";
  }
  initMobileView() {
    this.creator.showTabs = false;
    this.creator.showToolbar = false;
    this.creator.isMobileView = true;
  }
  resetMobileView() {
    this.creator.showTabs = void 0;
    this.creator.showToolbar = void 0;
    this.creator.isMobileView = void 0;
  }
  procesShowToolbox(toolboxVisible) {
    this.creator.allowShowToolbox = toolboxVisible;
  }
  procesShowPageNavigator(pageNavigatorVisibility) {
    this.creator.allowShowPageNavigator = this.creator.pageEditMode === "bypage" || pageNavigatorVisibility;
  }
  procesShowSurfaceToolbar(toolboxVisible) {
    this.creator.allowShowSurfaceToolbar = toolboxVisible;
  }
  findCorrectParent(container) {
    if (!!(window === null || window === void 0 ? void 0 : window.getComputedStyle)) {
      if (window.getComputedStyle(container.parentElement).display === "inline") {
        return this.findCorrectParent(container.parentElement);
      }
    }
    return container.parentElement;
  }
  constructor(container, creator) {
    this.container = container;
    this.creator = creator;
    this.resizeObserver = void 0;
    if (typeof ResizeObserver !== "undefined") {
      this.resizeObserver = new ResizeObserver((_) => this.process());
      this.resizeObserver.observe(this.findCorrectParent(this.container));
      this.process(true);
      if (this.currentWidth == "xs" || this.currentWidth == "s" || this.currentWidth === "m") {
        this.creator.setShowSidebar(false);
      }
    }
  }
  _process(toolboxIsCompact, toolboxVisible, flyoutSidebar) {
    this.creator.updateToolboxIsCompact(toolboxIsCompact);
    this.procesShowToolbox(toolboxVisible);
    this.procesShowPageNavigator(toolboxVisible);
    this.procesShowSurfaceToolbar(toolboxVisible);
    if (this.creator.sidebar.visible && !flyoutSidebar) {
      this.creator.sidebar.collapsedManually = false;
    }
    if (this.creator.sidebar.visible && !this.creator.sidebar.expandedManually && flyoutSidebar && this.creator.toolboxLocation != "right") {
      this.creator.sidebar.collapseSidebar();
    }
    if (!this.creator.sidebar.visible && !this.creator.sidebar.collapsedManually && !flyoutSidebar && this.creator.toolboxLocation != "right") {
      this.creator.sidebar.expandSidebar();
    }
    this.creator.sidebar.flyoutMode = flyoutSidebar;
  }
  process(isFirst = false) {
    if (isFirst) {
      this.creator.sidebar.blockAnimations();
      this.creator.toolbox.blockAnimations();
    }
    this.updateSurveyActualWidth();
    this.currentWidth = this.getScreenWidth();
    if (this.currentWidth === "xl" || this.currentWidth === "xxl") {
      this._process(false, true, false);
    } else if (this.currentWidth === "l") {
      this._process(true, true, false);
    } else if (this.currentWidth === "m") {
      this._process(true, true, true);
    } else {
      this._process(true, false, true);
    }
    if (this.currentWidth == "xs") {
      this.initMobileView();
    } else {
      this.resetMobileView();
    }
    if (isFirst) {
      this.creator.sidebar.releaseAnimations();
      this.creator.toolbox.releaseAnimations();
    }
  }
  updateSurveyActualWidth() {
    var _a;
    if (!!this.container && !!this.container.querySelector) {
      const surveyContainer = (_a = this.container) === null || _a === void 0 ? void 0 : _a.querySelector(".svc-tab-designer_content");
      if (!!surveyContainer && window && typeof window.getComputedStyle === "function") {
        const conputedStyles = getComputedStyle(surveyContainer);
        let paddingLeft = 0;
        let paddingRight = 0;
        try {
          paddingLeft = parseFloat((conputedStyles.paddingLeft || "").replace("px", ""));
          paddingRight = parseFloat((conputedStyles.paddingRight || "").replace("px", ""));
        } catch (e) {
        }
        this.creator.survey.setResponsiveStartWidth(surveyContainer.offsetWidth - paddingLeft - paddingRight);
        const surveyContent = surveyContainer.querySelector("div");
        if (!!surveyContent) {
          this.creator.survey.setStaticStartWidth(surveyContent.clientWidth / this.creator.survey.widthScale * 100);
        }
      }
    }
  }
  dispose() {
    this.creator.allowShowToolbox = true;
    this.creator.allowShowPageNavigator = true;
    if (!!this.resizeObserver) {
      this.resizeObserver.disconnect();
    }
  }
};
CreatorResponsivityManager.screenSizeBreakpoints = {
  "xxl": 1800,
  "xl": 1500,
  "l": 1200,
  "m": 900,
  "s": 600
};
var SidebarPageModel = class extends Base {
  constructor(id, sidePanel, componentName, componentData) {
    super();
    this.id = id;
    this.sidePanel = sidePanel;
    !!componentName && (this.componentName = componentName);
    !!componentData && (this.componentData = componentData);
  }
};
__decorate2([property()], SidebarPageModel.prototype, "caption", void 0);
__decorate2([property({
  onSet: (newVal, target) => {
    target.sidePanel.updateHasVisiblePages();
  }
})], SidebarPageModel.prototype, "visible", void 0);
__decorate2([property()], SidebarPageModel.prototype, "componentData", void 0);
__decorate2([property()], SidebarPageModel.prototype, "componentName", void 0);
var SidebarHeaderModel = class extends Base {
  constructor() {
    super(...arguments);
    this.toolbar = new AdaptiveActionContainer();
  }
  get component() {
    return this.componentName || "svc-side-bar-default-header";
  }
  get componentModel() {
    return this.componentData || this;
  }
  reset() {
    this.title = "";
    this.subTitle = "";
    this.componentName = "";
    this.componentData = void 0;
  }
};
__decorate2([property()], SidebarHeaderModel.prototype, "title", void 0);
__decorate2([property()], SidebarHeaderModel.prototype, "subTitle", void 0);
__decorate2([property()], SidebarHeaderModel.prototype, "componentData", void 0);
__decorate2([property()], SidebarHeaderModel.prototype, "componentName", void 0);
var ResizeManager = class {
  constructor(container, handles) {
    this.container = container;
    this.events = {
      "mousedown": {
        "touch": "touchend",
        "mouse": "mousedown",
        "pointer": "pointerdown"
      },
      "mouseup": {
        "touch": "touchstart",
        "mouse": "mouseup",
        "pointer": "pointerup"
      },
      "mousemove": {
        "touch": "touchmove",
        "mouse": "mousemove",
        "pointer": "pointermove"
      }
    };
    this.onMouseDownListener = (e) => {
      if (!window) return;
      e.preventDefault();
      this.originalWidth = this.getStyleValue(this.container, "width");
      this.originalMouseX = e.pageX;
      this.currentResizer = e.target;
      window.addEventListener(this.getMouseEvent("mousemove"), this.resize);
      window.addEventListener(this.getMouseEvent("mouseup"), this.stopResize);
    };
    this.resize = (e) => {
      let width = this.originalWidth;
      const horizontalDistinction = e.pageX - this.originalMouseX;
      if (this.currentResizer == this.westResizer) {
        width -= horizontalDistinction;
      } else {
        width += horizontalDistinction;
      }
      if (width > this.maxWidth) {
        width = this.maxWidth;
      } else if (width < this.minWidth) {
        width = this.minWidth;
      }
      this.container.style.width = width + "px";
    };
    this.stopResize = (e) => {
      if (!window) return;
      window.removeEventListener(this.getMouseEvent("mousemove"), this.resize);
      window.removeEventListener(this.getMouseEvent("mouseup"), this.stopResize);
    };
    this.init(container);
    this.setHandles(handles);
  }
  setHandles(newVal) {
    let isThereWestResizer = false;
    let isThereEastResizer = false;
    let inputVal = newVal.split(",");
    inputVal.forEach((str) => str.trim());
    inputVal = inputVal.filter((str) => !!str);
    (inputVal || []).forEach((handrail) => {
      if (handrail == "w") isThereWestResizer = true;
      if (handrail == "e") isThereEastResizer = true;
    });
    this.westResizer.style["display"] = isThereWestResizer ? "block" : "none";
    this.eastResizer.style["display"] = isThereEastResizer ? "block" : "none";
  }
  getStyleValue(element, style) {
    if (!window) return 0;
    return parseFloat(window.getComputedStyle(element).getPropertyValue(style).replace("px", ""));
  }
  isEventSupported(eventName) {
    let el = document.createElement("div");
    eventName = "on" + eventName;
    let isSupported = eventName in el;
    if (!isSupported) {
      el.setAttribute(eventName, "return;");
      isSupported = typeof el[eventName] == "function";
    }
    el = null;
    return isSupported;
  }
  getEventPrefix() {
    if (this.mouseDevice === void 0) {
      if (this.isEventSupported("pointerdown")) {
        this.mouseDevice = "pointer";
      } else if (this.isEventSupported("touchstart")) {
        this.mouseDevice = "touch";
      } else if (this.isEventSupported("mousedown")) {
        this.mouseDevice = "mouse";
      }
    }
    return this.mouseDevice;
  }
  getMouseEvent(eventName) {
    return this.events[eventName][this.getEventPrefix()];
  }
  init(container) {
    this.westResizer = this.createrResizerElement("svc-resizer svc-resizer-west");
    this.eastResizer = this.createrResizerElement("svc-resizer svc-resizer-east");
    this.minWidth = this.getStyleValue(container, "min-width");
    this.maxWidth = this.getStyleValue(container, "max-width");
    container.insertBefore(this.westResizer, container.children[0]);
    container.appendChild(this.eastResizer);
  }
  createrResizerElement(className) {
    const resizer = document.createElement("div");
    resizer.className = className;
    resizer.addEventListener(this.getMouseEvent("mousedown"), this.onMouseDownListener);
    return resizer;
  }
  dispose() {
    this.eastResizer.removeEventListener(this.getMouseEvent("mousedown"), this.onMouseDownListener);
    this.eastResizer.remove();
    this.eastResizer = void 0;
    this.westResizer.removeEventListener(this.getMouseEvent("mousedown"), this.onMouseDownListener);
    this.westResizer.remove();
    this.westResizer = void 0;
  }
};
var SidebarModel = class extends Base {
  get rootCss() {
    return new CssClassBuilder().append("svc-side-bar").append("svc-side-bar--flyout", this.flyoutPanelMode).append("svc-side-bar--mobile", this.creator.isMobileView).append("svc-side-bar--side-area", !!this.sideAreaComponentName).toString();
  }
  get renderRoot() {
    return this.hasVisiblePages && (!this.creator.isMobileView || this.renderedIsVisible);
  }
  get renderContainer() {
    return this.renderedIsVisible;
  }
  getAnimationOptions() {
    const onBeforeRunAnimation = (el) => {
      const animatedElements = el.querySelectorAll(".svc-side-bar__container-wrapper,.svc-side-bar__wrapper");
      animatedElements.forEach((el2) => {
        el2.style.setProperty("--animation-width", el2.offsetWidth + "px");
      });
    };
    return {
      getAnimatedElement: () => {
        return this.rootElement;
      },
      isAnimationEnabled: () => this.animationAllowed,
      getRerenderEvent: () => this.onElementRerendered,
      getLeaveOptions: () => {
        return {
          onBeforeRunAnimation,
          cssClass: "svc-side-bar--leave"
        };
      },
      getEnterOptions: () => {
        return {
          onBeforeRunAnimation,
          cssClass: "svc-side-bar--enter",
          onAfterRunAnimation: () => this.afterExpand()
        };
      }
    };
  }
  afterExpand() {
    this.onExpandCallback && this.onExpandCallback();
    this.onExpandCallback = void 0;
  }
  executeOnExpand(callback) {
    if (this.renderedIsVisible) {
      callback();
    }
    this.onExpandCallback = callback;
  }
  set visible(val) {
    if (this._visible && !val && !this.flyoutMode) {
      this.allowFlyoutMode = false;
    }
    if (this._visible !== val) {
      this._visible = val;
      if (!this.animationAllowed) {
        this.afterExpand();
      }
      this.visibilityAnimation.sync(val);
    }
  }
  get visible() {
    return this._visible;
  }
  get flyoutPanelMode() {
    return this.flyoutMode && this.allowFlyoutMode;
  }
  get closeText() {
    return getLocString("pe.close");
  }
  getPageById(id) {
    return this.pages.filter((page) => page.id === id)[0];
  }
  createActions() {
    this._collapseAction = new Action({
      id: "svd-grid-hide",
      iconName: "icon-collapse-panel",
      iconSize: "auto",
      css: "svd-grid-hide",
      locTitleName: "ed.hidePanel",
      showTitle: false,
      visible: new ComputedUpdater(() => {
        return notShortCircuitAnd(!notShortCircuitAnd(!this.creator.allowCollapseSidebar, !this.flyoutMode), this.visible, !this.hideSideBarVisibilityControlActions);
      }),
      action: () => {
        this.collapseSidebar();
        if (!this.flyoutMode) {
          this.collapsedManually = true;
          this.expandedManually = false;
        } else {
          this.creator.focusElement(this.creator.selectedElement, true);
        }
      }
    });
    this.header.toolbar.actions.push(this._collapseAction);
    if (this.creator.allowCollapseSidebar) {
      this._expandAction = new Action({
        id: "svd-grid-expand",
        iconName: "icon-expand-panel",
        iconSize: "auto",
        css: "svd-grid-expand",
        needSeparator: true,
        action: () => {
          this.expandSidebar();
          if (!this.flyoutMode) {
            this.collapsedManually = false;
            this.expandedManually = this.flyoutMode;
          }
        },
        locTitleName: "ed.showPanel",
        visible: new ComputedUpdater(() => {
          return notShortCircuitAnd(this.hasVisiblePages, !this.visible, !this.hideSideBarVisibilityControlActions);
        }),
        showTitle: false
      });
    }
  }
  getCurrentHandles() {
    return this.creator.sidebarLocation == "right" ? "w" : "e";
  }
  constructor(creator) {
    super();
    this.creator = creator;
    this.header = new SidebarHeaderModel();
    this.allowFlyoutMode = true;
    this.visibilityAnimation = new AnimationBoolean(this.getAnimationOptions(), (val) => {
      this.renderedIsVisible = val;
      this.allowFlyoutMode = true;
    }, () => this.renderedIsVisible);
    this.sidebarLocationChangedHandler = (sender, options) => {
      if (options.name === "sidebarLocation" && !!this.resizeManager) {
        this.resizeManager.setHandles(this.getCurrentHandles());
      }
    };
    this.onSidebarVisibilityChanged = (sender, options) => {
      if (this.isDisposed) return;
      this.visible = options.show;
    };
    this.creator.onShowSidebarVisibilityChanged.add(this.onSidebarVisibilityChanged);
    this.creator.onPropertyChanged.add(this.sidebarLocationChangedHandler);
    this.visible = this.creator.showSidebar;
    this.createActions();
  }
  get activePage() {
    return this.getPropertyValue("activePage");
  }
  set activePage(val) {
    this.setPropertyValue("activePage", val);
    this.setActivePage(this.pages.filter((page) => page.id === val)[0]);
  }
  getActivePage() {
    return this._activePage;
  }
  setActivePage(newPage) {
    if (!!this._activePage && this._activePage.id !== newPage.id && !!this._activePage.deactivateCallback) {
      this._activePage.deactivateCallback();
    }
    this.pages.forEach((page) => page.visible = false);
    this._activePage = newPage;
    if (this._activePage) {
      this.header.title = this._activePage.caption;
      this._activePage.visible = true;
      if (!!this._activePage.activateCallback) {
        this._activePage.activateCallback();
      }
    }
  }
  getExpandAction() {
    return this._expandAction;
  }
  collapseSidebar() {
    this.creator.setShowSidebar(false);
  }
  expandSidebar() {
    this.creator.setShowSidebar(true);
  }
  addPage(id, componentName, model, buildActions) {
    const page = new SidebarPageModel(id, this, componentName, model);
    this.pages.push(page);
    if (!!buildActions) {
      (buildActions() || []).forEach((action) => this.header.toolbar.actions.push(action));
    }
    return page;
  }
  updateHasVisiblePages() {
    this.hasVisiblePages = (this.pages || []).filter((page) => page.visible).length > 0;
  }
  dispose() {
    if (!!this.creator && !this.isDisposed) {
      this.creator.onShowSidebarVisibilityChanged.remove(this.onSidebarVisibilityChanged);
      this.creator.onPropertyChanged.remove(this.sidebarLocationChangedHandler);
      this.sidebarLocationChangedHandler = void 0;
    }
    this.resetResizeManager();
    super.dispose();
  }
  initResizeManager(container) {
    var _a;
    this.resizeManager = new ResizeManager(container, this.getCurrentHandles());
    this.rootElement = (_a = container === null || container === void 0 ? void 0 : container.parentElement) === null || _a === void 0 ? void 0 : _a.parentElement.parentElement;
  }
  resetResizeManager() {
    if (!!this.resizeManager) {
      this.resizeManager.dispose();
      this.resizeManager = void 0;
    }
    this.rootElement = void 0;
  }
  get toolbar() {
    var _a;
    return (_a = this.header) === null || _a === void 0 ? void 0 : _a.toolbar;
  }
};
__decorate2([propertyArray()], SidebarModel.prototype, "pages", void 0);
__decorate2([property({
  defaultValue: true
})], SidebarModel.prototype, "_visible", void 0);
__decorate2([property({
  defaultValue: true
})], SidebarModel.prototype, "renderedIsVisible", void 0);
__decorate2([property({
  defaultValue: false
})], SidebarModel.prototype, "collapsedManually", void 0);
__decorate2([property({
  defaultValue: false
})], SidebarModel.prototype, "expandedManually", void 0);
__decorate2([property()], SidebarModel.prototype, "hasVisiblePages", void 0);
__decorate2([property({
  defaultValue: false
})], SidebarModel.prototype, "flyoutMode", void 0);
__decorate2([property()], SidebarModel.prototype, "hideSideBarVisibilityControlActions", void 0);
__decorate2([property()], SidebarModel.prototype, "sideAreaComponentName", void 0);
__decorate2([property()], SidebarModel.prototype, "sideAreaComponentData", void 0);
__decorate2([property({})], SidebarModel.prototype, "allowFlyoutMode", void 0);
var StringItemsNavigatorBase = class _StringItemsNavigatorBase {
  constructor(question) {
    this.question = question;
  }
  static createItemsNavigator(question) {
    if (question instanceof QuestionImagePickerModel) return null;
    if (question instanceof QuestionMultipleTextModel) return new StringItemsNavigatorMultipleText(question);
    if (question instanceof QuestionMatrixDropdownModel) return new StringItemsNavigatorMatrixDropdown(question);
    if (question instanceof QuestionMatrixDynamicModel) return new StringItemsNavigatorMatrixDynamic(question);
    if (question instanceof QuestionMatrixModel) return new StringItemsNavigatorMatrix(question);
    if (question instanceof QuestionSelectBase) return new StringItemsNavigatorSelectBase(question);
    return null;
  }
  addNewItems(creator, items, startIndex, itemsToAdd) {
    let newItems = items.slice();
    const createNewItem = (text) => {
      const val = creator.inplaceEditForValues ? text : getNextItemValue(creator.getChoicesItemBaseTitle(), newItems);
      if (this.question.createItemValue) return this.question.createItemValue(val, text);
      return new ItemValue(val, text);
    };
    newItems.splice(startIndex, 1);
    itemsToAdd.forEach((item, offset) => {
      if (creator.maximumChoicesCount <= 0 || newItems.length < creator.maximumChoicesCount) {
        newItems.splice(startIndex + offset, 0, createNewItem(item));
      }
    });
    this.question[this.getItemsPropertyName(items)] = newItems;
  }
  setEventsForItem(creator, items, item) {
    const connector = StringEditorConnector.get(this.getItemLocString(items, item));
    connector.allowLineBreaksOnEdit = true;
    connector.onEditComplete.clear();
    connector.onEditComplete.add(() => {
      const itemIndex = items.indexOf(item);
      if (itemIndex >= 0 && itemIndex < items.length - 1) {
        StringEditorConnector.get(this.getItemLocString(items, items[itemIndex + 1])).activateEditor();
      }
      if (itemIndex == items.length - 1) {
        this.addNewItem(creator, items);
        StringEditorConnector.get(this.getItemLocString(items, items[items.length - 1])).setAutoFocus();
        StringEditorConnector.get(this.getItemLocString(items, items[items.length - 1])).activateEditor();
      }
    });
    connector.onBackspaceEmptyString.clear();
    connector.onBackspaceEmptyString.add(() => {
      const itemIndex = items.indexOf(item);
      let itemToFocus = null;
      if (itemIndex !== -1) {
        if (itemIndex == 0 && items.length >= 2) itemToFocus = items[1];
        if (itemIndex > 0) itemToFocus = items[itemIndex - 1];
        if (itemToFocus) {
          const connector2 = StringEditorConnector.get(this.getItemLocString(items, itemToFocus));
          connector2.setAutoFocus();
          connector2.activateEditor();
        }
        items.splice(itemIndex, 1);
      }
    });
    connector.onTextChanging.clear();
    connector.onTextChanging.add((sender, options) => {
      let lines = options.value.split(/\r?\n/).map((line) => (line || "").trim()).filter((line) => !!line);
      if (lines.length <= 1) return;
      options.cancel = true;
      const itemIndex = items.indexOf(item);
      this.addNewItems(creator, items, itemIndex, lines);
      let focusedItemIndex = itemIndex + lines.length;
      if (focusedItemIndex >= items.length) focusedItemIndex = items.length - 1;
      StringEditorConnector.get(this.getItemLocString(items, items[focusedItemIndex])).setAutoFocus();
      StringEditorConnector.get(this.getItemLocString(items, items[focusedItemIndex])).activateEditor();
    });
  }
  static setQuestion(questionAdorner) {
    const question = questionAdorner.element;
    const navigator2 = _StringItemsNavigatorBase.createItemsNavigator(question);
    if (navigator2) {
      const creator = questionAdorner.creator;
      const titleConnector = StringEditorConnector.get(question.locTitle);
      let allItemSets = navigator2.getItemSets();
      let activeChoices = allItemSets[0];
      if (!titleConnector.hasEditCompleteHandler) {
        titleConnector.onEditComplete.add(() => {
          if (activeChoices.length) StringEditorConnector.get(navigator2.getItemLocString(activeChoices, activeChoices[0])).activateEditor();
        });
        titleConnector.hasEditCompleteHandler = true;
      }
      allItemSets.forEach((activeChoices2) => {
        activeChoices2.forEach((item) => {
          navigator2.setEventsForItem(creator, activeChoices2, item);
        });
        const itemsPropertyName = navigator2.getItemsPropertyName(activeChoices2);
        question.onPropertyChanged.add((sender, options) => {
          if (options.name == itemsPropertyName) {
            activeChoices2.forEach((item) => {
              navigator2.setEventsForItem(creator, activeChoices2, item);
            });
          }
        });
      });
    }
    return !!navigator2;
  }
};
var StringItemsNavigatorSelectBase = class extends StringItemsNavigatorBase {
  getItemLocString(items, item) {
    return item.locText;
  }
  getItemSets() {
    return [this.question.choices];
  }
  addNewItem(creator, items, text = null) {
    if (creator.maximumChoicesCount && items.length >= creator.maximumChoicesCount) return;
    const itemValue = creator.createNewItemValue(this.question);
    if (!!text) itemValue.value = text;
  }
  getItemsPropertyName(items) {
    return "choices";
  }
};
var StringItemsNavigatorMultipleText = class extends StringItemsNavigatorBase {
  getItemLocString(items, item) {
    return item.locTitle;
  }
  getItemSets() {
    return [this.question.items];
  }
  addNewItem(creator, items, text = null) {
    this.question.addItem(text || getNextValue("text", items.map((i) => i.name)));
  }
  getItemsPropertyName(items) {
    return "items";
  }
  addNewItems(creator, items, startIndex, itemsToAdd) {
    let newItems = items.slice(0, startIndex).concat(itemsToAdd.map((text) => new MultipleTextItemModel(text))).concat(items.slice(startIndex + 1));
    this.question[this.getItemsPropertyName(items)] = newItems;
  }
};
var StringItemsNavigatorMatrix = class extends StringItemsNavigatorBase {
  getItemLocString(items, item) {
    return item.locText;
  }
  getItemSets() {
    return [this.question.columns, this.question.rows];
  }
  addNewItem(creator, items, text = null) {
    let titleBase;
    let propertyName;
    if (items == this.question.columns) {
      if (creator.maximumColumnsCount && items.length >= creator.maximumColumnsCount) return;
      titleBase = "Column ";
      propertyName = "columns";
    }
    if (items == this.question.rows) {
      if (creator.maximumRowsCount && items.length >= creator.maximumRowsCount) return;
      titleBase = "Row ";
      propertyName = "rows";
    }
    const newItem = new ItemValue(getNextValue(titleBase, items.map((i) => i.value)));
    items.push(text || newItem);
    creator.onItemValueAddedCallback(this.question, propertyName, newItem, items);
  }
  getItemsPropertyName(items) {
    if (items == this.question.columns) return "columns";
    if (items == this.question.rows) return "rows";
  }
};
var StringItemsNavigatorMatrixDropdown = class extends StringItemsNavigatorMatrix {
  getItemLocString(items, item) {
    if (items == this.question.columns) return item.locTitle;
    return item.locText;
  }
  addNewItem(creator, items, text = null) {
    if (items == this.question.columns) {
      if (creator.maximumColumnsCount && items.length >= creator.maximumColumnsCount) return;
      var column = new MatrixDropdownColumn(text || getNextValue("Column ", items.map((i) => i.value)));
      this.question.columns.push(column);
      creator.onMatrixDropdownColumnAddedCallback(this.question, column, this.question.columns);
    }
    if (items == this.question.rows) super.addNewItem(creator, items, text);
  }
  addNewItems(creator, items, startIndex, itemsToAdd) {
    if (items == this.question.columns) {
      let newItems = items.slice(0, startIndex).concat(itemsToAdd.map((text) => new MatrixDropdownColumn(text))).concat(items.slice(startIndex + 1));
      this.question[this.getItemsPropertyName(items)] = newItems;
    } else {
      super.addNewItems(creator, items, startIndex, itemsToAdd);
    }
  }
};
var StringItemsNavigatorMatrixDynamic = class extends StringItemsNavigatorMatrixDropdown {
  getItemSets() {
    return [this.question.columns];
  }
};
var StringEditorConnector = class _StringEditorConnector {
  static get(locString) {
    if (!locString["_stringEditorConnector"]) locString["_stringEditorConnector"] = new _StringEditorConnector(locString);
    return locString["_stringEditorConnector"];
  }
  setAutoFocus() {
    this.focusOnEditor = true;
  }
  activateEditor() {
    this.onDoActivate.fire(this.locString, {});
  }
  constructor(locString) {
    this.locString = locString;
    this.hasEditCompleteHandler = false;
    this.allowLineBreaksOnEdit = false;
    this.onDoActivate = new EventBase();
    this.onTextChanging = new EventBase();
    this.onEditComplete = new EventBase();
    this.onBackspaceEmptyString = new EventBase();
  }
};
var StringEditorViewModelBase = class extends Base {
  constructor(locString, creator) {
    super();
    this.locString = locString;
    this.creator = creator;
    this.blurredByEscape = false;
    this.focusedProgram = false;
    this.characterCounter = new CharacterCounter();
    this.activate = () => {
      const element = this.getEditorElement();
      if (element && element.offsetParent != null) {
        element.focus({
          preventScroll: true
        });
        select(element);
        return true;
      }
      return false;
    };
    this.justFocused = false;
    this.locString = locString;
    this.checkMarkdownToTextConversion(this.locString.owner, this.locString.name);
  }
  afterRender() {
    if (this.connector.focusOnEditor) {
      if (this.activate()) this.connector.focusOnEditor = false;
    }
  }
  detachFromUI() {
    var _a;
    (_a = this.connector) === null || _a === void 0 ? void 0 : _a.onDoActivate.remove(this.activate);
    this.getEditorElement = void 0;
    this.blurEditor = void 0;
  }
  dispose() {
    super.dispose();
    this.detachFromUI();
  }
  setLocString(locString) {
    var _a;
    (_a = this.connector) === null || _a === void 0 ? void 0 : _a.onDoActivate.remove(this.activate);
    this.locString = locString;
    this.connector = StringEditorConnector.get(locString);
    this.connector.onDoActivate.add(this.activate);
  }
  checkConstraints(event) {
    if (!this.compostionInProgress && this.maxLength > 0 && event.keyCode >= 32) {
      var text = event.target.innerText || "";
      if (text.length >= this.maxLength) {
        event.preventDefault();
      }
    }
    if (event.keyCode == 13 && !this.locString.allowLineBreaks) {
      event.preventDefault();
    }
    if (event.ctrlKey || event.metaKey) {
      if ([89, 90, 66, 73].indexOf(event.keyCode) !== -1) {
        event.stopImmediatePropagation();
        event.preventDefault();
      }
    }
  }
  onClick(event) {
    event.stopPropagation();
  }
  onFocus(event) {
    if (!this.focusedProgram) {
      this.valueBeforeEdit = this.locString.hasHtml ? event.target.innerHTML : event.target.innerText;
      this.focusedProgram = false;
    }
    if (this.maxLength > 0) {
      this.characterCounter.updateRemainingCharacterCounter(this.valueBeforeEdit, this.maxLength);
    }
    if (this.creator) {
      this.creator.selectFromStringEditor = true;
    }
    if (this.locString.hasHtml && this.editAsText) {
      event.target.innerText = event.target.textContent = this.locString.calculatedText;
    }
    event.target.parentElement.click();
    event.target.spellcheck = true;
    event.target.setAttribute("tabindex", -1);
    this.focused = true;
    this.justFocused = true;
  }
  checkMarkdownToTextConversion(element, name) {
    if (!this.creator) return;
    const options = {
      element,
      text: null,
      name,
      html: ""
    };
    this.creator.onHtmlToMarkdown.fire(this.creator, options);
    this.editAsText = options.text === null;
  }
  onCompositionStart(event) {
    this.compostionInProgress = true;
  }
  onInput(event) {
    var _a;
    if (this.maxLength > 0) {
      var text = event.target.innerText || "";
      this.characterCounter.updateRemainingCharacterCounter(text, this.maxLength);
    }
    if (this.editAsText && !this.compostionInProgress) {
      const options = {
        value: (_a = event.target) === null || _a === void 0 ? void 0 : _a.innerText,
        cancel: null
      };
      if (this.connector) this.connector.onTextChanging.fire(this, options);
      if (options.cancel) return;
      if (this.maxLength >= 0 && event.target.innerText.length > this.maxLength) {
        event.target.innerText = event.target.innerText.substring(0, this.maxLength);
      }
    }
  }
  onCompositionEnd(event) {
    this.compostionInProgress = false;
    this.onInput(event);
  }
  onBlur(event) {
    var _a;
    event.target.removeAttribute("tabindex");
    if (this.blurredByEscape) {
      this.blurredByEscape = false;
      if (this.locString.hasHtml) {
        event.target.innerHTML = this.valueBeforeEdit;
      } else {
        event.target.innerText = this.valueBeforeEdit;
      }
      this.errorText = null;
      this.focused = false;
      window === null || window === void 0 ? void 0 : window.getSelection().removeAllRanges();
      return;
    }
    let clearedText = this.getClearedText(event.target);
    this.errorText = this.getErrorTextOnChanged(clearedText);
    if (this.locString.text != clearedText && !(!this.locString.text && clearedText == this.locString.calculatedText)) {
      if (!this.errorText) {
        this.setValueIntoLocStr(clearedText, event === null || event === void 0 ? void 0 : event.target);
      } else {
        (_a = this.creator) === null || _a === void 0 ? void 0 : _a.notify(this.errorText, "error");
        this.focusedProgram = true;
        event.target.innerText = clearedText;
        event.target.focus();
        return;
      }
    } else {
      if (this.locString.hasHtml) {
        event.target.innerHTML = this.locString.renderedHtml;
      } else {
        event.target.innerText = this.locString.renderedHtml;
      }
      this.locString.strChanged();
    }
    this.focused = false;
    window === null || window === void 0 ? void 0 : window.getSelection().removeAllRanges();
  }
  getClearedText(target) {
    const html = target.innerHTML;
    const text = target.innerText;
    let mdText = null;
    if (!this.editAsText && this.creator) {
      const options = {
        element: this.locString.owner,
        text: null,
        name: this.locString.name,
        html
      };
      this.creator.onHtmlToMarkdown.fire(this.creator, options);
      mdText = options.text;
    }
    let clearedText;
    if (mdText) {
      clearedText = mdText;
    } else {
      clearedText = this.locString.hasHtml && !this.editAsText ? html : text;
      const txt = clearNewLines(clearedText);
      if (!this.locString.allowLineBreaks || !txt) {
        clearedText = txt;
      }
    }
    const owner = this.locString.owner;
    const changingOptions = {
      obj: owner,
      propertyName: this.locString.name,
      value: this.locString.text,
      newValue: clearedText,
      doValidation: false
    };
    if (this.creator) this.creator.onValueChangingCallback(changingOptions);
    return changingOptions.newValue;
  }
  getErrorTextOnChanged(clearedText) {
    if (!this.creator) return "";
    const owner = this.locString.owner;
    let res = this.creator.onGetErrorTextOnValidationCallback(this.locString.name, owner, clearedText);
    if (!!res || !!clearedText) return res;
    const propJSON = owner.getPropertyByName && owner.getPropertyByName(this.locString.name);
    if (propJSON && propJSON.isRequired) return editorLocalization.getString("pe.propertyIsEmpty");
    return "";
  }
  get isInplaceForEditValues() {
    return !!this.creator && this.creator.inplaceEditForValues && this.locString.owner instanceof ItemValue && this.creator.inplaceEditForValues && ["noneText", "otherText", "selectAllText"].indexOf(this.locString.name) === -1;
  }
  setValueIntoLocStr(clearedText, target) {
    if (this.isInplaceForEditValues) {
      const itemValue = this.locString.owner;
      if (itemValue.value !== clearedText) {
        if (!!itemValue.locOwner && !!itemValue.ownerPropertyName) {
          const choices = itemValue.locOwner[itemValue.ownerPropertyName];
          if (Array.isArray(choices) && !!ItemValue.getItemByValue(choices, clearedText)) {
            clearedText = getNextItemValue(clearedText, choices);
            if (!!target) {
              target.innerText = clearedText;
            }
          }
        }
        itemValue.value = clearedText;
      }
    } else {
      const oldStoreDefaultText = this.locString.storeDefaultText;
      this.locString.storeDefaultText = false;
      this.locString.text = clearedText;
      this.locString.storeDefaultText = oldStoreDefaultText;
    }
  }
  done(event) {
    event.stopImmediatePropagation();
    event.preventDefault();
  }
  onPaste(event) {
    var _a;
    if (this.editAsText) {
      event.preventDefault();
      let text = event.clipboardData.getData("text/plain");
      if (!this.locString.allowLineBreaks && !((_a = this.connector) === null || _a === void 0 ? void 0 : _a.allowLineBreaksOnEdit)) text = clearNewLines(text);
      const selection = window.getSelection();
      if (!selection.rangeCount) return;
      selection.deleteFromDocument();
      selection.getRangeAt(0).insertNode(document.createTextNode(text));
      selection.collapseToEnd();
      event.target.dispatchEvent(new Event("input", {
        bubbles: true
      }));
    }
  }
  onKeyDown(event) {
    if (event.keyCode === 13 && !event.shiftKey) {
      this.blurEditor();
      if (!event.ctrlKey && !event.metaKey) {
        this.connector.onEditComplete.fire(this, {});
      }
      this.done(event);
    }
    if (event.keyCode === 27) {
      this.blurredByEscape = true;
      this.blurEditor();
      this.done(event);
    }
    if (event.keyCode === 8 && !clearNewLines(event.target.innerText)) {
      this.done(event);
      this.connector.onBackspaceEmptyString.fire(this, {});
    }
    this.checkConstraints(event);
    return true;
  }
  onKeyUp(event) {
    if (event.keyCode === 9 && event.target === document.activeElement) {
      select(event.target);
    }
    return true;
  }
  onMouseUp(event) {
    if (this.justFocused) {
      this.justFocused = false;
      if (!window) return false;
      if (window.getSelection().focusNode && window.getSelection().focusNode.parentElement !== event.target || window.getSelection().toString().length == 0) {
        select(event.target);
      }
      return false;
    }
    return true;
  }
  findProperty() {
    if (!this.locString.owner.getType) return void 0;
    const ownerType = this.locString.owner.getType();
    if (!this.locString.name) return void 0;
    const property2 = Serializer.findProperty(ownerType, this.locString.name);
    return property2;
  }
  get maxLength() {
    const property2 = this.findProperty();
    if (!property2 || property2.maxLength <= 0) return -1;
    return property2.maxLength;
  }
  get placeholder() {
    var _a;
    if (this.placeholderValue !== void 0) return this.placeholderValue;
    const propPlaceholder = (_a = this.findProperty()) === null || _a === void 0 ? void 0 : _a.placeholder;
    if (!!propPlaceholder) {
      this.locString.placeholder = propPlaceholder;
    }
    if (!this.locString.placeholder) {
      this.placeholderValue = "";
      return "";
    }
    var re = /\{([^}]+)\}/g;
    this.placeholderValue = new ComputedUpdater(() => {
      let locPlaceholder = this.locString.placeholder;
      if (typeof locPlaceholder === "function") {
        locPlaceholder = locPlaceholder();
      }
      let result = editorLocalization.getString(locPlaceholder);
      let match = re.exec(result);
      while (match != null) {
        result = result.replace(re, (propertyName) => {
          const propertyValue2 = this.locString.owner && this.locString.owner[match[1]];
          return "" + propertyValue2;
        });
        match = re.exec(result);
      }
      return result;
    });
    return this.placeholderValue;
  }
  get contentEditable() {
    if (!this.creator) return true;
    return this.creator.isCanModifyProperty(this.locString.owner, this.locString.name);
  }
  get showCharacterCounter() {
    return this.maxLength !== -1;
  }
  get getCharacterCounterClass() {
    return "svc-remaining-character-counter";
  }
  className(text) {
    return new CssClassBuilder().append("svc-string-editor").append("svc-string-editor--hidden", text == "" && this.placeholder == "").append("svc-string-editor--readonly", !this.contentEditable).append("svc-string-editor--error", !!this.errorText).append("svc-string-editor--multiline", !!this.locString.allowLineBreaks).toString();
  }
};
__decorate2([property()], StringEditorViewModelBase.prototype, "errorText", void 0);
__decorate2([property()], StringEditorViewModelBase.prototype, "focused", void 0);
__decorate2([property({
  defaultValue: true
})], StringEditorViewModelBase.prototype, "editAsText", void 0);
__decorate2([property()], StringEditorViewModelBase.prototype, "placeholderValue", void 0);
var ThemeTabViewModel = class extends PreviewViewModel {
  constructor(surveyProvider, startThemeClasses) {
    super(surveyProvider, startThemeClasses);
  }
  get currentTheme() {
    return this.surveyProvider.theme;
  }
  get currentThemeCssVariables() {
    return this.currentTheme.cssVariables || {};
  }
  getTabName() {
    return "theme";
  }
};
var Switcher = class extends Action {
  getSwitcherIconCss() {
    return new CssClassBuilder().append("svc-switcher__icon").append("svc-switcher__icon--checked", this.checked).toString();
  }
  getActionBarItemCss() {
    return "svc-switcher " + super.getActionBarItemCss();
  }
};
__decorate2([property()], Switcher.prototype, "checked", void 0);
var themeModelProperties = {
  "theme": {
    properties: [{
      name: "header",
      tab: "header"
    }, {
      name: "--sjs-general-backcolor-dim",
      tab: "background"
    }, {
      name: "backgroundImage",
      tab: "background"
    }, {
      name: "backgroundImageFit",
      tab: "background"
    }, {
      name: "backgroundImageAttachment",
      tab: "background"
    }, {
      name: "backgroundOpacity",
      tab: "background"
    }, {
      name: "primaryColor",
      tab: "appearancecolor"
    }, {
      name: "panelBackgroundTransparency",
      tab: "appearancecolor"
    }, {
      name: "questionBackgroundTransparency",
      tab: "appearancecolor"
    }, {
      name: "--sjs-primary-backcolor",
      tab: "appearanceprimarycolor"
    }, {
      name: "--sjs-primary-backcolor-dark",
      tab: "appearanceprimarycolor"
    }, {
      name: "--sjs-primary-backcolor-light",
      tab: "appearanceprimarycolor"
    }, {
      name: "--sjs-primary-forecolor",
      tab: "appearanceprimarycolor"
    }, {
      name: "--sjs-primary-forecolor-light",
      tab: "appearanceprimarycolor"
    }, {
      name: "--sjs-special-red",
      tab: "appearanceprimarycolor"
    }, {
      name: "--sjs-special-red-light",
      tab: "appearanceprimarycolor"
    }, {
      name: "--sjs-font-family",
      tab: "appearancefont"
    }, {
      name: "fontSize",
      tab: "appearancefont"
    }, {
      name: "scale",
      tab: "appearanceother"
    }, {
      name: "cornerRadius",
      tab: "appearanceother"
    }, {
      name: "advancedMode",
      tab: "appearanceadvancedmode"
    }, {
      name: "pageTitle",
      tab: "appearancepage"
    }, {
      name: "pageDescription",
      tab: "appearancepage"
    }, {
      name: "questionPanel",
      tab: "appearancequestion"
    }, {
      name: "--sjs-shadow-small",
      tab: "appearancequestion"
    }, {
      name: "questionTitle",
      tab: "appearancequestion"
    }, {
      name: "questionDescription",
      tab: "appearancequestion"
    }, {
      name: "editorPanel",
      tab: "appearanceinput"
    }, {
      name: "--sjs-shadow-inner",
      tab: "appearanceinput"
    }, {
      name: "editorFont",
      tab: "appearanceinput"
    }, {
      name: "--sjs-border-default",
      tab: "appearancelines"
    }, {
      name: "--sjs-border-light",
      tab: "appearancelines"
    }],
    tabs: [{
      name: "header",
      index: 100
    }, {
      name: "background",
      index: 200
    }, {
      name: "appearance",
      index: 300
    }, {
      name: "appearancecolor",
      parent: "appearance",
      index: 100
    }, {
      name: "appearancefont",
      parent: "appearance",
      index: 200
    }, {
      name: "appearanceother",
      parent: "appearance",
      index: 300
    }, {
      name: "appearanceadvancedmode",
      parent: "appearance",
      index: 350
    }, {
      name: "appearanceprimarycolor",
      parent: "appearance",
      index: 400
    }, {
      name: "appearancepage",
      parent: "appearance",
      index: 500
    }, {
      name: "appearancequestion",
      parent: "appearance",
      index: 600
    }, {
      name: "appearanceinput",
      parent: "appearance",
      index: 700
    }, {
      name: "appearancelines",
      parent: "appearance",
      index: 800
    }]
  },
  "header@header": {
    properties: [{
      name: "headerView"
    }, {
      name: "logoPosition"
    }, {
      name: "surveyTitle"
    }, {
      name: "surveyDescription"
    }, {
      name: "height",
      tab: "layout"
    }, {
      name: "mobileHeight",
      tab: "layout"
    }, {
      name: "inheritWidthFrom",
      tab: "layout"
    }, {
      name: "textAreaWidth",
      tab: "layout"
    }, {
      name: "backgroundColorSwitch",
      tab: "background"
    }, {
      name: "backgroundColor",
      tab: "background"
    }, {
      name: "backgroundImage",
      tab: "background"
    }, {
      name: "backgroundImageFit",
      tab: "background"
    }, {
      name: "backgroundImageOpacity",
      tab: "background"
    }, {
      name: "overlapEnabled",
      tab: "background"
    }, {
      name: "headerTitle",
      tab: "header"
    }, {
      name: "headerDescription",
      tab: "header"
    }, {
      name: "logoPositionX",
      tab: "positions"
    }, {
      name: "logoPositionY",
      tab: "positions"
    }, {
      name: "titlePositionX",
      tab: "positions"
    }, {
      name: "titlePositionY",
      tab: "positions"
    }, {
      name: "descriptionPositionX",
      tab: "positions"
    }, {
      name: "descriptionPositionY",
      tab: "positions"
    }],
    tabs: [{
      name: "settings"
    }, {
      name: "layout",
      parent: "settings",
      index: 100
    }, {
      name: "background",
      parent: "settings",
      index: 200
    }, {
      name: "header",
      parent: "settings",
      index: 300
    }, {
      name: "positions",
      parent: "settings",
      index: 400
    }]
  }
};
var themeModelPropertyGridDefinition = {
  autoGenerateProperties: true,
  classes: themeModelProperties
};
var ThemeModelEditorDefinition = class {
};
ThemeModelEditorDefinition.definition = themeModelProperties;
var ThemeTabPlugin = class {
  get showOneCategoryInPropertyGrid() {
    return this._showOneCategoryInPropertyGrid;
  }
  set showOneCategoryInPropertyGrid(newValue) {
    if (this._showOneCategoryInPropertyGrid !== newValue) {
      this._showOneCategoryInPropertyGrid = newValue;
      this.creator.sidebar.hideSideBarVisibilityControlActions = newValue;
      this.updateAdvancedModeQuestion(newValue);
      this.propertyGrid.showOneCategoryInPropertyGrid = newValue;
      this.propertyGrid["setObj"](this.creator.selectedElement);
      if (this.creator.activeTab === "theme") {
        this.updateTabControl();
      }
    }
  }
  updateAdvancedModeQuestion(availableQuestion) {
    const advancedModeQuestion = this.propertyGrid.survey.getQuestionByName("advancedMode");
    if (advancedModeQuestion) {
      advancedModeQuestion.value = this._advancedModeValue;
      if (!availableQuestion) {
        advancedModeQuestion.visible = false;
      } else {
        advancedModeQuestion.visible = advancedModeQuestion.visible && !this.creator.isMobileView;
      }
    }
  }
  createVisibleUpdater() {
    return new ComputedUpdater(() => {
      return this.creator.activeTab === "theme";
    });
  }
  createAppearanceAdvancedModeAction() {
    const advancedMode = new Switcher({
      id: "advancedMode",
      component: "svc-switcher",
      ariaRole: "checkbox",
      css: "sv-theme-group_title-action",
      title: getLocString("theme.advancedMode"),
      visible: !this.creator.isMobileView,
      action: () => {
        advancedMode.checked = !advancedMode.checked;
        if (!!this.propertyGrid.survey.getQuestionByName("advancedMode")) {
          this.propertyGrid.survey.getQuestionByName("advancedMode").value = advancedMode.checked;
        }
      }
    });
    advancedMode.checked = this._advancedModeValue;
    this.advancedModeSwitcher = advancedMode;
  }
  addSubGroupTitle(panel, titleId) {
    if (!!panel.getQuestionByName(titleId)) return;
    const question = Serializer.createClass("html");
    question.fromJSON({
      name: titleId,
      visibleIf: "{advancedMode} = true",
      html: `<div class='spg-theme-group-caption'>${getLocString(titleId)}</div>`
    });
    panel.addElement(question);
  }
  updateSubGroups(survey) {
    ["appearancelines", "appearanceinput", "appearancequestion", "appearancepage", "appearanceprimarycolor"].forEach((panelName) => this.setVisibleIf(panelName, true));
    ["appearancecolor", "appearancefont", "appearanceother"].forEach((panelName) => this.setVisibleIf(panelName, false));
    this.addSubGroupTitle(survey.getPanelByName("appearanceprimarycolor"), "theme.pageTitle");
    this.addSubGroupTitle(survey.getPanelByName("appearancepage"), "theme.questionTitle");
    this.addSubGroupTitle(survey.getPanelByName("appearancequestion"), "theme.editorPanel");
    this.addSubGroupTitle(survey.getPanelByName("appearanceinput"), "theme.lines");
  }
  updatePropertyGridEditorsAvailability() {
    const simulatorSurvey = this.model.survey;
    const page = this.propertyGrid.survey.pages[0];
    const header = this.showOneCategoryInPropertyGrid ? this.propertyGrid.survey.getPageByName("header") : page === null || page === void 0 ? void 0 : page.getElementByName("header");
    if (header && header.elements.length > 0) {
      const headerViewContainer = header.elements[0].contentPanel;
      this.setCoverPropertiesFromSurvey(headerViewContainer, simulatorSurvey);
    }
    const pageTitleQuestion = this.propertyGrid.survey.getQuestionByName("pageTitle");
    let pageElements = simulatorSurvey.isSinglePage ? simulatorSurvey.visiblePages[0].elements : simulatorSurvey.pages;
    if (!!pageTitleQuestion) {
      pageTitleQuestion.readOnly = !pageElements.some((p) => !!p.title);
    }
    const pageDescriptionQuestion = this.propertyGrid.survey.getQuestionByName("pageDescription");
    if (pageDescriptionQuestion) {
      pageDescriptionQuestion.readOnly = !pageElements.some((p) => !!p.description);
    }
  }
  updatePropertyGridColorEditorWithPredefinedColors() {
    const page = this.propertyGrid.survey.pages[0];
    const header = page === null || page === void 0 ? void 0 : page.getElementByName("header");
    if (header && header.elements.length > 0) {
      const headerViewContainer = header.elements[0].contentPanel;
      const headerBackgroundQuestion = headerViewContainer.getQuestionByName("backgroundColor");
      if (!!headerBackgroundQuestion) {
        headerBackgroundQuestion.choices = getPredefinedColorsItemValues(this.themeModel.colorPalette);
      }
    }
    this.propertyGrid.survey.getAllQuestions().forEach((question) => {
      if (["color", "coloralpha"].indexOf(question.getType()) !== -1) {
        question.choices = getPredefinedColorsItemValues(this.themeModel.colorPalette);
      }
    });
  }
  _setPGEditorPropertyValue(editor, propertyName, value) {
    if (!!editor) {
      editor[propertyName] = value;
    }
  }
  setCoverPropertiesFromSurvey(panel, survey) {
    this._setPGEditorPropertyValue(panel.getQuestionByName("headerView"), "value", survey.headerView);
    this._setPGEditorPropertyValue(panel.getQuestionByName("logoPosition"), "value", survey.logoPosition);
    this._setPGEditorPropertyValue(panel.getQuestionByName("surveyTitle"), "readOnly", !survey.hasTitle);
    this._setPGEditorPropertyValue(panel.getQuestionByName("surveyDescription"), "readOnly", !survey.hasDescription);
    this._setPGEditorPropertyValue(panel.getQuestionByName("headerTitle"), "readOnly", !survey.hasTitle);
    this._setPGEditorPropertyValue(panel.getQuestionByName("headerDescription"), "readOnly", !survey.hasDescription);
    this._setPGEditorPropertyValue(panel.getQuestionByName("logoPositionX"), "readOnly", !survey.logo);
    this._setPGEditorPropertyValue(panel.getQuestionByName("logoPositionY"), "readOnly", !survey.logo);
    this._setPGEditorPropertyValue(panel.getQuestionByName("logoPosition"), "readOnly", !survey.logo);
    this._setPGEditorPropertyValue(panel.getQuestionByName("titlePositionX"), "readOnly", !survey.title);
    this._setPGEditorPropertyValue(panel.getQuestionByName("titlePositionY"), "readOnly", !survey.title);
    this._setPGEditorPropertyValue(panel.getQuestionByName("descriptionPositionX"), "readOnly", !survey.description);
    this._setPGEditorPropertyValue(panel.getQuestionByName("descriptionPositionY"), "readOnly", !survey.description);
    if (survey.showTOC) {
      const inheritWidthFrom = panel.getQuestionByName("inheritWidthFrom");
      this._setPGEditorPropertyValue(inheritWidthFrom, "value", "container");
      this._setPGEditorPropertyValue(inheritWidthFrom, "visible", false);
    }
  }
  updateVisibilityOfPropertyGridGroups() {
    const page = this.propertyGrid.survey.pages[0];
    const header = page === null || page === void 0 ? void 0 : page.getElementByName("header");
    if (header) {
      header.visible = !this.creator.isMobileView;
    }
    if (this.advancedModeSwitcher) {
      this.advancedModeSwitcher.visible = !this.creator.isMobileView;
    }
  }
  setVisibleIf(panelName, visibilityValue) {
    const panel = this.propertyGrid.survey.getPanelByName(panelName);
    if (!!panel) {
      panel.visibleIf = `{advancedMode} = ${visibilityValue}`;
    }
  }
  updateTabControl() {
    if (this.showOneCategoryInPropertyGrid) {
      this.updateTabControlActions();
      this.creator.sidebar.sideAreaComponentName = "svc-tab-control";
      this.creator.sidebar.sideAreaComponentData = this.tabControlModel;
      this.creator.sidebar.header.componentName = "svc-side-bar-header";
      this.creator.sidebar.header.componentData = this.creator.sidebar.header;
    } else {
      this.creator.sidebar.sideAreaComponentName = "";
      this.creator.sidebar.sideAreaComponentData = void 0;
      this.creator.sidebar.header.componentName = "";
      this.creator.sidebar.header.componentData = void 0;
    }
  }
  constructor(creator) {
    this.creator = creator;
    this.allowModifyTheme = true;
    this.simulatorCssClasses = surveyCss[defaultThemeName];
    this._availableThemes = [].concat(PredefinedThemes);
    this._showOneCategoryInPropertyGrid = true;
    this._advancedModeValue = false;
    this.creatorPropertyChanged = (sender, options) => {
      if (options.name === "isMobileView") {
        this.updateVisibilityOfPropertyGridGroups();
      }
    };
    this.previewDevice = "desktop";
    this.saveToFileHandler = saveToFileHandler;
    this.autoSaveTimerId = null;
    this.onThemeSelected = new EventBase();
    this.onThemePropertyChanged = new EventBase();
    this.onAllowModifyTheme = new EventBase();
    creator.addTab({
      name: "theme",
      plugin: this,
      iconName: "icon-theme"
    });
    this.simulatorCssClasses = surveyCss[defaultThemeName];
    this.tabControlModel = new TabControlModel(this.creator.sidebar);
    this.createActions().forEach((action) => creator.toolbar.actions.push(action));
    this.propertyGrid = new PropertyGridModel(void 0, creator, themeModelPropertyGridDefinition);
    this.propertyGrid.surveyInstanceCreatedArea = "theme-tab:property-grid";
    this.showOneCategoryInPropertyGrid = creator.showOneCategoryInPropertyGrid;
    this.propertyGrid.showOneCategoryInPropertyGrid = this.showOneCategoryInPropertyGrid;
    const propertyGridViewModel = new PropertyGridViewModel(this.propertyGrid, creator);
    this.propertyGridTab = this.creator.sidebar.addPage("theme", "svc-property-grid", propertyGridViewModel);
    this.propertyGridTab.caption = editorLocalization.getString("ed.themePropertyGridTitle");
    this.themeModel = new ThemeModel();
    creator.registerShortcut("undo_theme", {
      name: "undo",
      affectedTab: "theme",
      hotKey: {
        ctrlKey: true,
        keyCode: 90
      },
      macOsHotkey: {
        keyCode: 90
      },
      execute: () => this.undo()
    });
    creator.registerShortcut("redo_theme", {
      name: "redo",
      affectedTab: "theme",
      hotKey: {
        ctrlKey: true,
        keyCode: 89
      },
      macOsHotkey: {
        keyCode: 89
      },
      execute: () => this.redo()
    });
    creator.onPropertyChanged.add(this.creatorPropertyChanged);
  }
  activate() {
    this.model = new ThemeTabViewModel(this.creator, this.simulatorCssClasses);
    this.model.simulator.device = this.previewDevice;
    this.themeModel.initialize(this.creator.theme, this.creator.survey, this.creator);
    this.creator.sidebar.hideSideBarVisibilityControlActions = this.showOneCategoryInPropertyGrid;
    this.update();
    this.propertyGrid.showOneCategoryInPropertyGrid = this.showOneCategoryInPropertyGrid;
    this.propertyGrid.survey.onOpenFileChooser.clear();
    this.propertyGrid.obj = this.themeModel;
    this.propertyGrid.survey.mode = "edit";
    this.propertyGrid.survey.getAllQuestions().forEach((q) => q.readOnly = false);
    this.onAvailableThemesChanged(this.availableThemes);
    this.updateAllowModifyTheme();
    this.updateAdvancedModeQuestion(this.showOneCategoryInPropertyGrid);
    const themeBuilderCss = JSON.parse(JSON.stringify(propertyGridCss));
    themeBuilderCss.root += " spg-theme-builder-root";
    if (this.showOneCategoryInPropertyGrid) {
      themeBuilderCss.root += " spg-root--one-category";
      themeBuilderCss.page.root += " spg-panel__content";
    }
    this.propertyGrid.survey.css = themeBuilderCss;
    this.updateSubGroups(this.propertyGrid.survey);
    this.propertyGrid.survey.onGetPanelTitleActions.add((sender, opt) => {
      if (opt.panel && opt.panel.name == "appearance") {
        this.createAppearanceAdvancedModeAction();
        opt.titleActions.push(this.advancedModeSwitcher);
      }
    });
    this.propertyGrid.survey.onOpenFileChooser.add((_, options) => {
      var _a, _b;
      const context = {};
      assign(context, options.context, {
        element: this.themeModel,
        elementType: "theme"
      });
      if (options.element) {
        const question = options.element;
        context.propertyName = question.name;
        if (((_b = (_a = question === null || question === void 0 ? void 0 : question.parent) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.name) === "settings") {
          context.elementType = "header";
          context.element = context.element.header;
        }
      }
      this.creator.chooseFiles(options.input, options.callback, context);
    });
    this.propertyGrid.survey.onUpdatePanelCssClasses.add((sender, options) => {
      var _a, _b, _c;
      if (options.panel.hasParent) {
        const parent = (_a = options.panel.parent) !== null && _a !== void 0 ? _a : options.panel.parentQuestion;
        if (!parent || parent.hasParent && !(parent.name === "settings" || ((_b = parent.parentQuestion) === null || _b === void 0 ? void 0 : _b.name) === "settings")) {
          options.cssClasses.panel.container = "spg-panel-group";
          options.cssClasses.panel.content = "spg-panel-group__content";
        } else {
          options.cssClasses.panel.container = "spg-nested-panel";
          options.cssClasses.panel.content = "spg-nested-panel__content";
        }
      } else if (this.showOneCategoryInPropertyGrid && ((_c = options.panel.parent) === null || _c === void 0 ? void 0 : _c.isPage)) {
        options.cssClasses.panel.container = "spg-panel-by-page";
        options.cssClasses.panel.content = "spg-panel-by-page__content";
        if (options.panel.name === "appearanceother") {
          options.cssClasses.panel.container += " spg-panel--hidden-border";
        }
        if (options.panel.name === "appearanceadvancedmode") {
          options.cssClasses.panel.container += " spg-panel--hidden-border spg-panel--padding";
        }
      }
    });
    this.updatePropertyGridEditorsAvailability();
    this.updateVisibilityOfPropertyGridGroups();
    this.updatePropertyGridColorEditorWithPredefinedColors();
    this.creator.sidebar.activePage = this.propertyGridTab.id;
    this.propertyGridTab.visible = true;
    this.updateTabControl();
    this.expandCategoryIfNeeded();
  }
  expandCategoryIfNeeded() {
    if (!this.model.survey.isEmpty) {
      this.propertyGrid.expandCategoryIfNeeded();
    }
  }
  updateTabControlActions() {
    if (this.showOneCategoryInPropertyGrid) {
      const pgTabs = this.propertyGrid.survey.pages.map((p) => {
        const action = new MenuButton({
          id: p.name,
          tooltip: p.title,
          iconName: pgTabIcons[p.name] || pgTabIcons["undefined"],
          iconSize: "auto",
          active: p.name === this.propertyGrid.survey.currentPage.name,
          pressed: false,
          action: () => {
            this.creator.sidebar.expandSidebar();
            this.propertyGrid.survey.currentPage = p;
            this.creator.sidebar.header.title = p.title;
            pgTabs.forEach((i) => i.active = false);
            action.active = true;
          }
        });
        return action;
      });
      this.tabControlModel.topToolbar.setItems(pgTabs);
      this.creator.sidebar.header.title = this.propertyGrid.survey.currentPage.title;
      this.creator.sidebar.header.subTitle = this.propertyGridTab.caption;
    }
  }
  update() {
    if (!this.model) return;
    this.model.simulator.landscape = this.creator.previewOrientation != "portrait";
    this.model.testAgainAction = this.testAgainAction;
    this.model.prevPageAction = this.prevPageAction;
    this.model.nextPageAction = this.nextPageAction;
    const options = {
      showPagesInTestSurveyTab: this.creator.showPagesInTestSurveyTab
    };
    this.model.initialize(this.creator.JSON, options);
    this.updateSimulatorTheme(this.creator.theme);
    if (this.creator.showInvisibleElementsInTestSurveyTab) {
      this.invisibleToggleAction.active = this.model.showInvisibleElements;
      this.invisibleToggleAction.visible = this.model.isRunning;
    }
    this.updateUndeRedoActions();
    this.themeModel.undoRedoManager.canUndoRedoCallback = () => {
      this.updateUndeRedoActions();
    };
    this.model.show();
    this.model.onPropertyChanged.add((sender, options2) => {
      if (options2.name === "isRunning") {
        this.invisibleToggleAction && (this.invisibleToggleAction.visible = this.model.isRunning);
        this.testAgainAction.visible = !this.model.isRunning;
      }
    });
    this.themeModel.onThemeSelected.add((sender, options2) => {
      this.syncTheme(options2.theme);
      this.resetTheme.enabled = getThemeFullName(sender.defaultSessionTheme) !== getThemeFullName(options2.theme);
      this.saveThemeAction.enabled = true;
      this.onThemeSelected.fire(this, options2);
      if (this.creator.isAutoSave) {
        this.processAutoSave();
      }
      this.propertyGrid.survey.editingObj = void 0;
      this.propertyGrid.survey.editingObj = sender;
      this.updateAllowModifyTheme();
      this.updatePropertyGridColorEditorWithPredefinedColors();
    });
    this.themeModel.onThemePropertyChanged.add((sender, options2) => {
      this.syncTheme(this.themeModel.toJSON());
      if (options2.name == "--sjs-base-unit") {
        this.model.survey.triggerResponsiveness(true);
      }
      if (options2.name == "logoPosition") {
        this.creator.survey.logoPosition = options2.value;
        this.model.survey.logoPosition = options2.value;
      }
      this.resetTheme.enabled = true;
      this.saveThemeAction.enabled = true;
      this.onThemePropertyChanged.fire(this, options2);
      if (this.creator.isAutoSave) {
        this.processAutoSave();
      }
    });
    this.themeModel.onAllowModifyTheme.add((sender, options2) => {
      this.onAllowModifyTheme.fire(this, options2);
    });
    this.resetTheme.enabled = getThemeFullName(this.themeModel.defaultSessionTheme) !== getThemeFullName(this.creator.theme) || this.isModified;
  }
  updateAllowModifyTheme() {
    const opt = {
      theme: this.themeModel,
      allow: !this.creator.readOnly
    };
    this.onAllowModifyTheme.fire(this, opt);
    this.propertyGrid.survey.getAllQuestions().forEach((q) => {
      if (["themeName", "colorPalette", "isPanelless"].indexOf(q.name) === -1) {
        q.readOnly = this.creator.onIsPropertyReadOnlyCallback(this.themeModel, this.themeModel.getPropertyByName(q.name), !opt.allow, void 0, void 0, false);
      }
    });
  }
  deactivate() {
    var _a;
    if (this.model) {
      this.previewDevice = this.model.simulator.device;
      this.simulatorCssClasses = this.model.survey.css;
      this.model.onPropertyChanged.clear();
      this.themeModel.onThemeSelected.clear();
      this.themeModel.onThemePropertyChanged.clear();
      this.themeModel.onAllowModifyTheme.clear();
      this.model.onSurveyCreatedCallback = void 0;
      this.model.dispose();
      this.model = void 0;
      this.creator.sidebar.hideSideBarVisibilityControlActions = false;
    }
    this._advancedModeValue = !!((_a = this.propertyGrid.survey.getQuestionByName("advancedMode")) === null || _a === void 0 ? void 0 : _a.value);
    this.creator.sidebar.sideAreaComponentName = void 0;
    this.creator.sidebar.sideAreaComponentData = void 0;
    this.creator.sidebar.header.reset();
    this.propertyGridTab.visible = false;
    this.testAgainAction.visible = false;
    this.invisibleToggleAction && (this.invisibleToggleAction.visible = false);
    return true;
  }
  exportToFile(fileName) {
    const themeCopy = JSON.parse(JSON.stringify(this.themeModel.toJSON()));
    const themeData = JSON.stringify(themeCopy, null, 4);
    const themeBlob = new Blob([themeData], {
      type: "application/json"
    });
    this.saveToFileHandler(fileName, themeBlob);
  }
  importFromFile(file, callback) {
    let fileReader = new FileReader();
    fileReader.onload = (e) => {
      const theme = JSON.parse(fileReader.result);
      if (!!this.themeModel) {
        this.themeModel.setTheme(theme);
      }
      callback && callback(theme);
    };
    fileReader.readAsText(file);
  }
  createActions() {
    const items = [];
    this.designerAction = new Action({
      id: "svd-designer",
      iconName: "icon-config",
      iconSize: "auto",
      action: () => {
        this.creator.switchTab("designer");
      },
      visible: this.createVisibleUpdater(),
      locTitleName: "ed.designer",
      showTitle: false
    });
    this.prevPageAction = new Action({
      id: "prevPage",
      iconName: "icon-arrow-left_16x16",
      iconSize: "auto",
      needSeparator: new ComputedUpdater(() => {
        return this.creator.isMobileView;
      }),
      visible: false
    });
    this.nextPageAction = new Action({
      id: "nextPage",
      iconName: "icon-arrow-right_16x16",
      iconSize: "auto",
      visible: false
    });
    this.previewAction = new Action({
      id: "svd-preview",
      iconName: "icon-preview",
      iconSize: "auto",
      active: true,
      visible: this.createVisibleUpdater(),
      locTitleName: "tabs.preview",
      showTitle: false,
      action: () => {
      }
    });
    this.testAgainAction = new Action({
      id: "testSurveyAgain",
      visible: false,
      iconSize: "auto",
      locTitleName: "ed.testSurveyAgain",
      action: () => {
        this.model.testAgain();
      }
    });
    this.undoAction = new Action({
      id: "action-undo-theme",
      iconName: "icon-undo",
      iconSize: "auto",
      locTitleName: "ed.undo",
      showTitle: false,
      visible: this.createVisibleUpdater(),
      action: () => this.undo()
    });
    this.redoAction = new Action({
      id: "action-redo-theme",
      iconName: "icon-redo",
      iconSize: "auto",
      locTitleName: "ed.redo",
      showTitle: false,
      visible: this.createVisibleUpdater(),
      action: () => this.redo()
    });
    items.push(this.undoAction);
    items.push(this.redoAction);
    this.saveThemeAction = new Action({
      id: "svd-save-theme",
      iconName: "icon-save",
      iconSize: "auto",
      action: () => {
        this.creator.saveThemeActionHandler();
        this.saveThemeAction.enabled = false;
      },
      active: false,
      enabled: false,
      visible: new ComputedUpdater(() => {
        return notShortCircuitAnd(this.creator.activeTab === "theme", this.creator.showSaveButton);
      }),
      locTitleName: "ed.saveTheme",
      locTooltipName: "ed.saveThemeTooltip",
      showTitle: false
    });
    items.push(this.saveThemeAction);
    this.resetTheme = new Action({
      id: "svc-reset-theme",
      iconName: "icon-reset",
      iconSize: "auto",
      locTitleName: "ed.themeResetButton",
      locTooltipName: "ed.themeResetButton",
      mode: "small",
      visible: this.createVisibleUpdater(),
      action: () => {
        settings.confirmActionAsync(getLocString("ed.themeResetConfirmation"), (confirm2) => {
          if (confirm2) {
            this.themeModel.resetTheme();
          }
        }, {
          applyTitle: getLocString("ed.themeResetConfirmationOk"),
          locale: editorLocalization.currentLocale,
          cssClass: "sv-popup--confirm svc-creator-popup"
        });
      }
    });
    items.push(this.resetTheme);
    this.themeSettingsAction = new Action({
      id: "svc-theme-settings",
      iconName: "icon-theme",
      iconSize: "auto",
      action: () => {
        if (!this.creator.showSidebar) {
          this.creator.setShowSidebar(true, true);
        }
      },
      visible: new ComputedUpdater(() => {
        const isMobileView = this.creator.isMobileView;
        const isShowOneCategoryInPropertyGrid = this.creator.showOneCategoryInPropertyGrid;
        return this.creator.activeTab === "theme" && (isMobileView || !isShowOneCategoryInPropertyGrid);
      }),
      active: new ComputedUpdater(() => this.creator.showSidebar),
      pressed: new ComputedUpdater(() => this.creator.showSidebar),
      locTitleName: "ed.themeSettings",
      locTooltipName: "ed.themeSettingsTooltip",
      showTitle: false
    });
    items.push(this.themeSettingsAction);
    this.importAction = new Action({
      id: "svc-theme-import",
      iconName: "icon-load",
      iconSize: "auto",
      locTitleName: "ed.themeImportButton",
      locTooltipName: "ed.themeImportButton",
      visible: this.createVisibleUpdater(),
      mode: "small",
      component: "sv-action-bar-item",
      needSeparator: true,
      action: () => {
        if (!document) return;
        if (!this.inputFileElement) {
          this.inputFileElement = document.createElement("input");
          this.inputFileElement.type = "file";
          this.inputFileElement.style.display = "none";
          this.inputFileElement.onchange = () => {
            if (this.inputFileElement.files.length < 1) return;
            this.importFromFile(this.inputFileElement.files[0]);
            this.inputFileElement.value = "";
          };
        }
        this.inputFileElement.click();
      }
    });
    items.push(this.importAction);
    this.exportAction = new Action({
      id: "svc-theme-export",
      iconName: "icon-download",
      iconSize: "auto",
      locTitleName: "ed.themeExportButton",
      locTooltipName: "ed.themeExportButton",
      visible: this.createVisibleUpdater(),
      mode: "small",
      component: "sv-action-bar-item",
      action: () => {
        this.exportToFile(settings2.themeEditor.exportFileName);
      }
    });
    items.push(this.exportAction);
    if (this.creator.showInvisibleElementsInTestSurveyTab) {
      this.invisibleToggleAction = new Action({
        id: "showInvisible",
        iconName: "icon-invisible-items",
        iconSize: "auto",
        mode: "small",
        locTitleName: "ts.showInvisibleElements",
        visible: false,
        action: () => {
          this.model.showInvisibleElements = !this.model.showInvisibleElements;
          this.invisibleToggleAction.active = !this.invisibleToggleAction.active;
          this.invisibleToggleAction.title = getLocString(!this.model.showInvisibleElements ? "ts.showInvisibleElements" : "ts.hideInvisibleElements");
        }
      });
    }
    return items;
  }
  undo() {
    const _undoRedoManager = this.model && this.themeModel.undoRedoManager;
    if (!_undoRedoManager) return;
    _undoRedoManager.suspend();
    if (_undoRedoManager.canUndo()) {
      _undoRedoManager.undo();
    }
    _undoRedoManager.resume();
  }
  redo() {
    const _undoRedoManager = this.model && this.themeModel.undoRedoManager;
    if (!_undoRedoManager) return;
    _undoRedoManager.suspend();
    if (_undoRedoManager.canRedo()) {
      _undoRedoManager.redo();
    }
    _undoRedoManager.resume();
  }
  updateUndeRedoActions() {
    const _undoRedoManager = this.themeModel.undoRedoManager;
    this.undoAction.enabled = _undoRedoManager.canUndo();
    this.redoAction.enabled = _undoRedoManager.canRedo();
  }
  addFooterActions() {
    this.creator.footerToolbar.actions.push(this.designerAction);
    this.creator.footerToolbar.actions.push(this.previewAction);
    this.creator.footerToolbar.actions.push(this.prevPageAction);
    this.creator.footerToolbar.actions.push(this.nextPageAction);
    this.invisibleToggleAction && this.creator.footerToolbar.actions.push(this.invisibleToggleAction);
    this.creator.footerToolbar.actions.push(this.themeSettingsAction);
  }
  syncTheme(theme) {
    const newTheme = theme || this.themeModel.toJSON();
    this.creator.theme = newTheme;
    this.updateSimulatorTheme(newTheme);
  }
  updateSimulatorTheme(theme) {
    if (!!this.model.survey) {
      if (isThemeEmpty(theme)) {
        const preferredTheme = findSuitableTheme(void 0, this.creator.preferredColorPalette, void 0, void 0);
        this.model.survey.applyTheme(preferredTheme || this.themeModel.toJSON());
      } else {
        this.model.survey.applyTheme(theme);
      }
    }
  }
  /**
   * A function that is called each time users click the [Save button](https://surveyjs.io/survey-creator/documentation/api-reference/survey-creator#showSaveButton) or [auto-save](https://surveyjs.io/survey-creator/documentation/api-reference/survey-creator#autoSaveEnabled) is triggered to save a theme JSON object.
   *
   * For more information, refer to the [Save and Load Custom Themes](https://surveyjs.io/survey-creator/documentation/theme-editor#save-and-load-custom-themes) help topic.
   */
  get saveThemeFunc() {
    return this._saveThemeFuncValue;
  }
  set saveThemeFunc(value) {
    this._saveThemeFuncValue = value;
  }
  processAutoSave() {
    let saveThemeFunc = this.saveThemeFunc;
    if (!saveThemeFunc && this.creator.saveThemeFunc) {
      saveThemeFunc = () => this.creator.saveTheme();
    }
    if (!saveThemeFunc) {
      return;
    }
    if (this.creator.autoSaveDelay <= 0) {
      saveThemeFunc();
      return;
    }
    if (!!this.autoSaveTimerId) {
      clearTimeout(this.autoSaveTimerId);
    }
    this.autoSaveTimerId = setTimeout(() => {
      clearTimeout(this.autoSaveTimerId);
      this.autoSaveTimerId = null;
      saveThemeFunc && saveThemeFunc();
    }, this.creator.autoSaveDelay);
  }
  /**
   * A list of UI themes from which users can select. You can sort this list if you want to reorder themes in Theme Editor.
   * @see addTheme
   * @see removeTheme
   */
  get availableThemes() {
    return [].concat(this._availableThemes);
  }
  set availableThemes(availableThemes) {
    this._availableThemes = availableThemes || [];
    this.onAvailableThemesChanged(availableThemes);
    this.updateAllowModifyTheme();
  }
  onAvailableThemesChanged(availableThemes) {
    const themeChooser = this.propertyGrid.survey.getQuestionByName("themeName");
    if (!!themeChooser) {
      themeChooser.choices = availableThemes.map((theme) => ({
        value: theme,
        text: getLocString("theme.names." + theme)
      }));
      if (availableThemes.indexOf(themeChooser.value) === -1) {
        this.themeModel.setTheme(this.themeModel.defaultSessionTheme);
      }
    }
    this.propertyGrid.survey.runExpressions();
  }
  /**
   * Adds a new UI theme to Theme Editor.
   * @param theme A [UI theme](https://surveyjs.io/form-library/documentation/api-reference/itheme) to add.
   * @param setAsDefault For internal use.
   * @returns An identifier of the added theme, which is a concatenation of the [`themeName`](https://surveyjs.io/form-library/documentation/api-reference/itheme#themeName), [`colorPalette`](https://surveyjs.io/form-library/documentation/api-reference/itheme#colorPalette), and [`isPanelless`](https://surveyjs.io/form-library/documentation/api-reference/itheme#isPanelless) settings (for example, `"default-dark-panelless"`).
   * @see removeTheme
   * @see getCurrentTheme
   */
  addTheme(theme, setAsDefault = false) {
    const fullThemeName = getThemeFullName(theme);
    Themes[fullThemeName] = theme;
    if (this._availableThemes.indexOf(theme.themeName) === -1) {
      if (setAsDefault) {
        this.availableThemes = [theme.themeName].concat(this.availableThemes);
        ThemeModel.DefaultTheme = theme;
      } else {
        this.availableThemes = this.availableThemes.concat([theme.themeName]);
      }
    } else {
      this.availableThemes = this.availableThemes;
    }
    return fullThemeName;
  }
  /**
   * Removes a UI theme from Theme Editor.
   * @param themeAccessor A [UI theme](https://surveyjs.io/form-library/documentation/api-reference/itheme) to delete or a theme identifier, which is a concatenation of the [`themeName`](https://surveyjs.io/form-library/documentation/api-reference/itheme#themeName), [`colorPalette`](https://surveyjs.io/form-library/documentation/api-reference/itheme#colorPalette), and [`isPanelless`](https://surveyjs.io/form-library/documentation/api-reference/itheme#isPanelless) settings (for example, `"default-dark-panelless"`).
   * @param includeModifications Pass `true` to delete not only the specified UI theme, but also all other themes with the same `themeName` value (dark/light and panelless modifications).
   * @see addTheme
   * @see getCurrentTheme
   */
  removeTheme(themeAccessor, includeModifications = false) {
    const themeToDelete = typeof themeAccessor === "string" ? Themes[themeAccessor] : themeAccessor;
    const fullThemeName = typeof themeAccessor === "string" ? themeAccessor : getThemeFullName(themeToDelete);
    if (!!themeToDelete) {
      delete Themes[fullThemeName];
      if (ThemeModel.DefaultTheme === themeToDelete) {
        ThemeModel.DefaultTheme = Themes["default-light"] || Themes[Object.keys(Themes)[0]];
        this.themeModel.defaultSessionTheme = ThemeModel.DefaultTheme;
      }
      const registeredThemeNames = Object.keys(Themes);
      let themeModifications = registeredThemeNames.filter((themeName) => themeName.indexOf(themeToDelete.themeName + "-") === 0);
      if (includeModifications && themeModifications.length > 0) {
        themeModifications.forEach((themeModificationFullName) => delete Themes[themeModificationFullName]);
      }
      if (includeModifications || themeModifications.length === 0) {
        const themeIndex = this._availableThemes.indexOf(themeToDelete.themeName);
        if (themeIndex !== -1) {
          const availableThemes = this.availableThemes;
          availableThemes.splice(themeIndex, 1);
          this.availableThemes = availableThemes;
        }
      }
    }
  }
  /**
   * Returns a JSON object that describes the currently applied UI theme.
   * @param changesOnly Pass `true` to get a JSON object that contains only changed theme settings instead of a full theme JSON schema.
   * @returns A currently applied [theme JSON schema](https://surveyjs.io/form-library/documentation/api-reference/itheme).
   * @see availableThemes
   * @see addTheme
   * @see removeTheme
   */
  getCurrentTheme(changesOnly = false) {
    if (!changesOnly) {
      return this.creator.theme;
    }
    return this.getThemeChanges();
  }
  getThemeChanges() {
    return getThemeChanges(this.creator.theme);
  }
  /**
   * Indicates whether the selected theme has been modified.
   * @see [`creator.saveTheme()`](https://surveyjs.io/survey-creator/documentation/api-reference/survey-creator#saveTheme)
   * @see [`creator.saveThemeFunc`](https://surveyjs.io/survey-creator/documentation/api-reference/survey-creator#saveThemeFunc)
   */
  get isModified() {
    const currentThemeChanges = this.getThemeChanges();
    const hasCssModifications = Object.keys(currentThemeChanges.cssVariables).length > 0;
    const hasBackgroundModifications = Object.keys(currentThemeChanges).some((propertyName) => propertyName.toLowerCase().indexOf("background") !== -1);
    const hasHeaderModifications = !!currentThemeChanges.header && Object.keys(currentThemeChanges.header).length === 0;
    return hasCssModifications || hasBackgroundModifications || hasHeaderModifications;
  }
  /**
   * A Boolean value that indicates or specifies whether the Appearance category displays advanced settings.
   *
   * Default value: `false`
   *
   * [View Demo](https://surveyjs.io/survey-creator/examples/change-form-theme/ (linkStyle))
   */
  get advancedModeEnabled() {
    return this._advancedModeValue;
  }
  set advancedModeEnabled(newValue) {
    this._advancedModeValue = newValue;
    this.updateAdvancedModeQuestion(newValue);
  }
};
ThemeTabPlugin.DefaultTheme = Themes["default-light"];
var ExpandCollapseManager = class {
  constructor(creator) {
    this.creator = creator;
    this._lockQuestions = false;
    this.adorners = [];
  }
  expandCollapseElements(reason, isCollapsed, elements = null) {
    this.updateCollapsed(elements || this.getCollapsableElements(), isCollapsed, reason);
  }
  get questionsLocked() {
    return this._lockQuestions;
  }
  lockQuestions(locked) {
    this._lockQuestions = locked;
  }
  getCollapsableElements() {
    return this.creator.survey.pages.concat(this.creator.survey.getAllPanels()).concat(this.creator.survey.getAllQuestions());
  }
  updateCollapsed(elements, value, reason) {
    const canToSaveToStateManager = this.creator.designerStateManager && !this.creator.designerStateManager.isSuspended;
    elements.forEach((element) => {
      if (element.isQuestion && this._lockQuestions) return;
      if (canToSaveToStateManager) {
        this.creator.designerStateManager.getElementState(element).collapsed = this.creator.getElementExpandCollapseState(element, reason, value);
      }
    });
    for (let i = this.adorners.length - 1; i >= 0; i--) {
      const element = this.adorners[i].element;
      if (element.isQuestion && this._lockQuestions) continue;
      if (elements.indexOf(element) == -1) continue;
      if (this.adorners[i].allowExpandCollapse) {
        let newState = canToSaveToStateManager ? this.creator.designerStateManager.getElementState(element).collapsed : this.creator.getElementExpandCollapseState(element, reason, value);
        this.adorners[i].collapsed = newState;
      }
    }
  }
  add(adorner) {
    this.adorners.push(adorner);
  }
  remove(adorner) {
    this.adorners.splice(this.adorners.indexOf(adorner), 1);
  }
  clear() {
    this.adorners.length = 0;
  }
};
var TabbedMenuItem = class extends Action {
  constructor(item) {
    super(item);
  }
  getRootCss() {
    return new CssClassBuilder().append("svc-tabbed-menu-item").append("svc-tabbed-menu-item--selected", this.active).append("svc-tabbed-menu-item--disabled", this.enabled !== void 0 && !this.enabled).append("svc-tabbed-menu-item--icon", this.hasIcon).toString();
  }
  getTitleCss() {
    return new CssClassBuilder().append("svc-tabbed-menu-item__text").toString();
  }
  getIconCss() {
    return new CssClassBuilder().append("svc-tabbed-menu-item__icon").toString();
  }
  get hasTitle() {
    return !this.hasIcon;
  }
  get hasIcon() {
    return !this.disableShrink && this.iconName && this.mode == "small";
  }
};
var TabbedMenuContainer = class extends AdaptiveActionContainer {
  constructor(creator) {
    super();
    this.creator = creator;
    this.dotsItem.popupModel.horizontalPosition = "center";
    this.dotsItem.popupModel.cssClass += " svc-tabbed-menu-item__popup svc-creator-popup";
    this.hiddenItemsListModel.cssClasses = listComponentCss;
    this.minVisibleItemsCount = 1;
  }
  addTab(name, plugin, title, iconName, componentName, index) {
    const tabName = name === "test" ? "preview" : name;
    const locStrName = !title ? "tabs." + tabName : title.indexOf("ed.") == 0 ? title : "";
    const tab = new TabbedMenuItem({
      id: name,
      locTitleName: locStrName,
      title,
      componentContent: componentName ? componentName : "svc-tab-" + name,
      data: plugin,
      iconName: iconName || "icon-undefined-24x24",
      action: () => {
        this.creator.switchTab(name);
      },
      active: this.creator.viewType === name,
      disableHide: this.creator.viewType === name
    });
    tab.disableShrink = this.creator.tabResponsivenessMode == "menu";
    if (index !== void 0 && index >= 0 && index < this.actions.length) {
      this.actions.splice(index, 0, tab);
    } else {
      this.actions.push(tab);
    }
  }
  updateResponsivenessMode() {
    this.actions.forEach((tab) => {
      tab.disableShrink = this.creator.tabResponsivenessMode == "menu";
    });
    this.raiseUpdate(true);
  }
};
var iconsV1Data = {
  "actual-size-24x24": '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M10 6C7.79 6 6 7.79 6 10C6 12.21 7.79 14 10 14C12.21 14 14 12.21 14 10C14 7.79 12.21 6 10 6ZM10 12C8.9 12 8 11.1 8 10C8 8.9 8.9 8 10 8C11.1 8 12 8.9 12 10C12 11.1 11.1 12 10 12ZM22.71 21.29L17.03 15.61C18.26 14.07 19 12.12 19 10C19 5.04 14.96 1 10 1C5.04 1 1 5.04 1 10C1 14.96 5.04 19 10 19C12.12 19 14.07 18.26 15.61 17.03L21.29 22.71L22.7 21.3L22.71 21.29ZM3 10C3 6.14 6.14 3 10 3C13.86 3 17 6.14 17 10C17 13.86 13.86 17 10 17C6.14 17 3 13.86 3 10Z"></path></svg>',
  "add-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_554_309816)"><path d="M9 7H12V9H9V12H7V9H4V7H7V4H9V7ZM16 8C16 12.4 12.4 16 8 16C3.6 16 0 12.4 0 8C0 3.6 3.6 0 8 0C12.4 0 16 3.6 16 8ZM14 8C14 4.7 11.3 2 8 2C4.7 2 2 4.7 2 8C2 11.3 4.7 14 8 14C11.3 14 14 11.3 14 8Z"></path></g><defs><clipPath id="clip0_554_309816"><rect width="16" height="16" fill="white"></rect></clipPath></defs></svg>',
  "add-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M13 11H17V13H13V17H11V13H7V11H11V7H13V11ZM23 12C23 18.1 18.1 23 12 23C5.9 23 1 18.1 1 12C1 5.9 5.9 1 12 1C18.1 1 23 5.9 23 12ZM21 12C21 7 17 3 12 3C7 3 3 7 3 12C3 17 7 21 12 21C17 21 21 17 21 12Z"></path></svg>',
  "apply-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 1C5.9 1 1 5.9 1 12C1 18.1 5.9 23 12 23C18.1 23 23 18.1 23 12C23 5.9 18.1 1 12 1ZM12 21C7 21 3 17 3 12C3 7 7 3 12 3C17 3 21 7 21 12C21 17 17 21 12 21ZM16.3 8L17.7 9.4L10 17.1L6.3 13.4L7.7 12L10 14.3L16.3 8Z"></path></svg>',
  "arrowdown-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M17.01 11.59L13.01 15.59V6H11.01V15.59L7.00998 11.59L5.59998 13L12.01 19.41L18.43 13L17.01 11.59Z"></path></svg>',
  "arrowleft-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M15 8.99999H4.4L8.7 13.3L7.3 14.7L0.599998 7.99999L7.3 1.29999L8.7 2.69999L4.4 6.99999H15V8.99999Z"></path></svg>',
  "arrowleft-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M10.4 2.60001L11.8 4.00001L4.8 11H22V13H4.8L11.8 20L10.4 21.4L1 12L10.4 2.60001Z"></path></svg>',
  "arrowright-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M1 6.99999H11.6L7.3 2.69999L8.7 1.29999L15.4 7.99999L8.7 14.7L7.3 13.3L11.6 8.99999H1V6.99999Z"></path></svg>',
  "arrowright-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M13.6 2.60001L12.2 4.00001L19.2 11H2V13H19.2L12.2 20L13.6 21.4L23 12L13.6 2.60001Z"></path></svg>',
  "arrowup-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M18.43 11.01L12.01 4.59998L5.59998 11.01L7.00998 12.43L11.01 8.42998V18.01H13.01V8.42998L17.01 12.43L18.43 11.01Z"></path></svg>',
  "camera-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20.01 4H18.4C18.2 4 18.01 3.9 17.9 3.73L16.97 2.34C16.41 1.5 15.48 1 14.47 1H9.54C8.53 1 7.6 1.5 7.04 2.34L6.11 3.73C6 3.9 5.81 4 5.61 4H4C2.35 4 1 5.35 1 7V19C1 20.65 2.35 22 4 22H20C21.65 22 23 20.65 23 19V7C23 5.35 21.65 4 20 4H20.01ZM21.01 19C21.01 19.55 20.56 20 20.01 20H4.01C3.46 20 3.01 19.55 3.01 19V7C3.01 6.45 3.46 6 4.01 6H5.62C6.49 6 7.3 5.56 7.79 4.84L8.72 3.45C8.91 3.17 9.22 3 9.55 3H14.48C14.81 3 15.13 3.17 15.31 3.45L16.24 4.84C16.72 5.56 17.54 6 18.41 6H20.02C20.57 6 21.02 6.45 21.02 7V19H21.01ZM12.01 6C8.7 6 6.01 8.69 6.01 12C6.01 15.31 8.7 18 12.01 18C15.32 18 18.01 15.31 18.01 12C18.01 8.69 15.32 6 12.01 6ZM12.01 16C9.8 16 8.01 14.21 8.01 12C8.01 9.79 9.8 8 12.01 8C14.22 8 16.01 9.79 16.01 12C16.01 14.21 14.22 16 12.01 16ZM13.01 10C13.01 10.55 12.56 11 12.01 11C11.46 11 11.01 11.45 11.01 12C11.01 12.55 10.56 13 10.01 13C9.46 13 9.01 12.55 9.01 12C9.01 10.35 10.36 9 12.01 9C12.56 9 13.01 9.45 13.01 10Z"></path></svg>',
  "camera-32x32": '<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><path d="M27 6H23.8C23.34 6 22.92 5.77 22.66 5.39L22.25 4.78C21.51 3.66 20.26 3 18.92 3H13.06C11.72 3 10.48 3.67 9.73 4.78L9.32 5.39C9.07 5.77 8.64 6 8.18 6H4.98C2.79 6 1 7.79 1 10V24C1 26.21 2.79 28 5 28H27C29.21 28 31 26.21 31 24V10C31 7.79 29.21 6 27 6ZM29 24C29 25.1 28.1 26 27 26H5C3.9 26 3 25.1 3 24V10C3 8.9 3.9 8 5 8H8.2C9.33 8 10.38 7.44 11 6.5L11.41 5.89C11.78 5.33 12.41 5 13.07 5H18.93C19.6 5 20.22 5.33 20.59 5.89L21 6.5C21.62 7.44 22.68 8 23.8 8H27C28.1 8 29 8.9 29 10V24ZM16 9C12.13 9 9 12.13 9 16C9 19.87 12.13 23 16 23C19.87 23 23 19.87 23 16C23 12.13 19.87 9 16 9ZM16 21C13.24 21 11 18.76 11 16C11 13.24 13.24 11 16 11C18.76 11 21 13.24 21 16C21 18.76 18.76 21 16 21ZM17 13C17 13.55 16.55 14 16 14C14.9 14 14 14.9 14 16C14 16.55 13.55 17 13 17C12.45 17 12 16.55 12 16C12 13.79 13.79 12 16 12C16.55 12 17 12.45 17 13Z"></path></svg>',
  "cancel-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M22.6 8.6L16.4 2.4C16 2 15.5 1.8 15 1.8C14.5 1.8 14 2 13.6 2.4L1.40005 14.6C0.600049 15.4 0.600049 16.6 1.40005 17.4L6.00005 22H12L22.6 11.4C23.3 10.6 23.3 9.3 22.6 8.6ZM11.1 20H6.80005L2.80005 16L6.20005 12.6L12.4 18.8L11.1 20ZM13.8 17.4L7.60005 11.2L15 3.8L21.2 10L13.8 17.4ZM16 20H23V22H14L16 20Z"></path></svg>',
  "check-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M5.003 14.413L0.292999 9.70303L1.703 8.29303L5.003 11.583L14.293 2.29303L15.703 3.70303L5.003 14.413Z"></path></svg>',
  "check-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M9 20.1L1 12L3.1 9.9L9 15.9L20.9 4L23 6.1L9 20.1Z"></path></svg>',
  "chevrondown-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M8 11L13 6H3L8 11Z"></path></svg>',
  "chevrondown-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 15L17 10H7L12 15Z"></path></svg>',
  "chevronleft-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M10.393 12.6465L5.69297 8.04651L10.393 3.34651L9.69297 2.64651L4.29297 8.04651L9.69297 13.3465L10.393 12.6465Z"></path></svg>',
  "clear-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M13.35 3.34999L12.65 2.64999L8.05002 7.24999L3.35002 2.64999L2.65002 3.34999L7.25002 8.04999L2.65002 12.65L3.35002 13.35L8.05002 8.74999L12.65 13.35L13.35 12.65L8.75002 8.04999L13.35 3.34999Z"></path></svg>',
  "clear-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M22.6 8.6L16.4 2.4C16 2 15.5 1.8 15 1.8C14.5 1.8 14 2 13.6 2.4L1.40005 14.6C0.600049 15.4 0.600049 16.6 1.40005 17.4L6.00005 22H12L22.6 11.4C23.3 10.6 23.3 9.3 22.6 8.6ZM11.1 20H6.80005L2.80005 16L6.20005 12.6L12.4 18.8L11.1 20ZM13.8 17.4L7.60005 11.2L15 3.8L21.2 10L13.8 17.4ZM16 20H23V22H14L16 20Z"></path></svg>',
  "close-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M9.43 8.0025L13.7 3.7225C14.09 3.3325 14.09 2.6925 13.7 2.2925C13.31 1.9025 12.67 1.9025 12.27 2.2925L7.99 6.5725L3.72 2.3025C3.33 1.9025 2.69 1.9025 2.3 2.3025C1.9 2.6925 1.9 3.3325 2.3 3.7225L6.58 8.0025L2.3 12.2825C1.91 12.6725 1.91 13.3125 2.3 13.7125C2.69 14.1025 3.33 14.1025 3.73 13.7125L8.01 9.4325L12.29 13.7125C12.68 14.1025 13.32 14.1025 13.72 13.7125C14.11 13.3225 14.11 12.6825 13.72 12.2825L9.44 8.0025H9.43Z"></path></svg>',
  "close-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M13.4101 12L20.7001 4.71C21.0901 4.32 21.0901 3.69 20.7001 3.3C20.3101 2.91 19.6801 2.91 19.2901 3.3L12.0001 10.59L4.71006 3.29C4.32006 2.9 3.68006 2.9 3.29006 3.29C2.90006 3.68 2.90006 4.32 3.29006 4.71L10.5801 12L3.29006 19.29C2.90006 19.68 2.90006 20.31 3.29006 20.7C3.49006 20.9 3.74006 20.99 4.00006 20.99C4.26006 20.99 4.51006 20.89 4.71006 20.7L12.0001 13.41L19.2901 20.7C19.4901 20.9 19.7401 20.99 20.0001 20.99C20.2601 20.99 20.5101 20.89 20.7101 20.7C21.1001 20.31 21.1001 19.68 20.7101 19.29L13.4201 12H13.4101Z"></path></svg>',
  "codeeditor-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20 2H4C2.9 2 2 2.9 2 4V20C2 21.1 2.9 22 4 22H20C21.1 22 22 21.1 22 20V4C22 2.9 21.1 2 20 2ZM4 20V4H20V20H4ZM9 11C9 11.37 8.89 11.7 8.72 12C8.89 12.3 9 12.63 9 13V14.5C9 14.78 9.22 15 9.5 15H10C10.55 15 11 15.45 11 16C11 16.55 10.55 17 10 17H9.5C8.12 17 7 15.88 7 14.5V13C6.45 13 6 12.55 6 12C6 11.45 6.45 11 7 11V9.5C7 8.12 8.12 7 9.5 7H10C10.55 7 11 7.45 11 8C11 8.55 10.55 9 10 9H9.5C9.22 9 9 9.22 9 9.5V11ZM18 12C18 12.55 17.55 13 17 13V14.5C17 15.88 15.88 17 14.5 17H14C13.45 17 13 16.55 13 16C13 15.45 13.45 15 14 15H14.5C14.78 15 15 14.78 15 14.5V13C15 12.63 15.11 12.3 15.28 12C15.11 11.7 15 11.37 15 11V9.5C15 9.22 14.78 9 14.5 9H14C13.45 9 13 8.55 13 8C13 7.45 13.45 7 14 7H14.5C15.88 7 17 8.12 17 9.5V11C17.55 11 18 11.45 18 12Z"></path></svg>',
  "collapse-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M2 6L3 5L8 10L13 5L14 6L8 12L2 6Z"></path></svg>',
  "collapse-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M13 2V7.6L15.3 5.3L16.7 6.7L12 11.4L7.30005 6.7L8.70005 5.3L11 7.6V2H13Z"></path><path d="M8.70005 18.7001L7.30005 17.3001L12 12.6001L16.7 17.3001L15.3 18.7001L13 16.4001V22.0001H11V16.4001L8.70005 18.7001Z"></path></svg>',
  "collapse-pg-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M13 5.6L19.4 12L13 18.4L11.6 17L15.6 13H2V11H15.6L11.6 7L13 5.6ZM20 2V22H22V2H20Z"></path></svg>',
  "collapseall-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.59L16.41 19L15 20.41L13 18.41V23H11V18.41L9 20.41L7.59 19L12 14.59ZM16.41 5L15 3.59L13 5.59V1H11V5.59L9 3.59L7.59 5L12 9.41L16.41 5ZM2 11V13H22V11H2Z"></path></svg>',
  "collapsedetails-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M13 7H3V9H13V7Z"></path></svg>',
  "collapsefocused-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M1.08278 4.08272C2.14278 3.02272 3.85278 3.02272 4.91278 4.08272L8.00278 7.17272L11.0928 4.08272C12.1528 3.02272 13.8628 3.02272 14.9228 4.08272C15.9828 5.14272 15.9828 6.85272 14.9228 7.91272L9.42278 13.4127C8.64278 14.1927 7.37278 14.1927 6.59278 13.4127L1.08278 7.91272C0.0227808 6.85272 0.0227808 5.14272 1.08278 4.08272Z"></path><path d="M2.00281 6.00269L3.00281 5.00269L8.00281 10.0027L13.0028 5.00269L14.0028 6.00269L8.00281 12.0027L2.00281 6.00269Z" fill="white"></path></svg>',
  "collapsepage-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M11.71 12.29C12.1 12.68 12.1 13.31 11.71 13.7C11.51 13.9 11.26 13.99 11 13.99C10.74 13.99 10.49 13.89 10.29 13.7L9 12.41V15C9 15.55 8.55 16 8 16C7.45 16 7 15.55 7 15V12.41L5.71 13.7C5.32 14.09 4.69 14.09 4.3 13.7C3.91 13.31 3.91 12.68 4.3 12.29L7.3 9.29C7.69 8.9 8.32 8.9 8.71 9.29L11.71 12.29ZM7.29 6.71C7.49 6.91 7.74 7 8 7C8.26 7 8.51 6.9 8.71 6.71L11.71 3.71C12.1 3.32 12.1 2.69 11.71 2.3C11.32 1.91 10.69 1.91 10.3 2.3L9.01 3.59V1C9.01 0.45 8.56 0 8.01 0C7.46 0 7.01 0.45 7.01 1V3.59L5.72 2.3C5.33 1.91 4.7 1.91 4.31 2.3C3.92 2.69 3.9 3.32 4.29 3.71L7.29 6.71Z"></path></svg>',
  "collapsepanel-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M13 9H3C2.45 9 2 8.55 2 8C2 7.45 2.45 7 3 7H13C13.55 7 14 7.45 14 8C14 8.55 13.55 9 13 9Z"></path></svg>',
  "copy-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_9500_71113)"><path d="M14 0H6C5.46957 0 4.96086 0.210714 4.58579 0.585786C4.21071 0.960859 4 1.46957 4 2V4H2C1.46957 4 0.960859 4.21071 0.585786 4.58579C0.210714 4.96086 0 5.46957 0 6L0 14C0 14.5304 0.210714 15.0391 0.585786 15.4142C0.960859 15.7893 1.46957 16 2 16H10C10.5304 16 11.0391 15.7893 11.4142 15.4142C11.7893 15.0391 12 14.5304 12 14V12H14C14.5304 12 15.0391 11.7893 15.4142 11.4142C15.7893 11.0391 16 10.5304 16 10V2C16 1.46957 15.7893 0.960859 15.4142 0.585786C15.0391 0.210714 14.5304 0 14 0V0ZM10 14H2V6H10V14ZM14 10H12V6C12 5.46957 11.7893 4.96086 11.4142 4.58579C11.0391 4.21071 10.5304 4 10 4H6V2H14V10Z"></path></g><defs><clipPath id="clip0_9500_71113"><rect width="16" height="16" fill="white"></rect></clipPath></defs></svg>',
  "copy-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M21 1H9C7.9 1 7 1.9 7 3V7H3C1.9 7 1 7.9 1 9V21C1 22.1 1.9 23 3 23H15C16.1 23 17 22.1 17 21V17H21C22.1 17 23 16.1 23 15V3C23 1.9 22.1 1 21 1ZM15 21H3V9H15V21ZM21 15H17V9C17 7.9 16.1 7 15 7H9V3H21V15Z"></path></svg>',
  "cross-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M17.71 7.71L17 7L12.35 11.65L7.71 7L7 7.71L11.65 12.35L7 17L7.71 17.71L12.35 13.06L17 17.71L17.71 17L13.06 12.35L17.71 7.71Z"></path></svg>',
  "delete-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M15 2H14H11V1C11 0.4 10.6 0 10 0H7C6.4 0 6 0.4 6 1V2H3H2V4H3V14C3 15.1 3.9 16 5 16H12C13.1 16 14 15.1 14 14V4H15V2ZM7 1H10V2H7V1ZM12 14H5V4H12V14ZM7 13H6V5H7V13ZM9 13H8V5H9V13ZM11 13H10V5H11V13Z"></path></svg>',
  "delete-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M22 4H20H16V2C16 0.9 15.1 0 14 0H10C8.9 0 8 0.9 8 2V4H4H2V6H4V20C4 21.1 4.9 22 6 22H18C19.1 22 20 21.1 20 20V6H22V4ZM10 2H14V4H10V2ZM18 20H6V6H8H16H18V20ZM14 8H16V18H14V8ZM11 8H13V18H11V8ZM8 8H10V18H8V8Z"></path></svg>',
  "desktop-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M22 17V2H2V17H10V19C10 19.7956 9.68393 20.5587 9.12132 21.1213C8.55871 21.6839 7.79565 22 7 22H17C16.2044 22 15.4413 21.6839 14.8787 21.1213C14.3161 20.5587 14 19.7956 14 19V17H22ZM4 4H20V15H4V4Z"></path></svg>',
  "download-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 18.41L4.59 11L6 9.59L11 14.59V2H13V14.59L18 9.59L19.41 11L12 18.41ZM2 20V22H22V20H2Z"></path></svg>',
  "drag-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M13 6C13 4.9 13.9 4 15 4C16.1 4 17 4.9 17 6C17 7.1 16.1 8 15 8C13.9 8 13 7.1 13 6ZM9 4C7.9 4 7 4.9 7 6C7 7.1 7.9 8 9 8C10.1 8 11 7.1 11 6C11 4.9 10.1 4 9 4ZM15 10C13.9 10 13 10.9 13 12C13 13.1 13.9 14 15 14C16.1 14 17 13.1 17 12C17 10.9 16.1 10 15 10ZM9 10C7.9 10 7 10.9 7 12C7 13.1 7.9 14 9 14C10.1 14 11 13.1 11 12C11 10.9 10.1 10 9 10ZM15 16C13.9 16 13 16.9 13 18C13 19.1 13.9 20 15 20C16.1 20 17 19.1 17 18C17 16.9 16.1 16 15 16ZM9 16C7.9 16 7 16.9 7 18C7 19.1 7.9 20 9 20C10.1 20 11 19.1 11 18C11 16.9 10.1 16 9 16Z"></path></svg>',
  "draghorizontal-24x16": '<svg viewBox="0 0 24 16" xmlns="http://www.w3.org/2000/svg"><path d="M18 9C19.1 9 20 9.9 20 11C20 12.1 19.1 13 18 13C16.9 13 16 12.1 16 11C16 9.9 16.9 9 18 9ZM20 5C20 3.9 19.1 3 18 3C16.9 3 16 3.9 16 5C16 6.1 16.9 7 18 7C19.1 7 20 6.1 20 5ZM14 11C14 9.9 13.1 9 12 9C10.9 9 10 9.9 10 11C10 12.1 10.9 13 12 13C13.1 13 14 12.1 14 11ZM14 5C14 3.9 13.1 3 12 3C10.9 3 10 3.9 10 5C10 6.1 10.9 7 12 7C13.1 7 14 6.1 14 5ZM8 11C8 9.9 7.1 9 6 9C4.9 9 4 9.9 4 11C4 12.1 4.9 13 6 13C7.1 13 8 12.1 8 11ZM8 5C8 3.9 7.1 3 6 3C4.9 3 4 3.9 4 5C4 6.1 4.9 7 6 7C7.1 7 8 6.1 8 5Z"></path></svg>',
  "draghorizontalsmall-24x16": '<svg viewBox="0 0 24 16" xmlns="http://www.w3.org/2000/svg"><path d="M10 7C10 7.55 9.55 8 9 8C8.45 8 8 7.55 8 7C8 6.45 8.45 6 9 6C9.55 6 10 6.45 10 7ZM9 9C8.45 9 8 9.45 8 10C8 10.55 8.45 11 9 11C9.55 11 10 10.55 10 10C10 9.45 9.55 9 9 9ZM12 6C11.45 6 11 6.45 11 7C11 7.55 11.45 8 12 8C12.55 8 13 7.55 13 7C13 6.45 12.55 6 12 6ZM12 9C11.45 9 11 9.45 11 10C11 10.55 11.45 11 12 11C12.55 11 13 10.55 13 10C13 9.45 12.55 9 12 9ZM15 8C15.55 8 16 7.55 16 7C16 6.45 15.55 6 15 6C14.45 6 14 6.45 14 7C14 7.55 14.45 8 15 8ZM15 9C14.45 9 14 9.45 14 10C14 10.55 14.45 11 15 11C15.55 11 16 10.55 16 10C16 9.45 15.55 9 15 9Z"></path></svg>',
  "dropper-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M3.31 15C2.69 15 2.11 14.76 1.68 14.32C0.780005 13.42 0.780005 11.95 1.68 11.05L2.45 10.28C2.45 10.18 2.44 10.08 2.44 9.98C2.44 9.02 2.81 8.12 3.49 7.44L5.6 5.33C5.37 5.04 5.25 4.68 5.25 4.31C5.25 3.86 5.42 3.44 5.74 3.12C6.06 2.8 6.48 2.63 6.92 2.63C7.29 2.63 7.65 2.75 7.94 2.98L8.88 2.04C9.56001 1.36 10.46 0.989998 11.41 0.989998C12.36 0.989998 13.27 1.36 13.95 2.04C14.63 2.72 15 3.62 15 4.58C15 5.54 14.63 6.44 13.95 7.12L12.94 8.13C13.04 8.34 13.09 8.58 13.09 8.82C13.09 9.27 12.92 9.69 12.6 10C12.28 10.31 11.86 10.49 11.42 10.49C11.18 10.49 10.94 10.44 10.73 10.34L8.56 12.51C7.88 13.19 6.98 13.56 6.03 13.56C5.93001 13.56 5.83 13.56 5.73 13.54L4.97 14.3C4.53 14.74 3.95 14.98 3.34 14.98L3.31 15Z" fill="black" fill-opacity="0.15"></path><path d="M14 4.58C14 3.89 13.73 3.24 13.24 2.75C12.23 1.74 10.59 1.74 9.58 2.75L7.94 4.39L7.39 3.84C7.13 3.58 6.7 3.58 6.44 3.84C6.18 4.1 6.18 4.53 6.44 4.79L6.99 5.34L4.18 8.15C3.69 8.64 3.42 9.29 3.42 9.98C3.42 10.2 3.46 10.41 3.51 10.62L2.38 11.75C1.87 12.26 1.87 13.09 2.38 13.61C2.64 13.87 2.97 13.99 3.31 13.99C3.65 13.99 3.98 13.86 4.24 13.61L5.37 12.48C5.58 12.53 5.79 12.57 6.01 12.57C6.7 12.57 7.35 12.3 7.84 11.81L10.65 9L10.94 9.29C11.07 9.42 11.24 9.49 11.42 9.49C11.6 9.49 11.77 9.42 11.9 9.29C12.16 9.03 12.16 8.6 11.9 8.34L11.61 8.05L13.25 6.41C13.74 5.92 14.01 5.27 14.01 4.58H14ZM6.89 10.86C6.42 11.33 5.61 11.33 5.14 10.86C4.91 10.63 4.78 10.32 4.78 9.99C4.78 9.66 4.91 9.35 5.14 9.12L7.95 6.31L9.7 8.06L6.89 10.87V10.86Z" fill="white"></path></svg>',
  "edit-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_2693_58208)"><path d="M15.3 2.8L13.2 0.7C12.7 0.2 12.2 0 11.6 0C11 0 10.4 0.2 10 0.7L2 8.6C0.7 9.9 0 11.7 0 13.5V15.3C0 15.7 0.3 16 0.8 16H2.6C4.4 16 6.2 15.3 7.5 14L15.4 6.1C16.2 5.2 16.2 3.7 15.3 2.8ZM6 12.6C5.1 13.5 3.8 14 2.5 14H2V13.5C2 12.2 2.5 10.9 3.4 10L8 5.4L10.6 8L6 12.6ZM13.9 4.7L12 6.6L9.4 4L11.3 2.1C11.4 2 11.5 2 11.6 2C11.7 2 11.7 2 11.8 2.1L13.9 4.2C14 4.3 14 4.5 13.9 4.7Z"></path></g><defs><clipPath id="clip0_2693_58208"><rect width="16" height="16" fill="white"></rect></clipPath></defs></svg>',
  "edit-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M21.9 4.80001L19.1 2.00001C18.5 1.50001 17.8 1.20001 17 1.20001C16.2 1.20001 15.5 1.50001 14.9 2.10001L4.6 12.3C2.9 14 2 16.3 2 18.7V21C2 21.6 2.4 22 3 22H5.3C7.7 22 10 21.1 11.7 19.4L21.9 9.10001C23.1 7.90001 23.1 6.00001 21.9 4.80001ZM10.2 17.9C8.9 19.2 7.1 20 5.3 20H4V18.7C4 16.8 4.7 15.1 6.1 13.8L12.3 7.60001L16.5 11.8L10.2 17.9ZM20.5 7.70001L17.8 10.4L13.6 6.20001L16.3 3.50001C16.5 3.20001 16.8 3.20001 17 3.20001C17.2 3.20001 17.5 3.20001 17.7 3.50001L20.5 6.30001C20.9 6.60001 20.9 7.30001 20.5 7.70001Z"></path></svg>',
  "editsmall-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M13.59 4.5884L11.42 2.4184C11.03 2.0284 10.52 1.8284 10.01 1.8284C9.5 1.8284 8.99 2.0284 8.6 2.4184L3.76 7.2384C2.63 8.3684 2 9.8884 2 11.4784V12.9884C2 13.5384 2.45 13.9884 3 13.9884H4.51C6.1 13.9884 7.63 13.3584 8.75 12.2284L13.58 7.3984C14.36 6.6184 14.36 5.3484 13.58 4.5684L13.59 4.5884ZM7.35 10.8284C6.59 11.5884 5.59 11.9984 4.52 11.9984H4.01V11.4884C4.01 10.4184 4.43 9.4184 5.18 8.6584L7.72 6.1184L9.89 8.2884L7.35 10.8284ZM11.3 6.8784L9.13 4.7084L10.01 3.8284L12.18 5.9984L11.3 6.8784Z"></path></svg>',
  "embedsurvey-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M13 14.41V23H11V14.41L8.71 16.7L7.3 15.29L12.01 10.58L16.72 15.29L15.31 16.7L13.02 14.41H13ZM20 3H4C2.9 3 2 3.9 2 5V19C2 20.1 2.9 21 4 21H9V19H4V5H20V19H15V21H20C21.1 21 22 20.1 22 19V5C22 3.9 21.1 3 20 3ZM5 6V8H8V6H5ZM19 6H9V8H19V6Z"></path></svg>',
  "error-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_19289_560924)"><path d="M8 0C3.58 0 0 3.58 0 8C0 12.42 3.58 16 8 16C12.42 16 16 12.42 16 8C16 3.58 12.42 0 8 0ZM8 14C4.69 14 2 11.31 2 8C2 4.69 4.69 2 8 2C11.31 2 14 4.69 14 8C14 11.31 11.31 14 8 14ZM11.41 6L9.41 8L11.41 10L10 11.41L8 9.41L6 11.41L4.59 10L6.59 8L4.59 6L6 4.59L8 6.59L10 4.59L11.41 6Z"></path></g><defs><clipPath id="clip0_19289_560924"><rect width="16" height="16" fill="white"></rect></clipPath></defs></svg>',
  "error-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 4C7.58 4 4 7.58 4 12C4 16.42 7.58 20 12 20C16.42 20 20 16.42 20 12C20 7.58 16.42 4 12 4ZM12 18C8.69 18 6 15.31 6 12C6 8.69 8.69 6 12 6C15.31 6 18 8.69 18 12C18 15.31 15.31 18 12 18ZM15.41 10L13.41 12L15.41 14L14 15.41L12 13.41L10 15.41L8.59 14L10.59 12L8.59 10L10 8.59L12 10.59L14 8.59L15.41 10Z"></path></svg>',
  "expand-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M6 14L5 13L10 8L5 3L6 2L12 8L6 14Z"></path></svg>',
  "expand-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M8.70005 6.69998L7.30005 5.29998L12 0.599976L16.7 5.29998L15.3 6.69998L13 4.39998V9.99998H11V4.39998L8.70005 6.69998Z"></path><path d="M13 13.9999V19.5999L15.3 17.2999L16.7 18.6999L12 23.3999L7.30005 18.6999L8.70005 17.2999L11 19.5999V13.9999H13Z"></path></svg>',
  "expand-pg-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M19.9959 2H14.9959V22H21.9959V2H19.9959ZM19.9959 20H16.9959V4H19.9959V20ZM4.40594 11H12.9959V13H4.40594L8.40594 17L6.99594 18.41L0.585938 12L6.99594 5.59L8.40594 7L4.40594 11Z"></path></svg>',
  "expandall-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M9 6.83L7.59 5.42L12 1L16.41 5.41L15 6.82L13 4.82V10.41H11V4.83L9 6.83ZM13 20V14.41H11V20L9 18L7.59 19.41L12 23.82L16.41 19.41L15 18L13 20ZM20 8.41H15V10.41H20V14.41H15V16.41H20C21.1 16.41 22 15.51 22 14.41V10.41C22 9.31 21.1 8.41 20 8.41ZM9 14.41H4V10.41H9V8.41H4C2.9 8.41 2 9.31 2 10.41V14.41C2 15.51 2.9 16.41 4 16.41H9V14.41Z"></path></svg>',
  "expanddetails-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M13 7H9V3H7V7H3V9H7V13H9V9H13V7Z"></path></svg>',
  "expandfocused-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M4.08269 11.0827L7.17269 7.99272L4.08269 4.91272C3.02269 3.85272 3.02269 2.14272 4.08269 1.08272C5.14269 0.0227197 6.85269 0.0227197 7.91269 1.08272L13.4127 6.58272C14.1927 7.36272 14.1927 8.63272 13.4127 9.41272L7.91269 14.9127C6.85269 15.9727 5.14269 15.9727 4.08269 14.9127C3.02269 13.8527 3.02269 12.1427 4.08269 11.0827Z"></path><path d="M6.00269 14.0027L5.00269 13.0027L10.0027 8.00269L5.00269 3.00269L6.00269 2.00269L12.0027 8.00269L6.00269 14.0027Z" fill="white"></path></svg>',
  "expandpage-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_21945_90234)"><path d="M4.29 4.71C3.9 4.32 3.9 3.69 4.29 3.3L7.29 0.289998C7.68 -0.100002 8.31 -0.100002 8.7 0.289998L11.7 3.29C12.09 3.68 12.09 4.31 11.7 4.7C11.5 4.9 11.25 4.99 10.99 4.99C10.73 4.99 10.48 4.89 10.28 4.7L8.99 3.41V6C8.99 6.55 8.54 7 7.99 7C7.44 7 6.99 6.55 6.99 6V3.41L5.7 4.7C5.31 5.09 4.68 5.09 4.29 4.7V4.71ZM10.29 11.29L9 12.58V9.99C9 9.44 8.55 8.99 8 8.99C7.45 8.99 7 9.44 7 9.99V12.58L5.71 11.29C5.32 10.9 4.69 10.9 4.3 11.29C3.91 11.68 3.91 12.31 4.3 12.7L7.3 15.7C7.5 15.9 7.75 15.99 8.01 15.99C8.27 15.99 8.52 15.89 8.72 15.7L11.72 12.7C12.11 12.31 12.11 11.68 11.72 11.29C11.33 10.9 10.7 10.9 10.31 11.29H10.29Z"></path></g><defs><clipPath id="clip0_21945_90234"><rect width="16" height="16" fill="white"></rect></clipPath></defs></svg>',
  "expandpanel-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M12 13H4C2.9 13 2 12.1 2 11V5C2 3.9 2.9 3 4 3H12C13.1 3 14 3.9 14 5V11C14 12.1 13.1 13 12 13ZM4 5V11H12V5H4Z"></path></svg>',
  "file-72x72": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M22 9V7C22 5.9 21.1 5 20 5H12L10 3H4C2.9 3 2 3.9 2 5V9V10V21H22L24 9H22ZM4 5H9.2L10.6 6.4L11.2 7H12H20V9H4V5ZM20.3 19H4V11H21.6L20.3 19Z"></path></svg>',
  "finishedit-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M2.3 3.70001L7.8 9.20001L4.6 12.4C2.9 14.1 2 16.4 2 18.8V21.1C2 21.7 2.4 22.1 3 22.1H5.3C7.7 22.1 10 21.2 11.7 19.5L14.9 16.3L20.4 21.8L21.8 20.4L3.8 2.40001L2.3 3.70001ZM10.2 17.9C8.9 19.2 7.1 20 5.3 20H4V18.7C4 16.8 4.7 15.1 6.1 13.8L9.3 10.6L13.5 14.8L10.2 17.9ZM21.9 9.10001L17.2 13.8L15.8 12.4L20.5 7.70001C20.9 7.30001 20.9 6.70001 20.5 6.30001L17.7 3.50001C17.5 3.20001 17.2 3.20001 17 3.20001C16.8 3.20001 16.5 3.20001 16.3 3.50001L11.6 8.20001L10.2 6.80001L14.9 2.10001C15.5 1.50001 16.2 1.20001 17 1.20001C17.8 1.20001 18.5 1.50001 19.1 2.10001L21.9 4.90001C23.1 6.00001 23.1 7.90001 21.9 9.10001Z"></path></svg>',
  "fix-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_19268_561903)"><path d="M8.71 11.2901L5.71 8.29006C5.32 7.90006 4.69 7.90006 4.3 8.29006C3.91 8.68006 3.91 9.31006 4.3 9.70006L5.59 10.9901H1C0.45 10.9901 0 11.4401 0 11.9901C0 12.5401 0.45 12.9901 1 12.9901H5.59L4.3 14.2801C3.91 14.6701 3.91 15.3001 4.3 15.6901C4.5 15.8901 4.75 15.9801 5.01 15.9801C5.27 15.9801 5.52 15.8801 5.72 15.6901L8.72 12.6901C8.81 12.6001 8.89 12.4901 8.94 12.3601C9.04 12.1201 9.04 11.8401 8.94 11.6001C8.89 11.4801 8.82 11.3701 8.72 11.2701L8.71 11.2901Z"></path><path d="M15.71 10.29C15.32 9.89999 14.69 9.89999 14.3 10.29C13.91 10.68 13.91 11.31 14.3 11.7L16.3 13.7C16.5 13.9 16.75 13.99 17.01 13.99C17.27 13.99 17.52 13.89 17.72 13.7L23.72 7.69999C24.11 7.30999 24.11 6.67999 23.72 6.28999C23.33 5.89999 22.7 5.89999 22.31 6.28999L21.05 7.54999C19.99 6.57999 18.57 5.98999 17.02 5.98999C13.71 5.98999 11.02 8.67999 11.02 11.99C11.02 15.3 13.71 17.99 17.02 17.99C20.33 17.99 23.02 15.3 23.02 11.99C23.02 11.5 22.96 11.03 22.85 10.58L20.98 12.45C20.75 14.44 19.07 15.99 17.03 15.99C14.82 15.99 13.03 14.2 13.03 11.99C13.03 9.77999 14.82 7.98999 17.03 7.98999C18.03 7.98999 18.93 8.36999 19.63 8.97999L17.03 11.58L15.74 10.29H15.71Z"></path></g><defs><clipPath id="clip0_19268_561903"><rect width="24" height="24" fill="white"></rect></clipPath></defs></svg>',
  "flip-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M23 12.0037C23 14.2445 21.7794 16.3052 19.5684 17.8257C19.3984 17.9458 19.1983 18.0058 19.0082 18.0058C18.688 18.0058 18.3779 17.8557 18.1778 17.5756C17.8677 17.1155 17.9777 16.4953 18.4379 16.1852C20.0887 15.0448 21.0091 13.5643 21.0091 12.0138C21.0091 8.70262 16.9673 6.01171 12.005 6.01171C11.4948 6.01171 10.9945 6.04172 10.5043 6.09173L11.7149 7.30215C12.105 7.69228 12.105 8.32249 11.7149 8.71263C11.5148 8.9127 11.2647 9.00273 11.0045 9.00273C10.7444 9.00273 10.4943 8.90269 10.2942 8.71263L6.58254 5.00136L10.2842 1.2901C10.6744 0.899964 11.3047 0.899964 11.6949 1.2901C12.085 1.68023 12.085 2.31045 11.6949 2.70058L10.3042 4.09105C10.8545 4.03103 11.4147 4.00102 11.985 4.00102C18.0578 4.00102 22.99 7.59225 22.99 12.0037H23ZM12.2851 15.2949C11.895 15.685 11.895 16.3152 12.2851 16.7054L13.4957 17.9158C13.0055 17.9758 12.4952 17.9958 11.995 17.9958C7.03274 17.9958 2.99091 15.3049 2.99091 11.9937C2.99091 10.4332 3.90132 8.95271 5.56207 7.82232C6.02228 7.51222 6.13233 6.89201 5.82219 6.43185C5.51205 5.97169 4.89177 5.86166 4.43156 6.17176C2.22055 7.69228 1 9.76299 1 11.9937C1 16.4052 5.93224 19.9965 12.005 19.9965C12.5753 19.9965 13.1355 19.9665 13.6858 19.9064L12.2951 21.2969C11.905 21.6871 11.905 22.3173 12.2951 22.7074C12.4952 22.9075 12.7453 22.9975 13.0055 22.9975C13.2656 22.9975 13.5157 22.8975 13.7158 22.7074L17.4275 18.9961L13.7158 15.2849C13.3256 14.8947 12.6953 14.8947 12.3051 15.2849L12.2851 15.2949Z"></path></svg>',
  "folder-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M21.93 9H21V7C21 6.46957 20.7893 5.96086 20.4142 5.58579C20.0391 5.21071 19.5304 5 19 5H10L8 3H4C3.46957 3 2.96086 3.21071 2.58579 3.58579C2.21071 3.96086 2 4.46957 2 5L2 21H21L23.89 11.63C23.9916 11.3244 24.0179 10.9988 23.9667 10.6809C23.9155 10.363 23.7882 10.0621 23.5958 9.80392C23.4034 9.54571 23.1514 9.33779 22.8614 9.19782C22.5714 9.05786 22.2519 8.99 21.93 9ZM4 5H7.17L8.59 6.41L9.17 7H19V9H6L4 15V5ZM22 11L19.54 19H4.77L7.44 11H22Z"></path></svg>',
  "fullsize-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M12 13H4C2.9 13 2 12.1 2 11V5C2 3.9 2.9 3 4 3H12C13.1 3 14 3.9 14 5V11C14 12.1 13.1 13 12 13ZM4 5V11H12V5H4Z"></path></svg>',
  "gear-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12.5 3C12.78 3 13 3.22 13 3.5V5.08C14.18 5.25 15.27 5.71 16.19 6.4L17.31 5.28C17.41 5.18 17.54 5.13 17.66 5.13C17.78 5.13 17.92 5.18 18.01 5.28L18.72 5.99C18.92 6.19 18.92 6.5 18.72 6.7L17.6 7.82C18.29 8.74 18.75 9.82 18.92 11.01H20.5C20.78 11.01 21 11.23 21 11.51V12.51C21 12.79 20.78 13.01 20.5 13.01H18.92C18.75 14.19 18.29 15.28 17.6 16.2L18.72 17.32C18.92 17.52 18.92 17.83 18.72 18.03L18.01 18.74C17.91 18.84 17.78 18.89 17.66 18.89C17.54 18.89 17.4 18.84 17.31 18.74L16.19 17.62C15.27 18.31 14.19 18.77 13 18.94V20.52C13 20.8 12.78 21.02 12.5 21.02H11.5C11.22 21.02 11 20.8 11 20.52V18.94C9.82 18.77 8.73 18.31 7.81 17.62L6.69 18.74C6.59 18.84 6.46 18.89 6.34 18.89C6.22 18.89 6.08 18.84 5.99 18.74L5.28 18.03C5.08 17.83 5.08 17.52 5.28 17.32L6.4 16.2C5.71 15.28 5.25 14.2 5.08 13.01H3.5C3.22 13.01 3 12.79 3 12.51V11.51C3 11.23 3.22 11.01 3.5 11.01H5.08C5.25 9.83 5.71 8.74 6.4 7.82L5.28 6.7C5.08 6.5 5.08 6.19 5.28 5.99L5.99 5.28C6.09 5.18 6.22 5.13 6.34 5.13C6.46 5.13 6.6 5.18 6.69 5.28L7.81 6.4C8.73 5.71 9.81 5.25 11 5.08V3.5C11 3.22 11.22 3 11.5 3H12.5ZM12 16C14.21 16 16 14.21 16 12C16 9.79 14.21 8 12 8C9.79 8 8 9.79 8 12C8 14.21 9.79 16 12 16ZM12.5 1H11.5C10.12 1 9 2.12 9 3.5V3.52C8.7 3.63 8.41 3.75 8.13 3.88L8.11 3.86C7.64 3.39 7.01 3.13 6.34 3.13C5.67 3.13 5.04 3.39 4.57 3.86L3.86 4.57C2.89 5.55 2.89 7.13 3.86 8.11L3.88 8.13C3.74 8.41 3.62 8.71 3.52 9H3.5C2.12 9 1 10.12 1 11.5V12.5C1 13.88 2.12 15 3.5 15H3.52C3.63 15.3 3.75 15.59 3.88 15.87L3.86 15.89C2.89 16.87 2.89 18.45 3.86 19.43L4.57 20.14C5.04 20.61 5.67 20.87 6.34 20.87C7.01 20.87 7.64 20.61 8.11 20.14L8.13 20.12C8.41 20.26 8.71 20.38 9 20.48V20.5C9 21.88 10.12 23 11.5 23H12.5C13.88 23 15 21.88 15 20.5V20.48C15.3 20.37 15.59 20.25 15.87 20.12L15.89 20.14C16.36 20.61 16.99 20.87 17.66 20.87C18.33 20.87 18.96 20.61 19.43 20.14L20.14 19.43C21.11 18.46 21.11 16.87 20.14 15.89L20.12 15.87C20.26 15.59 20.38 15.29 20.48 15H20.5C21.88 15 23 13.88 23 12.5V11.5C23 10.12 21.88 9 20.5 9H20.48C20.37 8.7 20.25 8.41 20.12 8.13L20.14 8.11C21.11 7.14 21.11 5.55 20.14 4.57L19.43 3.86C18.96 3.39 18.33 3.13 17.66 3.13C16.99 3.13 16.36 3.39 15.89 3.86L15.87 3.88C15.59 3.74 15.29 3.62 15 3.52V3.5C15 2.12 13.88 1 12.5 1ZM12 14C10.9 14 10 13.1 10 12C10 10.9 10.9 10 12 10C13.1 10 14 10.9 14 12C14 13.1 13.1 14 12 14Z"></path></svg>',
  "help-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M17.88 3.25C15.62 3.25 13.31 3.64 12 4.24C10.7 3.65 8.38 3.25 6.12 3.25C3 3.25 0 4 0 6V22.76C0 20.76 3 20.01 6.12 20.01C7.88 20.01 9.67 20.25 11 20.63C11.38 20.74 11.71 20.86 12 20.99C12.29 20.86 12.62 20.74 13 20.63C14.32 20.25 16.12 20.01 17.88 20.01C21 20.01 24 20.76 24 22.76V6C24 4 21 3.25 17.88 3.25ZM11 18.56C8.97 18.06 6.79 18.02 6.12 18.02C4.54 18.02 3.15 18.19 2 18.52V6.07C2.29 5.79 3.61 5.25 6.12 5.25C8.32 5.25 10.15 5.64 11 5.97V18.56ZM22 18.52C20.84 18.19 19.46 18.02 17.88 18.02C17.21 18.02 15.04 18.06 13 18.56V5.97C13.85 5.64 15.67 5.25 17.88 5.25C20.4 5.25 21.72 5.79 22 6.07V18.51V18.52ZM3.87 7.94C5.48 7.73 7.35 7.76 9.14 8.01C9.69 8.09 10.07 8.59 9.99 9.14C9.92 9.64 9.49 10 9 10C8.95 10 8.91 10 8.86 10C7.27 9.77 5.54 9.75 4.13 9.93C3.58 10 3.08 9.62 3.01 9.07C2.94 8.52 3.32 8.02 3.87 7.95V7.94ZM9.99 13.14C9.92 13.64 9.49 14 9 14C8.95 14 8.91 14 8.86 14C7.27 13.77 5.55 13.75 4.13 13.93C3.58 14 3.08 13.61 3.01 13.07C2.94 12.52 3.32 12.02 3.87 11.95C5.48 11.74 7.35 11.77 9.14 12.02C9.69 12.1 10.07 12.61 9.99 13.15V13.14ZM20.13 7.94C20.68 8.01 21.06 8.51 20.99 9.06C20.92 9.61 20.42 10 19.87 9.92C18.46 9.74 16.74 9.76 15.14 9.99C15.09 9.99 15.04 9.99 15 9.99C14.51 9.99 14.08 9.63 14.01 9.13C13.93 8.58 14.31 8.08 14.86 8C16.65 7.75 18.53 7.72 20.13 7.93V7.94ZM20.99 13.06C20.92 13.61 20.42 13.99 19.87 13.92C18.45 13.74 16.73 13.76 15.14 13.99C15.09 13.99 15.04 13.99 15 13.99C14.51 13.99 14.08 13.63 14.01 13.13C13.93 12.58 14.31 12.08 14.86 12C16.65 11.74 18.52 11.72 20.13 11.93C20.68 12 21.06 12.5 20.99 13.05V13.06Z"></path></svg>',
  "hidehint-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_21403_120504)"><path d="M1.53333 2.46669L2.4 3.33335C1.33333 4.60002 0.666664 6.20002 0.666664 8.00002C0.666664 12.0667 3.93333 15.3334 8 15.3334C9.8 15.3334 11.4 14.6667 12.6667 13.6L13.5333 14.4667L14.4667 13.5334L2.46666 1.53335L1.53333 2.46669ZM8 14C4.66666 14 2 11.3334 2 8.00002C2 6.60002 2.46666 5.26669 3.33333 4.26669L7.2 8.13335C7.13333 8.20002 7.06666 8.26669 7.06666 8.33335C7 8.46669 6.93333 8.66669 6.93333 8.86669C6.93333 9.06669 7 9.26669 7.06666 9.40002C7.13333 9.53335 7.2 9.66669 7.26666 9.86669C7.33333 10 7.46666 10.0667 7.6 10.0667C7.66666 10.0667 7.66666 10.0667 7.73333 10.0667H7.8C7.86666 10.0667 7.93333 10.0667 8.06666 10C8.26666 9.93335 8.4 9.80002 8.4 9.66669V9.60002V9.40002L11.6667 12.6667C10.7333 13.5334 9.4 14 8 14ZM5.2 2.73335L4.2 1.73335C5.33333 1.06669 6.6 0.666687 8 0.666687C12.0667 0.666687 15.3333 3.93335 15.3333 8.00002C15.3333 9.40002 14.9333 10.6667 14.2667 11.8L13.2667 10.8C13.7333 10 14 9.00002 14 8.00002C14 4.66669 11.3333 2.00002 8 2.00002C7 2.00002 6 2.26669 5.2 2.73335ZM9 6.53335C9 6.46669 9.06666 6.40002 9.06666 6.26669C9.06666 6.00002 9 5.73335 8.8 5.60002C8.53333 5.33335 8.26666 5.26669 8 5.26669C7.93333 5.26669 7.86666 5.26669 7.73333 5.26669L6.73333 4.26669C6.8 4.26669 6.8 4.20002 6.86666 4.20002C7.66666 3.93335 8.46666 3.93335 9.06666 4.06669C9.4 4.13335 9.66666 4.26669 9.93333 4.40002C10.4 4.86669 10.6667 5.40002 10.6667 6.20002C10.6667 6.73335 10.4667 7.20002 10.1333 7.60002L9 6.53335ZM7.86666 10.6C8.33333 10.6 8.66666 10.8 8.86666 11.2C8.93333 11.3334 8.93333 11.4667 8.93333 11.6C8.93333 11.8667 8.8 12.1334 8.66666 12.3334C8.46666 12.5334 8.2 12.6 7.93333 12.6C7.66666 12.6 7.4 12.4667 7.2 12.3334C7 12.1334 6.93333 11.8667 6.93333 11.6C6.93333 11.3334 7.06666 11.0667 7.2 10.8667C7.33333 10.6667 7.6 10.6 7.86666 10.6Z"></path></g><defs><clipPath id="clip0_21403_120504"><rect width="16" height="16" fill="white"></rect></clipPath></defs></svg>',
  "hidehint-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M2.3 3.7L3.6 5C2 6.9 1 9.3 1 12C1 18.1 5.9 23 12 23C14.7 23 17.1 22 19 20.4L20.3 21.7L21.7 20.3L3.7 2.3L2.3 3.7ZM12 21C7 21 3 17 3 12C3 9.9 3.7 7.9 5 6.4L10.8 12.2C10.7 12.3 10.6 12.4 10.6 12.5C10.5 12.7 10.4 13 10.4 13.3C10.4 13.6 10.5 13.9 10.6 14.1C10.7 14.3 10.8 14.5 10.9 14.8C11 15 11.2 15.1 11.4 15.1C11.5 15.1 11.5 15.1 11.6 15.1H11.7C11.8 15.1 11.9 15.1 12.1 15C12.4 14.9 12.6 14.7 12.6 14.5V14.4V14.1L17.5 19C16.1 20.3 14.1 21 12 21ZM7.8 4.1L6.3 2.6C8 1.6 9.9 1 12 1C18.1 1 23 5.9 23 12C23 14.1 22.4 16 21.4 17.7L19.9 16.2C20.6 15 21 13.5 21 12C21 7 17 3 12 3C10.5 3 9 3.4 7.8 4.1ZM13.5 9.8C13.5 9.7 13.6 9.6 13.6 9.4C13.6 9 13.5 8.6 13.2 8.4C12.8 8 12.4 7.9 12 7.9C11.9 7.9 11.8 7.9 11.6 7.9L10.1 6.4C10.2 6.4 10.2 6.3 10.3 6.3C11.5 5.9 12.7 5.9 13.6 6.1C14.1 6.2 14.5 6.4 14.9 6.6C15.6 7.3 16 8.1 16 9.3C16 10.1 15.7 10.8 15.2 11.4L13.5 9.8ZM11.8 15.9C12.5 15.9 13 16.2 13.3 16.8C13.4 17 13.4 17.2 13.4 17.4C13.4 17.8 13.2 18.2 13 18.5C12.7 18.8 12.3 18.9 11.9 18.9C11.5 18.9 11.1 18.7 10.8 18.5C10.5 18.2 10.4 17.8 10.4 17.4C10.4 17 10.6 16.6 10.8 16.3C11 16 11.4 15.9 11.8 15.9Z"></path></svg>',
  "hint-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_21248_353340)"><path d="M8.00002 0.666687C3.93335 0.666687 0.666687 3.93335 0.666687 8.00002C0.666687 12.0667 3.93335 15.3334 8.00002 15.3334C12.0667 15.3334 15.3334 12.0667 15.3334 8.00002C15.3334 3.93335 12.0667 0.666687 8.00002 0.666687ZM8.00002 14C4.66669 14 2.00002 11.3334 2.00002 8.00002C2.00002 4.66669 4.66669 2.00002 8.00002 2.00002C11.3334 2.00002 14 4.66669 14 8.00002C14 11.3334 11.3334 14 8.00002 14ZM8.86669 11.2C8.93335 11.3334 8.93335 11.4667 8.93335 11.6C8.93335 11.8667 8.80002 12.1334 8.66669 12.3334C8.46669 12.5334 8.20002 12.6 7.93335 12.6C7.66669 12.6 7.40002 12.4667 7.20002 12.3334C7.00002 12.1334 6.93335 11.8667 6.93335 11.6C6.93335 11.3334 7.06669 11.0667 7.20002 10.8667C7.40002 10.6667 7.66669 10.5334 7.93335 10.5334C8.33335 10.6 8.66669 10.8 8.86669 11.2ZM10.6667 6.20002C10.6667 6.93335 10.3334 7.46669 9.73335 7.93335C9.60002 8.06669 9.40002 8.13335 9.26669 8.26669L8.86669 8.53335C8.66669 8.66669 8.60002 8.73335 8.60002 8.73335C8.53335 8.80002 8.53335 8.86669 8.53335 8.93335C8.53335 9.06669 8.46669 9.20002 8.46669 9.40002V9.60002V9.66669C8.40002 9.80002 8.26669 9.93335 8.13335 10C8.00002 10.0667 7.93335 10.0667 7.86669 10.0667H7.80002C7.73335 10.0667 7.73335 10.0667 7.66669 10.0667C7.53335 10 7.40002 9.93335 7.33335 9.86669C7.26669 9.73335 7.13335 9.60002 7.13335 9.40002C7.06669 9.20002 7.00002 9.06669 7.00002 8.86669C7.00002 8.66669 7.06669 8.46669 7.13335 8.33335C7.20002 8.20002 7.33335 8.06669 7.46669 7.93335C7.60002 7.80002 7.73335 7.73335 7.86669 7.66669L8.26669 7.46669C8.66669 7.26669 8.80002 7.13335 8.86669 7.06669C9.06669 6.86669 9.13335 6.60002 9.13335 6.33335C9.13335 6.06669 9.06669 5.80002 8.86669 5.66669C8.53335 5.33335 8.26669 5.26669 8.00002 5.26669C7.26669 5.26669 7.06669 5.60002 7.06669 5.86669C6.93335 6.20002 6.93335 6.26669 6.93335 6.26669V6.40002C6.93335 6.46669 6.93335 6.46669 6.93335 6.53335L7.00002 6.80002L6.80002 6.86669C6.40002 7.06669 6.06669 7.06669 5.80002 6.93335C5.73335 6.86669 5.60002 6.73335 5.53335 6.66669C5.40002 6.46669 5.33335 6.26669 5.33335 6.00002C5.33335 5.73335 5.40002 5.53335 5.46669 5.33335C5.53335 5.13335 5.66669 5.00002 5.80002 4.86669C5.93335 4.73335 6.06669 4.60002 6.26669 4.46669C6.46669 4.40002 6.66669 4.26669 6.86669 4.20002C7.66669 3.93335 8.46669 3.93335 9.06669 4.06669C9.40002 4.13335 9.66669 4.26669 9.93335 4.40002C10.4 4.86669 10.6667 5.40002 10.6667 6.20002Z"></path></g><defs><clipPath id="clip0_21248_353340"><rect width="16" height="16" fill="white"></rect></clipPath></defs></svg>',
  "hint-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 1C5.9 1 1 5.9 1 12C1 18.1 5.9 23 12 23C18.1 23 23 18.1 23 12C23 5.9 18.1 1 12 1ZM12 21C7 21 3 17 3 12C3 7 7 3 12 3C17 3 21 7 21 12C21 17 17 21 12 21ZM13.3 16.8C13.4 17 13.4 17.2 13.4 17.4C13.4 17.8 13.2 18.2 13 18.5C12.7 18.8 12.3 18.9 11.9 18.9C11.5 18.9 11.1 18.7 10.8 18.5C10.5 18.2 10.4 17.8 10.4 17.4C10.4 17 10.6 16.6 10.8 16.3C11.1 16 11.5 15.8 11.9 15.8C12.5 15.9 13 16.2 13.3 16.8ZM16 9.3C16 10.4 15.5 11.2 14.6 11.9C14.4 12.1 14.1 12.2 13.9 12.4L13.3 12.8C13 13 12.9 13.1 12.9 13.1C12.8 13.2 12.8 13.3 12.8 13.4C12.8 13.6 12.7 13.8 12.7 14.1V14.4V14.5C12.6 14.7 12.4 14.9 12.2 15C12 15.1 11.9 15.1 11.8 15.1H11.7C11.6 15.1 11.6 15.1 11.5 15.1C11.3 15 11.1 14.9 11 14.8C10.9 14.6 10.7 14.4 10.7 14.1C10.6 13.8 10.5 13.6 10.5 13.3C10.5 13 10.6 12.7 10.7 12.5C10.8 12.3 11 12.1 11.2 11.9C11.4 11.7 11.6 11.6 11.8 11.5L12.4 11.2C13 10.9 13.2 10.7 13.3 10.6C13.6 10.3 13.7 9.9 13.7 9.5C13.7 9.1 13.6 8.7 13.3 8.5C12.8 8 12.4 7.9 12 7.9C10.9 7.9 10.6 8.4 10.6 8.8C10.4 9.3 10.4 9.4 10.4 9.4V9.6C10.4 9.7 10.4 9.7 10.4 9.8L10.5 10.2L10.2 10.3C9.6 10.6 9.1 10.6 8.7 10.4C8.6 10.3 8.4 10.1 8.3 10C8.1 9.7 8 9.4 8 9C8 8.6 8.1 8.3 8.2 8C8.3 7.7 8.5 7.5 8.7 7.3C8.9 7.1 9.1 6.9 9.4 6.7C9.7 6.6 10 6.4 10.3 6.3C11.5 5.9 12.7 5.9 13.6 6.1C14.1 6.2 14.5 6.4 14.9 6.6C15.6 7.3 16 8.1 16 9.3Z"></path></svg>',
  "image-48x48": '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><path d="M36 8H12C9.79 8 8 9.79 8 12V36C8 38.21 9.79 40 12 40H36C38.21 40 40 38.21 40 36V12C40 9.79 38.21 8 36 8ZM38 36C38 37.1 37.1 38 36 38H12C10.9 38 10 37.1 10 36V12C10 10.9 10.9 10 12 10H36C37.1 10 38 10.9 38 12V36ZM14 17C14 15.34 15.34 14 17 14C18.66 14 20 15.34 20 17C20 18.66 18.66 20 17 20C15.34 20 14 18.66 14 17ZM27 24L36 36H12L19 27L23 29L27 24Z"></path></svg>',
  "import-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M21.93 9H21V7C21 6.46957 20.7893 5.96086 20.4142 5.58579C20.0391 5.21071 19.5304 5 19 5H10L8 3H4C3.46957 3 2.96086 3.21071 2.58579 3.58579C2.21071 3.96086 2 4.46957 2 5L2 21H21L23.89 11.63C23.9916 11.3244 24.0179 10.9988 23.9667 10.6809C23.9155 10.363 23.7882 10.0621 23.5958 9.80392C23.4034 9.54571 23.1514 9.33779 22.8614 9.19782C22.5714 9.05786 22.2519 8.99 21.93 9ZM4 5H7.17L8.59 6.41L9.17 7H19V9H6L4 15V5ZM22 11L19.54 19H4.77L7.44 11H22Z"></path></svg>',
  "invisible-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 7.003C12.4641 7.01107 12.9249 7.08171 13.37 7.213L11.54 9.053C10.9155 9.15262 10.3384 9.44704 9.89125 9.89423C9.44406 10.3414 9.14964 10.9185 9.05002 11.543L7.21002 13.373C7.07873 12.9279 7.00809 12.467 7.00002 12.003C7.00002 10.6769 7.5268 9.40515 8.46449 8.46747C9.40217 7.52978 10.6739 7.003 12 7.003ZM5.40002 15.183C4.39516 14.2466 3.52369 13.1766 2.81002 12.003C5.10002 8.223 8.47002 6.003 12 6.003C12.765 6.0082 13.5255 6.11925 14.26 6.333L15.86 4.733C14.6291 4.25486 13.3206 4.0074 12 4.003C7.24002 4.003 3.05002 7.173 0.52002 12.003C1.41557 13.7255 2.59165 15.2868 4.00002 16.623L5.40002 15.183ZM23.48 12.003C21 16.833 16.76 20.003 12 20.003C10.1707 19.9916 8.37315 19.5242 6.77002 18.643L2.71002 22.713L1.29002 21.293L21.29 1.293L22.71 2.713L18.94 6.473C20.8367 7.96509 22.3858 9.8521 23.48 12.003ZM14.7 10.723L10.7 14.723C11.1058 14.9158 11.5508 15.0116 12 15.003C12.7957 15.003 13.5587 14.6869 14.1213 14.1243C14.6839 13.5617 15 12.7986 15 12.003C14.9993 11.559 14.8967 11.1211 14.7 10.723ZM21.19 12.003C20.243 10.4087 18.9887 9.01851 17.5 7.913L16.16 9.263C16.7052 10.073 16.9975 11.0266 17 12.003C17 13.3291 16.4732 14.6009 15.5356 15.5385C14.5979 16.4762 13.3261 17.003 12 17.003C11.0237 17.0005 10.07 16.7081 9.26002 16.163L8.26002 17.163C9.43056 17.7122 10.707 17.9989 12 18.003C15.53 18.003 18.9 15.783 21.19 12.003Z"></path></svg>',
  "language-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M17.75 8H15.25L13.35 13.08C12.2029 12.2588 11.2439 11.2027 10.537 9.98187C9.83 8.76107 9.39127 7.40364 9.25 6H14V4H9V2H7V4H2V6H6.91C6.73189 7.75797 6.09115 9.43736 5.05302 10.8672C4.01489 12.2971 2.61643 13.4263 1 14.14C1.32315 14.7296 1.69441 15.2915 2.11 15.82C4.82764 14.5445 6.96846 12.2966 8.11 9.52C9.02641 11.7596 10.5985 13.6698 12.62 15L10 22H12.42L13.79 18.13H19.16L20.56 22H23L17.75 8ZM14.46 16.16L15.73 12.53C16.0406 11.7049 16.2945 10.8596 16.49 10C16.55 10.26 16.67 10.66 16.84 11.21C17.01 11.76 17.14 12.15 17.24 12.41L18.55 16.2L14.46 16.16Z"></path></svg>',
  "loading-48x48": '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_19679_369428)"><path opacity="0.25" d="M24 40C15.18 40 8 32.82 8 24C8 15.18 15.18 8 24 8C32.82 8 40 15.18 40 24C40 32.82 32.82 40 24 40ZM24 12C17.38 12 12 17.38 12 24C12 30.62 17.38 36 24 36C30.62 36 36 30.62 36 24C36 17.38 30.62 12 24 12Z"></path><path d="M10 26C8.9 26 8 25.1 8 24C8 15.18 15.18 8 24 8C25.1 8 26 8.9 26 10C26 11.1 25.1 12 24 12C17.38 12 12 17.38 12 24C12 25.1 11.1 26 10 26Z"></path></g><defs><clipPath id="clip0_19679_369428"><rect width="32" height="32" fill="white" transform="translate(8 8)"></rect></clipPath></defs></svg>',
  "logic-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M18 14.59L16.59 16L18.59 18H7.82C7.79 17.9 7.75 17.81 7.7 17.71L17.71 7.7C18.1 7.89 18.53 8 19 8C20.65 8 22 6.65 22 5C22 3.35 20.65 2 19 2C17.7 2 16.6 2.84 16.18 4H7.82C7.41 2.84 6.31 2 5 2C3.35 2 2 3.35 2 5C2 6.65 3.35 8 5 8C6.3 8 7.4 7.16 7.82 6H16.19C16.22 6.1 16.26 6.19 16.31 6.29L6.29 16.3C5.9 16.11 5.47 16 5 16C3.35 16 2 17.35 2 19C2 20.65 3.35 22 5 22C6.3 22 7.4 21.16 7.82 20H18.59L16.59 22L18 23.41L22.41 19L18 14.59ZM19 4C19.55 4 20 4.45 20 5C20 5.55 19.55 6 19 6C18.45 6 18 5.55 18 5C18 4.45 18.45 4 19 4ZM5 6C4.45 6 4 5.55 4 5C4 4.45 4.45 4 5 4C5.55 4 6 4.45 6 5C6 5.55 5.55 6 5 6ZM5 20C4.45 20 4 19.55 4 19C4 18.45 4.45 18 5 18C5.55 18 6 18.45 6 19C6 19.55 5.55 20 5 20Z"></path></svg>',
  "logo-angular-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_17790_388137)"><path fill-rule="evenodd" clip-rule="evenodd" d="M12.17 0L1 3.98L2.71 18.75L12.16 24L21.77 18.68L23.62 3.91L12.17 0ZM16.97 18.27L15.45 14.74H9.23L7.83 18.24L5.23 18.29L12.19 2.81L19.45 18.33L16.97 18.28V18.27ZM10.15 12.69L12.21 7.77L14.56 12.69H10.14H10.15Z" fill="#E23237"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M12.1899 12.69H12.1699V7.85L12.1999 7.77L14.5499 12.69H12.1799H12.1899ZM12.1699 0V2.84L12.1899 2.8L19.4499 18.32L16.9699 18.27L15.4499 14.74H12.1799V24L21.7899 18.68L23.6399 3.91L12.1699 0Z" fill="#B52E31"></path></g><defs><clipPath id="clip0_17790_388137"><rect width="22.63" height="24" fill="white" transform="translate(1)"></rect></clipPath></defs></svg>',
  "logo-jquery-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M23.42 17.5751C23.42 17.5751 20.43 25.5875 10.16 23.7169C7.55997 23.0467 5.16997 21.5963 3.35997 19.6157C3.00997 19.2356 2.67997 18.8354 2.37997 18.4153C-0.130033 14.9643 -1.02003 10.0228 1.51997 6.39164L3.17997 4.30101C0.199966 10.1128 4.07997 17.1649 9.63997 19.7657C14.13 22.0064 20.41 21.5263 23.41 17.5751H23.42ZM8.53997 12.4435C9.86997 14.3741 11.96 15.7845 14.23 16.3747C22.16 17.6851 24 11.6032 24 11.6032C18.31 19.1855 4.80997 10.6529 9.36997 2.07033L8.11997 3.83086C6.30997 6.41165 6.75997 9.96273 8.53997 12.4335V12.4435ZM16.9 9.72266C17.08 9.79268 17.27 9.8527 17.46 9.90272C21.84 10.743 23.03 7.66203 23.35 7.21189C21.99 9.39256 18.24 9.07246 16.2 7.47197C14.28 6.02153 13.09 3.26069 14.34 1C11.47 4.08094 13.21 8.36225 16.9 9.72266Z" fill="#0D61A8"></path></svg>',
  "logo-knockout-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_17790_388139)"><path d="M23.6098 20.0301C23.2398 19.8203 22.8498 19.6805 22.4198 19.6605C20.8398 19.6605 19.6398 19.6605 18.2098 19.6605C16.7898 19.7104 16.6398 18.1121 16.2198 17.0832C15.4698 15.1152 14.8298 13.0973 14.0598 11.1394C15.9698 9.15147 17.8298 7.1136 19.7298 5.12568C20.8498 4.09676 22.2798 2.13881 20.2898 1.17981C18.0898 0.880128 16.8298 3.6772 15.3098 4.90591C13.9298 6.46428 12.4398 7.92276 11.0798 9.48112C13.8898 4.27657 10.8798 -0.208732 5.07985 1.2897C1.39985 2.44849 -1.16015 6.95377 0.529846 10.6399C1.33985 12.2482 3.08985 13.447 4.89985 12.8776C5.75985 12.508 6.36985 11.4291 5.83985 10.55C5.51985 10.1704 5.06985 9.99059 4.61985 9.82077C3.57985 9.38123 3.20985 8.19247 3.47985 7.15356C3.83985 5.06575 7.02985 3.04786 8.43985 5.27553C8.75985 6.34441 8.15985 7.45325 7.80985 8.4522C6.89985 10.7798 5.96985 13.0874 5.04985 15.4049C4.68985 16.5138 3.93985 17.5627 4.09985 18.7714C4.89985 20.4397 6.86985 19.7803 7.55985 18.3518C8.52985 15.9344 9.58985 13.5269 10.4198 11.0795C11.7798 14.5558 12.8498 18.162 14.3298 21.5885C14.8598 22.6074 15.8598 22.957 16.9398 22.997C19.0098 22.997 20.3698 22.997 21.9098 22.997C22.2798 22.997 22.6298 22.8272 22.9898 22.7173C23.9298 22.2378 24.3698 20.8692 23.5998 20.0501L23.6098 20.0301Z" fill="#E42E16"></path></g><defs><clipPath id="clip0_17790_388139"><rect width="24" height="24" fill="white"></rect></clipPath></defs></svg>',
  "logo-react-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M14.1459 11.9624C14.1459 13.1424 13.1855 14.1024 12.005 14.1024C10.8245 14.1024 9.86411 13.1424 9.86411 11.9624C9.86411 10.7824 10.8245 9.8224 12.005 9.8224C13.1855 9.8224 14.1459 10.7824 14.1459 11.9624ZM24 11.9624C24 13.4324 22.2593 14.9224 19.4581 15.8524C19.308 15.9024 19.168 15.9424 19.0079 15.9924C19.0679 16.2124 19.108 16.4224 19.158 16.6324C19.4181 17.9524 19.4581 19.1824 19.278 20.1824C19.0779 21.2424 18.6378 22.0024 17.9975 22.3724C17.6774 22.5624 17.2972 22.6524 16.877 22.6524C15.7165 22.6524 14.2359 21.9524 12.7053 20.6324C12.4852 20.4424 12.2751 20.2524 12.055 20.0424C11.885 20.2024 11.7249 20.3624 11.5548 20.5024C10.5344 21.3924 9.49396 22.0424 8.53356 22.3824C8.03335 22.5624 7.56315 22.6524 7.14298 22.6524C6.7228 22.6524 6.32263 22.5624 6.0025 22.3724C4.77199 21.6624 4.35181 19.6224 4.86203 16.9124C4.91205 16.6324 4.98208 16.3524 5.0521 16.0624C4.82201 16.0024 4.61192 15.9324 4.40183 15.8524C3.1213 15.4124 2.04085 14.8324 1.26053 14.1724C0.440183 13.4724 0 12.7024 0 11.9724C0 10.5524 1.56065 9.1624 4.17174 8.2624C4.46186 8.1624 4.76198 8.0724 5.06211 7.9824C4.99208 7.7124 4.93205 7.4524 4.88203 7.1924C4.63193 5.9024 4.58191 4.7224 4.74198 3.7624C4.92205 2.7224 5.34223 1.9824 5.97249 1.6224C7.24302 0.882403 9.41392 1.6424 11.6148 3.6024C11.7449 3.7224 11.8749 3.8424 12.015 3.9724C12.2151 3.7824 12.4152 3.5924 12.6153 3.4224C13.6057 2.5624 14.6161 1.9224 15.5165 1.5924C16.5069 1.2324 17.3572 1.2324 17.9775 1.5924C19.258 2.3224 19.6782 4.5824 19.0779 7.4724C19.0479 7.6524 18.9979 7.8224 18.9579 8.0024C19.218 8.0824 19.4781 8.1624 19.7282 8.2424C20.9687 8.6724 22.0192 9.2224 22.7595 9.8424C23.5698 10.5124 23.99 11.2524 23.99 11.9824L24 11.9624ZM13.2855 4.1924C13.1055 4.3524 12.9154 4.5224 12.7353 4.6924C13.4156 5.4224 14.0959 6.2824 14.7561 7.2224C15.8866 7.3324 16.9671 7.5024 17.9675 7.7324C18.0075 7.5724 18.0475 7.4124 18.0775 7.2624C18.6378 4.5424 18.1576 2.8724 17.4673 2.4824C17.1171 2.2824 16.5469 2.3024 15.8666 2.5624C15.0763 2.8524 14.1859 3.4224 13.2855 4.2024V4.1924ZM16.3868 11.9824C16.0767 11.3524 15.7266 10.7124 15.3464 10.0524C14.9762 9.4024 14.5861 8.7924 14.1859 8.2024C13.4756 8.1424 12.7453 8.1224 11.995 8.1224C11.2447 8.1224 10.5244 8.1524 9.81409 8.2024C9.40392 8.7924 9.02376 9.4124 8.6436 10.0624C8.27345 10.7024 7.93331 11.3524 7.62318 11.9924C7.93331 12.6424 8.27345 13.2824 8.65361 13.9324C9.03376 14.5824 9.41392 15.1924 9.82409 15.7924C10.5244 15.8324 11.2447 15.8624 11.995 15.8624C12.7453 15.8624 13.4856 15.8324 14.1959 15.7824C14.5861 15.2024 14.9662 14.5824 15.3464 13.9324C15.7165 13.2824 16.0667 12.6324 16.3768 11.9924L16.3868 11.9824ZM16.2368 14.4324C15.9967 14.8524 15.7466 15.2624 15.5065 15.6524C16.2968 15.5624 17.0471 15.4324 17.7474 15.2724C17.5373 14.6024 17.2672 13.8924 16.9371 13.1624C16.717 13.5824 16.4869 14.0124 16.2368 14.4324ZM13.4456 16.8424C12.9654 16.8624 12.4852 16.8724 11.995 16.8724C11.5048 16.8724 11.0546 16.8724 10.5944 16.8424C11.0646 17.4624 11.5548 18.0424 12.035 18.5724C12.5052 18.0524 12.9754 17.4724 13.4456 16.8324V16.8424ZM7.75323 14.4324C7.51313 14.0224 7.28303 13.6124 7.07295 13.1924C6.77282 13.9124 6.51271 14.6224 6.29262 15.3124C6.97291 15.4624 7.71321 15.5824 8.50354 15.6624C8.24343 15.2624 7.99333 14.8424 7.75323 14.4324ZM8.48353 8.3324C7.72322 8.4224 6.99291 8.5524 6.30263 8.7024C6.51271 9.3724 6.77282 10.0724 7.06294 10.7824C7.27303 10.3724 7.50313 9.9524 7.74323 9.5424C7.98333 9.1324 8.22343 8.7224 8.47353 8.3324H8.48353ZM10.5744 7.1224C11.0346 7.1024 11.5048 7.0924 11.985 7.0924C12.4652 7.0924 12.9454 7.1024 13.4156 7.1224C12.9454 6.5024 12.4752 5.9324 12.005 5.4224C11.5248 5.9424 11.0446 6.5124 10.5844 7.1224H10.5744ZM16.917 10.7924C17.2172 10.0824 17.4773 9.3824 17.6874 8.7224C16.9971 8.5624 16.2568 8.4324 15.4965 8.3424C15.7466 8.7324 15.9867 9.1324 16.2268 9.5424C16.4669 9.9624 16.697 10.3824 16.917 10.8024V10.7924ZM6.03251 7.7224C7.03293 7.4924 8.11338 7.3324 9.24385 7.2224C9.89412 6.2924 10.5844 5.4424 11.2847 4.7024C11.1647 4.5824 11.0446 4.4724 10.9246 4.3724C8.84369 2.5224 7.16298 2.1124 6.4727 2.5124C6.12255 2.7124 5.86244 3.2224 5.74239 3.9424C5.60233 4.7724 5.64235 5.8324 5.87245 6.9924C5.92247 7.2324 5.97249 7.4824 6.04252 7.7324L6.03251 7.7224ZM5.30221 15.0624C5.60233 14.0724 6.0025 13.0424 6.4827 11.9924C6.01251 10.9624 5.61234 9.9424 5.31221 8.9624C5.02209 9.0424 4.75198 9.1324 4.49187 9.2224C2.09087 10.0624 1.01042 11.2024 1.01042 11.9724C1.01042 12.7424 2.1709 14.0224 4.71196 14.8824C4.90204 14.9424 5.10213 15.0124 5.30221 15.0624ZM10.8545 19.7424C11.0046 19.6124 11.1546 19.4724 11.3147 19.3224C10.6144 18.5624 9.91413 17.7124 9.25386 16.7724C8.08337 16.6824 6.99291 16.5224 6.02251 16.3024C5.95248 16.5724 5.90246 16.8424 5.84243 17.0924C5.37224 19.5924 5.82243 21.0924 6.4827 21.4724C6.64277 21.5624 6.86286 21.6224 7.12297 21.6224C7.97332 21.6224 9.31388 21.0824 10.8545 19.7324V19.7424ZM18.0175 16.2524C17.0271 16.4824 15.9366 16.6524 14.7662 16.7524C14.1059 17.7124 13.4256 18.5724 12.7553 19.3024C12.9554 19.5024 13.1655 19.6824 13.3656 19.8524C15.2964 21.5124 16.827 21.8724 17.4873 21.4824C18.1776 21.0824 18.6778 19.4624 18.1576 16.8224C18.1175 16.6324 18.0675 16.4424 18.0275 16.2424L18.0175 16.2524ZM22.9696 11.9624C22.9696 11.5524 22.6594 11.0824 22.0992 10.6124C21.4489 10.0724 20.5185 9.5824 19.3881 9.1924C19.158 9.1124 18.9179 9.0424 18.6778 8.9624C18.3877 9.9124 17.9875 10.9324 17.5073 11.9624C18.0075 13.0224 18.4177 14.0424 18.7178 15.0024C18.8579 14.9624 18.9879 14.9124 19.128 14.8724C21.7691 14.0024 22.9696 12.7524 22.9696 11.9624Z" fill="#00D8FF"></path></svg>',
  "logo-surveycreator-48x48": '<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><path d="M31.45 3.5H8.55C4.11 3.5 0.5 7.11 0.5 11.55V25.55C0.5 28.73 2.39 31.57 5.19 32.86C4.82 33.58 4.67 34.39 4.8 35.2C4.96 36.21 5.5 37.09 6.32 37.69C6.98 38.17 7.76 38.42 8.56 38.42C8.76 38.42 8.96 38.4 9.16 38.37C10.17 38.21 11.05 37.67 11.65 36.85L17.99 28.14C19.19 28.41 20.43 28.46 21.65 28.26C24.2 27.86 26.45 26.48 27.97 24.39C29.49 22.3 30.11 19.74 29.7 17.19C29.45 15.59 28.8 14.07 27.81 12.8C27.52 12.43 27.05 12.23 26.6 12.22C26.13 12.22 25.69 12.46 25.41 12.84L22.15 17.31C21.89 17.67 21.38 17.75 21.01 17.49C20.83 17.36 20.72 17.17 20.68 16.96C20.65 16.75 20.7 16.53 20.83 16.35L24.09 11.87C24.37 11.49 24.45 11 24.31 10.54C24.17 10.09 23.83 9.73 23.38 9.57C21.86 9.03 20.22 8.87 18.62 9.13C16.07 9.53 13.82 10.91 12.3 13C10.78 15.09 10.16 17.65 10.57 20.2C10.76 21.42 11.19 22.59 11.81 23.64L6.95 30.32C4.92 29.65 3.49 27.73 3.49 25.55V11.55C3.49 8.77 5.75 6.5 8.54 6.5H31.45C34.23 6.5 36.5 8.76 36.5 11.55V25.55C36.5 28.33 34.24 30.59 31.45 30.59H27.5V34L22.95 30.59H18.25C17.42 30.59 16.75 31.26 16.75 32.09C16.75 32.92 17.42 33.59 18.25 33.59H21.95L30.5 40V33.59H31.45C35.89 33.59 39.5 29.98 39.5 25.55V11.55C39.5 7.11 35.89 3.5 31.45 3.5ZM14.87 24.56C15.26 24.02 15.25 23.29 14.85 22.76C14.17 21.88 13.72 20.83 13.55 19.73C13.27 17.97 13.7 16.2 14.75 14.76C15.8 13.32 17.35 12.37 19.11 12.09C19.46 12.04 19.8 12.01 20.15 12.01C20.2 12.01 20.24 12.01 20.29 12.01L18.42 14.58C17.82 15.4 17.58 16.41 17.74 17.42C17.9 18.43 18.44 19.31 19.26 19.91C20.08 20.51 21.09 20.75 22.1 20.59C23.11 20.43 23.99 19.89 24.59 19.07L26.46 16.5C26.59 16.87 26.68 17.26 26.75 17.65C27.03 19.41 26.6 21.18 25.55 22.62C24.5 24.06 22.95 25.01 21.19 25.29C20.09 25.46 18.95 25.36 17.91 24.98C17.28 24.76 16.58 24.98 16.19 25.51L9.23 35.07C9.1 35.25 8.91 35.36 8.7 35.4C8.48 35.43 8.27 35.38 8.09 35.25C7.91 35.12 7.8 34.93 7.76 34.72C7.73 34.51 7.78 34.29 7.91 34.11L14.87 24.55V24.56Z"></path></svg>',
  "logo-vue-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_17790_388140)"><path d="M19.2 2H24L12 22.7L0 2H9.18L12 6.8L14.76 2H19.2Z" fill="#41B883"></path><path d="M4.74023 2L12.0002 14.48L19.2002 2H14.7602L12.0002 6.8L9.18023 2H4.74023Z" fill="#35495E"></path></g><defs><clipPath id="clip0_17790_388140"><rect width="24" height="20.7" fill="white" transform="translate(0 2)"></rect></clipPath></defs></svg>',
  "maximize-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M6.71 10.71L4.42 13H6.01C6.56 13 7.01 13.45 7.01 14C7.01 14.55 6.56 15 6.01 15H2C1.45 15 1 14.55 1 14V10C1 9.45 1.45 9 2 9C2.55 9 3 9.45 3 10V11.59L5.29 9.3C5.68 8.91 6.31 8.91 6.7 9.3C7.09 9.69 7.09 10.32 6.7 10.71H6.71ZM14 1H10C9.45 1 9 1.45 9 2C9 2.55 9.45 3 10 3H11.59L9.3 5.29C8.91 5.68 8.91 6.31 9.3 6.7C9.5 6.9 9.75 6.99 10.01 6.99C10.27 6.99 10.52 6.89 10.72 6.7L13.01 4.41V6C13.01 6.55 13.46 7 14.01 7C14.56 7 15.01 6.55 15.01 6V2C15.01 1.45 14.56 1 14.01 1H14Z"></path></svg>',
  "minimize-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M13 9H3C2.45 9 2 8.55 2 8C2 7.45 2.45 7 3 7H13C13.55 7 14 7.45 14 8C14 8.55 13.55 9 13 9Z"></path></svg>',
  "minus-32x32": '<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><path d="M30 16H3V17H30V16Z"></path></svg>',
  "minusbox-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_2362_25245)"><path d="M12 9H4V7H12V9ZM16 0V16H0V0H16ZM14 2H2V14H14V2Z"></path></g><defs><clipPath id="clip0_2362_25245"><rect width="16" height="16" fill="white"></rect></clipPath></defs></svg>',
  "more-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M10 8C10 9.1 9.1 10 8 10C6.9 10 6 9.1 6 8C6 6.9 6.9 6 8 6C9.1 6 10 6.9 10 8ZM14 6C12.9 6 12 6.9 12 8C12 9.1 12.9 10 14 10C15.1 10 16 9.1 16 8C16 6.9 15.1 6 14 6ZM2 6C0.9 6 0 6.9 0 8C0 9.1 0.9 10 2 10C3.1 10 4 9.1 4 8C4 6.9 3.1 6 2 6Z"></path></svg>',
  "more-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M6 12C6 13.1 5.1 14 4 14C2.9 14 2 13.1 2 12C2 10.9 2.9 10 4 10C5.1 10 6 10.9 6 12ZM12 10C10.9 10 10 10.9 10 12C10 13.1 10.9 14 12 14C13.1 14 14 13.1 14 12C14 10.9 13.1 10 12 10ZM20 10C18.9 10 18 10.9 18 12C18 13.1 18.9 14 20 14C21.1 14 22 13.1 22 12C22 10.9 21.1 10 20 10Z"></path></svg>',
  "navmenu-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M16 7H2V5H16V7ZM2 11V13H22V11H2ZM2 19H10V17H2V19Z"></path></svg>',
  "noimage-48x48": '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><path d="M14 17.01C14 16.4167 14.1759 15.8366 14.5056 15.3433C14.8352 14.8499 15.3038 14.4654 15.8519 14.2384C16.4001 14.0113 17.0033 13.9519 17.5853 14.0676C18.1672 14.1834 18.7018 14.4691 19.1213 14.8887C19.5409 15.3082 19.8266 15.8428 19.9424 16.4247C20.0581 17.0067 19.9987 17.6099 19.7716 18.1581C19.5446 18.7062 19.1601 19.1748 18.6667 19.5044C18.1734 19.8341 17.5933 20.01 17 20.01C16.2044 20.01 15.4413 19.6939 14.8787 19.1313C14.3161 18.5687 14 17.8056 14 17.01ZM27.09 24.14L20 36.01H36L27.09 24.14ZM36.72 8.14L35.57 10.01H36C36.5304 10.01 37.0391 10.2207 37.4142 10.5958C37.7893 10.9709 38 11.4796 38 12.01V36.01C38 36.5404 37.7893 37.0491 37.4142 37.4242C37.0391 37.7993 36.5304 38.01 36 38.01H18.77L17.57 40.01H36C37.0609 40.01 38.0783 39.5886 38.8284 38.8384C39.5786 38.0883 40 37.0709 40 36.01V12.01C39.9966 11.0765 39.6668 10.1737 39.0678 9.45778C38.4688 8.74188 37.6382 8.25802 36.72 8.09V8.14ZM36.86 4.5L12.86 44.5L11.14 43.5L13.23 40.01H12C10.9391 40.01 9.92172 39.5886 9.17157 38.8384C8.42143 38.0883 8 37.0709 8 36.01V12.01C8 10.9491 8.42143 9.93172 9.17157 9.18157C9.92172 8.43143 10.9391 8.01 12 8.01H32.43L35.14 3.5L36.86 4.5ZM14.43 38.01L15.63 36.01H12L19 27.01L20.56 27.8L31.23 10.01H12C11.4696 10.01 10.9609 10.2207 10.5858 10.5958C10.2107 10.9709 10 11.4796 10 12.01V36.01C10 36.5404 10.2107 37.0491 10.5858 37.4242C10.9609 37.7993 11.4696 38.01 12 38.01H14.43Z"></path></svg>',
  "pg-appearance-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20 8H19V1H5V8H4V13H5V13.14C5 14.72 6.28 16 7.86 16C8.2 16 8.41 16.19 8.51 16.3C8.61 16.41 8.76 16.65 8.71 16.98L8.44 18.89C8.29 19.92 8.6 20.97 9.28 21.76C9.96 22.55 10.96 23 12 23C13.04 23 14.04 22.55 14.72 21.76C15.4 20.97 15.71 19.93 15.57 18.89L15.3 16.98C15.25 16.64 15.41 16.41 15.5 16.3C15.59 16.19 15.81 16 16.15 16C17.73 16 19.01 14.72 19.01 13.14V13H20.01V8H20ZM18 11H6V10H18V11ZM7 3H11V5H13V3H14V6H16V3H17V8H7V3ZM17 13.14C17 13.61 16.62 14 16.14 14C15.31 14 14.52 14.36 13.98 14.98C13.44 15.61 13.19 16.44 13.31 17.26L13.58 19.17C13.65 19.64 13.51 20.09 13.2 20.45C12.59 21.15 11.39 21.15 10.78 20.45C10.47 20.09 10.34 19.64 10.4 19.17L10.67 17.26C10.79 16.44 10.54 15.61 10 14.98C9.46 14.35 8.67 13.99 7.84 13.99C7.37 13.99 6.98 13.61 6.98 13.13V12.99H16.98V13.13L17 13.14ZM11 19C11 18.45 11.45 18 12 18C12.55 18 13 18.45 13 19C13 19.55 12.55 20 12 20C11.45 20 11 19.55 11 19Z"></path></svg>',
  "pg-background-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M6 9.41L4.59 8L8 4.59L9.41 6L6 9.41ZM14.41 6L13 4.59L4.59 13L6 14.41L14.41 6ZM4.59 18L6 19.41L19.41 6L18 4.59L4.59 18ZM9.59 18L11 19.41L19.41 11L18 9.59L9.59 18ZM14.59 18L16 19.41L19.41 16L18 14.59L14.59 18ZM22 4V20C22 21.1 21.1 22 20 22H4C2.9 22 2 21.1 2 20V4C2 2.9 2.9 2 4 2H20C21.1 2 22 2.9 22 4ZM20 20V4H4V20H20Z"></path></svg>',
  "pg-columns-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M22 3V21H20V3H22ZM14 21H16V3H14V21ZM8 21H10V3H8V21ZM2 21H4V3H2V21Z"></path></svg>',
  "pg-conditions-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M18 14.59L16.59 16L18.59 18H7.82C7.79 17.9 7.75 17.81 7.7 17.71L17.71 7.7C18.1 7.89 18.53 8 19 8C20.65 8 22 6.65 22 5C22 3.35 20.65 2 19 2C17.7 2 16.6 2.84 16.18 4H7.82C7.41 2.84 6.31 2 5 2C3.35 2 2 3.35 2 5C2 6.65 3.35 8 5 8C6.3 8 7.4 7.16 7.82 6H16.19C16.22 6.1 16.26 6.19 16.31 6.29L6.29 16.3C5.9 16.11 5.47 16 5 16C3.35 16 2 17.35 2 19C2 20.65 3.35 22 5 22C6.3 22 7.4 21.16 7.82 20H18.59L16.59 22L18 23.41L22.41 19L18 14.59ZM19 4C19.55 4 20 4.45 20 5C20 5.55 19.55 6 19 6C18.45 6 18 5.55 18 5C18 4.45 18.45 4 19 4ZM5 6C4.45 6 4 5.55 4 5C4 4.45 4.45 4 5 4C5.55 4 6 4.45 6 5C6 5.55 5.55 6 5 6ZM5 20C4.45 20 4 19.55 4 19C4 18.45 4.45 18 5 18C5.55 18 6 18.45 6 19C6 19.55 5.55 20 5 20Z"></path></svg>',
  "pg-data-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 2C8.02 2 4 3.37 4 6V18C4 20.63 8.02 22 12 22C15.98 22 20 20.63 20 18V6C20 3.37 15.98 2 12 2ZM12 4C15.72 4 18 5.29 18 6C18 6.71 15.72 8 12 8C8.28 8 6 6.71 6 6C6 5.29 8.28 4 12 4ZM12 20C8.28 20 6 18.71 6 18V16.73C7.54 17.57 9.78 18 12 18C14.22 18 16.46 17.57 18 16.73V18C18 18.71 15.72 20 12 20ZM18 14C18 14.71 15.72 16 12 16C8.28 16 6 14.71 6 14V12.73C7.54 13.57 9.78 14 12 14C14.22 14 16.46 13.57 18 12.73V14ZM18 10C18 10.71 15.72 12 12 12C8.28 12 6 10.71 6 10V8.73C7.54 9.57 9.78 10 12 10C14.22 10 16.46 9.57 18 8.73V10Z"></path></svg>',
  "pg-design-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M2.59 22H22V2.59L2.59 22ZM20 20H7.41L20 7.41V20ZM13 18L18 13V18H13ZM10 8C11.1 8 12 8.9 12 10C12 11.1 11.1 12 10 12C8.9 12 8 11.1 8 10C8 8.9 8.9 8 10 8ZM2 9.83C2 8.89 2.61 8.09 3.45 7.8C3.56 7.44 3.71 7.09 3.89 6.75C3.75 6.46 3.67 6.13 3.67 5.8C3.67 5.23 3.89 4.69 4.3 4.29C4.94 3.65 5.97 3.5 6.76 3.89C7.1 3.71 7.45 3.57 7.81 3.45C8.1 2.61 8.9 2 9.84 2C10.78 2 11.58 2.61 11.87 3.45C12.23 3.56 12.58 3.71 12.92 3.89C13.71 3.5 14.74 3.65 15.38 4.3C15.78 4.7 16.01 5.24 16.01 5.81C16.01 6.38 15.79 6.92 15.38 7.32L14.67 8.03L13.26 6.61L13.97 5.9C13.97 5.9 14.01 5.83 14.01 5.8C14.01 5.77 14.01 5.74 13.97 5.7C13.9 5.63 13.84 5.63 13.77 5.7L13.1 6.36L12.42 5.91C11.91 5.57 11.36 5.34 10.78 5.22L9.98 5.06V4.13C9.98 3.98 9.7 3.98 9.7 4.13V5.06L8.9 5.22C8.32 5.34 7.76 5.57 7.26 5.91L6.58 6.36L5.92 5.7C5.84 5.63 5.79 5.63 5.72 5.7C5.68 5.74 5.68 5.77 5.68 5.8C5.68 5.83 5.68 5.86 5.72 5.9L6.38 6.57L5.93 7.25C5.59 7.76 5.36 8.31 5.24 8.89L5.08 9.69H4.15C4.07 9.69 4.01 9.75 4.01 9.83C4.01 9.91 4.07 9.97 4.15 9.97H5.08L5.24 10.77C5.36 11.35 5.59 11.91 5.93 12.41L6.38 13.09L5.72 13.75C5.72 13.75 5.68 13.83 5.68 13.85C5.68 13.87 5.68 13.91 5.72 13.95C5.79 14.02 5.85 14.02 5.92 13.95L6.63 13.24L8.05 14.65L7.34 15.36C6.94 15.77 6.4 15.99 5.83 15.99C5.26 15.99 4.72 15.77 4.32 15.36C3.92 14.96 3.69 14.42 3.69 13.85C3.69 13.51 3.77 13.19 3.91 12.9C3.73 12.56 3.59 12.21 3.47 11.85C2.63 11.56 2.02 10.76 2.02 9.82L2 9.83Z"></path></svg>',
  "pg-general-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20 2H4C2.9 2 2 2.9 2 4V20C2 21.1 2.9 22 4 22H20C21.1 22 22 21.1 22 20V4C22 2.9 21.1 2 20 2ZM4 20V4H20V20H4ZM6 7H9V9H6V7ZM12 7H18V9H12V7ZM6 11H9V13H6V11ZM12 11H18V13H12V11ZM6 15H9V17H6V15ZM12 15H18V17H12V15Z"></path></svg>',
  "pg-header-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M21 2H3C1.9 2 1 2.9 1 4V15C1 16.1 1.9 17 3 17H21C22.1 17 23 16.1 23 15V4C23 2.9 22.1 2 21 2ZM4.41 15L9 10.41L12 13.41L14 11.41L17.59 15H4.41ZM20.41 15L14 8.59L12 10.59L9 7.59L3 13.59V4H21V15H20.41ZM19 7.5C19 8.33 18.33 9 17.5 9C16.67 9 16 8.33 16 7.5C16 6.67 16.67 6 17.5 6C18.33 6 19 6.67 19 7.5ZM8 21H16V23H8V21ZM6 18H18V20H6V18Z"></path></svg>',
  "pg-language-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M17.75 8H15.25L13.35 13.08C12.2029 12.2588 11.2439 11.2027 10.537 9.98187C9.83 8.76107 9.39127 7.40364 9.25 6H14V4H9V2H7V4H2V6H6.91C6.73189 7.75797 6.09115 9.43736 5.05302 10.8672C4.01489 12.2971 2.61643 13.4263 1 14.14C1.32315 14.7296 1.69441 15.2915 2.11 15.82C4.82764 14.5445 6.96846 12.2966 8.11 9.52C9.02641 11.7596 10.5985 13.6698 12.62 15L10 22H12.42L13.79 18.13H19.16L20.56 22H23L17.75 8ZM14.46 16.16L15.73 12.53C16.0406 11.7049 16.2945 10.8596 16.49 10C16.55 10.26 16.67 10.66 16.84 11.21C17.01 11.76 17.14 12.15 17.24 12.41L18.55 16.2L14.46 16.16Z"></path></svg>',
  "pg-layout-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20 2H4C2.9 2 2 2.9 2 4V9C2 10.1 2.9 11 4 11H20C21.1 11 22 10.1 22 9V4C22 2.9 21.1 2 20 2ZM4 9V4H20V9H4ZM11 12H4C2.9 12 2 12.9 2 14V20C2 21.1 2.9 22 4 22H11C12.1 22 13 21.1 13 20V14C13 12.9 12.1 12 11 12ZM4 20V14H11V20H4ZM20 12H16C14.9 12 14 12.9 14 14V20C14 21.1 14.9 22 16 22H20C21.1 22 22 21.1 22 20V14C22 12.9 21.1 12 20 12ZM16 20V14H20V20H16Z"></path></svg>',
  "pg-logo-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20 2H4C2.9 2 2 2.9 2 4V20C2 21.1 2.9 22 4 22H20C21.1 22 22 21.1 22 20V4C22 2.9 21.1 2 20 2ZM20 4V17.59L15 12.59L13 14.59L10 11.59L4 17.59V4H20ZM19.59 20H4.41L10 14.41L13 17.41L15 15.41L19.59 20ZM14 8C14 6.9 14.9 6 16 6C17.1 6 18 6.9 18 8C18 9.1 17.1 10 16 10C14.9 10 14 9.1 14 8Z"></path></svg>',
  "pg-navigation-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M5 12L10 8V16L5 12ZM14 8V16L19 12L14 8ZM23 12C23 18.07 18.07 23 12 23C5.93 23 1 18.07 1 12C1 5.93 5.93 1 12 1C18.07 1 23 5.93 23 12ZM21 12C21 7.04 16.96 3 12 3C7.04 3 3 7.04 3 12C3 16.96 7.04 21 12 21C16.96 21 21 16.96 21 12Z"></path></svg>',
  "pg-pages-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M19 1H5C3.9 1 3 1.9 3 3V21C3 22.1 3.9 23 5 23H19C20.1 23 21 22.1 21 21V3C21 1.9 20.1 1 19 1ZM5 21V3H19V21H5ZM11 7H7V5H11V7ZM7 8H17V10H7V8ZM7 11H17V13H7V11ZM7 14H17V16H7V14ZM12 17H17V19H12V17Z"></path></svg>',
  "pg-questiondesign-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20.01 14.98H22.01V17.98C22.01 19.08 21.11 19.98 20.01 19.98H12.42L8.71 23.69C8.52 23.88 8.26 23.98 8 23.98C7.87 23.98 7.74 23.96 7.62 23.9C7.25 23.75 7 23.38 7 22.98V19.98H4C2.9 19.98 2 19.08 2 17.98V3.98C2 2.88 2.9 1.98 4 1.98H8V3.98H4.01V17.98H8.01C8.56 17.98 9.01 18.43 9.01 18.98V20.57L11.3 18.28C11.49 18.09 11.74 17.99 12.01 17.99H20.01V14.99V14.98ZM23.01 7.48C23.01 8.39 22.43 9.16 21.62 9.44C21.51 9.77 21.38 10.09 21.22 10.4C21.59 11.17 21.46 12.13 20.82 12.78C20.43 13.17 19.9 13.39 19.35 13.39C19.03 13.39 18.73 13.32 18.45 13.18C18.14 13.34 17.82 13.47 17.49 13.58C17.2 14.39 16.43 14.97 15.53 14.97C14.63 14.97 13.85 14.39 13.57 13.58C13.24 13.47 12.92 13.34 12.61 13.18C11.85 13.55 10.85 13.39 10.23 12.77C9.84 12.38 9.62 11.85 9.62 11.3C9.62 10.98 9.69 10.67 9.83 10.4C9.67 10.09 9.54 9.77 9.43 9.44C8.62 9.15 8.04 8.38 8.04 7.48C8.04 6.58 8.62 5.8 9.43 5.52C9.54 5.19 9.67 4.87 9.83 4.56C9.7 4.28 9.62 3.97 9.62 3.66C9.62 3.1 9.84 2.58 10.23 2.19C10.87 1.55 11.83 1.41 12.61 1.79C12.92 1.63 13.24 1.5 13.57 1.39C13.86 0.58 14.63 0 15.53 0C16.43 0 17.21 0.58 17.49 1.39C17.82 1.5 18.14 1.63 18.45 1.79C19.22 1.42 20.18 1.55 20.83 2.19C21.47 2.83 21.61 3.79 21.24 4.57C21.4 4.88 21.53 5.2 21.64 5.53C22.45 5.82 23.03 6.59 23.03 7.49L23.01 7.48ZM21.01 7.48C21.01 7.48 20.97 7.4 20.93 7.4H20L19.84 6.6C19.73 6.05 19.51 5.53 19.19 5.05L18.74 4.37L19.4 3.71C19.4 3.71 19.43 3.62 19.4 3.59C19.37 3.56 19.32 3.56 19.28 3.59L18.62 4.25L17.94 3.8C17.46 3.48 16.94 3.27 16.39 3.15L15.59 2.99V2.06C15.59 1.97 15.42 1.97 15.42 2.06V2.99L14.62 3.15C14.07 3.26 13.55 3.48 13.07 3.8L12.39 4.25L11.73 3.59C11.73 3.59 11.65 3.56 11.61 3.59V3.71L12.26 4.37L11.81 5.05C11.49 5.53 11.28 6.05 11.16 6.6L11 7.4H10.07C10.07 7.4 9.99 7.44 9.99 7.48C9.99 7.52 10.03 7.56 10.07 7.56H11L11.16 8.36C11.27 8.91 11.49 9.43 11.81 9.91L12.26 10.59L11.61 11.25V11.37H11.73L12.39 10.72L13.07 11.17C13.55 11.49 14.07 11.71 14.62 11.82L15.42 11.98V12.91C15.42 13 15.59 13 15.59 12.91V11.98L16.39 11.82C16.94 11.71 17.46 11.49 17.94 11.17L18.62 10.72L19.28 11.38H19.4C19.4 11.38 19.43 11.3 19.4 11.26L18.74 10.6L19.19 9.92C19.51 9.44 19.72 8.92 19.84 8.37L20 7.57H20.93C20.93 7.57 21.01 7.53 21.01 7.49V7.48ZM15.51 4.98C14.13 4.98 13.01 6.1 13.01 7.48C13.01 8.86 14.13 9.98 15.51 9.98C16.89 9.98 18.01 8.86 18.01 7.48C18.01 6.1 16.89 4.98 15.51 4.98Z"></path></svg>',
  "pg-quiz-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M19.26 7.15L20.41 6L19 4.59L17.75 5.84C16.12 4.69 14.14 4.01 12 4.01C9.86 4.01 7.88 4.69 6.25 5.84L5 4.59L3.59 6L4.74 7.15C3.05 8.94 2 11.35 2 14C2 19.51 6.49 24 12 24C17.51 24 22 19.51 22 14C22 11.35 20.96 8.94 19.26 7.15ZM12 22C7.59 22 4 18.41 4 14C4 9.59 7.59 6 12 6C16.41 6 20 9.59 20 14C20 18.41 16.41 22 12 22ZM15 8.58L16.41 9.99L12 14.4L10.59 12.99L15 8.58ZM9.2 3.36L8.83 1.4L9.81 1.21C11.29 0.93 12.7 0.93 14.18 1.21L15.16 1.4L14.79 3.36L13.81 3.17C12.57 2.94 11.42 2.94 10.18 3.17L9.2 3.36Z"></path></svg>',
  "pg-rows-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M21 2V4H3V2H21ZM3 10H21V8H3V10ZM3 16H21V14H3V16ZM3 22H21V20H3V22Z"></path></svg>',
  "pg-specific-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_22397_60021)"><path d="M20 10.005H22V18.005C22 19.105 21.1 20.005 20 20.005H12.41L8.69999 23.715C8.50999 23.905 8.24999 24.005 7.98999 24.005C7.85999 24.005 7.72999 23.985 7.60999 23.925C7.23999 23.775 6.98999 23.405 6.98999 23.005V20.005H4.98999C3.33999 20.005 1.98999 18.655 1.98999 17.005V5.005C1.99999 3.355 3.34999 2.005 4.99999 2.005H14V4.005H4.99999C4.44999 4.005 3.99999 4.455 3.99999 5.005V17.005C3.99999 17.555 4.44999 18.005 4.99999 18.005H7.99999C8.54999 18.005 8.99999 18.455 8.99999 19.005V20.595L11.29 18.305C11.48 18.115 11.73 18.015 12 18.015H20V10.015V10.005ZM10.1 9.49501L16.79 2.795C18.01 1.575 19.99 1.575 21.2 2.795C22.41 4.015 22.42 5.99501 21.2 7.20501L14.5 13.905L8.60999 15.375L10.08 9.485L10.1 9.49501ZM18.21 4.215L17.42 5.005L19.01 6.59501L19.8 5.80501C20.01 5.59501 20.13 5.31501 20.13 5.01501C20.13 4.71501 20.01 4.435 19.8 4.225C19.38 3.805 18.64 3.805 18.21 4.225V4.215ZM11.37 12.635L13.48 12.105L17.58 8.005L15.99 6.41501L11.89 10.515L11.36 12.625L11.37 12.635Z"></path></g><defs><clipPath id="clip0_22397_60021"><rect width="24" height="24" fill="white"></rect></clipPath></defs></svg>',
  "pg-thankyyoupage-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M15.0001 13.59L19.4101 18L18.0001 19.41L13.5901 15L15.0001 13.59ZM15.0001 10.42L13.4101 12.01L12.0001 13.42L6.00009 19.42L4.59009 18.01L10.5901 12.01L9.00009 10.42L5.00009 14.42L0.590088 10L4.59009 6L3.59009 5L5.00009 3.59L6.00009 4.59L10.4101 9L12.0001 10.59L13.5901 9L18.0001 4.59L19.0001 3.59L20.4101 5L19.4101 6L23.4101 10L19.0001 14.41L15.0001 10.41V10.42ZM7.59009 9L6.00009 7.41L3.41009 10L5.00009 11.59L7.59009 9ZM16.4201 9L19.0101 11.59L20.6001 10L18.0101 7.41L16.4201 9Z"></path></svg>',
  "pg-themes-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20 2H4C2.9 2 2 2.9 2 4V20C2 21.1 2.9 22 4 22H20C21.1 22 22 21.1 22 20V4C22 2.9 21.1 2 20 2ZM4 20V4H20V20H4ZM11 5H5V11H11V5ZM9 9H7V7H9V9ZM12 12H19V5H12V12ZM14 7H17V10H14V7ZM13 19H19V13H13V19ZM15 15H17V17H15V15ZM5 19H12V12H5V19ZM7 14H10V17H7V14Z"></path></svg>',
  "pg-totals-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20.0001 5H7.42009L14.4201 12L7.42009 19H20.0101V21H2.59009L11.5901 12L2.59009 3H20.0001V5Z"></path></svg>',
  "pg-undefined-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M3.34 5.325C3.57 5.785 3.41 6.335 2.99 6.615C2.93 7.115 2.51 7.505 2 7.505C1.45 7.505 1 7.055 1 6.505V6.005C1 5.625 1.21 5.275 1.55 5.115L2 4.895C2.49 4.645 3.09 4.845 3.34 5.345V5.325ZM2 15.415C2.55 15.415 3 14.965 3 14.415V13.535C3 12.985 2.55 12.535 2 12.535C1.45 12.535 1 12.985 1 13.535V14.415C1 14.965 1.45 15.415 2 15.415ZM2 11.455C2.55 11.455 3 11.005 3 10.455V9.575C3 9.025 2.55 8.575 2 8.575C1.45 8.575 1 9.025 1 9.575V10.455C1 11.005 1.45 11.455 2 11.455ZM2.99 17.385C2.93 16.885 2.51 16.495 2 16.495C1.45 16.495 1 16.945 1 17.495V17.995C1 18.375 1.21 18.725 1.55 18.885L2 19.105C2.14 19.175 2.3 19.215 2.45 19.215C2.82 19.215 3.17 19.015 3.35 18.665C3.58 18.205 3.42 17.655 3 17.375L2.99 17.385ZM9.45 20.605L8.72 20.245C8.23 19.995 7.63 20.195 7.38 20.695C7.13 21.185 7.33 21.785 7.83 22.035L8.56 22.395C8.7 22.465 8.86 22.505 9.01 22.505C9.38 22.505 9.73 22.305 9.91 21.955C10.16 21.465 9.96 20.865 9.46 20.615L9.45 20.605ZM6.17 18.965L5.44 18.605C4.95 18.355 4.35 18.555 4.1 19.055C3.85 19.545 4.05 20.145 4.55 20.395L5.28 20.755C5.42 20.825 5.58 20.865 5.73 20.865C6.1 20.865 6.45 20.665 6.63 20.315C6.88 19.825 6.68 19.225 6.18 18.975L6.17 18.965ZM12 21.875C11.51 21.625 10.91 21.825 10.66 22.325C10.41 22.815 10.61 23.415 11.11 23.665L11.56 23.885C11.7 23.955 11.85 23.995 12.01 23.995C12.17 23.995 12.32 23.955 12.46 23.885L12.91 23.665C13.4 23.415 13.6 22.815 13.36 22.325C13.11 21.835 12.51 21.635 12.02 21.875H12ZM18.56 18.595L17.83 18.955C17.34 19.205 17.14 19.805 17.38 20.295C17.56 20.645 17.91 20.845 18.28 20.845C18.43 20.845 18.58 20.815 18.73 20.735L19.46 20.375C19.95 20.125 20.15 19.525 19.91 19.035C19.66 18.545 19.06 18.345 18.57 18.585L18.56 18.595ZM15.28 20.235L14.55 20.595C14.06 20.845 13.86 21.445 14.1 21.935C14.28 22.285 14.63 22.485 15 22.485C15.15 22.485 15.3 22.455 15.45 22.375L16.18 22.015C16.67 21.765 16.87 21.165 16.63 20.675C16.38 20.185 15.78 19.985 15.29 20.225L15.28 20.235ZM22 16.495C21.49 16.495 21.06 16.885 21.01 17.385C20.59 17.655 20.43 18.215 20.66 18.675C20.84 19.025 21.19 19.225 21.56 19.225C21.71 19.225 21.86 19.195 22.01 19.115L22.46 18.895C22.8 18.725 23.01 18.375 23.01 18.005V17.505C23.01 16.955 22.56 16.505 22.01 16.505L22 16.495ZM22 12.535C21.45 12.535 21 12.985 21 13.535V14.415C21 14.965 21.45 15.415 22 15.415C22.55 15.415 23 14.965 23 14.415V13.535C23 12.985 22.55 12.535 22 12.535ZM22 8.575C21.45 8.575 21 9.025 21 9.575V10.455C21 11.005 21.45 11.455 22 11.455C22.55 11.455 23 11.005 23 10.455V9.575C23 9.025 22.55 8.575 22 8.575ZM22.45 5.105L22 4.885C21.51 4.635 20.91 4.835 20.66 5.335C20.43 5.795 20.59 6.345 21.01 6.625C21.07 7.125 21.49 7.515 22 7.515C22.55 7.515 23 7.065 23 6.515V6.015C23 5.635 22.79 5.285 22.45 5.125V5.105ZM14.55 3.385L15.28 3.745C15.42 3.815 15.58 3.855 15.73 3.855C16.1 3.855 16.45 3.655 16.63 3.305C16.88 2.815 16.68 2.215 16.18 1.965L15.45 1.605C14.96 1.355 14.36 1.555 14.11 2.055C13.86 2.555 14.06 3.145 14.56 3.395L14.55 3.385ZM17.83 5.025L18.56 5.385C18.7 5.455 18.86 5.495 19.01 5.495C19.38 5.495 19.73 5.295 19.91 4.945C20.16 4.455 19.96 3.855 19.46 3.605L18.73 3.245C18.24 2.995 17.64 3.195 17.39 3.695C17.14 4.185 17.34 4.785 17.84 5.035L17.83 5.025ZM12.89 0.325L12.44 0.105C12.16 -0.035 11.83 -0.035 11.55 0.105L11.1 0.325C10.61 0.575 10.41 1.175 10.65 1.665C10.9 2.155 11.5 2.355 11.99 2.115C12.13 2.185 12.29 2.225 12.44 2.225C12.81 2.225 13.16 2.025 13.34 1.675C13.59 1.185 13.39 0.585 12.89 0.335V0.325ZM8.28 3.855C8.43 3.855 8.58 3.825 8.73 3.745L9.46 3.385C9.95 3.135 10.15 2.535 9.91 2.045C9.66 1.555 9.06 1.355 8.57 1.595L7.84 1.955C7.35 2.205 7.15 2.805 7.39 3.295C7.57 3.645 7.92 3.845 8.29 3.845L8.28 3.855ZM5 5.495C5.15 5.495 5.3 5.465 5.45 5.385L6.18 5.025C6.67 4.775 6.87 4.175 6.63 3.685C6.38 3.195 5.78 2.995 5.29 3.235L4.56 3.595C4.07 3.845 3.87 4.445 4.11 4.935C4.29 5.285 4.64 5.485 5.01 5.485L5 5.495ZM6 6.655L5.56 6.415C5.07 6.155 4.47 6.335 4.21 6.825C3.95 7.315 4.13 7.915 4.62 8.175L5.06 8.415C5.21 8.495 5.37 8.535 5.53 8.535C5.89 8.535 6.23 8.345 6.41 8.005C6.67 7.515 6.49 6.915 6 6.655ZM7.7 9.835L8.45 10.235C8.6 10.315 8.76 10.355 8.92 10.355C9.28 10.355 9.62 10.165 9.8 9.825C10.06 9.335 9.88 8.735 9.39 8.475L8.64 8.075C8.15 7.815 7.55 7.995 7.29 8.485C7.03 8.975 7.21 9.575 7.7 9.835ZM13.32 10.285C13.06 9.805 12.48 9.625 12 9.855C11.52 9.615 10.93 9.805 10.68 10.285C10.44 10.745 10.6 11.295 11.02 11.585C11.07 12.095 11.48 12.495 12 12.495C12.52 12.495 12.93 12.095 12.98 11.585C13.41 11.305 13.57 10.745 13.32 10.285ZM15.37 8.065L14.61 8.465C14.12 8.725 13.94 9.335 14.2 9.815C14.38 10.155 14.73 10.345 15.08 10.345C15.24 10.345 15.4 10.305 15.55 10.225L16.31 9.825C16.8 9.565 16.98 8.955 16.72 8.475C16.46 7.985 15.85 7.805 15.37 8.065ZM18.46 6.415L18.02 6.655C17.53 6.915 17.35 7.525 17.61 8.005C17.79 8.345 18.14 8.535 18.49 8.535C18.65 8.535 18.81 8.495 18.96 8.415L19.4 8.175C19.89 7.915 20.07 7.305 19.81 6.825C19.55 6.335 18.94 6.155 18.46 6.415ZM12 17.495C11.45 17.495 11 17.945 11 18.495V18.995C11 19.545 11.45 19.995 12 19.995C12.55 19.995 13 19.545 13 18.995V18.495C13 17.945 12.55 17.495 12 17.495ZM13 14.555C13 14.005 12.55 13.555 12 13.555C11.45 13.555 11 14.005 11 14.555V15.435C11 15.985 11.45 16.435 12 16.435C12.55 16.435 13 15.985 13 15.435V14.555Z"></path></svg>',
  "pg-validation-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 1C5.93 1 1 5.93 1 12C1 18.07 5.93 23 12 23C18.07 23 23 18.07 23 12C23 5.93 18.07 1 12 1ZM12 21C7.04 21 3 16.96 3 12C3 7.04 7.04 3 12 3C16.96 3 21 7.04 21 12C21 16.96 16.96 21 12 21ZM17.41 8L13.41 12L17.41 16L16 17.41L12 13.41L8 17.41L6.59 16L10.59 12L6.59 8L8 6.59L12 10.59L16 6.59L17.41 8Z"></path></svg>',
  "pg-webservice-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M10.97 12.84C10.97 12.84 11.03 12.92 11.06 12.95C11.08 12.97 11.1 12.98 11.12 13C12.38 14.24 14.11 15 16.01 15C19.87 15 23.01 11.86 23.01 8C23.01 6.12 22.26 4.42 21.05 3.16C21.02 3.12 20.99 3.08 20.96 3.05C20.93 3.02 20.88 2.98 20.84 2.95C19.58 1.75 17.88 1 16.01 1C12.15 1 9.01 4.14 9.01 8C9.01 9.88 9.76 11.58 10.97 12.84ZM12.93 6.33C12.18 7.18 11.56 8.09 11.11 8.98C11.05 8.66 11.01 8.34 11.01 8C11.01 6.98 11.32 6.04 11.84 5.25L12.92 6.33H12.93ZM19.33 4.43C19.45 4.43 19.51 4.45 19.54 4.46C19.58 4.53 19.66 4.93 19.29 5.8C18.95 6.59 18.37 7.45 17.68 8.25L15.76 6.33C16.56 5.63 17.42 5.06 18.21 4.72C18.76 4.48 19.12 4.43 19.33 4.43ZM21.01 8C21.01 9.02 20.7 9.96 20.18 10.75L19.1 9.67C19.85 8.82 20.47 7.91 20.92 7.02C20.98 7.34 21.02 7.66 21.02 8H21.01ZM16.27 9.67C15.47 10.37 14.61 10.94 13.82 11.28C12.95 11.65 12.55 11.58 12.49 11.54C12.45 11.47 12.37 11.07 12.74 10.2C13.08 9.41 13.66 8.55 14.35 7.75L16.27 9.67ZM15.03 12.9C15.92 12.46 16.83 11.83 17.68 11.08L18.76 12.16C17.97 12.68 17.02 12.99 16.01 12.99C15.68 12.99 15.35 12.95 15.03 12.89V12.9ZM16.99 3.1C16.1 3.54 15.19 4.17 14.34 4.92L13.26 3.84C14.05 3.32 15 3.01 16.01 3.01C16.34 3.01 16.67 3.05 16.99 3.11V3.1ZM20.01 15H22.01V18C22.01 19.1 21.11 20 20.01 20H12.42L8.71 23.71C8.52 23.9 8.26 24 8 24C7.87 24 7.74 23.98 7.62 23.92C7.25 23.77 7 23.4 7 23V20H5C3.35 20 2 18.65 2 17V5C2.01 3.35 3.36 2 5.01 2H9.01V4H5.01C4.46 4 4.01 4.45 4.01 5V17C4.01 17.55 4.46 18 5.01 18H8.01C8.56 18 9.01 18.45 9.01 19V20.59L11.3 18.3C11.49 18.11 11.74 18.01 12.01 18.01H20.01V15.01V15Z"></path></svg>',
  "phone-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M16 18H8V6H16V18ZM16 2H8C7.46957 2 6.96086 2.21071 6.58579 2.58579C6.21071 2.96086 6 3.46957 6 4V20C6 20.5304 6.21071 21.0391 6.58579 21.4142C6.96086 21.7893 7.46957 22 8 22H16C16.5304 22 17.0391 21.7893 17.4142 21.4142C17.7893 21.0391 18 20.5304 18 20V4C18 3.46957 17.7893 2.96086 17.4142 2.58579C17.0391 2.21071 16.5304 2 16 2Z"></path></svg>',
  "plus-32x32": '<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><path d="M30 16H17V3H16V16H3V17H16V30H17V17H30V16Z"></path></svg>',
  "plusbox-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_2362_25244)"><path d="M7 9H4V7H7V4H9V7H12V9H9V12H7V9ZM16 0V16H0V0H16ZM14 2H2V14H14V2Z"></path></g><defs><clipPath id="clip0_2362_25244"><rect width="16" height="16" fill="white"></rect></clipPath></defs></svg>',
  "preview-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 1C5.92 1 1 5.92 1 12C1 18.08 5.92 23 12 23C18.08 23 23 18.08 23 12C23 5.92 18.08 1 12 1ZM12 21C7.04 21 3 16.96 3 12C3 7.04 7.04 3 12 3C16.96 3 21 7.04 21 12C21 16.96 16.96 21 12 21ZM16.91 10.25L10.97 6.95C10.35 6.6 9.6 6.61 8.99 6.97C8.37 7.33 8 7.98 8 8.69V15.29C8 16.01 8.37 16.65 8.99 17.01C9.31 17.2 9.65 17.29 10 17.29C10.35 17.29 10.67 17.21 10.97 17.04L16.91 13.74C17.54 13.39 17.94 12.72 17.94 11.99C17.94 11.26 17.55 10.59 16.91 10.24V10.25ZM10 15.3V8.7L15.94 12L10 15.3Z"></path></svg>',
  "publish-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M21.98 11.0038C21.99 10.8337 22 10.6737 22 10.5036C22 6.3616 18.64 3 14.5 3C11.66 3 9.14 4.58075 7.87 7.00191C4.78 7.07194 2.26 9.48309 2.02 12.5245C0.82 13.2149 0 14.5155 0 15.9962C0 18.2072 1.79 19.9981 4 19.9981H10V17.9971H4C2.9 17.9971 2 17.0967 2 15.9962C2 14.8957 2.9 13.9952 4 13.9952H4.14C4.06 13.6751 4 13.3449 4 12.9948C4 10.7837 5.79 8.99285 8 8.99285C8.41 8.99285 8.79 9.07289 9.16 9.18294C9.75 6.7818 11.91 4.99095 14.5 4.99095C17.54 4.99095 20 7.45212 20 10.4936C20 11.0538 19.92 11.5941 19.76 12.1043C21.05 12.4445 22 13.6051 22 14.9957C22 16.6565 20.66 17.9971 19 17.9971H14V13.405L17 16.4064L18.41 14.9957L13 9.58314L7.59 14.9957L9 16.4064L12 13.405V24H14V19.9981H19C21.76 19.9981 24 17.757 24 14.9957C24 13.3849 23.22 11.9142 21.98 10.9938V11.0038Z"></path></svg>',
  "questionlock-24x24": '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.59 17H11V19H10.41L6 23.41V19H4C2.9 19 2 18.1 2 17V4C2 2.9 2.9 2 4 2H20C21.1 2 22 2.9 22 4V7H20V4H4V17H8V18.59L9.59 17ZM23 13V19C23 20.65 21.65 22 20 22H16C14.35 22 13 20.65 13 19V13H14V12C14 9.79 15.79 8 18 8C20.21 8 22 9.79 22 12V13H23ZM16 13H20V12C20 10.9 19.1 10 18 10C16.9 10 16 10.9 16 12V13ZM21 15H15V19C15 19.55 15.45 20 16 20H20C20.55 20 21 19.55 21 19V15ZM19 16H17V18H19V16Z"></path></svg>',
  "ranking-arrows": '<svg viewBox="0 0 10 24" xmlns="http://www.w3.org/2000/svg"><path d="M10 5L5 0L0 5H4V9H6V5H10Z"></path><path d="M6 19V15H4V19H0L5 24L10 19H6Z"></path></svg>',
  "rankingundefined-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M13 7H3V9H13V7Z"></path></svg>',
  "redo-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M7 8H19.6L15.6 4L17 2.6L23.4 9L17 15.4L15.6 14L19.6 10H7C4.8 10 3 11.8 3 14C3 16.2 4.8 18 7 18H8V20H7C3.7 20 1 17.3 1 14C1 10.7 3.7 8 7 8Z"></path></svg>',
  "refresh-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M15 2V7H10L12 5C11.1 3.8 9.6 3 8 3C5.2 3 3 5.2 3 8H1C1 4.1 4.1 1 8 1C10.2 1 12.1 2 13.4 3.6L15 2ZM8 13C6.4 13 4.9 12.2 4 11L6 9H1V14L2.6 12.4C3.9 14 5.8 15 8 15C11.9 15 15 11.9 15 8H13C13 10.8 10.8 13 8 13Z"></path></svg>',
  "remove-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_554_309818)"><path d="M12 7V9H4V7H12ZM16 8C16 12.4 12.4 16 8 16C3.6 16 0 12.4 0 8C0 3.6 3.6 0 8 0C12.4 0 16 3.6 16 8ZM14 8C14 4.7 11.3 2 8 2C4.7 2 2 4.7 2 8C2 11.3 4.7 14 8 14C11.3 14 14 11.3 14 8Z"></path></g><defs><clipPath id="clip0_554_309818"><rect width="16" height="16" fill="white"></rect></clipPath></defs></svg>',
  "reorder-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M17 5L12 0L7 5H11V9H13V5H17Z"></path><path d="M13 19V15H11V19H7L12 24L17 19H13Z"></path></svg>',
  "required-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_19892_573966)"><path d="M2.77 14.1393L6.09 9.0393L0 9.1893L0.06 6.5193L6.15 6.8893L2.96 1.6893L5.29 0.379303L8.02 5.8193L10.96 0.489303L13.23 1.8493L9.91 6.9493L16 6.7993L15.94 9.4693L9.85 9.0993L13.04 14.2993L10.71 15.6093L7.98 10.1693L5.04 15.4993L2.77 14.1393Z"></path></g><defs><clipPath id="clip0_19892_573966"><rect width="16" height="16" fill="white"></rect></clipPath></defs></svg>',
  "restore-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12.01 2.99297C11.8 2.99297 11.59 3.02297 11.37 3.04297L12.71 1.70297L11.3 0.292969L7.59 4.00297L11.3 7.71297L12.71 6.30297L11.46 5.05297C11.64 5.04297 11.82 5.01297 12 5.01297C15.86 5.01297 19 8.15297 19 12.013C19 15.873 15.86 19.013 12 19.013C8.14 19.013 5 15.873 5 12.013C5 11.463 4.55 11.013 4 11.013C3.45 11.013 3 11.463 3 12.013C3 16.973 7.04 21.013 12 21.013C16.96 21.013 21 16.973 21 12.013C21 7.05297 16.97 2.99297 12.01 2.99297Z"></path></svg>',
  "restoredown-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M15 6C15 6.55 14.55 7 14 7H10C9.45 7 9 6.55 9 6V2C9 1.45 9.45 1 10 1C10.55 1 11 1.45 11 2V3.59L13.29 1.29C13.49 1.09 13.74 1 14 1C14.26 1 14.51 1.1 14.71 1.29C15.1 1.68 15.1 2.31 14.71 2.7L12.42 4.99H14.01C14.56 4.99 15.01 5.44 15.01 5.99L15 6ZM6 9H2C1.45 9 0.999998 9.45 0.999998 10C0.999998 10.55 1.45 11 2 11H3.59L1.29 13.29C0.899998 13.68 0.899998 14.31 1.29 14.7C1.68 15.09 2.31 15.09 2.7 14.7L4.99 12.41V14C4.99 14.55 5.44 15 5.99 15C6.54 15 6.99 14.55 6.99 14V10C6.99 9.45 6.54 9 5.99 9H6Z"></path></svg>',
  "rotate-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M23.41 5.99588L18 11.4059L16.59 9.99588L19.59 6.99588H17C13.5522 6.99588 10.2456 8.36551 7.80761 10.8035C5.36964 13.2415 4 16.5481 4 19.9959V21.9959H2V19.9959C2 16.0176 3.58035 12.2023 6.3934 9.38927C9.20644 6.57623 13.0218 4.99588 17 4.99588H19.59L16.59 1.99588L18 0.585876L23.41 5.99588Z"></path></svg>',
  "save-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20 2H4L2 4V20C2 20.5304 2.21071 21.0391 2.58579 21.4142C2.96086 21.7893 3.46957 22 4 22H20C20.5304 22 21.0391 21.7893 21.4142 21.4142C21.7893 21.0391 22 20.5304 22 20V4C22 3.46957 21.7893 2.96086 21.4142 2.58579C21.0391 2.21071 20.5304 2 20 2ZM15 4V6H9V4H15ZM8 20V15H16V20H8ZM20 20H18V13H6V20H4V4.83L4.83 4H7V8H17V4H20V20Z"></path></svg>',
  "saveas-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M24 11H22V13H20V11H18V9H20V7H22V9H24V11ZM20 14H22V20C22 21.1 21.1 22 20 22H4C2.9 22 2 21.1 2 20V4L4 2H20C21.1 2 22 2.9 22 4V6H20V4H17V8H7V4H4.83L4 4.83V20H6V13H18V20H20V14ZM9 6H15V4H9V6ZM16 15H8V20H16V15Z"></path></svg>',
  "search-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M14 2C9.6 2 6 5.6 6 10C6 11.8 6.6 13.5 7.7 14.9L2.3 20.3C1.9 20.7 1.9 21.3 2.3 21.7C2.5 21.9 2.7 22 3 22C3.3 22 3.5 21.9 3.7 21.7L9.1 16.3C10.5 17.4 12.2 18 14 18C18.4 18 22 14.4 22 10C22 5.6 18.4 2 14 2ZM14 16C10.7 16 8 13.3 8 10C8 6.7 10.7 4 14 4C17.3 4 20 6.7 20 10C20 13.3 17.3 16 14 16Z"></path></svg>',
  "selectpage-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M23 11H19.9C19.4 7.4 16.6 4.5 13 4.1V1H11V4.1C7.4 4.5 4.5 7.4 4.1 11H1V13H4.1C4.6 16.6 7.4 19.5 11 19.9V23H13V19.9C16.6 19.4 19.5 16.6 19.9 13H23V11ZM12 18C8.7 18 6 15.3 6 12C6 8.7 8.7 6 12 6C15.3 6 18 8.7 18 12C18 15.3 15.3 18 12 18Z"></path></svg>',
  "settings-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M6.8 2C6.4 0.8 5.3 0 4 0C2.3 0 1 1.3 1 3C1 4.7 2.3 6 4 6C5.3 6 6.4 5.2 6.8 4H15V2H6.8ZM4 4C3.4 4 3 3.6 3 3C3 2.4 3.4 2 4 2C4.6 2 5 2.4 5 3C5 3.6 4.6 4 4 4ZM12 5C10.7 5 9.6 5.8 9.2 7H1V9H9.2C9.6 10.2 10.7 11 12 11C13.7 11 15 9.7 15 8C15 6.3 13.7 5 12 5ZM12 9C11.4 9 11 8.6 11 8C11 7.4 11.4 7 12 7C12.6 7 13 7.4 13 8C13 8.6 12.6 9 12 9ZM6 10C4.7 10 3.6 10.8 3.2 12H1V14H3.2C3.6 15.2 4.7 16 6 16C7.3 16 8.4 15.2 8.8 14H15V12H8.8C8.4 10.8 7.3 10 6 10ZM6 14C5.4 14 5 13.6 5 13C5 12.4 5.4 12 6 12C6.6 12 7 12.4 7 13C7 13.6 6.6 14 6 14Z"></path></svg>',
  "settings-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M9.9 4C9.4 2.3 7.9 1 6 1C3.8 1 2 2.8 2 5C2 7.2 3.8 9 6 9C7.9 9 9.4 7.7 9.9 6H22V4H9.9ZM6 7C4.9 7 4 6.1 4 5C4 3.9 4.9 3 6 3C7.1 3 8 3.9 8 5C8 6.1 7.1 7 6 7ZM9 15C7.1 15 5.6 16.3 5.1 18H2V20H5.1C5.5 21.7 7.1 23 9 23C10.9 23 12.4 21.7 12.9 20H22V18H12.9C12.4 16.3 10.9 15 9 15ZM9 21C7.9 21 7 20.1 7 19C7 17.9 7.9 17 9 17C10.1 17 11 17.9 11 19C11 20.1 10.1 21 9 21ZM18 8C16.1 8 14.6 9.3 14.1 11H2V13H14.1C14.5 14.7 16.1 16 18 16C20.2 16 22 14.2 22 12C22 9.8 20.2 8 18 8ZM18 14C16.9 14 16 13.1 16 12C16 10.9 16.9 10 18 10C19.1 10 20 10.9 20 12C20 13.1 19.1 14 18 14Z"></path></svg>',
  "smile-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_15858_138723)"><path d="M23.9966 14.16C22.8663 20.95 17.1547 24 12.0033 24C6.85193 24 1.15039 20.96 0.0100771 14.16C-0.0799473 13.62 0.290153 13.1 0.830299 13.01C1.37045 12.91 1.89059 13.29 1.98061 13.83C2.92087 19.47 7.69216 21.99 11.9933 21.99C16.2945 21.99 21.0658 19.47 22.006 13.83C22.0961 13.29 22.6162 12.91 23.1564 13.01C23.6965 13.1 24.0666 13.62 23.9766 14.16H23.9966ZM7.00197 7C7.55212 7 8.00224 6.55 8.00224 6V2C8.00224 1.45 7.55212 1 7.00197 1C6.45182 1 6.0017 1.45 6.0017 2V6C6.0017 6.55 6.45182 7 7.00197 7ZM17.0047 7C17.5548 7 18.005 6.55 18.005 6V2C18.005 1.45 17.5548 1 17.0047 1C16.4545 1 16.0044 1.45 16.0044 2V6C16.0044 6.55 16.4545 7 17.0047 7Z"></path></g><defs><clipPath id="clip0_15858_138723"><rect width="24" height="24" fill="white"></rect></clipPath></defs></svg>',
  "smiley-rate0-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M13.4101 12L22.7101 2.71C23.1001 2.32 23.1001 1.69 22.7101 1.3C22.3201 0.909998 21.6901 0.909998 21.3001 1.3L12.0101 10.59L2.71006 1.29C2.32006 0.899998 1.68006 0.899998 1.29006 1.29C0.900059 1.68 0.900059 2.32 1.29006 2.71L10.5801 12L1.29006 21.29C0.900059 21.68 0.900059 22.31 1.29006 22.7C1.49006 22.9 1.74006 22.99 2.00006 22.99C2.26006 22.99 2.51006 22.89 2.71006 22.7L12.0001 13.41L21.2901 22.7C21.4901 22.9 21.7401 22.99 22.0001 22.99C22.2601 22.99 22.5101 22.89 22.7101 22.7C23.1001 22.31 23.1001 21.68 22.7101 21.29L13.4201 12H13.4101Z"></path></svg>',
  "smiley-rate1-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M4 4.9938C4 4.44362 4.45 3.99348 5 3.99348H6.59L5.3 2.70306C4.91 2.31293 4.91 1.68272 5.3 1.2926C5.69 0.902468 6.32 0.902468 6.71 1.2926L9.71 4.29357C9.8 4.3836 9.88 4.49364 9.93 4.62368C10.03 4.86376 10.03 5.14385 9.93 5.38393C9.88 5.50397 9.81 5.614 9.71 5.71404L6.71 8.71501C6.51 8.91508 6.26 9.00511 6 9.00511C5.74 9.00511 5.49 8.90508 5.29 8.71501C4.9 8.32489 4.9 7.69468 5.29 7.30456L6.58 6.01413H4.99C4.44 6.01413 3.99 5.56399 3.99 5.01381L4 4.9938ZM14.08 5.37393C14.13 5.49397 14.2 5.604 14.3 5.70403L17.3 8.70501C17.5 8.90508 17.75 8.99511 18.01 8.99511C18.27 8.99511 18.52 8.89507 18.72 8.70501C19.11 8.31488 19.11 7.68468 18.72 7.29455L17.43 6.00413H19.02C19.57 6.00413 20.02 5.55399 20.02 5.00381C20.02 4.45363 19.57 4.00348 19.02 4.00348H17.43L18.72 2.71306C19.11 2.32293 19.11 1.69273 18.72 1.3026C18.33 0.912471 17.7 0.912471 17.31 1.3026L14.31 4.30358C14.22 4.39361 14.14 4.50364 14.09 4.63368C13.99 4.87376 13.99 5.15385 14.09 5.39393L14.08 5.37393ZM22 14.9971V20.999C22 22.6496 20.65 24 19 24H5C3.35 24 2 22.6496 2 20.999V14.9971C2 13.3465 3.35 11.9961 5 11.9961H19C20.65 11.9961 22 13.3465 22 14.9971ZM19 13.9967H16V16.9977H20V14.9971C20 14.4469 19.55 13.9967 19 13.9967ZM14 16.9977V13.9967H10V16.9977H14ZM10 18.9984V21.9993H14V18.9984H10ZM4 14.9971V16.9977H8V13.9967H5C4.45 13.9967 4 14.4469 4 14.9971ZM5 21.9993H8V18.9984H4V20.999C4 21.5492 4.45 21.9993 5 21.9993ZM20 20.999V18.9984H16V21.9993H19C19.55 21.9993 20 21.5492 20 20.999Z"></path></svg>',
  "smiley-rate10-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12.01 23C6.85721 23 1.15412 19.9621 0.0134987 13.1669C-0.0765501 12.6272 0.293651 12.1076 0.833944 12.0177C1.38424 11.9277 1.89452 12.2975 1.98457 12.8371C2.92508 18.4732 7.69767 20.9914 12 20.9914C16.3023 20.9914 21.0749 18.4732 22.0154 12.8371C22.1055 12.2975 22.6158 11.9277 23.1661 12.0177C23.7063 12.1076 24.0765 12.6272 23.9865 13.1669C22.8559 19.9521 17.1428 23 11.99 23H12.01ZM21.165 6.15177C22.3056 5.01257 22.3056 3.16386 21.165 2.02465L21.0049 1.85477C19.9143 0.765533 18.1633 0.725561 17.0227 1.71487C15.8821 0.715568 14.1312 0.765533 13.0406 1.85477L12.8705 2.01466C11.7299 3.15386 11.7299 5.00257 12.8705 6.14178L17.0227 10.2889L21.175 6.14178L21.165 6.15177ZM15.742 3.27378L17.0127 4.54289L18.2834 3.27378C18.6436 2.91403 19.2239 2.91403 19.5841 3.27378L19.7442 3.43367C20.1044 3.79342 20.1044 4.37301 19.7442 4.73276L17.0127 7.46086L14.2812 4.73276C13.921 4.37301 13.921 3.79342 14.2812 3.43367L14.4413 3.27378C14.6214 3.09391 14.8515 3.00397 15.0917 3.00397C15.3318 3.00397 15.5619 3.09391 15.742 3.27378ZM11.1595 6.15177C12.3002 5.01257 12.3002 3.16386 11.1595 2.02465L10.9995 1.85477C9.90886 0.765533 8.15792 0.725561 7.0173 1.71487C5.87668 0.715568 4.12573 0.765533 3.03514 1.85477L2.86505 2.01466C1.72443 3.15386 1.72443 5.00257 2.86505 6.14178L7.0173 10.2889L11.1695 6.14178L11.1595 6.15177ZM5.7366 3.27378L7.00729 4.54289L8.27798 3.27378C8.63818 2.91403 9.21849 2.91403 9.57869 3.27378L9.73877 3.43367C10.099 3.79342 10.099 4.37301 9.73877 4.73276L7.00729 7.46086L4.27581 4.73276C3.91562 4.37301 3.91562 3.79342 4.27581 3.43367L4.4359 3.27378C4.61599 3.09391 4.84612 3.00397 5.08625 3.00397C5.32638 3.00397 5.5565 3.09391 5.7366 3.27378Z"></path></svg>',
  "smiley-rate2-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_15894_140103)"><path d="M4.88291 4.51001C4.47291 4.51001 4.08291 4.25001 3.94291 3.84001C3.76291 3.32001 4.03291 2.75001 4.55291 2.57001L8.32291 1.25001C8.84291 1.06001 9.41291 1.34001 9.59291 1.86001C9.77291 2.38001 9.50291 2.95001 8.98291 3.13001L5.20291 4.45001C5.09291 4.49001 4.98291 4.51001 4.87291 4.51001H4.88291ZM19.8129 3.89001C20.0229 3.38001 19.7729 2.79001 19.2629 2.59001L15.5529 1.07001C15.0429 0.860007 14.4529 1.11001 14.2529 1.62001C14.0429 2.13001 14.2929 2.72001 14.8029 2.92001L18.5029 4.43001C18.6229 4.48001 18.7529 4.50001 18.8829 4.50001C19.2729 4.50001 19.6529 4.27001 19.8129 3.88001V3.89001ZM3.50291 6.00001C2.64291 6.37001 1.79291 6.88001 1.00291 7.48001C0.79291 7.64001 0.64291 7.87001 0.59291 8.14001C0.48291 8.73001 0.87291 9.29001 1.45291 9.40001C2.04291 9.51001 2.60291 9.12001 2.71291 8.54001C2.87291 7.69001 3.12291 6.83001 3.50291 5.99001V6.00001ZM21.0429 8.55001C21.6029 10.48 24.2429 8.84001 22.7529 7.48001C21.9629 6.88001 21.1129 6.37001 20.2529 6.00001C20.6329 6.84001 20.8829 7.70001 21.0429 8.55001ZM21.5729 13.2C21.2529 14.2 22.5429 15.09 23.3629 14.39C23.8529 14 23.9229 13.29 23.5429 12.81C21.7429 10.67 22.1329 10.55 21.5829 13.2H21.5729ZM1.75291 11C1.22291 11.79 -0.14709 12.64 0.0129102 13.75C0.15291 14.36 0.75291 14.74 1.35291 14.6C2.98291 14.1 1.80291 12.22 1.75291 11ZM19.8829 17C19.8829 13.14 16.2929 10 11.8829 10C7.47291 10 3.88291 13.14 3.88291 17C3.88291 20.86 7.47291 24 11.8829 24C16.2929 24 19.8829 20.86 19.8829 17ZM17.8829 17C17.8829 19.76 15.1929 22 11.8829 22C8.57291 22 5.88291 19.76 5.88291 17C5.88291 14.24 8.57291 12 11.8829 12C15.1929 12 17.8829 14.24 17.8829 17Z"></path></g><defs><clipPath id="clip0_15894_140103"><rect width="24" height="24" fill="white"></rect></clipPath></defs></svg>',
  "smiley-rate3-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M7.01915 7C6.46961 7 6.01998 6.55 6.01998 6V2C6.01998 1.45 6.46961 1 7.01915 1C7.56869 1 8.01832 1.45 8.01832 2V6C8.01832 6.55 7.56869 7 7.01915 7ZM18.01 6V2C18.01 1.45 17.5604 1 17.0108 1C16.4613 1 16.0117 1.45 16.0117 2V6C16.0117 6.55 16.4613 7 17.0108 7C17.5604 7 18.01 6.55 18.01 6ZM16.4213 21.58L18.01 19.99L19.2989 21.28C19.6886 21.67 20.3181 21.67 20.7077 21.28C21.0974 20.89 21.0974 20.26 20.7077 19.87L19.4188 18.58C18.6395 17.8 17.3705 17.8 16.5912 18.58L15.0025 20.17L13.4138 18.58C12.6345 17.8 11.3655 17.8 10.5862 18.58L8.9975 20.17L7.40883 18.58C6.62948 17.8 5.36053 17.8 4.58118 18.58L3.29226 19.87C2.90258 20.26 2.90258 20.89 3.29226 21.28C3.68193 21.67 4.31141 21.67 4.70108 21.28L5.99001 19.99L7.57868 21.58C8.35803 22.36 9.62698 22.36 10.4063 21.58L11.995 19.99L13.5837 21.58C13.9734 21.97 14.4829 22.16 14.9925 22.16C15.5021 22.16 16.0117 21.97 16.4013 21.58H16.4213Z"></path></svg>',
  "smiley-rate4-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M7.06927 7C6.51927 7 6.06927 6.55 6.06927 6V2C6.06927 1.45 6.51927 1 7.06927 1C7.61927 1 8.06927 1.45 8.06927 2V6C8.06927 6.55 7.61927 7 7.06927 7ZM18.0693 6V2C18.0693 1.45 17.6193 1 17.0693 1C16.5193 1 16.0693 1.45 16.0693 2V6C16.0693 6.55 16.5193 7 17.0693 7C17.6193 7 18.0693 6.55 18.0693 6ZM22.5693 21.9C23.0693 21.66 23.2793 21.07 23.0393 20.57C21.1093 16.52 16.9093 14 12.0693 14C7.22927 14 3.02927 16.52 1.09927 20.57C0.859273 21.07 1.06927 21.67 1.56927 21.9C2.06927 22.14 2.65927 21.93 2.89927 21.43C4.49927 18.08 8.00927 16 12.0593 16C16.1093 16 19.6293 18.08 21.2193 21.43C21.3893 21.79 21.7493 22 22.1193 22C22.2593 22 22.4093 21.97 22.5493 21.9H22.5693Z"></path></svg>',
  "smiley-rate5-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M7.00572 7C6.45572 7 6.00572 6.55 6.00572 6V2C6.00572 1.45 6.45572 1 7.00572 1C7.55572 1 8.00572 1.45 8.00572 2V6C8.00572 6.55 7.55572 7 7.00572 7ZM18.0057 6V2C18.0057 1.45 17.5557 1 17.0057 1C16.4557 1 16.0057 1.45 16.0057 2V6C16.0057 6.55 16.4557 7 17.0057 7C17.5557 7 18.0057 6.55 18.0057 6ZM19.9457 21.33C20.1257 20.81 19.8557 20.24 19.3357 20.05C14.5457 18.35 9.45572 18.35 4.66572 20.05C4.14572 20.23 3.87572 20.81 4.05572 21.33C4.23572 21.85 4.80572 22.12 5.33572 21.94C9.69572 20.4 14.3057 20.4 18.6657 21.94C18.7757 21.98 18.8857 22 18.9957 22C19.4057 22 19.7957 21.74 19.9357 21.33H19.9457Z"></path></svg>',
  "smiley-rate6-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M7 7C6.45 7 6 6.55 6 6V2C6 1.45 6.45 1 7 1C7.55 1 8 1.45 8 2V6C8 6.55 7.55 7 7 7ZM18 6V2C18 1.45 17.55 1 17 1C16.45 1 16 1.45 16 2V6C16 6.55 16.45 7 17 7C17.55 7 18 6.55 18 6ZM21 21C21 20.45 20.55 20 20 20H4C3.45 20 3 20.45 3 21C3 21.55 3.45 22 4 22H20C20.55 22 21 21.55 21 21Z"></path></svg>',
  "smiley-rate7-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12.0022 23.99C11.452 23.99 11.0018 23.5402 11.0018 22.9904C11.0018 22.4407 11.452 21.9909 12.0022 21.9909C16.3137 21.9909 21.0755 19.472 22.0158 13.8344C22.1058 13.2947 22.616 12.9248 23.1662 13.0148C23.7064 13.1047 24.0765 13.6245 23.9865 14.1643C22.8561 20.9513 17.144 24 11.9922 24L12.0022 23.99ZM8.00072 5.99783V1.99957C8.00072 1.4498 7.55056 1 7.00036 1C6.45016 1 6 1.4498 6 1.99957V5.99783C6 6.54759 6.45016 6.99739 7.00036 6.99739C7.55056 6.99739 8.00072 6.54759 8.00072 5.99783ZM18.0043 5.99783V1.99957C18.0043 1.4498 17.5542 1 17.004 1C16.4538 1 16.0036 1.4498 16.0036 1.99957V5.99783C16.0036 6.54759 16.4538 6.99739 17.004 6.99739C17.5542 6.99739 18.0043 6.54759 18.0043 5.99783Z"></path></svg>',
  "smiley-rate8-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12.01 24C6.85721 24 1.15412 20.96 0.0134987 14.16C-0.0765501 13.62 0.293651 13.1 0.833944 13.01C1.38424 12.92 1.89452 13.29 1.98457 13.83C2.92508 19.47 7.69767 21.99 12 21.99C16.3023 21.99 21.0749 19.47 22.0154 13.83C22.1055 13.29 22.6158 12.92 23.1661 13.01C23.7063 13.1 24.0765 13.62 23.9865 14.16C22.8559 20.95 17.1428 24 11.99 24H12.01ZM8.00783 6V2C8.00783 1.45 7.55759 1 7.00729 1C6.45699 1 6.00675 1.45 6.00675 2V6C6.00675 6.55 6.45699 7 7.00729 7C7.55759 7 8.00783 6.55 8.00783 6ZM18.0133 6V2C18.0133 1.45 17.563 1 17.0127 1C16.4624 1 16.0122 1.45 16.0122 2V6C16.0122 6.55 16.4624 7 17.0127 7C17.563 7 18.0133 6.55 18.0133 6Z"></path></svg>',
  "smiley-rate9-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12.01 24C6.85767 24 1.15509 20.96 0.0145752 14.16C-0.0354475 13.87 0.0445888 13.57 0.234675 13.35C0.424761 13.13 0.704888 13 0.995019 13H23.005C23.2951 13 23.5752 13.13 23.7653 13.35C23.9554 13.57 24.0354 13.87 23.9854 14.16C22.8549 20.95 17.1423 24 11.99 24H12.01ZM2.25559 15C3.61621 19.82 8.0182 22 12.01 22C16.0018 22 20.4038 19.82 21.7644 15H2.25559ZM8.00819 6V2C8.00819 1.45 7.55799 1 7.00774 1C6.45749 1 6.00729 1.45 6.00729 2V6C6.00729 6.55 6.45749 7 7.00774 7C7.55799 7 8.00819 6.55 8.00819 6ZM18.0127 6V2C18.0127 1.45 17.5625 1 17.0123 1C16.462 1 16.0118 1.45 16.0118 2V6C16.0118 6.55 16.462 7 17.0123 7C17.5625 7 18.0127 6.55 18.0127 6Z"></path></svg>',
  "speechbubble-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M8 11L13 6H3L8 11Z"></path></svg>',
  "switchoff-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M11 5C12.7 5 14 6.3 14 8C14 9.7 12.7 11 11 11H5C3.3 11 2 9.7 2 8C2 6.3 3.3 5 5 5H11ZM11 3H5C2.2 3 0 5.2 0 8C0 10.8 2.2 13 5 13H11C13.8 13 16 10.8 16 8C16 5.2 13.8 3 11 3ZM5 6C3.9 6 3 6.9 3 8C3 9.1 3.9 10 5 10C6.1 10 7 9.1 7 8C7 6.9 6.1 6 5 6Z"></path></svg>',
  "switchon-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M11 5C12.7 5 14 6.3 14 8C14 9.7 12.7 11 11 11H5C3.3 11 2 9.7 2 8C2 6.3 3.3 5 5 5H11ZM11 3H5C2.2 3 0 5.2 0 8C0 10.8 2.2 13 5 13H11C13.8 13 16 10.8 16 8C16 5.2 13.8 3 11 3ZM11 6C9.9 6 9 6.9 9 8C9 9.1 9.9 10 11 10C12.1 10 13 9.1 13 8C13 6.9 12.1 6 11 6Z"></path></svg>',
  "tablet-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20 18H4V6H20V18ZM21 4H3C2.46957 4 1.96086 4.21071 1.58579 4.58579C1.21071 4.96086 1 5.46957 1 6V18C1 18.5304 1.21071 19.0391 1.58579 19.4142C1.96086 19.7893 2.46957 20 3 20H21C21.5304 20 22.0391 19.7893 22.4142 19.4142C22.7893 19.0391 23 18.5304 23 18V6C23 5.46957 22.7893 4.96086 22.4142 4.58579C22.0391 4.21071 21.5304 4 21 4Z"></path></svg>',
  "textedit-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M13 5H2V3H13V5ZM10 7H2V9H10V7ZM2 17H10V15H2V17ZM13 11H2V13H13V11ZM23.4 14.9L17 21.3C16 22.4 14.5 23 13 23H11.6C11.3 23 11 22.7 11 22.4V21C11 19.5 11.6 18.1 12.7 17L19.1 10.6C19.4 10.2 19.9 10 20.4 10C20.9 10 21.4 10.2 21.7 10.6L23.4 12.3C24.2 13 24.2 14.2 23.4 14.9ZM21.9 13.6L20.3 12L14 18.3C13.4 19.1 13 20 13 21C14 21 14.9 20.6 15.6 19.9L21.9 13.6Z"></path></svg>',
  "theme-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_9352_93115)"><path d="M24 21.4201C23.9387 22.1566 23.5894 22.8394 23.0278 23.3202C22.4662 23.8011 21.7376 24.0413 21 23.9888C20.2624 24.0413 19.5338 23.8011 18.9722 23.3202C18.4106 22.8394 18.0613 22.1566 18 21.4201C18 18.8513 21 16.2826 21 14.9932C21 16.2826 24 18.8513 24 21.4201ZM22 12.9942L11 1.99951L8.71 4.2884L10.12 5.70771L11 4.82814L18.17 11.9946L5.64 15.8028L2.83 12.9942L7.71 8.11653L9.29 9.70576C9.38296 9.79944 9.49356 9.8738 9.61542 9.92455C9.73728 9.97529 9.86799 10.0014 10 10.0014C10.132 10.0014 10.2627 9.97529 10.3846 9.92455C10.5064 9.8738 10.617 9.79944 10.71 9.70576C10.8037 9.61284 10.8781 9.5023 10.9289 9.3805C10.9797 9.2587 11.0058 9.12805 11.0058 8.99611C11.0058 8.86416 10.9797 8.73352 10.9289 8.61172C10.8781 8.48992 10.8037 8.37937 10.71 8.28645L3.71 1.28986C3.5217 1.10165 3.2663 0.995911 3 0.995911C2.7337 0.995911 2.4783 1.10165 2.29 1.28986C2.1017 1.47807 1.99591 1.73334 1.99591 1.99951C1.99591 2.26569 2.1017 2.52096 2.29 2.70917L6.29 6.70722L0 12.9942L10 22.9893L18 14.9932L22 12.9942Z"></path></g><defs><clipPath id="clip0_9352_93115"><rect width="24" height="24" fill="white"></rect></clipPath></defs></svg>',
  "toolbox-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M21 4H16V2C16 1.46957 15.7893 0.960859 15.4142 0.585786C15.0391 0.210714 14.5304 0 14 0L10 0C9.46957 0 8.96086 0.210714 8.58579 0.585786C8.21071 0.960859 8 1.46957 8 2V4H3C2.46957 4 1.96086 4.21071 1.58579 4.58579C1.21071 4.96086 1 5.46957 1 6V12H2V20C2 20.5304 2.21071 21.0391 2.58579 21.4142C2.96086 21.7893 3.46957 22 4 22H20C20.5304 22 21.0391 21.7893 21.4142 21.4142C21.7893 21.0391 22 20.5304 22 20V12H23V6C23 5.46957 22.7893 4.96086 22.4142 4.58579C22.0391 4.21071 21.5304 4 21 4ZM10 2H14V4H10V2ZM20 20H4V12H9V16H15V12H20V20ZM11 14V10H13V14H11ZM21 10H15V8H9V10H3V6H21V10Z"></path></svg>',
  "toolbox-boolean-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M4.66658 7.33334H11.3333C13.1999 7.33334 14.6666 5.86667 14.6666 4.00001C14.6666 2.13334 13.1999 0.666672 11.3333 0.666672H4.66658C2.79992 0.666672 1.33325 2.13334 1.33325 4.00001C1.33325 5.86667 2.79992 7.33334 4.66658 7.33334ZM4.66658 2.00001H11.3333C12.4666 2.00001 13.3333 2.86667 13.3333 4.00001C13.3333 5.13334 12.4666 6.00001 11.3333 6.00001H4.66658C3.53325 6.00001 2.66659 5.13334 2.66659 4.00001C2.66659 2.86667 3.53325 2.00001 4.66658 2.00001ZM3.33325 4.00001C3.33325 3.26667 3.93325 2.66667 4.66658 2.66667C5.39992 2.66667 5.99992 3.26667 5.99992 4.00001C5.99992 4.73334 5.39992 5.33334 4.66658 5.33334C3.93325 5.33334 3.33325 4.73334 3.33325 4.00001ZM12.6666 12C12.6666 12.7333 12.0666 13.3333 11.3333 13.3333C10.5999 13.3333 9.99992 12.7333 9.99992 12C9.99992 11.2667 10.5999 10.6667 11.3333 10.6667C12.0666 10.6667 12.6666 11.2667 12.6666 12ZM11.3333 8.66667H4.66658C2.79992 8.66667 1.33325 10.1333 1.33325 12C1.33325 13.8667 2.79992 15.3333 4.66658 15.3333H11.3333C13.1999 15.3333 14.6666 13.8667 14.6666 12C14.6666 10.1333 13.1999 8.66667 11.3333 8.66667ZM11.3333 14H4.66658C3.53325 14 2.66659 13.1333 2.66659 12C2.66659 10.8667 3.53325 10 4.66658 10H11.3333C12.4666 10 13.3333 10.8667 13.3333 12C13.3333 13.1333 12.4666 14 11.3333 14Z"></path></svg>',
  "toolbox-boolean-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M7 11H17C19.8 11 22 8.8 22 6C22 3.2 19.8 1 17 1H7C4.2 1 2 3.2 2 6C2 8.8 4.2 11 7 11ZM7 3H17C18.7 3 20 4.3 20 6C20 7.7 18.7 9 17 9H7C5.3 9 4 7.7 4 6C4 4.3 5.3 3 7 3ZM5 6C5 4.9 5.9 4 7 4C8.1 4 9 4.9 9 6C9 7.1 8.1 8 7 8C5.9 8 5 7.1 5 6ZM19 18C19 19.1 18.1 20 17 20C15.9 20 15 19.1 15 18C15 16.9 15.9 16 17 16C18.1 16 19 16.9 19 18ZM17 13H7C4.2 13 2 15.2 2 18C2 20.8 4.2 23 7 23H17C19.8 23 22 20.8 22 18C22 15.2 19.8 13 17 13ZM17 21H7C5.3 21 4 19.7 4 18C4 16.3 5.3 15 7 15H17C18.7 15 20 16.3 20 18C20 19.7 18.7 21 17 21Z"></path></svg>',
  "toolbox-checkbox-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M12.6667 5.93333L14 4.06667V12.6667C14 13.4 13.4 14 12.6667 14H3.33333C2.6 14 2 13.4 2 12.6667V3.33333C2 2.6 2.6 2 3.33333 2H12.6667C12.6667 2 12.6667 2 12.7333 2L13.8667 0.400002L14.9333 1.2L7.4 11.6667L4.4 8.66667L5.33333 7.73333L7.26667 9.66667L11.8 3.33333H3.33333V12.6667H12.6667V5.93333Z"></path></svg>',
  "toolbox-checkbox-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M19 8.9L21 6.1V19C21 20.1 20.1 21 19 21H5C3.9 21 3 20.1 3 19V5C3 3.9 3.9 3 5 3H19C19 3 19 3 19.1 3L20.8 0.599998L22.4 1.8L11.1 17.5L6.6 13L8 11.6L10.9 14.5L17.7 5H5V19H19V8.9Z"></path></svg>',
  "toolbox-customquestion-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M7.99992 2.66665C10.9399 2.66665 13.3333 4.75998 13.3333 7.33331C13.3267 7.95199 13.1883 8.56216 12.9274 9.12314C12.6664 9.68413 12.2889 10.1831 11.8199 10.5866C11.6735 10.72 11.5586 10.8844 11.4837 11.0678C11.4087 11.2511 11.3755 11.4489 11.3866 11.6466C11.1834 11.5315 10.9535 11.4717 10.7199 11.4733C10.549 11.4746 10.3798 11.5062 10.2199 11.5666C9.51469 11.8526 8.76091 11.9997 7.99992 12C5.05992 12 2.66659 9.90665 2.66659 7.33331C2.66659 4.75998 5.05992 2.66665 7.99992 2.66665ZM7.99992 1.33331C4.31992 1.33331 1.33325 3.99998 1.33325 7.33331C1.33325 10.6666 4.31992 13.3333 7.99992 13.3333C8.93406 13.333 9.85954 13.1543 10.7266 12.8066L13.3333 14.6666L12.7133 11.5733C13.3197 11.0445 13.8072 10.3932 14.1439 9.66246C14.4806 8.93167 14.6587 8.13788 14.6666 7.33331C14.6666 3.99998 11.6799 1.33331 7.99992 1.33331Z"></path></svg>',
  "toolbox-customquestion-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 4C16.41 4 20 7.14 20 11C19.9901 11.928 19.7826 12.8433 19.3911 13.6847C18.9997 14.5262 18.4334 15.2746 17.73 15.88C17.5103 16.0801 17.338 16.3266 17.2256 16.6017C17.1132 16.8767 17.0634 17.1733 17.08 17.47C16.7752 17.2972 16.4304 17.2076 16.08 17.21C15.8237 17.212 15.5698 17.2594 15.33 17.35C14.2722 17.7789 13.1415 17.9996 12 18C7.59 18 4 14.86 4 11C4 7.14 7.59 4 12 4ZM12 2C6.48 2 2 6 2 11C2 16 6.48 20 12 20C13.4012 19.9996 14.7894 19.7314 16.09 19.21L20 22L19.07 17.36C19.9796 16.5667 20.711 15.5899 21.216 14.4937C21.721 13.3975 21.9882 12.2069 22 11C22 6 17.52 2 12 2Z"></path></svg>',
  "toolbox-dropdown-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M13.3333 1.33331H2.66659C1.93325 1.33331 1.33325 1.93331 1.33325 2.66665V3.99998C1.33325 4.73331 1.93325 5.33331 2.66659 5.33331V13.3333C2.66659 14.0666 3.26659 14.6666 3.99992 14.6666H13.3333C14.0666 14.6666 14.6666 14.0666 14.6666 13.3333V5.33331V3.99998V2.66665C14.6666 1.93331 14.0666 1.33331 13.3333 1.33331ZM13.3333 13.3333H3.99992V5.33331H13.3333V13.3333ZM2.66659 3.99998V2.66665H13.3333V3.99998H2.66659ZM11.9999 7.99998H5.33325V6.66665H11.9999V7.99998ZM11.9999 10.6666H5.33325V9.33331H11.9999V10.6666Z"></path></svg>',
  "toolbox-dropdown-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20 2H4C2.9 2 2 2.9 2 4V6C2 7.1 2.9 8 4 8V20C4 21.1 4.9 22 6 22H20C21.1 22 22 21.1 22 20V8V6V4C22 2.9 21.1 2 20 2ZM20 20H6V8H20V20ZM4 6V4H20V6H4ZM18 12H8V10H18V12ZM18 16H8V14H18V16Z"></path></svg>',
  "toolbox-dynamicmatrix-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_22761_58174)"><path d="M4.66675 2.66666C4.66675 3.79999 3.80008 4.66666 2.66675 4.66666C1.53341 4.66666 0.666748 3.79999 0.666748 2.66666C0.666748 1.53332 1.53341 0.666656 2.66675 0.666656C3.80008 0.666656 4.66675 1.53332 4.66675 2.66666ZM10.0001 2.66666C10.0001 3.79999 9.13342 4.66666 8.00008 4.66666C6.86675 4.66666 6.00008 3.79999 6.00008 2.66666C6.00008 1.53332 6.86675 0.666656 8.00008 0.666656C9.13342 0.666656 10.0001 1.53332 10.0001 2.66666ZM8.66675 2.66666C8.66675 2.26666 8.40008 1.99999 8.00008 1.99999C7.60008 1.99999 7.33342 2.26666 7.33342 2.66666C7.33342 3.06666 7.60008 3.33332 8.00008 3.33332C8.40008 3.33332 8.66675 3.06666 8.66675 2.66666ZM11.3334 2.66666C11.3334 1.53332 12.2001 0.666656 13.3334 0.666656C14.4667 0.666656 15.3334 1.53332 15.3334 2.66666C15.3334 3.79999 14.4667 4.66666 13.3334 4.66666C12.2001 4.66666 11.3334 3.79999 11.3334 2.66666ZM12.6667 2.66666C12.6667 3.06666 12.9334 3.33332 13.3334 3.33332C13.7334 3.33332 14.0001 3.06666 14.0001 2.66666C14.0001 2.26666 13.7334 1.99999 13.3334 1.99999C12.9334 1.99999 12.6667 2.26666 12.6667 2.66666ZM4.66675 7.99999C4.66675 9.13332 3.80008 9.99999 2.66675 9.99999C1.53341 9.99999 0.666748 9.13332 0.666748 7.99999C0.666748 6.86666 1.53341 5.99999 2.66675 5.99999C3.80008 5.99999 4.66675 6.86666 4.66675 7.99999ZM3.33341 7.99999C3.33341 7.59999 3.06675 7.33332 2.66675 7.33332C2.26675 7.33332 2.00008 7.59999 2.00008 7.99999C2.00008 8.39999 2.26675 8.66666 2.66675 8.66666C3.06675 8.66666 3.33341 8.39999 3.33341 7.99999ZM8.00008 5.99999C6.86675 5.99999 6.00008 6.86666 6.00008 7.99999C6.00008 9.13332 6.86675 9.99999 8.00008 9.99999C9.13342 9.99999 10.0001 9.13332 10.0001 7.99999C10.0001 6.86666 9.13342 5.99999 8.00008 5.99999ZM13.3334 5.99999C12.2001 5.99999 11.3334 6.86666 11.3334 7.99999C11.3334 9.13332 12.2001 9.99999 13.3334 9.99999C14.4667 9.99999 15.3334 9.13332 15.3334 7.99999C15.3334 6.86666 14.4667 5.99999 13.3334 5.99999ZM3.33341 11.3333H2.00008V12.6667H0.666748V14H2.00008V15.3333H3.33341V14H4.66675V12.6667H3.33341V11.3333Z"></path></g><defs><clipPath id="clip0_22761_58174"><rect width="16" height="16" fill="white"></rect></clipPath></defs></svg>',
  "toolbox-dynamicmatrix-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M7 4C7 5.7 5.7 7 4 7C2.3 7 1 5.7 1 4C1 2.3 2.3 1 4 1C5.7 1 7 2.3 7 4ZM15 4C15 5.7 13.7 7 12 7C10.3 7 9 5.7 9 4C9 2.3 10.3 1 12 1C13.7 1 15 2.3 15 4ZM13 4C13 3.4 12.6 3 12 3C11.4 3 11 3.4 11 4C11 4.6 11.4 5 12 5C12.6 5 13 4.6 13 4ZM17 4C17 2.3 18.3 1 20 1C21.7 1 23 2.3 23 4C23 5.7 21.7 7 20 7C18.3 7 17 5.7 17 4ZM19 4C19 4.6 19.4 5 20 5C20.6 5 21 4.6 21 4C21 3.4 20.6 3 20 3C19.4 3 19 3.4 19 4ZM7 12C7 13.7 5.7 15 4 15C2.3 15 1 13.7 1 12C1 10.3 2.3 9 4 9C5.7 9 7 10.3 7 12ZM5 12C5 11.4 4.6 11 4 11C3.4 11 3 11.4 3 12C3 12.6 3.4 13 4 13C4.6 13 5 12.6 5 12ZM12 9C10.3 9 9 10.3 9 12C9 13.7 10.3 15 12 15C13.7 15 15 13.7 15 12C15 10.3 13.7 9 12 9ZM20 9C18.3 9 17 10.3 17 12C17 13.7 18.3 15 20 15C21.7 15 23 13.7 23 12C23 10.3 21.7 9 20 9ZM5 17H3V19H1V21H3V23H5V21H7V19H5V17Z"></path></svg>',
  "toolbox-dynamicpanel-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M5.99992 1.33334V2.66668H2.66659V6.00001H1.33325V2.66668C1.33325 2.31305 1.47373 1.97392 1.72378 1.72387C1.97382 1.47382 2.31296 1.33334 2.66659 1.33334H5.99992ZM13.3333 1.33334H9.99992V2.66668H13.3333V6.00001H14.6666V2.66668C14.6666 2.31305 14.5261 1.97392 14.2761 1.72387C14.026 1.47382 13.6869 1.33334 13.3333 1.33334ZM2.66659 13.3333V10H1.33325V13.3333C1.33325 13.687 1.47373 14.0261 1.72378 14.2762C1.97382 14.5262 2.31296 14.6667 2.66659 14.6667H5.99992V13.3333H2.66659ZM13.3333 13.3333H9.99992V14.6667H13.3333C13.6869 14.6667 14.026 14.5262 14.2761 14.2762C14.5261 14.0261 14.6666 13.687 14.6666 13.3333V10H13.3333V13.3333ZM11.3333 8.66668H9.99992V7.33334H8.66658V8.66668H7.33325V10H8.66658V11.3333H9.99992V10H11.3333V8.66668Z"></path></svg>',
  "toolbox-dynamicpanel-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M9 2V4H4V9H2V4C2 3.46957 2.21071 2.96086 2.58579 2.58579C2.96086 2.21071 3.46957 2 4 2H9ZM20 2H15V4H20V9H22V4C22 3.46957 21.7893 2.96086 21.4142 2.58579C21.0391 2.21071 20.5304 2 20 2ZM4 20V15H2V20C2 20.5304 2.21071 21.0391 2.58579 21.4142C2.96086 21.7893 3.46957 22 4 22H9V20H4ZM20 20H15V22H20C20.5304 22 21.0391 21.7893 21.4142 21.4142C21.7893 21.0391 22 20.5304 22 20V15H20V20ZM17 13H15V11H13V13H11V15H13V17H15V15H17V13Z"></path></svg>',
  "toolbox-expression-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M13.3333 0.333333C12.9333 0.133333 12.4667 0 11.8667 0C10.6 0 9.53333 0.533333 8.66667 1.53333C7.66667 2.73333 6.73333 4.73333 6 7.66667H4.13333L3.86667 8.66667H5.66667L5.53333 9.33333C5.46667 9.6 5.4 9.93333 5.26667 10.4667C5.13333 10.9333 5.06667 11.4 5 11.7333C4.53333 13.7333 4.06667 14.6 3.73333 14.9333C3.73333 14.7333 3.66667 14.5333 3.46667 14.4C3.13333 14.2 2.53333 14.1333 2.2 14.5333C2.06667 14.6667 2 14.9333 2 15.1333C2 15.4 2.06667 15.6 2.26667 15.7333C2.46667 15.9333 2.8 16 3.2 16C3.6 16 4 15.9333 4.33333 15.7333C5.26667 15.3333 6 14.4667 6.53333 13.0667C6.8 12.3333 7.2 11.1333 7.6 9.4L7.8 8.6H10.0667L10.3333 7.6H8.06667C8.73333 4.8 9.46667 2.8 10.2 1.8C10.4 1.53333 10.6 1.33333 10.8 1.2C11.0667 1 11.2 1 11.3333 1C11.4667 1 11.6 1 11.8 1.06667C11.6667 1.26667 11.6667 1.46667 11.6667 1.66667C11.6667 1.93333 11.8 2.2 12 2.4C12.4667 2.73333 13.2 2.73333 13.6667 2.4C13.8667 2.13333 14 1.86667 14 1.53333C14 1 13.8 0.6 13.3333 0.333333Z"></path></svg>',
  "toolbox-expression-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20 0.5C19.4 0.2 18.7 0 17.8 0C15.9 0 14.3 0.8 13 2.3C11.5 4.1 10.1 7.1 9 11.5H6.2L5.8 13H8.5L8.3 14C8.2 14.4 8.1 14.9 7.9 15.7C7.7 16.4 7.6 17.1 7.5 17.6C6.8 20.6 6.1 21.9 5.6 22.4C5.6 22.1 5.5 21.8 5.2 21.6C4.7 21.3 3.8 21.2 3.3 21.8C3.1 22 3 22.4 3 22.7C3 23.1 3.1 23.4 3.4 23.6C3.7 23.9 4.2 24 4.8 24C5.4 24 6 23.9 6.5 23.6C7.9 23 9 21.7 9.8 19.6C10.2 18.5 10.8 16.7 11.4 14.1L11.7 12.9H15.1L15.5 11.4H12.1C13.1 7.2 14.2 4.2 15.3 2.7C15.6 2.3 15.9 2 16.2 1.8C16.6 1.5 16.8 1.5 17 1.5C17.2 1.5 17.4 1.5 17.7 1.6C17.5 1.9 17.5 2.2 17.5 2.5C17.5 2.9 17.7 3.3 18 3.6C18.7 4.1 19.8 4.1 20.5 3.6C20.8 3.2 21 2.8 21 2.3C21 1.5 20.7 0.9 20 0.5Z"></path></svg>',
  "toolbox-file-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_22761_58159)"><path d="M14.6666 6V4.66667C14.6666 3.93333 14.0666 3.33333 13.3333 3.33333H7.99992L6.66659 2H2.66659C1.93325 2 1.33325 2.6 1.33325 3.33333V6V6.66667V14H14.6666L15.9999 6H14.6666ZM2.66659 3.33333H6.13325L7.06659 4.26667L7.46659 4.66667H7.99992H13.3333V6H2.66659V3.33333ZM13.5333 12.6667H2.66659V7.33333H14.3999L13.5333 12.6667Z"></path></g><defs><clipPath id="clip0_22761_58159"><rect width="16" height="16" fill="white"></rect></clipPath></defs></svg>',
  "toolbox-file-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M22 9V7C22 5.9 21.1 5 20 5H12L10 3H4C2.9 3 2 3.9 2 5V9V10V21H22L24 9H22ZM4 5H9.2L10.6 6.4L11.2 7H12H20V9H4V5ZM20.3 19H4V11H21.6L20.3 19Z"></path></svg>',
  "toolbox-html-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M5.23333 4.43333L2.23333 7.96666L5.23333 11.5667L4.16667 12.4333L0.5 7.96666L4.16667 3.56666L5.23333 4.43333ZM11.9 3.56666L10.8333 4.43333L13.8333 7.96666L10.8333 11.5667L11.8333 12.4333L15.5 8.03333L11.9 3.56666ZM5.43333 13.7667L6.7 14.1667L10.7 2.16666L9.43333 1.76666L5.43333 13.7667Z"></path></svg>',
  "toolbox-html-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M7.85 6.65002L3.35 11.95L7.85 17.35L6.25 18.65L0.75 11.95L6.25 5.35002L7.85 6.65002ZM17.85 5.35002L16.25 6.65002L20.75 11.95L16.25 17.35L17.75 18.65L23.25 12.05L17.85 5.35002ZM8.15 20.65L10.05 21.25L16.05 3.25002L14.15 2.65002L8.15 20.65Z"></path></svg>',
  "toolbox-image-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M13.3333 1.33333H2.66659C1.93325 1.33333 1.33325 1.93333 1.33325 2.66666V13.3333C1.33325 14.0667 1.93325 14.6667 2.66659 14.6667H13.3333C14.0666 14.6667 14.6666 14.0667 14.6666 13.3333V2.66666C14.6666 1.93333 14.0666 1.33333 13.3333 1.33333ZM13.3333 13.3333H2.66659V2.66666H13.3333V13.3333ZM4.66658 5.33333C4.66658 4.59999 5.26659 3.99999 5.99992 3.99999C6.73325 3.99999 7.33325 4.59999 7.33325 5.33333C7.33325 6.06666 6.73325 6.66666 5.99992 6.66666C5.26659 6.66666 4.66658 6.06666 4.66658 5.33333ZM12.6666 12.6667H3.33325L5.99992 9.33333L7.33325 9.99999L9.33325 7.99999L12.6666 12.6667Z"></path></svg>',
  "toolbox-image-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20 2H4C2.9 2 2 2.9 2 4V20C2 21.1 2.9 22 4 22H20C21.1 22 22 21.1 22 20V4C22 2.9 21.1 2 20 2ZM20 20H4V4H20V20ZM7 8C7 6.9 7.9 6 9 6C10.1 6 11 6.9 11 8C11 9.1 10.1 10 9 10C7.9 10 7 9.1 7 8ZM19 19H5L9 14L11 15L14 12L19 19Z"></path></svg>',
  "toolbox-imagepicker-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M11.3333 3.33331H2.66659C1.93325 3.33331 1.33325 3.93331 1.33325 4.66665V13.3333C1.33325 14.0666 1.93325 14.6666 2.66659 14.6666H11.3333C12.0666 14.6666 12.6666 14.0666 12.6666 13.3333V4.66665C12.6666 3.93331 12.0666 3.33331 11.3333 3.33331ZM11.3333 13.3333H2.66659V4.66665H11.3333V13.3333ZM3.99992 7.33331C3.99992 6.59998 4.59992 5.99998 5.33325 5.99998C6.06659 5.99998 6.66658 6.59998 6.66658 7.33331C6.66658 8.06665 6.06659 8.66665 5.33325 8.66665C4.59992 8.66665 3.99992 8.06665 3.99992 7.33331ZM10.6666 12.6666H3.33325L10.6666 9.33331V12.6666ZM14.6666 2.66665V11.3333C14.6666 12.0666 14.0666 12.6666 13.3333 12.6666V11.3333V2.66665H4.66658H3.33325C3.33325 1.93331 3.93325 1.33331 4.66658 1.33331H13.3333C14.0666 1.33331 14.6666 1.93331 14.6666 2.66665Z"></path></svg>',
  "toolbox-imagepicker-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M17 5H4C2.9 5 2 5.9 2 7V20C2 21.1 2.9 22 4 22H17C18.1 22 19 21.1 19 20V7C19 5.9 18.1 5 17 5ZM17 20H4V7H17V20ZM6 11C6 9.9 6.9 9 8 9C9.1 9 10 9.9 10 11C10 12.1 9.1 13 8 13C6.9 13 6 12.1 6 11ZM16 19H5L16 14V19ZM22 4V17C22 18.1 21.1 19 20 19V17V4H7H5C5 2.9 5.9 2 7 2H20C21.1 2 22 2.9 22 4Z"></path></svg>',
  "toolbox-longtext-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M13.3333 2H2.66659C1.93325 2 1.33325 2.6 1.33325 3.33333V12.6667C1.33325 13.4 1.93325 14 2.66659 14H13.3333C14.0666 14 14.6666 13.4 14.6666 12.6667V3.33333C14.6666 2.6 14.0666 2 13.3333 2ZM13.3333 12.6667H2.66659V3.33333H13.3333V12.6667ZM11.9999 6H3.99992V4.66667H11.9999V6ZM11.9999 8.66667H3.99992V7.33333H11.9999V8.66667ZM7.99992 11.3333H3.99992V10H7.99992V11.3333Z"></path></svg>',
  "toolbox-longtext-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20 3H4C2.9 3 2 3.9 2 5V19C2 20.1 2.9 21 4 21H20C21.1 21 22 20.1 22 19V5C22 3.9 21.1 3 20 3ZM20 19H4V5H20V19ZM18 9H6V7H18V9ZM18 13H6V11H18V13ZM12 17H6V15H12V17Z"></path></svg>',
  "toolbox-matrix-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_22761_58164)"><path d="M4.00008 0.666656C2.13341 0.666656 0.666748 2.13332 0.666748 3.99999C0.666748 5.86666 2.13341 7.33332 4.00008 7.33332C5.86675 7.33332 7.33342 5.86666 7.33342 3.99999C7.33342 2.13332 5.86675 0.666656 4.00008 0.666656ZM4.00008 5.99999C2.86675 5.99999 2.00008 5.13332 2.00008 3.99999C2.00008 2.86666 2.86675 1.99999 4.00008 1.99999C5.13341 1.99999 6.00008 2.86666 6.00008 3.99999C6.00008 5.13332 5.13341 5.99999 4.00008 5.99999ZM5.33342 3.99999C5.33342 4.73332 4.73341 5.33332 4.00008 5.33332C3.26675 5.33332 2.66675 4.73332 2.66675 3.99999C2.66675 3.26666 3.26675 2.66666 4.00008 2.66666C4.73341 2.66666 5.33342 3.26666 5.33342 3.99999ZM13.3334 12C13.3334 12.7333 12.7334 13.3333 12.0001 13.3333C11.2667 13.3333 10.6667 12.7333 10.6667 12C10.6667 11.2667 11.2667 10.6667 12.0001 10.6667C12.7334 10.6667 13.3334 11.2667 13.3334 12ZM4.00008 8.66666C2.13341 8.66666 0.666748 10.1333 0.666748 12C0.666748 13.8667 2.13341 15.3333 4.00008 15.3333C5.86675 15.3333 7.33342 13.8667 7.33342 12C7.33342 10.1333 5.86675 8.66666 4.00008 8.66666ZM4.00008 14C2.86675 14 2.00008 13.1333 2.00008 12C2.00008 10.8667 2.86675 9.99999 4.00008 9.99999C5.13341 9.99999 6.00008 10.8667 6.00008 12C6.00008 13.1333 5.13341 14 4.00008 14ZM12.0001 7.33332C13.8667 7.33332 15.3334 5.86666 15.3334 3.99999C15.3334 2.13332 13.8667 0.666656 12.0001 0.666656C10.1334 0.666656 8.66675 2.13332 8.66675 3.99999C8.66675 5.86666 10.1334 7.33332 12.0001 7.33332ZM12.0001 1.99999C13.1334 1.99999 14.0001 2.86666 14.0001 3.99999C14.0001 5.13332 13.1334 5.99999 12.0001 5.99999C10.8667 5.99999 10.0001 5.13332 10.0001 3.99999C10.0001 2.86666 10.8667 1.99999 12.0001 1.99999ZM12.0001 8.66666C10.1334 8.66666 8.66675 10.1333 8.66675 12C8.66675 13.8667 10.1334 15.3333 12.0001 15.3333C13.8667 15.3333 15.3334 13.8667 15.3334 12C15.3334 10.1333 13.8667 8.66666 12.0001 8.66666ZM12.0001 14C10.8667 14 10.0001 13.1333 10.0001 12C10.0001 10.8667 10.8667 9.99999 12.0001 9.99999C13.1334 9.99999 14.0001 10.8667 14.0001 12C14.0001 13.1333 13.1334 14 12.0001 14Z"></path></g><defs><clipPath id="clip0_22761_58164"><rect width="16" height="16" fill="white"></rect></clipPath></defs></svg>',
  "toolbox-matrix-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M6 1C3.2 1 1 3.2 1 6C1 8.8 3.2 11 6 11C8.8 11 11 8.8 11 6C11 3.2 8.8 1 6 1ZM6 9C4.3 9 3 7.7 3 6C3 4.3 4.3 3 6 3C7.7 3 9 4.3 9 6C9 7.7 7.7 9 6 9ZM8 6C8 7.1 7.1 8 6 8C4.9 8 4 7.1 4 6C4 4.9 4.9 4 6 4C7.1 4 8 4.9 8 6ZM20 18C20 19.1 19.1 20 18 20C16.9 20 16 19.1 16 18C16 16.9 16.9 16 18 16C19.1 16 20 16.9 20 18ZM6 13C3.2 13 1 15.2 1 18C1 20.8 3.2 23 6 23C8.8 23 11 20.8 11 18C11 15.2 8.8 13 6 13ZM6 21C4.3 21 3 19.7 3 18C3 16.3 4.3 15 6 15C7.7 15 9 16.3 9 18C9 19.7 7.7 21 6 21ZM18 11C20.8 11 23 8.8 23 6C23 3.2 20.8 1 18 1C15.2 1 13 3.2 13 6C13 8.8 15.2 11 18 11ZM18 3C19.7 3 21 4.3 21 6C21 7.7 19.7 9 18 9C16.3 9 15 7.7 15 6C15 4.3 16.3 3 18 3ZM18 13C15.2 13 13 15.2 13 18C13 20.8 15.2 23 18 23C20.8 23 23 20.8 23 18C23 15.2 20.8 13 18 13ZM18 21C16.3 21 15 19.7 15 18C15 16.3 16.3 15 18 15C19.7 15 21 16.3 21 18C21 19.7 19.7 21 18 21Z"></path></svg>',
  "toolbox-multimatrix-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_22761_58169)"><path d="M4.66675 2.66666C4.66675 3.79999 3.80008 4.66666 2.66675 4.66666C1.53341 4.66666 0.666748 3.79999 0.666748 2.66666C0.666748 1.53332 1.53341 0.666656 2.66675 0.666656C3.80008 0.666656 4.66675 1.53332 4.66675 2.66666ZM10.0001 2.66666C10.0001 3.79999 9.13342 4.66666 8.00008 4.66666C6.86675 4.66666 6.00008 3.79999 6.00008 2.66666C6.00008 1.53332 6.86675 0.666656 8.00008 0.666656C9.13342 0.666656 10.0001 1.53332 10.0001 2.66666ZM8.66675 2.66666C8.66675 2.26666 8.40008 1.99999 8.00008 1.99999C7.60008 1.99999 7.33342 2.26666 7.33342 2.66666C7.33342 3.06666 7.60008 3.33332 8.00008 3.33332C8.40008 3.33332 8.66675 3.06666 8.66675 2.66666ZM11.3334 2.66666C11.3334 1.53332 12.2001 0.666656 13.3334 0.666656C14.4667 0.666656 15.3334 1.53332 15.3334 2.66666C15.3334 3.79999 14.4667 4.66666 13.3334 4.66666C12.2001 4.66666 11.3334 3.79999 11.3334 2.66666ZM12.6667 2.66666C12.6667 3.06666 12.9334 3.33332 13.3334 3.33332C13.7334 3.33332 14.0001 3.06666 14.0001 2.66666C14.0001 2.26666 13.7334 1.99999 13.3334 1.99999C12.9334 1.99999 12.6667 2.26666 12.6667 2.66666ZM4.66675 7.99999C4.66675 9.13332 3.80008 9.99999 2.66675 9.99999C1.53341 9.99999 0.666748 9.13332 0.666748 7.99999C0.666748 6.86666 1.53341 5.99999 2.66675 5.99999C3.80008 5.99999 4.66675 6.86666 4.66675 7.99999ZM3.33341 7.99999C3.33341 7.59999 3.06675 7.33332 2.66675 7.33332C2.26675 7.33332 2.00008 7.59999 2.00008 7.99999C2.00008 8.39999 2.26675 8.66666 2.66675 8.66666C3.06675 8.66666 3.33341 8.39999 3.33341 7.99999ZM8.00008 5.99999C6.86675 5.99999 6.00008 6.86666 6.00008 7.99999C6.00008 9.13332 6.86675 9.99999 8.00008 9.99999C9.13342 9.99999 10.0001 9.13332 10.0001 7.99999C10.0001 6.86666 9.13342 5.99999 8.00008 5.99999ZM13.3334 5.99999C12.2001 5.99999 11.3334 6.86666 11.3334 7.99999C11.3334 9.13332 12.2001 9.99999 13.3334 9.99999C14.4667 9.99999 15.3334 9.13332 15.3334 7.99999C15.3334 6.86666 14.4667 5.99999 13.3334 5.99999ZM2.66675 11.3333C1.53341 11.3333 0.666748 12.2 0.666748 13.3333C0.666748 14.4667 1.53341 15.3333 2.66675 15.3333C3.80008 15.3333 4.66675 14.4667 4.66675 13.3333C4.66675 12.2 3.80008 11.3333 2.66675 11.3333ZM8.00008 11.3333C6.86675 11.3333 6.00008 12.2 6.00008 13.3333C6.00008 14.4667 6.86675 15.3333 8.00008 15.3333C9.13342 15.3333 10.0001 14.4667 10.0001 13.3333C10.0001 12.2 9.13342 11.3333 8.00008 11.3333ZM15.3334 13.3333C15.3334 14.4667 14.4667 15.3333 13.3334 15.3333C12.2001 15.3333 11.3334 14.4667 11.3334 13.3333C11.3334 12.2 12.2001 11.3333 13.3334 11.3333C14.4667 11.3333 15.3334 12.2 15.3334 13.3333ZM14.0001 13.3333C14.0001 12.9333 13.7334 12.6667 13.3334 12.6667C12.9334 12.6667 12.6667 12.9333 12.6667 13.3333C12.6667 13.7333 12.9334 14 13.3334 14C13.7334 14 14.0001 13.7333 14.0001 13.3333Z"></path></g><defs><clipPath id="clip0_22761_58169"><rect width="16" height="16" fill="white"></rect></clipPath></defs></svg>',
  "toolbox-multimatrix-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M7 4C7 5.7 5.7 7 4 7C2.3 7 1 5.7 1 4C1 2.3 2.3 1 4 1C5.7 1 7 2.3 7 4ZM15 4C15 5.7 13.7 7 12 7C10.3 7 9 5.7 9 4C9 2.3 10.3 1 12 1C13.7 1 15 2.3 15 4ZM13 4C13 3.4 12.6 3 12 3C11.4 3 11 3.4 11 4C11 4.6 11.4 5 12 5C12.6 5 13 4.6 13 4ZM17 4C17 2.3 18.3 1 20 1C21.7 1 23 2.3 23 4C23 5.7 21.7 7 20 7C18.3 7 17 5.7 17 4ZM19 4C19 4.6 19.4 5 20 5C20.6 5 21 4.6 21 4C21 3.4 20.6 3 20 3C19.4 3 19 3.4 19 4ZM7 12C7 13.7 5.7 15 4 15C2.3 15 1 13.7 1 12C1 10.3 2.3 9 4 9C5.7 9 7 10.3 7 12ZM5 12C5 11.4 4.6 11 4 11C3.4 11 3 11.4 3 12C3 12.6 3.4 13 4 13C4.6 13 5 12.6 5 12ZM12 9C10.3 9 9 10.3 9 12C9 13.7 10.3 15 12 15C13.7 15 15 13.7 15 12C15 10.3 13.7 9 12 9ZM20 9C18.3 9 17 10.3 17 12C17 13.7 18.3 15 20 15C21.7 15 23 13.7 23 12C23 10.3 21.7 9 20 9ZM4 17C2.3 17 1 18.3 1 20C1 21.7 2.3 23 4 23C5.7 23 7 21.7 7 20C7 18.3 5.7 17 4 17ZM12 17C10.3 17 9 18.3 9 20C9 21.7 10.3 23 12 23C13.7 23 15 21.7 15 20C15 18.3 13.7 17 12 17ZM23 20C23 21.7 21.7 23 20 23C18.3 23 17 21.7 17 20C17 18.3 18.3 17 20 17C21.7 17 23 18.3 23 20ZM21 20C21 19.4 20.6 19 20 19C19.4 19 19 19.4 19 20C19 20.6 19.4 21 20 21C20.6 21 21 20.6 21 20Z"></path></svg>',
  "toolbox-multipletext-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M13.3333 0.666656H2.66659C1.93325 0.666656 1.33325 1.26666 1.33325 1.99999V5.99999C1.33325 6.73332 1.93325 7.33332 2.66659 7.33332H13.3333C14.0666 7.33332 14.6666 6.73332 14.6666 5.99999V1.99999C14.6666 1.26666 14.0666 0.666656 13.3333 0.666656ZM13.3333 5.99999H2.66659V1.99999H13.3333V5.99999ZM9.33325 4.66666H3.99992V3.33332H9.33325V4.66666ZM13.3333 8.66666H2.66659C1.93325 8.66666 1.33325 9.26666 1.33325 9.99999V14C1.33325 14.7333 1.93325 15.3333 2.66659 15.3333H13.3333C14.0666 15.3333 14.6666 14.7333 14.6666 14V9.99999C14.6666 9.26666 14.0666 8.66666 13.3333 8.66666ZM13.3333 14H2.66659V9.99999H13.3333V14ZM9.33325 12.6667H3.99992V11.3333H9.33325V12.6667Z"></path></svg>',
  "toolbox-multipletext-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20 1H4C2.9 1 2 1.9 2 3V9C2 10.1 2.9 11 4 11H20C21.1 11 22 10.1 22 9V3C22 1.9 21.1 1 20 1ZM20 9H4V3H20V9ZM14 7H6V5H14V7ZM20 13H4C2.9 13 2 13.9 2 15V21C2 22.1 2.9 23 4 23H20C21.1 23 22 22.1 22 21V15C22 13.9 21.1 13 20 13ZM20 21H4V15H20V21ZM14 19H6V17H14V19Z"></path></svg>',
  "toolbox-panel-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M5.99992 1.33334V2.66668H2.66659V6.00001H1.33325V2.66668C1.33325 1.93334 1.93325 1.33334 2.66659 1.33334H5.99992ZM13.3333 1.33334H9.99992V2.66668H13.3333V6.00001H14.6666V2.66668C14.6666 1.93334 14.0666 1.33334 13.3333 1.33334ZM2.66659 13.3333V10H1.33325V13.3333C1.33325 14.0667 1.93325 14.6667 2.66659 14.6667H5.99992V13.3333H2.66659ZM13.3333 13.3333H9.99992V14.6667H13.3333C14.0666 14.6667 14.6666 14.0667 14.6666 13.3333V10H13.3333V13.3333Z"></path></svg>',
  "toolbox-panel-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M9 2V4H4V9H2V4C2 2.9 2.9 2 4 2H9ZM20 2H15V4H20V9H22V4C22 2.9 21.1 2 20 2ZM4 20V15H2V20C2 21.1 2.9 22 4 22H9V20H4ZM20 20H15V22H20C21.1 22 22 21.1 22 20V15H20V20Z"></path></svg>',
  "toolbox-radiogroup-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M7.99992 2.66665C10.9333 2.66665 13.3333 5.06665 13.3333 7.99998C13.3333 10.9333 10.9333 13.3333 7.99992 13.3333C5.06659 13.3333 2.66659 10.9333 2.66659 7.99998C2.66659 5.06665 5.06659 2.66665 7.99992 2.66665ZM7.99992 1.33331C4.33325 1.33331 1.33325 4.33331 1.33325 7.99998C1.33325 11.6666 4.33325 14.6666 7.99992 14.6666C11.6666 14.6666 14.6666 11.6666 14.6666 7.99998C14.6666 4.33331 11.6666 1.33331 7.99992 1.33331ZM7.99992 6.66665C8.73325 6.66665 9.33325 7.26665 9.33325 7.99998C9.33325 8.73331 8.73325 9.33331 7.99992 9.33331C7.26658 9.33331 6.66658 8.73331 6.66658 7.99998C6.66658 7.26665 7.26658 6.66665 7.99992 6.66665ZM7.99992 5.33331C6.53325 5.33331 5.33325 6.53331 5.33325 7.99998C5.33325 9.46665 6.53325 10.6666 7.99992 10.6666C9.46659 10.6666 10.6666 9.46665 10.6666 7.99998C10.6666 6.53331 9.46659 5.33331 7.99992 5.33331Z"></path></svg>',
  "toolbox-radiogroup-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 4C16.4 4 20 7.6 20 12C20 16.4 16.4 20 12 20C7.6 20 4 16.4 4 12C4 7.6 7.6 4 12 4ZM12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C17.5 22 22 17.5 22 12C22 6.5 17.5 2 12 2ZM12 10C13.1 10 14 10.9 14 12C14 13.1 13.1 14 12 14C10.9 14 10 13.1 10 12C10 10.9 10.9 10 12 10ZM12 8C9.8 8 8 9.8 8 12C8 14.2 9.8 16 12 16C14.2 16 16 14.2 16 12C16 9.8 14.2 8 12 8Z"></path></svg>',
  "toolbox-ranking-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.6666 2.66669H1.33325V14H9.33325V10.6667H11.9999V7.33335H14.6666V2.66669ZM7.99992 12.6667H2.66659V10.6667H7.99992V12.6667ZM10.6666 9.33335H2.66659V7.33335H10.6666V9.33335ZM13.3333 6.00002H2.66659V4.00002H13.3333V6.00002Z"></path></svg>',
  "toolbox-ranking-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M22 4H2V21H14V16H18V11H22V4ZM12 19H4V16H12V19ZM16 14H4V11H16V14ZM20 9H4V6H20V9Z"></path></svg>',
  "toolbox-rating-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_22761_58144)"><path d="M8 4.53333L8.6 6.46666L8.86667 7.4H9.86667H11.8667L10.2667 8.6L9.46667 9.2L9.73333 10.1333L10.3333 12.0667L8.73333 10.8667L8 10.2L7.2 10.8L5.6 12L6.2 10.0667L6.46667 9.13333L5.66667 8.53333L4.06667 7.33333H6.06667H7.06667L7.33333 6.4L8 4.53333ZM8 0.199997L6.13333 6H0L4.93333 9.6L3.06667 15.4L8 11.8L12.9333 15.4L11.0667 9.6L16 6H9.86667L8 0.199997Z"></path></g><defs><clipPath id="clip0_22761_58144"><rect width="16" height="16" fill="white"></rect></clipPath></defs></svg>',
  "toolbox-rating-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_554_309749)"><path d="M12 6.8L12.9 9.7L13.3 11.1H14.8H17.8L15.4 12.9L14.2 13.8L14.6 15.2L15.5 18.1L13.1 16.3L12 15.3L10.8 16.2L8.4 18L9.3 15.1L9.7 13.7L8.5 12.8L6.1 11H9.1H10.6L11 9.6L12 6.8ZM12 0.300003L9.2 9H0L7.4 14.4L4.6 23.1L12 17.7L19.4 23.1L16.6 14.4L24 9H14.8L12 0.300003Z"></path></g><defs><clipPath id="clip0_554_309749"><rect width="24" height="24" fill="white"></rect></clipPath></defs></svg>',
  "toolbox-signature-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_22761_58139)"><path d="M16 11.3333V12.6667H6.06667C6.33333 12.2667 6.6 11.8 6.8 11.3333H16ZM7.93333 6C7.33333 9.13333 5.73333 13.0667 3.33333 15.0667C2.53333 15.7333 1.33333 15.0667 1.33333 14.0667C1.33333 13.6 1.4 13.1333 1.46667 12.6667H0V11.3333H1.86667C2.86667 8.6 5.06667 6.06667 6.8 5.06667C6.93333 4.06667 6.93333 3.2 6.8 2.6C6.6 2.2 6.46667 2 6.4 2C6.26667 2 5.2 1.93333 2.53333 5.8L1.46667 5.06667C3.66667 1.86667 5.26667 0.466666 6.6 0.666666C8 0.799999 8.33333 3.06667 8.13333 4.6C9.53333 4.66667 9.86667 5.46667 9.93333 6.86667C10.8 6.06667 12.0667 5.26667 12.8 6.13333C13.8667 5.93333 14.7333 6.93333 15.2667 7.66667L14.2 8.46667C13.6 7.6 13.2 7.46667 13.0667 7.46667C13 7.46667 13 7.53333 12.9333 7.6C12.6667 8 12.4 8.53333 12 9.13333C11.8 9.4 11.4667 9.53333 11.1333 9.4C10.3333 9 11 8.06667 11.2 7.46667C10.5333 8 9.6 8.93333 9.26667 9.86667C9.2 10.3333 8.86667 10.8667 8.33333 10.7333C7.73333 10.6 7.8 9.93333 8 9.46667C8.86667 6.53333 8.33333 6 8.33333 6C8.33333 5.93333 8.13333 5.86667 7.93333 6ZM6.33333 6.93333C4.6 8.53333 2.73333 11.4 2.66667 13.8667C4.4 12.3333 5.66667 9.53333 6.33333 6.93333Z"></path></g><defs><clipPath id="clip0_22761_58139"><rect width="16" height="16" fill="white"></rect></clipPath></defs></svg>',
  "toolbox-signature-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_554_309751)"><path d="M24 17V19H9.1C9.5 18.4 9.9 17.7 10.2 17H24ZM11.9 9C11 13.7 8.6 19.6 5 22.6C3.8 23.6 2 22.6 2 21.1C2 20.4 2.1 19.7 2.2 19H0V17H2.8C4.3 12.9 7.6 9.1 10.2 7.6C10.4 6.1 10.4 4.8 10.2 3.9C9.9 3.3 9.7 3 9.6 3C9.4 3 7.8 2.9 3.8 8.7L2.2 7.6C5.5 2.8 7.9 0.699999 9.9 0.999999C12 1.2 12.5 4.6 12.2 6.9C14.3 7 14.8 8.2 14.9 10.3C16.2 9.1 18.1 7.9 19.2 9.2C20.8 8.9 22.1 10.4 22.9 11.5L21.3 12.7C20.4 11.4 19.8 11.2 19.6 11.2C19.5 11.2 19.5 11.3 19.4 11.4C19 12 18.6 12.8 18 13.7C17.7 14.1 17.2 14.3 16.7 14.1C15.5 13.5 16.5 12.1 16.8 11.2C15.8 12 14.4 13.4 13.9 14.8C13.8 15.5 13.3 16.3 12.5 16.1C11.6 15.9 11.7 14.9 12 14.2C13.3 9.8 12.5 9 12.5 9C12.5 8.9 12.2 8.8 11.9 9ZM9.5 10.4C6.9 12.8 4.1 17.1 4 20.8C6.6 18.5 8.5 14.3 9.5 10.4Z"></path></g><defs><clipPath id="clip0_554_309751"><rect width="24" height="24" fill="white"></rect></clipPath></defs></svg>',
  "toolbox-singleline-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M13.3333 4H2.66659C1.93325 4 1.33325 4.6 1.33325 5.33333V10.6667C1.33325 11.4 1.93325 12 2.66659 12H13.3333C14.0666 12 14.6666 11.4 14.6666 10.6667V5.33333C14.6666 4.6 14.0666 4 13.3333 4ZM13.3333 10.6667H2.66659V5.33333H13.3333V10.6667ZM9.33325 8.66667H3.99992V7.33333H9.33325V8.66667Z"></path></svg>',
  "toolbox-singleline-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20 6H4C2.9 6 2 6.9 2 8V16C2 17.1 2.9 18 4 18H20C21.1 18 22 17.1 22 16V8C22 6.9 21.1 6 20 6ZM20 16H4V8H20V16ZM14 13H6V11H14V13Z"></path></svg>',
  "toolbox-tagbox-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.6666 4.66669V4.00002C14.6666 3.26669 14.0666 2.66669 13.3333 2.66669H10.6666C9.93325 2.66669 9.33325 3.26669 9.33325 4.00002V4.66669C9.33325 5.40002 9.93325 6.00002 10.6666 6.00002H13.3333C14.0666 6.00002 14.6666 5.40002 14.6666 4.66669ZM13.3333 4.66669H10.6666V4.00002H13.3333V4.66669ZM1.33325 4.00002V4.66669C1.33325 5.40002 1.93325 6.00002 2.66659 6.00002H7.33325C8.06659 6.00002 8.66658 5.40002 8.66658 4.66669V4.00002C8.66658 3.26669 8.06659 2.66669 7.33325 2.66669H2.66659C1.93325 2.66669 1.33325 3.26669 1.33325 4.00002ZM2.66659 4.00002H7.33325V4.66669H2.66659V4.00002ZM5.99992 8.00002V8.66669C5.99992 9.40002 6.59992 10 7.33325 10H13.3333C14.0666 10 14.6666 9.40002 14.6666 8.66669V8.00002C14.6666 7.26669 14.0666 6.66669 13.3333 6.66669H7.33325C6.59992 6.66669 5.99992 7.26669 5.99992 8.00002ZM7.33325 8.00002H13.3333V8.66669H7.33325V8.00002ZM1.33325 12V12.6667C1.33325 13.4 1.93325 14 2.66659 14H9.99992C10.7333 14 11.3333 13.4 11.3333 12.6667V12C11.3333 11.2667 10.7333 10.6667 9.99992 10.6667H2.66659C1.93325 10.6667 1.33325 11.2667 1.33325 12ZM2.66659 12H9.99992V12.6667H2.66659V12ZM1.33325 8.00002V8.66669C1.33325 9.40002 1.93325 10 2.66659 10H3.99992C4.73325 10 5.33325 9.40002 5.33325 8.66669V8.00002C5.33325 7.26669 4.73325 6.66669 3.99992 6.66669H2.66659C1.93325 6.66669 1.33325 7.26669 1.33325 8.00002ZM2.66659 8.00002H3.99992V8.66669H2.66659V8.00002Z"></path></svg>',
  "toolbox-tagbox-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M22 7V6C22 4.9 21.1 4 20 4H16C14.9 4 14 4.9 14 6V7C14 8.1 14.9 9 16 9H20C21.1 9 22 8.1 22 7ZM20 7H16V6H20V7ZM2 6V7C2 8.1 2.9 9 4 9H11C12.1 9 13 8.1 13 7V6C13 4.9 12.1 4 11 4H4C2.9 4 2 4.9 2 6ZM4 6H11V7H4V6ZM9 12V13C9 14.1 9.9 15 11 15H20C21.1 15 22 14.1 22 13V12C22 10.9 21.1 10 20 10H11C9.9 10 9 10.9 9 12ZM11 12H20V13H11V12ZM2 18V19C2 20.1 2.9 21 4 21H15C16.1 21 17 20.1 17 19V18C17 16.9 16.1 16 15 16H4C2.9 16 2 16.9 2 18ZM4 18H15V19H4V18ZM2 12V13C2 14.1 2.9 15 4 15H6C7.1 15 8 14.1 8 13V12C8 10.9 7.1 10 6 10H4C2.9 10 2 10.9 2 12ZM4 12H6V13H4V12Z"></path></svg>',
  "undo-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M17 8H4.39998L8.39998 4L6.99998 2.6L0.599976 9L6.99998 15.4L8.39998 14L4.39998 10H17C19.2 10 21 11.8 21 14C21 16.2 19.2 18 17 18H16V20H17C20.3 20 23 17.3 23 14C23 10.7 20.3 8 17 8Z"></path></svg>',
  "visible-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 4C7.2 4 3 7.2 0.5 12C3 16.8 7.2 20 12 20C16.8 20 20.9 16.8 23.5 12C20.9 7.2 16.7 4 12 4ZM12 18C8.5 18 5.1 15.8 2.8 12C5.1 8.2 8.5 6 12 6C15.5 6 18.9 8.2 21.2 12C18.9 15.8 15.5 18 12 18ZM12 7C9.2 7 7 9.2 7 12C7 14.8 9.2 17 12 17C14.8 17 17 14.8 17 12C17 9.2 14.7 7 12 7ZM12 15C10.3 15 9 13.7 9 12C9 11.7 9 11.5 9.1 11.3L12 12L10.3 9.5C10.8 9.2 11.3 9 12 9C13.7 9 15 10.3 15 12C15 13.7 13.6 15 12 15Z"></path></svg>',
  "wand-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M7.7 16.3C8.1 16.7 8.1 17.3 7.7 17.7L3.7 21.7C3.5 21.9 3.3 22 3 22C2.7 22 2.5 21.9 2.3 21.7C1.9 21.3 1.9 20.7 2.3 20.3L6.3 16.3C6.7 15.9 7.3 15.9 7.7 16.3ZM20.5 10L23 13.7L18.6 14.6L17.7 19L14 16.5L10.3 19L9.4 14.6L5 13.7L7.5 10L5 6.3L9.4 5.4L10.3 1L14 3.5L17.7 1L18.6 5.4L23 6.3L20.5 10ZM18.1 10L18.8 8.9L19.6 7.7L18.1 7.4L16.8 7.1L16.5 5.8L16.2 4.3L15 5.1L14 5.9L12.9 5.2L11.7 4.3L11.4 5.8L11.1 7.1L9.8 7.4L8.3 7.7L9.1 8.9L9.9 10L9.2 11.1L8.4 12.3L9.9 12.6L11.2 12.9L11.5 14.2L11.8 15.7L13 14.9L14.1 14.2L15.2 14.9L16.4 15.7L16.7 14.2L17 12.9L18.3 12.6L19.8 12.3L19 11.1L18.1 10Z"></path></svg>',
  "warning-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M23.0336 16.4803L14.5736 2.45346C13.9936 1.4878 12.9936 1 12.0036 1C11.0136 1 10.0136 1.4878 9.43364 2.45346L0.973642 16.4803C-0.226358 18.4714 1.21364 21 3.54364 21H20.4536C22.7836 21 24.2236 18.4714 23.0236 16.4803H23.0336ZM21.3336 18.5112C21.2436 18.6605 20.9936 19.0189 20.4636 19.0189H3.54364C3.01364 19.0189 2.76364 18.6705 2.67364 18.5112C2.58364 18.3519 2.41364 17.9537 2.68364 17.5057L11.1436 3.47885C11.4036 3.04082 11.8336 2.99104 12.0036 2.99104C12.1736 2.99104 12.5936 3.04082 12.8636 3.47885L21.3136 17.5057C21.5836 17.9537 21.4136 18.3519 21.3236 18.5112H21.3336ZM13.0036 8.05824V13.0358C13.0036 13.5834 12.5536 14.0314 12.0036 14.0314C11.4536 14.0314 11.0036 13.5834 11.0036 13.0358V8.05824C11.0036 7.5107 11.4536 7.06272 12.0036 7.06272C12.5536 7.06272 13.0036 7.5107 13.0036 8.05824ZM13.0036 16.0224C13.0036 16.5699 12.5536 17.0179 12.0036 17.0179C11.4536 17.0179 11.0036 16.5699 11.0036 16.0224C11.0036 15.4749 11.4536 15.0269 12.0036 15.0269C12.5536 15.0269 13.0036 15.4749 13.0036 16.0224Z"></path></svg>',
  "wrench-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_19764_194726)"><path d="M14.8099 2.19999C15.4199 2.19999 16.0099 2.28999 16.5799 2.42999L13.3099 5.69999C11.9299 7.07999 11.9299 9.31999 13.3099 10.7C13.9999 11.39 14.9099 11.74 15.8099 11.74C16.7099 11.74 17.6199 11.39 18.3099 10.7L21.5799 7.42999C21.7299 7.99999 21.8099 8.58999 21.8099 9.19999C21.8099 13.07 18.6799 16.2 14.8099 16.2C13.6499 16.2 12.5599 15.91 11.5999 15.41L5.80993 21.2C5.39993 21.61 4.84993 21.82 4.30993 21.82C3.76993 21.82 3.21993 21.61 2.80993 21.2C1.97993 20.37 1.97993 19.03 2.80993 18.2L8.59993 12.41C8.09993 11.45 7.80993 10.36 7.80993 9.19999C7.80993 5.32999 10.9399 2.19999 14.8099 2.19999ZM14.8099 0.199993C9.84993 0.199993 5.80993 4.23999 5.80993 9.19999C5.80993 10.13 5.95993 11.06 6.23993 11.94L1.38993 16.79C0.609932 17.57 0.179932 18.6 0.179932 19.7C0.179932 20.8 0.609932 21.84 1.38993 22.61C2.16993 23.39 3.19993 23.82 4.29993 23.82C5.39993 23.82 6.43993 23.39 7.20993 22.61L12.0599 17.76C12.9499 18.04 13.8699 18.19 14.7999 18.19C19.7599 18.19 23.7999 14.15 23.7999 9.18999C23.7999 8.43999 23.6999 7.67999 23.4999 6.91999C23.3199 6.22999 22.7799 5.67999 22.0899 5.48999C21.9199 5.43999 21.7399 5.41999 21.5699 5.41999C21.0499 5.41999 20.5399 5.62999 20.1599 6.00999L16.8899 9.27999C16.5999 9.56999 16.2099 9.72999 15.7999 9.72999C15.3899 9.72999 14.9999 9.56999 14.7099 9.27999C14.4199 8.98999 14.2599 8.59999 14.2599 8.18999C14.2599 7.77999 14.4199 7.38999 14.7099 7.09999L17.9799 3.82999C18.4899 3.31999 18.6799 2.57999 18.4999 1.88999C18.3099 1.19999 17.7699 0.659993 17.0699 0.479993C16.3099 0.279993 15.5499 0.179993 14.7999 0.179993L14.8099 0.199993Z"></path></g><defs><clipPath id="clip0_19764_194726"><rect width="24" height="24" fill="white"></rect></clipPath></defs></svg>',
  "zoomin-24x24": '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M22.71 21.29L17.03 15.61C18.26 14.07 19 12.12 19 10C19 5.04 14.96 1 10 1C5.04 1 1 5.04 1 10C1 14.96 5.04 19 10 19C12.12 19 14.07 18.26 15.61 17.03L21.29 22.71L22.7 21.3L22.71 21.29ZM3 10C3 6.14 6.14 3 10 3C13.86 3 17 6.14 17 10C17 13.86 13.86 17 10 17C6.14 17 3 13.86 3 10ZM11 9H14V11H11V14H9V11H6V9H9V6H11V9Z"></path></svg>',
  "zoomout-24x24": '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M22.71 21.29L17.03 15.61C18.26 14.07 19 12.12 19 10C19 5.04 14.96 1 10 1C5.04 1 1 5.04 1 10C1 14.96 5.04 19 10 19C12.12 19 14.07 18.26 15.61 17.03L21.29 22.71L22.7 21.3L22.71 21.29ZM3 10C3 6.14 6.14 3 10 3C13.86 3 17 6.14 17 10C17 13.86 13.86 17 10 17C6.14 17 3 13.86 3 10ZM6 9H14V11H6V9Z"></path></svg>'
};
var iconsV2Data = {
  "actual-size-24x24": '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M10 6.25C7.93 6.25 6.25 7.93 6.25 10C6.25 12.07 7.93 13.75 10 13.75C12.07 13.75 13.75 12.07 13.75 10C13.75 7.93 12.07 6.25 10 6.25ZM10 12.25C8.76 12.25 7.75 11.24 7.75 10C7.75 8.76 8.76 7.75 10 7.75C11.24 7.75 12.25 8.76 12.25 10C12.25 11.24 11.24 12.25 10 12.25ZM21.53 20.47L15.98 14.92C17.08 13.58 17.75 11.87 17.75 10C17.75 5.73 14.27 2.25 10 2.25C5.73 2.25 2.25 5.73 2.25 10C2.25 14.27 5.73 17.75 10 17.75C11.87 17.75 13.58 17.09 14.92 15.98L20.47 21.53C20.62 21.68 20.81 21.75 21 21.75C21.19 21.75 21.38 21.68 21.53 21.53C21.82 21.24 21.82 20.76 21.53 20.47ZM3.75 10C3.75 6.55 6.55 3.75 10 3.75C13.45 3.75 16.25 6.55 16.25 10C16.25 13.45 13.45 16.25 10 16.25C6.55 16.25 3.75 13.45 3.75 10Z"></path></svg>',
  "add-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M8 1.25C4.28 1.25 1.25 4.28 1.25 8C1.25 11.72 4.28 14.75 8 14.75C11.72 14.75 14.75 11.72 14.75 8C14.75 4.28 11.72 1.25 8 1.25ZM8 13.25C5.11 13.25 2.75 10.89 2.75 8C2.75 5.11 5.11 2.75 8 2.75C10.89 2.75 13.25 5.11 13.25 8C13.25 10.89 10.89 13.25 8 13.25ZM10.75 8C10.75 8.41 10.41 8.75 10 8.75H8.75V10C8.75 10.41 8.41 10.75 8 10.75C7.59 10.75 7.25 10.41 7.25 10V8.75H6C5.59 8.75 5.25 8.41 5.25 8C5.25 7.59 5.59 7.25 6 7.25H7.25V6C7.25 5.59 7.59 5.25 8 5.25C8.41 5.25 8.75 5.59 8.75 6V7.25H10C10.41 7.25 10.75 7.59 10.75 8Z"></path></svg>',
  "add-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M15.75 12C15.75 12.41 15.41 12.75 15 12.75H12.75V15C12.75 15.41 12.41 15.75 12 15.75C11.59 15.75 11.25 15.41 11.25 15V12.75H9C8.59 12.75 8.25 12.41 8.25 12C8.25 11.59 8.59 11.25 9 11.25H11.25V9C11.25 8.59 11.59 8.25 12 8.25C12.41 8.25 12.75 8.59 12.75 9V11.25H15C15.41 11.25 15.75 11.59 15.75 12ZM21.75 12C21.75 17.38 17.38 21.75 12 21.75C6.62 21.75 2.25 17.38 2.25 12C2.25 6.62 6.62 2.25 12 2.25C17.38 2.25 21.75 6.62 21.75 12ZM20.25 12C20.25 7.45 16.55 3.75 12 3.75C7.45 3.75 3.75 7.45 3.75 12C3.75 16.55 7.45 20.25 12 20.25C16.55 20.25 20.25 16.55 20.25 12Z"></path></svg>',
  "apply-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 2.25C6.62 2.25 2.25 6.62 2.25 12C2.25 17.38 6.62 21.75 12 21.75C17.38 21.75 21.75 17.38 21.75 12C21.75 6.62 17.38 2.25 12 2.25ZM12 20.25C7.45 20.25 3.75 16.55 3.75 12C3.75 7.45 7.45 3.75 12 3.75C16.55 3.75 20.25 7.45 20.25 12C20.25 16.55 16.55 20.25 12 20.25ZM16.53 8.47C16.82 8.76 16.82 9.24 16.53 9.53L10.53 15.53C10.38 15.68 10.19 15.75 10 15.75C9.81 15.75 9.62 15.68 9.47 15.53L7.47 13.53C7.18 13.24 7.18 12.76 7.47 12.47C7.76 12.18 8.24 12.18 8.53 12.47L10 13.94L15.47 8.47C15.76 8.18 16.24 8.18 16.53 8.47Z"></path></svg>',
  "arrowdown-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M16.5275 12.53L12.5275 16.53C12.4575 16.6 12.3775 16.65 12.2875 16.69C12.1975 16.73 12.0975 16.75 11.9975 16.75C11.8975 16.75 11.7975 16.73 11.7075 16.69C11.6175 16.65 11.5375 16.6 11.4675 16.53L7.4675 12.53C7.1775 12.24 7.1775 11.76 7.4675 11.47C7.7575 11.18 8.2375 11.18 8.5275 11.47L11.2475 14.19V7C11.2475 6.59 11.5875 6.25 11.9975 6.25C12.4075 6.25 12.7475 6.59 12.7475 7V14.19L15.4675 11.47C15.7575 11.18 16.2375 11.18 16.5275 11.47C16.8175 11.76 16.8175 12.24 16.5275 12.53Z"></path></svg>',
  "arrowleft-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.7475 7.9975C14.7475 8.4075 14.4075 8.7475 13.9975 8.7475H3.8075L7.5275 12.4675C7.8175 12.7575 7.8175 13.2375 7.5275 13.5275C7.3775 13.6775 7.1875 13.7475 6.9975 13.7475C6.8075 13.7475 6.6175 13.6775 6.4675 13.5275L1.4675 8.5275C1.1775 8.2375 1.1775 7.7575 1.4675 7.4675L6.4675 2.4675C6.7575 2.1775 7.2375 2.1775 7.5275 2.4675C7.8175 2.7575 7.8175 3.2375 7.5275 3.5275L3.8075 7.2475H13.9975C14.4075 7.2475 14.7475 7.5875 14.7475 7.9975Z"></path></svg>',
  "arrowleft-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M21.75 11.9975C21.75 12.4075 21.41 12.7475 21 12.7475H4.81L9.53 17.4675C9.82 17.7575 9.82 18.2375 9.53 18.5275C9.38 18.6775 9.19 18.7475 9 18.7475C8.81 18.7475 8.62 18.6775 8.47 18.5275L2.47 12.5275C2.4 12.4575 2.35 12.3775 2.31 12.2875C2.23 12.1075 2.23 11.8975 2.31 11.7175C2.35 11.6275 2.4 11.5475 2.47 11.4775L8.47 5.4675C8.76 5.1775 9.24 5.1775 9.53 5.4675C9.82 5.7575 9.82 6.2375 9.53 6.5275L4.81 11.2475H21C21.41 11.2475 21.75 11.5875 21.75 11.9975Z"></path></svg>',
  "arrowright-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.53 8.5275L9.53 13.5275C9.38 13.6775 9.19 13.7475 9 13.7475C8.81 13.7475 8.62 13.6775 8.47 13.5275C8.18 13.2375 8.18 12.7575 8.47 12.4675L12.19 8.7475H2C1.59 8.7475 1.25 8.4075 1.25 7.9975C1.25 7.5875 1.59 7.2475 2 7.2475H12.19L8.47 3.5275C8.18 3.2375 8.18 2.7575 8.47 2.4675C8.76 2.1775 9.24 2.1775 9.53 2.4675L14.53 7.4675C14.82 7.7575 14.82 8.2375 14.53 8.5275Z"></path></svg>',
  "arrowright-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M21.69 12.2875C21.65 12.3775 21.6 12.4575 21.53 12.5275L15.53 18.5275C15.38 18.6775 15.19 18.7475 15 18.7475C14.81 18.7475 14.62 18.6775 14.47 18.5275C14.18 18.2375 14.18 17.7575 14.47 17.4675L19.19 12.7475H3C2.59 12.7475 2.25 12.4075 2.25 11.9975C2.25 11.5875 2.59 11.2475 3 11.2475H19.19L14.47 6.5275C14.18 6.2375 14.18 5.7575 14.47 5.4675C14.76 5.1775 15.24 5.1775 15.53 5.4675L21.53 11.4675C21.6 11.5375 21.65 11.6175 21.69 11.7075C21.77 11.8875 21.77 12.0975 21.69 12.2775V12.2875Z"></path></svg>',
  "arrowup-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M16.5275 11.53C16.3775 11.68 16.1875 11.75 15.9975 11.75C15.8075 11.75 15.6175 11.68 15.4675 11.53L12.7475 8.81V16C12.7475 16.41 12.4075 16.75 11.9975 16.75C11.5875 16.75 11.2475 16.41 11.2475 16V8.81L8.5275 11.53C8.2375 11.82 7.7575 11.82 7.4675 11.53C7.1775 11.24 7.1775 10.76 7.4675 10.47L11.4675 6.47C11.5375 6.4 11.6175 6.35 11.7075 6.31C11.8875 6.23 12.0975 6.23 12.2775 6.31C12.3675 6.35 12.4475 6.4 12.5175 6.47L16.5175 10.47C16.8075 10.76 16.8075 11.24 16.5175 11.53H16.5275Z"></path></svg>',
  "camera-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M19.19 4.25H17.12C16.72 4.25 16.35 4.03 16.17 3.67C15.73 2.8 14.86 2.25 13.88 2.25H10.12C9.14 2.25 8.27 2.79 7.83 3.67C7.65 4.03 7.29 4.25 6.88 4.25H4.81C3.4 4.25 2.25 5.4 2.25 6.81V18.19C2.25 19.6 3.4 20.75 4.81 20.75H19.19C20.6 20.75 21.75 19.6 21.75 18.19V6.81C21.75 5.4 20.6 4.25 19.19 4.25ZM20.25 18.19C20.25 18.77 19.78 19.25 19.19 19.25H4.81C4.23 19.25 3.75 18.78 3.75 18.19V6.81C3.75 6.23 4.22 5.75 4.81 5.75H6.88C7.86 5.75 8.73 5.21 9.17 4.33C9.35 3.97 9.71 3.75 10.12 3.75H13.88C14.28 3.75 14.65 3.97 14.83 4.33C15.27 5.2 16.14 5.75 17.12 5.75H19.19C19.77 5.75 20.25 6.22 20.25 6.81V18.19ZM12 6.25C8.83 6.25 6.25 8.83 6.25 12C6.25 15.17 8.83 17.75 12 17.75C15.17 17.75 17.75 15.17 17.75 12C17.75 8.83 15.17 6.25 12 6.25ZM12 16.25C9.66 16.25 7.75 14.34 7.75 12C7.75 9.66 9.66 7.75 12 7.75C14.34 7.75 16.25 9.66 16.25 12C16.25 14.34 14.34 16.25 12 16.25ZM14.75 12C14.75 13.52 13.52 14.75 12 14.75C11.59 14.75 11.25 14.41 11.25 14C11.25 13.59 11.59 13.25 12 13.25C12.69 13.25 13.25 12.69 13.25 12C13.25 11.59 13.59 11.25 14 11.25C14.41 11.25 14.75 11.59 14.75 12Z"></path></svg>',
  "camera-32x32": '<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><path d="M25 7.25H22.19C21.73 7.25 21.31 7 21.09 6.59L20.89 6.22C20.23 5.01 18.97 4.25 17.59 4.25H14.41C13.03 4.25 11.77 5 11.11 6.22L10.91 6.6C10.69 7 10.27 7.26 9.81 7.26H7C4.93 7.26 3.25 8.94 3.25 11.01V24.01C3.25 26.08 4.93 27.76 7 27.76H25C27.07 27.76 28.75 26.08 28.75 24.01V11C28.75 8.93 27.07 7.25 25 7.25ZM27.25 24C27.25 25.24 26.24 26.25 25 26.25H7C5.76 26.25 4.75 25.24 4.75 24V11C4.75 9.76 5.76 8.75 7 8.75H9.81C10.82 8.75 11.75 8.2 12.23 7.31L12.43 6.94C12.82 6.21 13.58 5.76 14.41 5.76H17.59C18.42 5.76 19.18 6.21 19.57 6.94L19.77 7.31C20.25 8.2 21.18 8.76 22.19 8.76H25C26.24 8.76 27.25 9.77 27.25 11.01V24.01V24ZM16 10.25C12.28 10.25 9.25 13.28 9.25 17C9.25 20.72 12.28 23.75 16 23.75C19.72 23.75 22.75 20.72 22.75 17C22.75 13.28 19.72 10.25 16 10.25ZM16 22.25C13.11 22.25 10.75 19.89 10.75 17C10.75 14.11 13.11 11.75 16 11.75C18.89 11.75 21.25 14.11 21.25 17C21.25 19.89 18.89 22.25 16 22.25ZM19.75 17C19.75 19.07 18.07 20.75 16 20.75C15.59 20.75 15.25 20.41 15.25 20C15.25 19.59 15.59 19.25 16 19.25C17.24 19.25 18.25 18.24 18.25 17C18.25 16.59 18.59 16.25 19 16.25C19.41 16.25 19.75 16.59 19.75 17Z"></path></svg>',
  "cancel-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12.8099 11.75L15.2799 9.28C15.5699 8.99 15.5699 8.51 15.2799 8.22C14.9899 7.93 14.5099 7.93 14.2199 8.22L11.7499 10.69L9.27994 8.22C8.98994 7.93 8.50994 7.93 8.21994 8.22C7.92994 8.51 7.92994 8.99 8.21994 9.28L10.6899 11.75L8.21994 14.22C7.92994 14.51 7.92994 14.99 8.21994 15.28C8.36994 15.43 8.55994 15.5 8.74994 15.5C8.93994 15.5 9.12994 15.43 9.27994 15.28L11.7499 12.81L14.2199 15.28C14.3699 15.43 14.5599 15.5 14.7499 15.5C14.9399 15.5 15.1299 15.43 15.2799 15.28C15.5699 14.99 15.5699 14.51 15.2799 14.22L12.8099 11.75Z"></path></svg>',
  "check-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.0275 5.0275L6.5275 12.5275C6.3775 12.6775 6.1875 12.7475 5.9975 12.7475C5.8075 12.7475 5.6175 12.6775 5.4675 12.5275L2.4675 9.5275C2.1775 9.2375 2.1775 8.7575 2.4675 8.4675C2.7575 8.1775 3.2375 8.1775 3.5275 8.4675L5.9975 10.9375L12.9675 3.9675C13.2575 3.6775 13.7375 3.6775 14.0275 3.9675C14.3175 4.2575 14.3175 4.7375 14.0275 5.0275Z"></path></svg>',
  "check-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M19.5275 7.5275L9.5275 17.5275C9.3775 17.6775 9.1875 17.7475 8.9975 17.7475C8.8075 17.7475 8.6175 17.6775 8.4675 17.5275L4.4675 13.5275C4.1775 13.2375 4.1775 12.7575 4.4675 12.4675C4.7575 12.1775 5.2375 12.1775 5.5275 12.4675L8.9975 15.9375L18.4675 6.4675C18.7575 6.1775 19.2375 6.1775 19.5275 6.4675C19.8175 6.7575 19.8175 7.2375 19.5275 7.5275Z"></path></svg>',
  "chevrondown-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M11.5275 7.5275L8.5275 10.5275C8.3775 10.6775 8.1875 10.7475 7.9975 10.7475C7.8075 10.7475 7.6175 10.6775 7.4675 10.5275L4.4675 7.5275C4.1775 7.2375 4.1775 6.7575 4.4675 6.4675C4.7575 6.1775 5.2375 6.1775 5.5275 6.4675L7.9975 8.9375L10.4675 6.4675C10.7575 6.1775 11.2375 6.1775 11.5275 6.4675C11.8175 6.7575 11.8175 7.2375 11.5275 7.5275Z"></path></svg>',
  "chevrondown-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M16.5275 10.5275L12.5275 14.5275C12.3775 14.6775 12.1875 14.7475 11.9975 14.7475C11.8075 14.7475 11.6175 14.6775 11.4675 14.5275L7.4675 10.5275C7.1775 10.2375 7.1775 9.7575 7.4675 9.4675C7.7575 9.1775 8.2375 9.1775 8.5275 9.4675L11.9975 12.9375L15.4675 9.4675C15.7575 9.1775 16.2375 9.1775 16.5275 9.4675C16.8175 9.7575 16.8175 10.2375 16.5275 10.5275Z"></path></svg>',
  "chevronleft-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M9.35 11.65C9.55 11.85 9.55 12.16 9.35 12.36C9.25 12.46 9.12 12.51 9 12.51C8.88 12.51 8.74 12.46 8.65 12.36L4.65 8.35C4.45 8.15 4.45 7.84 4.65 7.64L8.65 3.65C8.85 3.45 9.16 3.45 9.36 3.65C9.56 3.85 9.56 4.16 9.36 4.36L5.71 8.01L9.36 11.66L9.35 11.65Z"></path></svg>',
  "chevronright-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M11.35 8.34627L7.35 12.3463C7.25 12.4463 7.12 12.4963 7 12.4963C6.88 12.4963 6.74 12.4463 6.65 12.3463C6.45 12.1463 6.45 11.8363 6.65 11.6363L10.3 7.98627L6.65 4.34627C6.45 4.15627 6.45 3.83627 6.65 3.64627C6.85 3.45627 7.16 3.44627 7.35 3.64627L11.35 7.64627C11.55 7.84627 11.55 8.15627 11.35 8.35627V8.34627Z"></path></svg>',
  "clear-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M12.35 11.65C12.55 11.85 12.55 12.16 12.35 12.36C12.25 12.46 12.12 12.51 12 12.51C11.88 12.51 11.74 12.46 11.65 12.36L8 8.71L4.35 12.36C4.25 12.46 4.12 12.51 4 12.51C3.88 12.51 3.74 12.46 3.65 12.36C3.45 12.16 3.45 11.85 3.65 11.65L7.3 8L3.65 4.35C3.45 4.16 3.45 3.84 3.65 3.65C3.85 3.46 4.16 3.45 4.35 3.65L8 7.3L11.65 3.65C11.85 3.45 12.16 3.45 12.36 3.65C12.56 3.85 12.56 4.16 12.36 4.36L8.71 8.01L12.36 11.66L12.35 11.65Z"></path></svg>',
  "clear-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20.12 10.9325C20.64 10.4125 20.93 9.7225 20.93 8.9925C20.93 8.2625 20.64 7.5725 20.12 7.0525L16.95 3.8825C15.88 2.8125 14.13 2.8125 13.06 3.8825L3.88 13.0525C3.36 13.5725 3.07 14.2625 3.07 14.9925C3.07 15.7225 3.36 16.4125 3.88 16.9325L5.64 18.6925C6.57 19.6225 7.78 20.0825 9 20.0825C10.22 20.0825 11.43 19.6225 12.36 18.6925L20.12 10.9325ZM14.12 4.9325C14.36 4.6925 14.67 4.5625 15 4.5625C15.33 4.5625 15.65 4.6925 15.88 4.9325L19.05 8.1025C19.54 8.5925 19.54 9.3825 19.05 9.8725L12.99 15.9325L8.05 10.9925L14.12 4.9325ZM6.7 17.6325L4.94 15.8725C4.45 15.3825 4.45 14.5925 4.94 14.1025L7 12.0425L11.94 16.9825L11.3 17.6225C10.07 18.8525 7.93 18.8525 6.7 17.6225V17.6325ZM22.75 20.9925C22.75 21.4025 22.41 21.7425 22 21.7425H14C13.59 21.7425 13.25 21.4025 13.25 20.9925C13.25 20.5825 13.59 20.2425 14 20.2425H22C22.41 20.2425 22.75 20.5825 22.75 20.9925ZM4.75 20.9925C4.75 21.4025 4.41 21.7425 4 21.7425H2C1.59 21.7425 1.25 21.4025 1.25 20.9925C1.25 20.5825 1.59 20.2425 2 20.2425H4C4.41 20.2425 4.75 20.5825 4.75 20.9925Z"></path></svg>',
  "close-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M13.5275 12.4675C13.8175 12.7575 13.8175 13.2375 13.5275 13.5275C13.3775 13.6775 13.1875 13.7475 12.9975 13.7475C12.8075 13.7475 12.6175 13.6775 12.4675 13.5275L7.9975 9.0575L3.5275 13.5275C3.3775 13.6775 3.1875 13.7475 2.9975 13.7475C2.8075 13.7475 2.6175 13.6775 2.4675 13.5275C2.1775 13.2375 2.1775 12.7575 2.4675 12.4675L6.9375 7.9975L2.4675 3.5275C2.1775 3.2375 2.1775 2.7575 2.4675 2.4675C2.7575 2.1775 3.2375 2.1775 3.5275 2.4675L7.9975 6.9375L12.4675 2.4675C12.7575 2.1775 13.2375 2.1775 13.5275 2.4675C13.8175 2.7575 13.8175 3.2375 13.5275 3.5275L9.0575 7.9975L13.5275 12.4675Z"></path></svg>',
  "close-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M19.5275 18.4675C19.8175 18.7575 19.8175 19.2375 19.5275 19.5275C19.3775 19.6775 19.1875 19.7475 18.9975 19.7475C18.8075 19.7475 18.6175 19.6775 18.4675 19.5275L11.9975 13.0575L5.5275 19.5275C5.3775 19.6775 5.1875 19.7475 4.9975 19.7475C4.8075 19.7475 4.6175 19.6775 4.4675 19.5275C4.1775 19.2375 4.1775 18.7575 4.4675 18.4675L10.9375 11.9975L4.4675 5.5275C4.1775 5.2375 4.1775 4.7575 4.4675 4.4675C4.7575 4.1775 5.2375 4.1775 5.5275 4.4675L11.9975 10.9375L18.4675 4.4675C18.7575 4.1775 19.2375 4.1775 19.5275 4.4675C19.8175 4.7575 19.8175 5.2375 19.5275 5.5275L13.0575 11.9975L19.5275 18.4675Z"></path></svg>',
  "codeeditor-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M19 3.25H5C3.48 3.25 2.25 4.48 2.25 6V18C2.25 19.52 3.48 20.75 5 20.75H19C20.52 20.75 21.75 19.52 21.75 18V6C21.75 4.48 20.52 3.25 19 3.25ZM20.25 18C20.25 18.69 19.69 19.25 19 19.25H5C4.31 19.25 3.75 18.69 3.75 18V6C3.75 5.31 4.31 4.75 5 4.75H19C19.69 4.75 20.25 5.31 20.25 6V18ZM8.75 11C8.75 11.37 8.63 11.72 8.43 12C8.63 12.28 8.75 12.63 8.75 13V14.5C8.75 14.91 9.09 15.25 9.5 15.25H10C10.41 15.25 10.75 15.59 10.75 16C10.75 16.41 10.41 16.75 10 16.75H9.5C8.26 16.75 7.25 15.74 7.25 14.5V13C7.25 12.86 7.14 12.75 7 12.75C6.59 12.75 6.25 12.41 6.25 12C6.25 11.59 6.59 11.25 7 11.25C7.14 11.25 7.25 11.14 7.25 11V9.5C7.25 8.26 8.26 7.25 9.5 7.25H10C10.41 7.25 10.75 7.59 10.75 8C10.75 8.41 10.41 8.75 10 8.75H9.5C9.09 8.75 8.75 9.09 8.75 9.5V11ZM17.75 12C17.75 12.41 17.41 12.75 17 12.75C16.86 12.75 16.75 12.86 16.75 13V14.5C16.75 15.74 15.74 16.75 14.5 16.75H14C13.59 16.75 13.25 16.41 13.25 16C13.25 15.59 13.59 15.25 14 15.25H14.5C14.91 15.25 15.25 14.91 15.25 14.5V13C15.25 12.63 15.37 12.28 15.57 12C15.37 11.72 15.25 11.37 15.25 11V9.5C15.25 9.09 14.91 8.75 14.5 8.75H14C13.59 8.75 13.25 8.41 13.25 8C13.25 7.59 13.59 7.25 14 7.25H14.5C15.74 7.25 16.75 8.26 16.75 9.5V11C16.75 11.14 16.86 11.25 17 11.25C17.41 11.25 17.75 11.59 17.75 12Z"></path></svg>',
  "collapse-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M11.75 8C11.75 8.41 11.41 8.75 11 8.75H5C4.59 8.75 4.25 8.41 4.25 8C4.25 7.59 4.59 7.25 5 7.25H11C11.41 7.25 11.75 7.59 11.75 8Z"></path></svg>',
  "collapse-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M16.5275 17.47C16.8175 17.76 16.8175 18.24 16.5275 18.53C16.3775 18.68 16.1875 18.75 15.9975 18.75C15.8075 18.75 15.6175 18.68 15.4675 18.53L12.7475 15.81V21C12.7475 21.41 12.4075 21.75 11.9975 21.75C11.5875 21.75 11.2475 21.41 11.2475 21V15.81L8.5275 18.53C8.2375 18.82 7.7575 18.82 7.4675 18.53C7.1775 18.24 7.1775 17.76 7.4675 17.47L11.4675 13.47C11.5375 13.4 11.6175 13.35 11.7075 13.31C11.8875 13.23 12.0975 13.23 12.2775 13.31C12.3675 13.35 12.4475 13.4 12.5175 13.47L16.5175 17.47H16.5275ZM11.4675 10.53C11.5375 10.6 11.6175 10.65 11.7075 10.69C11.7975 10.73 11.8975 10.75 11.9975 10.75C12.0975 10.75 12.1975 10.73 12.2875 10.69C12.3775 10.65 12.4575 10.6 12.5275 10.53L16.5275 6.53C16.8175 6.24 16.8175 5.76 16.5275 5.47C16.2375 5.18 15.7575 5.18 15.4675 5.47L12.7475 8.19V3C12.7475 2.59 12.4075 2.25 11.9975 2.25C11.5875 2.25 11.2475 2.59 11.2475 3V8.19L8.5275 5.47C8.2375 5.18 7.7575 5.18 7.4675 5.47C7.1775 5.76 7.1775 6.24 7.4675 6.53L11.4675 10.53Z"></path></svg>',
  "collapse-pg-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M16.69 12.29C16.65 12.38 16.6 12.46 16.53 12.53L13.53 15.53C13.38 15.68 13.19 15.75 13 15.75C12.81 15.75 12.62 15.68 12.47 15.53C12.18 15.24 12.18 14.76 12.47 14.47L14.19 12.75H3C2.59 12.75 2.25 12.41 2.25 12C2.25 11.59 2.59 11.25 3 11.25H14.19L12.47 9.53C12.18 9.24 12.18 8.76 12.47 8.47C12.76 8.18 13.24 8.18 13.53 8.47L16.53 11.47C16.6 11.54 16.65 11.62 16.69 11.71C16.77 11.89 16.77 12.1 16.69 12.28V12.29ZM20 3.25C19.59 3.25 19.25 3.59 19.25 4V20C19.25 20.41 19.59 20.75 20 20.75C20.41 20.75 20.75 20.41 20.75 20V4C20.75 3.59 20.41 3.25 20 3.25Z"></path></svg>',
  "collapseall-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M15.53 18.47C15.82 18.76 15.82 19.24 15.53 19.53C15.38 19.68 15.19 19.75 15 19.75C14.81 19.75 14.62 19.68 14.47 19.53L12.75 17.81V22C12.75 22.41 12.41 22.75 12 22.75C11.59 22.75 11.25 22.41 11.25 22V17.81L9.53 19.53C9.24 19.82 8.76 19.82 8.47 19.53C8.18 19.24 8.18 18.76 8.47 18.47L11.47 15.47C11.54 15.4 11.62 15.35 11.71 15.31C11.89 15.23 12.1 15.23 12.28 15.31C12.37 15.35 12.45 15.4 12.52 15.47L15.52 18.47H15.53ZM11.47 8.53C11.54 8.6 11.62 8.65 11.71 8.69C11.8 8.73 11.9 8.75 12 8.75C12.1 8.75 12.2 8.73 12.29 8.69C12.38 8.65 12.46 8.6 12.53 8.53L15.53 5.53C15.82 5.24 15.82 4.76 15.53 4.47C15.24 4.18 14.76 4.18 14.47 4.47L12.75 6.19V2C12.75 1.59 12.41 1.25 12 1.25C11.59 1.25 11.25 1.59 11.25 2V6.19L9.53 4.47C9.24 4.18 8.76 4.18 8.47 4.47C8.18 4.76 8.18 5.24 8.47 5.53L11.47 8.53ZM21 11.25H3C2.59 11.25 2.25 11.59 2.25 12C2.25 12.41 2.59 12.75 3 12.75H21C21.41 12.75 21.75 12.41 21.75 12C21.75 11.59 21.41 11.25 21 11.25Z"></path></svg>',
  "collapsedetails-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M11.75 8C11.75 8.41 11.41 8.75 11 8.75H5C4.59 8.75 4.25 8.41 4.25 8C4.25 7.59 4.59 7.25 5 7.25H11C11.41 7.25 11.75 7.59 11.75 8Z"></path></svg>',
  "collapsefocused-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M11.75 8C11.75 8.41 11.41 8.75 11 8.75H5C4.59 8.75 4.25 8.41 4.25 8C4.25 7.59 4.59 7.25 5 7.25H11C11.41 7.25 11.75 7.59 11.75 8Z"></path><path d="M13 3H3C1.35 3 0 4.35 0 6V10C0 11.65 1.35 13 3 13H13C14.65 13 16 11.65 16 10V6C16 4.35 14.65 3 13 3ZM14 10C14 10.55 13.55 11 13 11H3C2.45 11 2 10.55 2 10V6C2 5.45 2.45 5 3 5H13C13.55 5 14 5.45 14 6V10Z"></path></svg>',
  "collapsepage-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M10.53 11.47C10.82 11.76 10.82 12.24 10.53 12.53C10.38 12.68 10.19 12.75 10 12.75C9.81 12.75 9.62 12.68 9.47 12.53L8.75 11.81V14C8.75 14.41 8.41 14.75 8 14.75C7.59 14.75 7.25 14.41 7.25 14V11.81L6.53 12.53C6.24 12.82 5.76 12.82 5.47 12.53C5.18 12.24 5.18 11.76 5.47 11.47L7.47 9.47C7.54 9.4 7.62 9.35 7.71 9.31C7.89 9.23 8.1 9.23 8.28 9.31C8.37 9.35 8.45 9.4 8.52 9.47L10.52 11.47H10.53ZM9.47 3.47L8.75 4.19V2C8.75 1.59 8.41 1.25 8 1.25C7.59 1.25 7.25 1.59 7.25 2V4.19L6.53 3.47C6.24 3.18 5.76 3.18 5.47 3.47C5.18 3.76 5.18 4.24 5.47 4.53L7.47 6.53C7.54 6.6 7.62 6.65 7.71 6.69C7.8 6.73 7.9 6.75 8 6.75C8.1 6.75 8.2 6.73 8.29 6.69C8.38 6.65 8.46 6.6 8.53 6.53L10.53 4.53C10.82 4.24 10.82 3.76 10.53 3.47C10.24 3.18 9.76 3.18 9.47 3.47ZM3 6.75C3.41 6.75 3.75 6.41 3.75 6C3.75 5.59 3.41 5.25 3 5.25C2.04 5.25 1.25 6.04 1.25 7V9C1.25 9.96 2.04 10.75 3 10.75C3.41 10.75 3.75 10.41 3.75 10C3.75 9.59 3.41 9.25 3 9.25C2.86 9.25 2.75 9.14 2.75 9V7C2.75 6.86 2.86 6.75 3 6.75ZM13 5.25C12.59 5.25 12.25 5.59 12.25 6C12.25 6.41 12.59 6.75 13 6.75C13.14 6.75 13.25 6.86 13.25 7V9C13.25 9.14 13.14 9.25 13 9.25C12.59 9.25 12.25 9.59 12.25 10C12.25 10.41 12.59 10.75 13 10.75C13.96 10.75 14.75 9.96 14.75 9V7C14.75 6.04 13.96 5.25 13 5.25Z"></path></svg>',
  "collapsepanel-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M12.75 8C12.75 8.41 12.41 8.75 12 8.75H4C3.59 8.75 3.25 8.41 3.25 8C3.25 7.59 3.59 7.25 4 7.25H12C12.41 7.25 12.75 7.59 12.75 8Z"></path></svg>',
  "copy-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M9 5.25H3C2.04 5.25 1.25 6.04 1.25 7V13C1.25 13.96 2.04 14.75 3 14.75H9C9.96 14.75 10.75 13.96 10.75 13V7C10.75 6.04 9.96 5.25 9 5.25ZM9.25 13C9.25 13.14 9.14 13.25 9 13.25H3C2.86 13.25 2.75 13.14 2.75 13V7C2.75 6.86 2.86 6.75 3 6.75H9C9.14 6.75 9.25 6.86 9.25 7V13ZM14.75 3V9C14.75 9.96 13.96 10.75 13 10.75H12C11.59 10.75 11.25 10.41 11.25 10C11.25 9.59 11.59 9.25 12 9.25H13C13.14 9.25 13.25 9.14 13.25 9V3C13.25 2.86 13.14 2.75 13 2.75H7C6.86 2.75 6.75 2.86 6.75 3V4C6.75 4.41 6.41 4.75 6 4.75C5.59 4.75 5.25 4.41 5.25 4V3C5.25 2.04 6.04 1.25 7 1.25H13C13.96 1.25 14.75 2.04 14.75 3Z"></path></svg>',
  "copy-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M13 8.25H6C4.48 8.25 3.25 9.48 3.25 11V18C3.25 19.52 4.48 20.75 6 20.75H13C14.52 20.75 15.75 19.52 15.75 18V11C15.75 9.48 14.52 8.25 13 8.25ZM14.25 18C14.25 18.69 13.69 19.25 13 19.25H6C5.31 19.25 4.75 18.69 4.75 18V11C4.75 10.31 5.31 9.75 6 9.75H13C13.69 9.75 14.25 10.31 14.25 11V18ZM20.75 6V13C20.75 14.52 19.52 15.75 18 15.75C17.59 15.75 17.25 15.41 17.25 15C17.25 14.59 17.59 14.25 18 14.25C18.69 14.25 19.25 13.69 19.25 13V6C19.25 5.31 18.69 4.75 18 4.75H11C10.31 4.75 9.75 5.31 9.75 6C9.75 6.41 9.41 6.75 9 6.75C8.59 6.75 8.25 6.41 8.25 6C8.25 4.48 9.48 3.25 11 3.25H18C19.52 3.25 20.75 4.48 20.75 6Z"></path></svg>',
  "cross-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M16.35 15.65C16.55 15.85 16.55 16.16 16.35 16.36C16.25 16.46 16.12 16.51 16 16.51C15.88 16.51 15.74 16.46 15.65 16.36L12 12.71L8.35 16.36C8.25 16.46 8.12 16.51 8 16.51C7.88 16.51 7.74 16.46 7.65 16.36C7.45 16.16 7.45 15.85 7.65 15.65L11.3 12L7.65 8.35C7.45 8.16 7.45 7.84 7.65 7.65C7.85 7.46 8.16 7.45 8.35 7.65L12 11.3L15.65 7.65C15.85 7.45 16.16 7.45 16.36 7.65C16.56 7.85 16.56 8.16 16.36 8.36L12.71 12.01L16.36 15.66L16.35 15.65Z"></path></svg>',
  "delete-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M13 3.25H10.75V3C10.75 2.04 9.96 1.25 9 1.25H7C6.04 1.25 5.25 2.04 5.25 3V3.25H3C2.59 3.25 2.25 3.59 2.25 4C2.25 4.41 2.59 4.75 3 4.75H3.25V13C3.25 13.96 4.04 14.75 5 14.75H11C11.96 14.75 12.75 13.96 12.75 13V4.75H13C13.41 4.75 13.75 4.41 13.75 4C13.75 3.59 13.41 3.25 13 3.25ZM6.75 3C6.75 2.86 6.86 2.75 7 2.75H9C9.14 2.75 9.25 2.86 9.25 3V3.25H6.75V3ZM11.25 13C11.25 13.14 11.14 13.25 11 13.25H5C4.86 13.25 4.75 13.14 4.75 13V4.75H11.25V13ZM9.25 6.25C9.66 6.25 10 6.59 10 7V11C10 11.41 9.66 11.75 9.25 11.75C8.84 11.75 8.5 11.41 8.5 11V7C8.5 6.59 8.84 6.25 9.25 6.25ZM7.5 7V11C7.5 11.41 7.16 11.75 6.75 11.75C6.34 11.75 6 11.41 6 11V7C6 6.59 6.34 6.25 6.75 6.25C7.16 6.25 7.5 6.59 7.5 7Z"></path></svg>',
  "delete-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12.75 9V17C12.75 17.41 12.41 17.75 12 17.75C11.59 17.75 11.25 17.41 11.25 17V9C11.25 8.59 11.59 8.25 12 8.25C12.41 8.25 12.75 8.59 12.75 9ZM14.25 9V17C14.25 17.41 14.59 17.75 15 17.75C15.41 17.75 15.75 17.41 15.75 17V9C15.75 8.59 15.41 8.25 15 8.25C14.59 8.25 14.25 8.59 14.25 9ZM9 8.25C8.59 8.25 8.25 8.59 8.25 9V17C8.25 17.41 8.59 17.75 9 17.75C9.41 17.75 9.75 17.41 9.75 17V9C9.75 8.59 9.41 8.25 9 8.25ZM20.75 6C20.75 6.41 20.41 6.75 20 6.75H18.75V18C18.75 19.52 17.52 20.75 16 20.75H8C6.48 20.75 5.25 19.52 5.25 18V6.75H4C3.59 6.75 3.25 6.41 3.25 6C3.25 5.59 3.59 5.25 4 5.25H8.25V4C8.25 3.04 9.04 2.25 10 2.25H14C14.96 2.25 15.75 3.04 15.75 4V5.25H20C20.41 5.25 20.75 5.59 20.75 6ZM9.75 5.25H14.25V4C14.25 3.86 14.14 3.75 14 3.75H10C9.86 3.75 9.75 3.86 9.75 4V5.25ZM17.25 6.75H6.75V18C6.75 18.69 7.31 19.25 8 19.25H16C16.69 19.25 17.25 18.69 17.25 18V6.75Z"></path></svg>',
  "desktop-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M22 14.25H20.75V7C20.75 5.48 19.52 4.25 18 4.25H6C4.48 4.25 3.25 5.48 3.25 7V14.25H2C1.59 14.25 1.25 14.59 1.25 15V17C1.25 18.52 2.58 19.75 4.22 19.75H19.77C21.41 19.75 22.74 18.52 22.74 17V15C22.74 14.59 22.4 14.25 21.99 14.25H22ZM4.75 7C4.75 6.31 5.31 5.75 6 5.75H18C18.69 5.75 19.25 6.31 19.25 7V14.25H4.75V7ZM21.25 17C21.25 17.69 20.59 18.25 19.78 18.25H4.22C3.41 18.25 2.75 17.69 2.75 17V15.75H21.25V17Z"></path></svg>',
  "download-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20.75 16V18C20.75 19.52 19.52 20.75 18 20.75H6C4.48 20.75 3.25 19.52 3.25 18V16C3.25 15.59 3.59 15.25 4 15.25C4.41 15.25 4.75 15.59 4.75 16V18C4.75 18.69 5.31 19.25 6 19.25H18C18.69 19.25 19.25 18.69 19.25 18V16C19.25 15.59 19.59 15.25 20 15.25C20.41 15.25 20.75 15.59 20.75 16ZM11.47 16.53C11.54 16.6 11.62 16.65 11.71 16.69C11.8 16.73 11.9 16.75 12 16.75C12.1 16.75 12.2 16.73 12.29 16.69C12.38 16.65 12.46 16.6 12.53 16.53L16.53 12.53C16.82 12.24 16.82 11.76 16.53 11.47C16.24 11.18 15.76 11.18 15.47 11.47L12.75 14.19V4C12.75 3.59 12.41 3.25 12 3.25C11.59 3.25 11.25 3.59 11.25 4V14.19L8.53 11.47C8.24 11.18 7.76 11.18 7.47 11.47C7.18 11.76 7.18 12.24 7.47 12.53L11.47 16.53Z"></path></svg>',
  "drag-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 8.75C15.19 8.75 15.75 8.19 15.75 7.5C15.75 6.81 15.19 6.25 14.5 6.25C13.81 6.25 13.25 6.81 13.25 7.5C13.25 8.19 13.81 8.75 14.5 8.75ZM14.5 7.25C14.64 7.25 14.75 7.36 14.75 7.5C14.75 7.78 14.25 7.78 14.25 7.5C14.25 7.36 14.36 7.25 14.5 7.25ZM9.5 6.25C8.81 6.25 8.25 6.81 8.25 7.5C8.25 8.19 8.81 8.75 9.5 8.75C10.19 8.75 10.75 8.19 10.75 7.5C10.75 6.81 10.19 6.25 9.5 6.25ZM9.25 7.5C9.25 7.36 9.36 7.25 9.5 7.25C9.64 7.25 9.75 7.36 9.75 7.5C9.75 7.78 9.25 7.78 9.25 7.5ZM14.5 11.25C13.81 11.25 13.25 11.81 13.25 12.5C13.25 13.19 13.81 13.75 14.5 13.75C15.19 13.75 15.75 13.19 15.75 12.5C15.75 11.81 15.19 11.25 14.5 11.25ZM14.25 12.5C14.25 12.36 14.36 12.25 14.5 12.25C14.64 12.25 14.75 12.36 14.75 12.5C14.75 12.78 14.25 12.78 14.25 12.5ZM9.5 11.25C8.81 11.25 8.25 11.81 8.25 12.5C8.25 13.19 8.81 13.75 9.5 13.75C10.19 13.75 10.75 13.19 10.75 12.5C10.75 11.81 10.19 11.25 9.5 11.25ZM9.25 12.5C9.25 12.36 9.36 12.25 9.5 12.25C9.64 12.25 9.75 12.36 9.75 12.5C9.75 12.78 9.25 12.78 9.25 12.5ZM14.5 16.25C13.81 16.25 13.25 16.81 13.25 17.5C13.25 18.19 13.81 18.75 14.5 18.75C15.19 18.75 15.75 18.19 15.75 17.5C15.75 16.81 15.19 16.25 14.5 16.25ZM14.25 17.5C14.25 17.36 14.36 17.25 14.5 17.25C14.64 17.25 14.75 17.36 14.75 17.5C14.75 17.78 14.25 17.78 14.25 17.5ZM9.5 16.25C8.81 16.25 8.25 16.81 8.25 17.5C8.25 18.19 8.81 18.75 9.5 18.75C10.19 18.75 10.75 18.19 10.75 17.5C10.75 16.81 10.19 16.25 9.5 16.25ZM9.25 17.5C9.25 17.36 9.36 17.25 9.5 17.25C9.64 17.25 9.75 17.36 9.75 17.5C9.75 17.78 9.25 17.78 9.25 17.5Z"></path></svg>',
  "draghorizontal-24x16": '<svg viewBox="0 0 24 16" xmlns="http://www.w3.org/2000/svg"><path d="M17.5 9.25C16.81 9.25 16.25 9.81 16.25 10.5C16.25 11.19 16.81 11.75 17.5 11.75C18.19 11.75 18.75 11.19 18.75 10.5C18.75 9.81 18.19 9.25 17.5 9.25ZM17.25 10.5C17.25 10.36 17.36 10.25 17.5 10.25C17.64 10.25 17.75 10.36 17.75 10.5C17.75 10.78 17.25 10.78 17.25 10.5ZM17.5 6.75C18.19 6.75 18.75 6.19 18.75 5.5C18.75 4.81 18.19 4.25 17.5 4.25C16.81 4.25 16.25 4.81 16.25 5.5C16.25 6.19 16.81 6.75 17.5 6.75ZM17.5 5.25C17.64 5.25 17.75 5.36 17.75 5.5C17.75 5.78 17.25 5.78 17.25 5.5C17.25 5.36 17.36 5.25 17.5 5.25ZM12.5 9.25C11.81 9.25 11.25 9.81 11.25 10.5C11.25 11.19 11.81 11.75 12.5 11.75C13.19 11.75 13.75 11.19 13.75 10.5C13.75 9.81 13.19 9.25 12.5 9.25ZM12.25 10.5C12.25 10.36 12.36 10.25 12.5 10.25C12.64 10.25 12.75 10.36 12.75 10.5C12.75 10.78 12.25 10.78 12.25 10.5ZM12.5 4.25C11.81 4.25 11.25 4.81 11.25 5.5C11.25 6.19 11.81 6.75 12.5 6.75C13.19 6.75 13.75 6.19 13.75 5.5C13.75 4.81 13.19 4.25 12.5 4.25ZM12.25 5.5C12.25 5.36 12.36 5.25 12.5 5.25C12.64 5.25 12.75 5.36 12.75 5.5C12.75 5.78 12.25 5.78 12.25 5.5ZM7.5 9.25C6.81 9.25 6.25 9.81 6.25 10.5C6.25 11.19 6.81 11.75 7.5 11.75C8.19 11.75 8.75 11.19 8.75 10.5C8.75 9.81 8.19 9.25 7.5 9.25ZM7.25 10.5C7.25 10.36 7.36 10.25 7.5 10.25C7.64 10.25 7.75 10.36 7.75 10.5C7.75 10.78 7.25 10.78 7.25 10.5ZM7.5 4.25C6.81 4.25 6.25 4.81 6.25 5.5C6.25 6.19 6.81 6.75 7.5 6.75C8.19 6.75 8.75 6.19 8.75 5.5C8.75 4.81 8.19 4.25 7.5 4.25ZM7.25 5.5C7.25 5.36 7.36 5.25 7.5 5.25C7.64 5.25 7.75 5.36 7.75 5.5C7.75 5.78 7.25 5.78 7.25 5.5Z"></path></svg>',
  "draghorizontalsmall-24x16": '<svg viewBox="0 0 24 16" xmlns="http://www.w3.org/2000/svg"><path d="M16.5 9.25C15.81 9.25 15.25 9.81 15.25 10.5C15.25 11.19 15.81 11.75 16.5 11.75C17.19 11.75 17.75 11.19 17.75 10.5C17.75 9.81 17.19 9.25 16.5 9.25ZM16.25 10.5C16.25 10.36 16.36 10.25 16.5 10.25C16.64 10.25 16.75 10.36 16.75 10.5C16.75 10.78 16.25 10.78 16.25 10.5ZM16.5 7.75C17.19 7.75 17.75 7.19 17.75 6.5C17.75 5.81 17.19 5.25 16.5 5.25C15.81 5.25 15.25 5.81 15.25 6.5C15.25 7.19 15.81 7.75 16.5 7.75ZM16.5 6.25C16.64 6.25 16.75 6.36 16.75 6.5C16.75 6.78 16.25 6.78 16.25 6.5C16.25 6.36 16.36 6.25 16.5 6.25ZM12.5 9.25C11.81 9.25 11.25 9.81 11.25 10.5C11.25 11.19 11.81 11.75 12.5 11.75C13.19 11.75 13.75 11.19 13.75 10.5C13.75 9.81 13.19 9.25 12.5 9.25ZM12.25 10.5C12.25 10.36 12.36 10.25 12.5 10.25C12.64 10.25 12.75 10.36 12.75 10.5C12.75 10.78 12.25 10.78 12.25 10.5ZM12.5 5.25C11.81 5.25 11.25 5.81 11.25 6.5C11.25 7.19 11.81 7.75 12.5 7.75C13.19 7.75 13.75 7.19 13.75 6.5C13.75 5.81 13.19 5.25 12.5 5.25ZM12.25 6.5C12.25 6.36 12.36 6.25 12.5 6.25C12.64 6.25 12.75 6.36 12.75 6.5C12.75 6.78 12.25 6.78 12.25 6.5ZM8.5 9.25C7.81 9.25 7.25 9.81 7.25 10.5C7.25 11.19 7.81 11.75 8.5 11.75C9.19 11.75 9.75 11.19 9.75 10.5C9.75 9.81 9.19 9.25 8.5 9.25ZM8.25 10.5C8.25 10.36 8.36 10.25 8.5 10.25C8.64 10.25 8.75 10.36 8.75 10.5C8.75 10.78 8.25 10.78 8.25 10.5ZM8.5 5.25C7.81 5.25 7.25 5.81 7.25 6.5C7.25 7.19 7.81 7.75 8.5 7.75C9.19 7.75 9.75 7.19 9.75 6.5C9.75 5.81 9.19 5.25 8.5 5.25ZM8.25 6.5C8.25 6.36 8.36 6.25 8.5 6.25C8.64 6.25 8.75 6.36 8.75 6.5C8.75 6.78 8.25 6.78 8.25 6.5Z"></path></svg>',
  "dropper-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M3.31 15C2.69 15 2.11 14.76 1.68 14.32C0.780005 13.42 0.780005 11.95 1.68 11.05L2.45 10.28C2.45 10.18 2.44 10.08 2.44 9.98C2.44 9.02 2.81 8.12 3.49 7.44L5.6 5.33C5.37 5.04 5.25 4.68 5.25 4.31C5.25 3.86 5.42 3.44 5.74 3.12C6.06 2.8 6.48 2.63 6.92 2.63C7.29 2.63 7.65 2.75 7.94 2.98L8.88 2.04C9.56001 1.36 10.46 0.989998 11.41 0.989998C12.36 0.989998 13.27 1.36 13.95 2.04C14.63 2.72 15 3.62 15 4.58C15 5.54 14.63 6.44 13.95 7.12L12.94 8.13C13.04 8.34 13.09 8.58 13.09 8.82C13.09 9.27 12.92 9.69 12.6 10C12.28 10.31 11.86 10.49 11.42 10.49C11.18 10.49 10.94 10.44 10.73 10.34L8.56 12.51C7.88 13.19 6.98 13.56 6.03 13.56C5.93001 13.56 5.83 13.56 5.73 13.54L4.97 14.3C4.53 14.74 3.95 14.98 3.34 14.98L3.31 15Z" fill="black" fill-opacity="0.15"></path><path d="M14 4.58C14 3.89 13.73 3.24 13.24 2.75C12.23 1.74 10.59 1.74 9.58 2.75L7.94 4.39L7.39 3.84C7.13 3.58 6.7 3.58 6.44 3.84C6.18 4.1 6.18 4.53 6.44 4.79L6.99 5.34L4.18 8.15C3.69 8.64 3.42 9.29 3.42 9.98C3.42 10.2 3.46 10.41 3.51 10.62L2.38 11.75C1.87 12.26 1.87 13.09 2.38 13.61C2.64 13.87 2.97 13.99 3.31 13.99C3.65 13.99 3.98 13.86 4.24 13.61L5.37 12.48C5.58 12.53 5.79 12.57 6.01 12.57C6.7 12.57 7.35 12.3 7.84 11.81L10.65 9L10.94 9.29C11.07 9.42 11.24 9.49 11.42 9.49C11.6 9.49 11.77 9.42 11.9 9.29C12.16 9.03 12.16 8.6 11.9 8.34L11.61 8.05L13.25 6.41C13.74 5.92 14.01 5.27 14.01 4.58H14ZM6.89 10.86C6.42 11.33 5.61 11.33 5.14 10.86C4.91 10.63 4.78 10.32 4.78 9.99C4.78 9.66 4.91 9.35 5.14 9.12L7.95 6.31L9.7 8.06L6.89 10.87V10.86Z" fill="white"></path></svg>',
  "edit-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.1209 2.0525L13.9509 1.8825C12.8809 0.812502 11.1309 0.812502 10.0609 1.8825L2.47089 9.4625C2.37089 9.5625 2.31089 9.6825 2.27089 9.8125L1.27089 13.8125C1.21089 14.0625 1.28089 14.3425 1.47089 14.5225C1.61089 14.6625 1.80089 14.7425 2.00089 14.7425C2.06089 14.7425 2.12089 14.7425 2.18089 14.7225L6.18089 13.7225C6.31089 13.6925 6.43089 13.6225 6.53089 13.5225L14.1209 5.9325C15.1909 4.8625 15.1909 3.1125 14.1209 2.0425V2.0525ZM5.62089 12.3125L3.04089 12.9625L3.69089 10.3825L9.00089 5.0525L10.9409 6.9925L5.62089 12.3125ZM13.0609 4.8725L12.0009 5.9325L10.0609 3.9925L11.1209 2.9325C11.6109 2.4425 12.4009 2.4425 12.8909 2.9325L13.0609 3.1025C13.5509 3.5925 13.5509 4.3825 13.0609 4.8725Z"></path></svg>',
  "edit-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20.1301 6.05249L17.9601 3.88249C16.8901 2.81249 15.1401 2.81249 14.0701 3.88249L4.48014 13.4625C4.37014 13.5725 4.30014 13.7125 4.27014 13.8725L3.26014 19.8725C3.22014 20.1125 3.30014 20.3525 3.47014 20.5225C3.61014 20.6625 3.80014 20.7425 4.00014 20.7425C4.04014 20.7425 4.08014 20.7425 4.12014 20.7425L10.1201 19.7425C10.2701 19.7125 10.4201 19.6425 10.5301 19.5325L20.1201 9.94249C20.6401 9.42249 20.9301 8.73249 20.9301 8.00249C20.9301 7.27249 20.6401 6.57249 20.1201 6.06249L20.1301 6.05249ZM16.0101 11.9325L12.0701 7.99249L13.0101 7.05249L16.9501 10.9925L16.0101 11.9325ZM9.65014 18.2925L4.92014 19.0825L5.71014 14.3525L11.0101 9.05249L14.9501 12.9925L9.65014 18.2925ZM19.0701 8.87249L18.0101 9.93249L14.0701 5.99249L15.1301 4.93249C15.6201 4.44249 16.4101 4.44249 16.9001 4.93249L19.0701 7.10249C19.3101 7.34249 19.4401 7.65249 19.4401 7.98249C19.4401 8.31249 19.3101 8.63249 19.0701 8.86249V8.87249Z"></path></svg>',
  "editsmall-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M13.1209 3.0525L12.9509 2.8825C11.8809 1.8125 10.1309 1.8125 9.06089 2.8825L3.47089 8.4625C3.37089 8.5625 3.31089 8.6825 3.27089 8.8125L2.27089 12.8125C2.21089 13.0625 2.28089 13.3425 2.47089 13.5225C2.61089 13.6625 2.80089 13.7425 3.00089 13.7425C3.06089 13.7425 3.12089 13.7425 3.18089 13.7225L7.18089 12.7225C7.31089 12.6925 7.43089 12.6225 7.53089 12.5225L13.1209 6.9325C14.1909 5.8625 14.1909 4.1125 13.1209 3.0425V3.0525ZM6.62089 11.3125L4.04089 11.9625L4.69089 9.3825L8.01089 6.0625L9.95089 8.0025L6.63089 11.3225L6.62089 11.3125ZM12.0609 5.8725L11.0009 6.9325L9.06089 4.9925L10.1209 3.9325C10.6109 3.4425 11.4009 3.4425 11.8909 3.9325L12.0609 4.1025C12.5509 4.5925 12.5509 5.3825 12.0609 5.8725Z"></path></svg>',
  "embedsurvey-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M13 14.41V23H11V14.41L8.71 16.7L7.3 15.29L12.01 10.58L16.72 15.29L15.31 16.7L13.02 14.41H13ZM20 3H4C2.9 3 2 3.9 2 5V19C2 20.1 2.9 21 4 21H9V19H4V5H20V19H15V21H20C21.1 21 22 20.1 22 19V5C22 3.9 21.1 3 20 3ZM5 6V8H8V6H5ZM19 6H9V8H19V6Z"></path></svg>',
  "error-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M8 1.25C4.28 1.25 1.25 4.28 1.25 8C1.25 11.72 4.28 14.75 8 14.75C11.72 14.75 14.75 11.72 14.75 8C14.75 4.28 11.72 1.25 8 1.25ZM8 13.25C5.11 13.25 2.75 10.89 2.75 8C2.75 5.11 5.11 2.75 8 2.75C10.89 2.75 13.25 5.11 13.25 8C13.25 10.89 10.89 13.25 8 13.25ZM10.53 6.53L9.06 8L10.53 9.47C10.82 9.76 10.82 10.24 10.53 10.53C10.38 10.68 10.19 10.75 10 10.75C9.81 10.75 9.62 10.68 9.47 10.53L8 9.06L6.53 10.53C6.38 10.68 6.19 10.75 6 10.75C5.81 10.75 5.62 10.68 5.47 10.53C5.18 10.24 5.18 9.76 5.47 9.47L6.94 8L5.47 6.53C5.18 6.24 5.18 5.76 5.47 5.47C5.76 5.18 6.24 5.18 6.53 5.47L8 6.94L9.47 5.47C9.76 5.18 10.24 5.18 10.53 5.47C10.82 5.76 10.82 6.24 10.53 6.53Z"></path></svg>',
  "error-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 5.25C8.28 5.25 5.25 8.28 5.25 12C5.25 15.72 8.28 18.75 12 18.75C15.72 18.75 18.75 15.72 18.75 12C18.75 8.28 15.72 5.25 12 5.25ZM12 17.25C9.11 17.25 6.75 14.89 6.75 12C6.75 9.11 9.11 6.75 12 6.75C14.89 6.75 17.25 9.11 17.25 12C17.25 14.89 14.89 17.25 12 17.25ZM14.53 10.53L13.06 12L14.53 13.47C14.82 13.76 14.82 14.24 14.53 14.53C14.38 14.68 14.19 14.75 14 14.75C13.81 14.75 13.62 14.68 13.47 14.53L12 13.06L10.53 14.53C10.38 14.68 10.19 14.75 10 14.75C9.81 14.75 9.62 14.68 9.47 14.53C9.18 14.24 9.18 13.76 9.47 13.47L10.94 12L9.47 10.53C9.18 10.24 9.18 9.76 9.47 9.47C9.76 9.18 10.24 9.18 10.53 9.47L12 10.94L13.47 9.47C13.76 9.18 14.24 9.18 14.53 9.47C14.82 9.76 14.82 10.24 14.53 10.53Z"></path></svg>',
  "expand-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M11.75 8C11.75 8.41 11.41 8.75 11 8.75H8.75V11C8.75 11.41 8.41 11.75 8 11.75C7.59 11.75 7.25 11.41 7.25 11V8.75H5C4.59 8.75 4.25 8.41 4.25 8C4.25 7.59 4.59 7.25 5 7.25H7.25V5C7.25 4.59 7.59 4.25 8 4.25C8.41 4.25 8.75 4.59 8.75 5V7.25H11C11.41 7.25 11.75 7.59 11.75 8Z"></path></svg>',
  "expand-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M7.4675 7.53C7.1775 7.24 7.1775 6.76 7.4675 6.47L11.4675 2.47C11.5375 2.4 11.6175 2.35 11.7075 2.31C11.8875 2.23 12.0975 2.23 12.2775 2.31C12.3675 2.35 12.4475 2.4 12.5175 2.47L16.5175 6.47C16.8075 6.76 16.8075 7.24 16.5175 7.53C16.3675 7.68 16.1775 7.75 15.9875 7.75C15.7975 7.75 15.6075 7.68 15.4575 7.53L12.7375 4.81V10C12.7375 10.41 12.3975 10.75 11.9875 10.75C11.5775 10.75 11.2375 10.41 11.2375 10V4.81L8.5175 7.53C8.2275 7.82 7.7475 7.82 7.4575 7.53H7.4675ZM15.4675 16.47L12.7475 19.19V14C12.7475 13.59 12.4075 13.25 11.9975 13.25C11.5875 13.25 11.2475 13.59 11.2475 14V19.19L8.5275 16.47C8.2375 16.18 7.7575 16.18 7.4675 16.47C7.1775 16.76 7.1775 17.24 7.4675 17.53L11.4675 21.53C11.5375 21.6 11.6175 21.65 11.7075 21.69C11.7975 21.73 11.8975 21.75 11.9975 21.75C12.0975 21.75 12.1975 21.73 12.2875 21.69C12.3775 21.65 12.4575 21.6 12.5275 21.53L16.5275 17.53C16.8175 17.24 16.8175 16.76 16.5275 16.47C16.2375 16.18 15.7575 16.18 15.4675 16.47Z"></path></svg>',
  "expand-pg-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M6.53 14.47C6.82 14.76 6.82 15.24 6.53 15.53C6.38 15.68 6.19 15.75 6 15.75C5.81 15.75 5.62 15.68 5.47 15.53L2.47 12.53C2.4 12.46 2.35 12.38 2.31 12.29C2.23 12.11 2.23 11.9 2.31 11.72C2.35 11.63 2.4 11.55 2.47 11.48L5.47 8.48C5.76 8.19 6.24 8.19 6.53 8.48C6.82 8.77 6.82 9.25 6.53 9.54L4.81 11.26H13C13.41 11.26 13.75 11.6 13.75 12.01C13.75 12.42 13.41 12.76 13 12.76H4.81L6.53 14.48V14.47ZM18 3.25H12C10.48 3.25 9.25 4.48 9.25 6V9C9.25 9.41 9.59 9.75 10 9.75C10.41 9.75 10.75 9.41 10.75 9V6C10.75 5.31 11.31 4.75 12 4.75H18C18.69 4.75 19.25 5.31 19.25 6V18C19.25 18.69 18.69 19.25 18 19.25H12C11.31 19.25 10.75 18.69 10.75 18V15C10.75 14.59 10.41 14.25 10 14.25C9.59 14.25 9.25 14.59 9.25 15V18C9.25 19.52 10.48 20.75 12 20.75H18C19.52 20.75 20.75 19.52 20.75 18V6C20.75 4.48 19.52 3.25 18 3.25Z"></path></svg>',
  "expandall-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M8.47 5.53C8.18 5.24 8.18 4.76 8.47 4.47L11.47 1.47C11.54 1.4 11.62 1.35 11.71 1.31C11.89 1.23 12.1 1.23 12.28 1.31C12.37 1.35 12.45 1.4 12.52 1.47L15.52 4.47C15.81 4.76 15.81 5.24 15.52 5.53C15.37 5.68 15.18 5.75 14.99 5.75C14.8 5.75 14.61 5.68 14.46 5.53L12.74 3.81V9C12.74 9.41 12.4 9.75 11.99 9.75C11.58 9.75 11.24 9.41 11.24 9V3.81L9.52 5.53C9.23 5.82 8.75 5.82 8.46 5.53H8.47ZM14.47 18.47L12.75 20.19V15C12.75 14.59 12.41 14.25 12 14.25C11.59 14.25 11.25 14.59 11.25 15V20.19L9.53 18.47C9.24 18.18 8.76 18.18 8.47 18.47C8.18 18.76 8.18 19.24 8.47 19.53L11.47 22.53C11.54 22.6 11.62 22.65 11.71 22.69C11.8 22.73 11.9 22.75 12 22.75C12.1 22.75 12.2 22.73 12.29 22.69C12.38 22.65 12.46 22.6 12.53 22.53L15.53 19.53C15.82 19.24 15.82 18.76 15.53 18.47C15.24 18.18 14.76 18.18 14.47 18.47ZM19 8.25H16C15.59 8.25 15.25 8.59 15.25 9C15.25 9.41 15.59 9.75 16 9.75H19C19.69 9.75 20.25 10.31 20.25 11V13C20.25 13.69 19.69 14.25 19 14.25H16C15.59 14.25 15.25 14.59 15.25 15C15.25 15.41 15.59 15.75 16 15.75H19C20.52 15.75 21.75 14.52 21.75 13V11C21.75 9.48 20.52 8.25 19 8.25ZM8.75 15C8.75 14.59 8.41 14.25 8 14.25H5C4.31 14.25 3.75 13.69 3.75 13V11C3.75 10.31 4.31 9.75 5 9.75H8C8.41 9.75 8.75 9.41 8.75 9C8.75 8.59 8.41 8.25 8 8.25H5C3.48 8.25 2.25 9.48 2.25 11V13C2.25 14.52 3.48 15.75 5 15.75H8C8.41 15.75 8.75 15.41 8.75 15Z"></path></svg>',
  "expanddetails-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M11.75 8C11.75 8.41 11.41 8.75 11 8.75H8.75V11C8.75 11.41 8.41 11.75 8 11.75C7.59 11.75 7.25 11.41 7.25 11V8.75H5C4.59 8.75 4.25 8.41 4.25 8C4.25 7.59 4.59 7.25 5 7.25H7.25V5C7.25 4.59 7.59 4.25 8 4.25C8.41 4.25 8.75 4.59 8.75 5V7.25H11C11.41 7.25 11.75 7.59 11.75 8Z"></path></svg>',
  "expandfocused-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_22167_104453)"><path d="M11.75 8C11.75 8.41 11.41 8.75 11 8.75H8.75V11C8.75 11.41 8.41 11.75 8 11.75C7.59 11.75 7.25 11.41 7.25 11V8.75H5C4.59 8.75 4.25 8.41 4.25 8C4.25 7.59 4.59 7.25 5 7.25H7.25V5C7.25 4.59 7.59 4.25 8 4.25C8.41 4.25 8.75 4.59 8.75 5V7.25H11C11.41 7.25 11.75 7.59 11.75 8Z"></path><path d="M13 3C13 1.35 11.65 0 10 0H6C4.35 0 3 1.35 3 3C1.35 3 0 4.35 0 6V10C0 11.65 1.35 13 3 13C3 14.65 4.35 16 6 16H10C11.65 16 13 14.65 13 13C14.65 13 16 11.65 16 10V6C16 4.35 14.65 3 13 3ZM14 10C14 10.55 13.55 11 13 11H12C11.45 11 11 11.45 11 12V13C11 13.55 10.55 14 10 14H6C5.45 14 5 13.55 5 13V12C5 11.45 4.55 11 4 11H3C2.45 11 2 10.55 2 10V6C2 5.45 2.45 5 3 5H4C4.55 5 5 4.55 5 4V3C5 2.45 5.45 2 6 2H10C10.55 2 11 2.45 11 3V4C11 4.55 11.45 5 12 5H13C13.55 5 14 5.45 14 6V10Z"></path></g><defs><clipPath id="clip0_22167_104453"><rect width="16" height="16" fill="white"></rect></clipPath></defs></svg>',
  "expandpage-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M10.53 3.47C10.82 3.76 10.82 4.24 10.53 4.53C10.38 4.68 10.19 4.75 10 4.75C9.81 4.75 9.62 4.68 9.47 4.53L8.75 3.81V6C8.75 6.41 8.41 6.75 8 6.75C7.59 6.75 7.25 6.41 7.25 6V3.81L6.53 4.53C6.24 4.82 5.76 4.82 5.47 4.53C5.18 4.24 5.18 3.76 5.47 3.47L7.47 1.47C7.54 1.4 7.62 1.35 7.71 1.31C7.89 1.23 8.1 1.23 8.28 1.31C8.37 1.35 8.45 1.4 8.52 1.47L10.52 3.47H10.53ZM9.47 11.47L8.75 12.19V10C8.75 9.59 8.41 9.25 8 9.25C7.59 9.25 7.25 9.59 7.25 10V12.19L6.53 11.47C6.24 11.18 5.76 11.18 5.47 11.47C5.18 11.76 5.18 12.24 5.47 12.53L7.47 14.53C7.54 14.6 7.62 14.65 7.71 14.69C7.8 14.73 7.9 14.75 8 14.75C8.1 14.75 8.2 14.73 8.29 14.69C8.38 14.65 8.46 14.6 8.53 14.53L10.53 12.53C10.82 12.24 10.82 11.76 10.53 11.47C10.24 11.18 9.76 11.18 9.47 11.47ZM3 3.75C3.41 3.75 3.75 3.41 3.75 3C3.75 2.59 3.41 2.25 3 2.25C2.04 2.25 1.25 3.04 1.25 4V12C1.25 12.96 2.04 13.75 3 13.75C3.41 13.75 3.75 13.41 3.75 13C3.75 12.59 3.41 12.25 3 12.25C2.86 12.25 2.75 12.14 2.75 12V4C2.75 3.86 2.86 3.75 3 3.75ZM13 2.25C12.59 2.25 12.25 2.59 12.25 3C12.25 3.41 12.59 3.75 13 3.75C13.14 3.75 13.25 3.86 13.25 4V12C13.25 12.14 13.14 12.25 13 12.25C12.59 12.25 12.25 12.59 12.25 13C12.25 13.41 12.59 13.75 13 13.75C13.96 13.75 14.75 12.96 14.75 12V4C14.75 3.04 13.96 2.25 13 2.25Z"></path></svg>',
  "expandpanel-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M11 3.25H5C4.04 3.25 3.25 4.04 3.25 5V11C3.25 11.96 4.04 12.75 5 12.75H11C11.96 12.75 12.75 11.96 12.75 11V5C12.75 4.04 11.96 3.25 11 3.25ZM11.25 11C11.25 11.14 11.14 11.25 11 11.25H5C4.86 11.25 4.75 11.14 4.75 11V5C4.75 4.86 4.86 4.75 5 4.75H11C11.14 4.75 11.25 4.86 11.25 5V11Z"></path></svg>',
  "file-72x72": '<svg viewBox="0 0 72 72" xmlns="http://www.w3.org/2000/svg"><path d="M62.83 12.83L53.17 3.17C52.7982 2.79866 52.357 2.50421 51.8714 2.30346C51.3858 2.1027 50.8654 1.99959 50.34 2H14C12.4087 2 10.8826 2.63214 9.75735 3.75736C8.63214 4.88258 8 6.4087 8 8V64C8 65.5913 8.63214 67.1174 9.75735 68.2426C10.8826 69.3679 12.4087 70 14 70H58C59.5913 70 61.1174 69.3679 62.2426 68.2426C63.3679 67.1174 64 65.5913 64 64V15.66C64.0004 15.1346 63.8973 14.6142 63.6965 14.1286C63.4958 13.643 63.2013 13.2018 62.83 12.83ZM52 4.83L61.17 14H56C54.9391 14 53.9217 13.5786 53.1716 12.8284C52.4214 12.0783 52 11.0609 52 10V4.83ZM62 64C62 65.0609 61.5786 66.0783 60.8284 66.8284C60.0783 67.5786 59.0609 68 58 68H14C12.9391 68 11.9217 67.5786 11.1716 66.8284C10.4214 66.0783 10 65.0609 10 64V8C10 6.93914 10.4214 5.92172 11.1716 5.17157C11.9217 4.42143 12.9391 4 14 4H50V10C50 11.5913 50.6321 13.1174 51.7574 14.2426C52.8826 15.3679 54.4087 16 56 16H62V64ZM22 26H50V28H22V26ZM22 32H50V34H22V32ZM22 38H50V40H22V38ZM22 44H50V46H22V44Z"></path></svg>',
  "finishedit-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M11.5301 8.53249L13.0001 7.06249L16.9401 11.0025L15.4701 12.4725C15.1801 12.7625 15.1801 13.2425 15.4701 13.5325C15.6201 13.6825 15.8101 13.7525 16.0001 13.7525C16.1901 13.7525 16.3801 13.6825 16.5301 13.5325L20.1201 9.94249C21.1901 8.87249 21.1901 7.12249 20.1201 6.05249L17.9501 3.88249C16.8801 2.81249 15.1301 2.81249 14.0601 3.88249L10.4701 7.47249C10.1801 7.76249 10.1801 8.24249 10.4701 8.53249C10.7601 8.82249 11.2401 8.82249 11.5301 8.53249ZM16.8801 4.94249L19.0501 7.11249C19.5401 7.60249 19.5401 8.39249 19.0501 8.88249L17.9901 9.94249L14.0501 6.00249L15.1101 4.94249C15.6001 4.45249 16.3901 4.45249 16.8801 4.94249ZM13.5301 15.4725C13.8201 15.7625 13.8201 16.2425 13.5301 16.5325L10.5301 19.5325C10.4201 19.6425 10.2801 19.7125 10.1201 19.7425L4.12014 20.7425C4.12014 20.7425 4.04014 20.7425 4.00014 20.7425C3.80014 20.7425 3.61014 20.6625 3.47014 20.5225C3.30014 20.3525 3.22014 20.1025 3.26014 19.8725L4.26014 13.8725C4.29014 13.7225 4.36014 13.5725 4.47014 13.4625L7.47014 10.4625C7.76014 10.1725 8.24014 10.1725 8.53014 10.4625C8.82014 10.7525 8.82014 11.2325 8.53014 11.5225L5.70014 14.3525L4.91014 19.0825L9.64014 18.2925L12.4701 15.4625C12.7601 15.1725 13.2401 15.1725 13.5301 15.4625V15.4725ZM20.5301 19.4725C20.8201 19.7625 20.8201 20.2425 20.5301 20.5325C20.3801 20.6825 20.1901 20.7525 20.0001 20.7525C19.8101 20.7525 19.6201 20.6825 19.4701 20.5325L3.47014 4.53249C3.18014 4.24249 3.18014 3.76249 3.47014 3.47249C3.76014 3.18249 4.24014 3.18249 4.53014 3.47249L20.5301 19.4725Z"></path></svg>',
  "fix-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_21942_302540)"><path d="M8.71 11.2901L5.71 8.29006C5.32 7.90006 4.69 7.90006 4.3 8.29006C3.91 8.68006 3.91 9.31006 4.3 9.70006L5.59 10.9901H1C0.45 10.9901 0 11.4401 0 11.9901C0 12.5401 0.45 12.9901 1 12.9901H5.59L4.3 14.2801C3.91 14.6701 3.91 15.3001 4.3 15.6901C4.5 15.8901 4.75 15.9801 5.01 15.9801C5.27 15.9801 5.52 15.8801 5.72 15.6901L8.72 12.6901C8.81 12.6001 8.89 12.4901 8.94 12.3601C9.04 12.1201 9.04 11.8401 8.94 11.6001C8.89 11.4801 8.82 11.3701 8.72 11.2701L8.71 11.2901Z"></path><path d="M15.71 10.29C15.32 9.89999 14.69 9.89999 14.3 10.29C13.91 10.68 13.91 11.31 14.3 11.7L16.3 13.7C16.5 13.9 16.75 13.99 17.01 13.99C17.27 13.99 17.52 13.89 17.72 13.7L23.72 7.69999C24.11 7.30999 24.11 6.67999 23.72 6.28999C23.33 5.89999 22.7 5.89999 22.31 6.28999L21.05 7.54999C19.99 6.57999 18.57 5.98999 17.02 5.98999C13.71 5.98999 11.02 8.67999 11.02 11.99C11.02 15.3 13.71 17.99 17.02 17.99C20.33 17.99 23.02 15.3 23.02 11.99C23.02 11.5 22.96 11.03 22.85 10.58L20.98 12.45C20.75 14.44 19.07 15.99 17.03 15.99C14.82 15.99 13.03 14.2 13.03 11.99C13.03 9.77999 14.82 7.98999 17.03 7.98999C18.03 7.98999 18.93 8.36999 19.63 8.97999L17.03 11.58L15.74 10.29H15.71Z"></path></g><defs><clipPath id="clip0_21942_302540"><rect width="24" height="24" fill="white"></rect></clipPath></defs></svg>',
  "flip-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M14.53 17.4775C14.82 17.7675 14.82 18.2475 14.53 18.5375L11.53 21.5375C11.38 21.6875 11.19 21.7575 11 21.7575C10.81 21.7575 10.62 21.6875 10.47 21.5375C10.18 21.2475 10.18 20.7675 10.47 20.4775L12.2 18.7475C12.13 18.7475 12.07 18.7475 12 18.7475C6.62 18.7475 2.25 15.7475 2.25 12.0575C2.25 10.2975 3.22 8.6375 4.99 7.3875C5.33 7.1475 5.8 7.2275 6.03 7.5675C6.27 7.9075 6.19 8.3775 5.85 8.6075C4.49 9.5675 3.74 10.7875 3.74 12.0575C3.74 14.9175 7.44 17.2475 11.99 17.2475C12.05 17.2475 12.11 17.2475 12.17 17.2475L10.46 15.5375C10.17 15.2475 10.17 14.7675 10.46 14.4775C10.75 14.1875 11.23 14.1875 11.52 14.4775L14.52 17.4775H14.53ZM12 5.2575C11.93 5.2575 11.87 5.2575 11.8 5.2575L13.53 3.5275C13.82 3.2375 13.82 2.7575 13.53 2.4675C13.24 2.1775 12.76 2.1775 12.47 2.4675L9.47 5.4675C9.18 5.7575 9.18 6.2375 9.47 6.5275L12.47 9.5275C12.62 9.6775 12.81 9.7475 13 9.7475C13.19 9.7475 13.38 9.6775 13.53 9.5275C13.82 9.2375 13.82 8.7575 13.53 8.4675L11.82 6.7575C11.88 6.7575 11.94 6.7575 12 6.7575C16.55 6.7575 20.25 9.0875 20.25 11.9475C20.25 13.2075 19.5 14.4375 18.14 15.3975C17.8 15.6375 17.72 16.1075 17.96 16.4475C18.11 16.6575 18.34 16.7675 18.57 16.7675C18.72 16.7675 18.87 16.7275 19 16.6275C20.77 15.3775 21.75 13.7175 21.75 11.9575C21.75 8.2675 17.38 5.2675 12 5.2675V5.2575Z"></path></svg>',
  "folder-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M21.72 9.24C21.45 8.92 21.12 8.67 20.75 8.5V8C20.75 6.48 19.52 5.25 18 5.25H10.65C10.32 4.1 9.26 3.25 8 3.25H6C4.48 3.25 3.25 4.48 3.25 6V18C3.25 19.52 4.48 20.75 6 20.75H18.33C19.66 20.75 20.8 19.8 21.04 18.49L22.31 11.49C22.46 10.69 22.24 9.86 21.72 9.24ZM4.75 18V6C4.75 5.31 5.31 4.75 6 4.75H8C8.69 4.75 9.25 5.31 9.25 6C9.25 6.41 9.59 6.75 10 6.75H18C18.69 6.75 19.25 7.31 19.25 8V8.25H9.27C7.94 8.25 6.8 9.2 6.56 10.51L5.29 17.51C5.19 18.07 5.27 18.64 5.51 19.15C5.06 18.96 4.75 18.52 4.75 18ZM20.83 11.22L19.56 18.22C19.45 18.81 18.94 19.25 18.33 19.25H8C7.63 19.25 7.28 19.09 7.04 18.8C6.8 18.51 6.7 18.14 6.77 17.78L8.04 10.78C8.15 10.19 8.66 9.75 9.27 9.75H19.6C19.97 9.75 20.32 9.91 20.56 10.2C20.8 10.49 20.9 10.86 20.83 11.22Z"></path></svg>',
  "fullsize-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M12 3.25H4C3.04 3.25 2.25 4.04 2.25 5V11C2.25 11.96 3.04 12.75 4 12.75H12C12.96 12.75 13.75 11.96 13.75 11V5C13.75 4.04 12.96 3.25 12 3.25ZM12.25 11C12.25 11.14 12.14 11.25 12 11.25H4C3.86 11.25 3.75 11.14 3.75 11V5C3.75 4.86 3.86 4.75 4 4.75H12C12.14 4.75 12.25 4.86 12.25 5V11Z"></path></svg>',
  "gear-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M11.99 8.25C9.92 8.25 8.24 9.93 8.24 12C8.24 14.07 9.92 15.75 11.99 15.75C14.06 15.75 15.74 14.07 15.74 12C15.74 9.93 14.06 8.25 11.99 8.25ZM11.99 14.25C10.75 14.25 9.74 13.24 9.74 12C9.74 10.76 10.75 9.75 11.99 9.75C13.23 9.75 14.24 10.76 14.24 12C14.24 13.24 13.23 14.25 11.99 14.25ZM20.37 10.09L20.13 10.04C19.72 9.95 19.39 9.65 19.23 9.24C19.18 9.11 19.12 8.98 19.07 8.85C18.89 8.44 18.91 7.99 19.14 7.63L19.27 7.42C19.71 6.72 19.61 5.83 19.03 5.25L18.75 4.97C18.17 4.39 17.27 4.29 16.57 4.73L16.36 4.86C16.01 5.08 15.55 5.11 15.15 4.92C15.02 4.86 14.89 4.81 14.76 4.76C14.34 4.6 14.04 4.26 13.95 3.86L13.9 3.62C13.72 2.81 13.02 2.25 12.19 2.25H11.79C10.96 2.25 10.26 2.81 10.08 3.62L10.03 3.86C9.94 4.27 9.64 4.6 9.23 4.76C9.1 4.81 8.97 4.87 8.84 4.92C8.43 5.1 7.98 5.08 7.63 4.86L7.42 4.73C6.72 4.29 5.83 4.39 5.25 4.97L4.97 5.25C4.39 5.83 4.29 6.73 4.73 7.43L4.86 7.64C5.08 7.99 5.11 8.45 4.92 8.85C4.86 8.98 4.81 9.11 4.76 9.24C4.6 9.66 4.26 9.96 3.86 10.05L3.62 10.1C2.81 10.28 2.25 10.98 2.25 11.81V12.21C2.25 13.04 2.81 13.74 3.62 13.92L3.86 13.97C4.27 14.06 4.6 14.36 4.76 14.77C4.81 14.9 4.87 15.03 4.92 15.16C5.1 15.57 5.08 16.02 4.85 16.38L4.72 16.59C4.28 17.29 4.38 18.18 4.96 18.76L5.24 19.04C5.82 19.62 6.72 19.72 7.42 19.28L7.63 19.15C7.98 18.93 8.44 18.9 8.84 19.09C8.97 19.15 9.1 19.2 9.23 19.25C9.65 19.41 9.95 19.75 10.04 20.15L10.09 20.39C10.27 21.2 10.97 21.76 11.8 21.76H12.2C13.03 21.76 13.73 21.2 13.91 20.39L13.96 20.15C14.05 19.74 14.35 19.41 14.76 19.25C14.89 19.2 15.02 19.14 15.15 19.09C15.56 18.9 16.01 18.93 16.36 19.15L16.57 19.28C17.27 19.72 18.16 19.62 18.74 19.04L19.02 18.76C19.6 18.18 19.7 17.28 19.26 16.58L19.13 16.37C18.91 16.02 18.88 15.56 19.07 15.16C19.13 15.03 19.18 14.9 19.23 14.77C19.39 14.35 19.73 14.05 20.13 13.96L20.37 13.91C21.18 13.73 21.74 13.03 21.74 12.2V11.8C21.74 10.97 21.18 10.27 20.37 10.09ZM20.24 12.2C20.24 12.32 20.16 12.42 20.04 12.44L19.8 12.49C18.9 12.69 18.16 13.34 17.82 14.23C17.78 14.33 17.74 14.44 17.69 14.54C17.3 15.41 17.36 16.39 17.86 17.17L17.99 17.38C18.05 17.48 18.04 17.61 17.96 17.69L17.68 17.97C17.6 18.05 17.47 18.07 17.37 18.01L17.16 17.88C16.38 17.38 15.39 17.32 14.53 17.71C14.43 17.76 14.33 17.8 14.22 17.84C13.33 18.18 12.69 18.92 12.49 19.82L12.44 20.06C12.41 20.18 12.32 20.26 12.2 20.26H11.8C11.68 20.26 11.58 20.18 11.56 20.06L11.51 19.82C11.31 18.92 10.66 18.18 9.77 17.84C9.67 17.8 9.56 17.76 9.46 17.71C9.08 17.54 8.68 17.46 8.29 17.46C7.78 17.46 7.27 17.6 6.83 17.88L6.62 18.01C6.52 18.07 6.39 18.06 6.31 17.98L6.03 17.7C5.95 17.62 5.93 17.49 5.99 17.39L6.12 17.18C6.62 16.4 6.68 15.42 6.29 14.54C6.24 14.44 6.2 14.34 6.16 14.23C5.82 13.34 5.08 12.7 4.18 12.5L3.94 12.45C3.82 12.42 3.74 12.33 3.74 12.21V11.81C3.74 11.69 3.82 11.59 3.94 11.57L4.18 11.52C5.08 11.32 5.82 10.67 6.16 9.78C6.2 9.68 6.24 9.57 6.29 9.47C6.68 8.6 6.62 7.62 6.12 6.84L5.99 6.63C5.93 6.53 5.94 6.4 6.02 6.32L6.3 6.04C6.38 5.96 6.51 5.94 6.61 6.01L6.82 6.14C7.6 6.64 8.58 6.7 9.45 6.31C9.55 6.26 9.65 6.22 9.76 6.18C10.65 5.84 11.29 5.1 11.49 4.2L11.54 3.96C11.57 3.84 11.66 3.76 11.78 3.76H12.18C12.3 3.76 12.4 3.84 12.42 3.96L12.47 4.2C12.67 5.1 13.32 5.84 14.21 6.18C14.31 6.22 14.42 6.26 14.52 6.31C15.39 6.7 16.38 6.64 17.15 6.14L17.36 6.01C17.46 5.95 17.59 5.96 17.67 6.04L17.95 6.32C18.03 6.4 18.05 6.53 17.99 6.63L17.86 6.84C17.36 7.62 17.3 8.6 17.69 9.48C17.74 9.58 17.78 9.68 17.82 9.79C18.16 10.68 18.9 11.32 19.8 11.52L20.04 11.57C20.16 11.6 20.24 11.69 20.24 11.81V12.21V12.2Z"></path></svg>',
  "help-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 2.25C6.62 2.25 2.25 6.62 2.25 12C2.25 17.38 6.62 21.75 12 21.75C17.38 21.75 21.75 17.38 21.75 12C21.75 6.62 17.38 2.25 12 2.25ZM12 20.25C7.45 20.25 3.75 16.55 3.75 12C3.75 7.45 7.45 3.75 12 3.75C16.55 3.75 20.25 7.45 20.25 12C20.25 16.55 16.55 20.25 12 20.25ZM12.59 15.38C12.8 15.59 12.9 15.83 12.9 16.12C12.9 16.41 12.8 16.67 12.59 16.88C12.38 17.09 12.13 17.19 11.83 17.19C11.53 17.19 11.28 17.09 11.08 16.88C10.88 16.67 10.78 16.42 10.78 16.12C10.78 15.82 10.88 15.58 11.09 15.38C11.3 15.18 11.54 15.07 11.83 15.07C12.12 15.07 12.38 15.17 12.59 15.38ZM14.76 8.28C14.99 8.62 15.11 8.99 15.11 9.39C15.11 9.75 15.05 10.06 14.92 10.32C14.79 10.58 14.64 10.79 14.46 10.95C14.28 11.11 14.04 11.3 13.75 11.52C13.48 11.72 13.26 11.88 13.11 12.02C12.95 12.16 12.82 12.33 12.71 12.54C12.6 12.75 12.55 12.99 12.55 13.27V13.68H11.05V13.2C11.05 12.8 11.12 12.46 11.25 12.17C11.38 11.88 11.55 11.65 11.74 11.47C11.93 11.29 12.18 11.09 12.48 10.86C12.82 10.6 13.08 10.38 13.24 10.2C13.4 10.02 13.48 9.79 13.48 9.51C13.48 9.17 13.35 8.91 13.07 8.72C12.8 8.53 12.45 8.43 12.02 8.43C11.68 8.43 11.35 8.51 11.02 8.67C10.69 8.83 10.39 9.07 10.13 9.4L9.08 8.59C9.9 7.64 10.93 7.16 12.17 7.16C12.78 7.16 13.3 7.26 13.75 7.47C14.2 7.68 14.53 7.95 14.76 8.3V8.28Z"></path></svg>',
  "hidehint-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M10.13 5.45C10.3 5.69 10.38 5.95 10.38 6.24C10.38 6.5 10.33 6.72 10.24 6.9C10.16 7.06 10.06 7.19 9.95 7.29L7.43 4.77C7.68 4.71 7.94 4.66 8.22 4.66C8.68 4.66 9.07 4.73 9.39 4.87C9.71 5.01 9.96 5.2 10.13 5.44V5.45ZM8.56 11.24L7.37 10.05C7.21 10.21 7.13 10.4 7.13 10.63C7.13 10.87 7.21 11.07 7.38 11.23C7.55 11.4 7.74 11.48 7.98 11.48C8.22 11.48 8.4 11.4 8.57 11.24H8.56ZM5.95 3.18C6.6 2.9 7.29 2.76 8 2.76C10.89 2.76 13.25 5.12 13.25 8.01C13.25 8.72 13.11 9.41 12.83 10.06C12.67 10.44 12.85 10.88 13.23 11.04C13.33 11.08 13.43 11.1 13.52 11.1C13.81 11.1 14.09 10.93 14.21 10.64C14.57 9.8 14.75 8.92 14.75 8C14.75 4.28 11.72 1.25 8 1.25C7.09 1.25 6.2 1.43 5.36 1.79C4.98 1.95 4.8 2.39 4.96 2.77C5.12 3.15 5.56 3.33 5.94 3.17L5.95 3.18ZM10.05 12.84C9.4 13.12 8.71 13.26 8 13.26C5.11 13.26 2.75 10.9 2.75 8.01C2.75 7.3 2.89 6.61 3.17 5.96C3.33 5.58 3.15 5.14 2.77 4.98C2.39 4.82 1.95 5 1.79 5.38C1.43 6.22 1.25 7.1 1.25 8.02C1.25 11.74 4.28 14.77 8 14.77C8.91 14.77 9.8 14.59 10.64 14.23C11.02 14.07 11.2 13.63 11.04 13.25C10.88 12.87 10.44 12.69 10.06 12.85L10.05 12.84ZM2.53 1.48C2.24 1.19 1.76 1.19 1.47 1.48C1.18 1.77 1.18 2.25 1.47 2.54L13.47 14.54C13.62 14.69 13.81 14.76 14 14.76C14.19 14.76 14.38 14.69 14.53 14.54C14.82 14.25 14.82 13.77 14.53 13.48L2.53 1.48Z"></path></svg>',
  "hidehint-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M11.84 17.18C11.54 17.18 11.29 17.08 11.09 16.87C10.89 16.66 10.79 16.41 10.79 16.11C10.79 15.81 10.89 15.57 11.1 15.37C11.31 15.17 11.55 15.06 11.84 15.06C12.13 15.06 12.39 15.16 12.6 15.37C12.81 15.58 12.91 15.82 12.91 16.11C12.91 16.4 12.81 16.66 12.6 16.87C12.39 17.08 12.14 17.18 11.84 17.18ZM14.28 11.1C14.34 11.05 14.41 10.99 14.46 10.94C14.64 10.78 14.79 10.57 14.92 10.31C15.05 10.05 15.11 9.74 15.11 9.38C15.11 8.99 14.99 8.62 14.76 8.27C14.53 7.92 14.19 7.65 13.75 7.44C13.31 7.23 12.78 7.13 12.17 7.13C11.61 7.13 11.1 7.24 10.63 7.43L11.64 8.44C11.76 8.42 11.89 8.4 12.01 8.4C12.44 8.4 12.79 8.5 13.06 8.69C13.33 8.88 13.47 9.15 13.47 9.48C13.47 9.72 13.4 9.92 13.28 10.09L14.28 11.09V11.1ZM16.18 19.1C14.91 19.85 13.46 20.25 12 20.25C7.45 20.25 3.75 16.55 3.75 12C3.75 10.54 4.15 9.09 4.9 7.82C5.11 7.46 4.99 7 4.64 6.79C4.28 6.58 3.82 6.7 3.61 7.05C2.72 8.55 2.25 10.26 2.25 12C2.25 17.38 6.62 21.75 12 21.75C13.73 21.75 15.44 21.28 16.95 20.39C17.31 20.18 17.43 19.72 17.21 19.36C17 19 16.54 18.88 16.18 19.1ZM7.82 4.9C9.09 4.15 10.54 3.75 12 3.75C16.55 3.75 20.25 7.45 20.25 12C20.25 13.46 19.85 14.91 19.1 16.18C18.89 16.54 19.01 17 19.36 17.21C19.48 17.28 19.61 17.31 19.74 17.31C20 17.31 20.25 17.18 20.39 16.94C21.28 15.44 21.75 13.73 21.75 11.99C21.75 6.62 17.38 2.25 12 2.25C10.27 2.25 8.56 2.72 7.05 3.61C6.69 3.82 6.57 4.28 6.79 4.64C7 5 7.46 5.12 7.82 4.9ZM4.53 3.47C4.24 3.18 3.76 3.18 3.47 3.47C3.18 3.76 3.18 4.24 3.47 4.53L19.47 20.53C19.62 20.68 19.81 20.75 20 20.75C20.19 20.75 20.38 20.68 20.53 20.53C20.82 20.24 20.82 19.76 20.53 19.47L4.53 3.47Z"></path></svg>',
  "hint-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M10.13 5.44C10.3 5.68 10.38 5.94 10.38 6.23C10.38 6.49 10.33 6.71 10.24 6.89C10.15 7.07 10.04 7.22 9.91 7.34C9.78 7.46 9.61 7.59 9.39 7.73C9.13 7.9 8.94 8.05 8.82 8.19C8.7 8.33 8.63 8.51 8.63 8.74V8.94H7.28V8.7C7.28 8.41 7.33 8.16 7.42 7.96C7.51 7.76 7.63 7.6 7.76 7.48C7.89 7.36 8.06 7.23 8.26 7.09C8.46 6.95 8.61 6.84 8.7 6.74C8.79 6.64 8.84 6.52 8.84 6.38C8.84 6.21 8.77 6.08 8.63 5.99C8.49 5.9 8.31 5.85 8.09 5.85C7.88 5.85 7.67 5.9 7.47 6C7.27 6.1 7.09 6.24 6.92 6.43L5.98 5.7C6.55 5.03 7.3 4.69 8.23 4.69C8.69 4.69 9.08 4.76 9.4 4.9C9.72 5.04 9.97 5.23 10.14 5.47L10.13 5.44ZM7.98 9.78C7.75 9.78 7.55 9.86 7.38 10.03C7.21 10.2 7.13 10.39 7.13 10.63C7.13 10.87 7.21 11.07 7.38 11.23C7.55 11.4 7.74 11.48 7.98 11.48C8.22 11.48 8.42 11.4 8.58 11.23C8.75 11.06 8.83 10.86 8.83 10.63C8.83 10.4 8.75 10.2 8.58 10.03C8.41 9.86 8.21 9.78 7.98 9.78ZM14.75 8C14.75 11.72 11.72 14.75 8 14.75C4.28 14.75 1.25 11.72 1.25 8C1.25 4.28 4.28 1.25 8 1.25C11.72 1.25 14.75 4.28 14.75 8ZM13.25 8C13.25 5.11 10.89 2.75 8 2.75C5.11 2.75 2.75 5.11 2.75 8C2.75 10.89 5.11 13.25 8 13.25C10.89 13.25 13.25 10.89 13.25 8Z"></path></svg>',
  "hint-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 2.25C6.62 2.25 2.25 6.62 2.25 12C2.25 17.38 6.62 21.75 12 21.75C17.38 21.75 21.75 17.38 21.75 12C21.75 6.62 17.38 2.25 12 2.25ZM12 20.25C7.45 20.25 3.75 16.55 3.75 12C3.75 7.45 7.45 3.75 12 3.75C16.55 3.75 20.25 7.45 20.25 12C20.25 16.55 16.55 20.25 12 20.25ZM12.59 15.38C12.8 15.59 12.9 15.83 12.9 16.12C12.9 16.41 12.8 16.67 12.59 16.88C12.38 17.09 12.13 17.19 11.83 17.19C11.53 17.19 11.28 17.09 11.08 16.88C10.88 16.67 10.78 16.42 10.78 16.12C10.78 15.82 10.88 15.58 11.09 15.38C11.3 15.18 11.54 15.07 11.83 15.07C12.12 15.07 12.38 15.17 12.59 15.38ZM14.76 8.28C14.99 8.62 15.11 8.99 15.11 9.39C15.11 9.75 15.05 10.06 14.92 10.32C14.79 10.58 14.64 10.79 14.46 10.95C14.28 11.11 14.04 11.3 13.75 11.52C13.48 11.72 13.26 11.88 13.11 12.02C12.95 12.16 12.82 12.33 12.71 12.54C12.6 12.75 12.55 12.99 12.55 13.27V13.68H11.05V13.2C11.05 12.8 11.12 12.46 11.25 12.17C11.38 11.88 11.55 11.65 11.74 11.47C11.93 11.29 12.18 11.09 12.48 10.86C12.82 10.6 13.08 10.38 13.24 10.2C13.4 10.02 13.48 9.79 13.48 9.51C13.48 9.17 13.35 8.91 13.07 8.72C12.8 8.53 12.45 8.43 12.02 8.43C11.68 8.43 11.35 8.51 11.02 8.67C10.69 8.83 10.39 9.07 10.13 9.4L9.08 8.59C9.9 7.64 10.93 7.16 12.17 7.16C12.78 7.16 13.3 7.26 13.75 7.47C14.2 7.68 14.53 7.95 14.76 8.3V8.28Z"></path></svg>',
  "image-48x48": '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><path d="M33 10.25H15C12.38 10.25 10.25 12.38 10.25 15V33C10.25 35.62 12.38 37.75 15 37.75H33C35.62 37.75 37.75 35.62 37.75 33V15C37.75 12.38 35.62 10.25 33 10.25ZM36.25 33C36.25 34.79 34.79 36.25 33 36.25H15C13.21 36.25 11.75 34.79 11.75 33V15C11.75 13.21 13.21 11.75 15 11.75H33C34.79 11.75 36.25 13.21 36.25 15V33ZM30.5 14.25C28.71 14.25 27.25 15.71 27.25 17.5C27.25 19.29 28.71 20.75 30.5 20.75C32.29 20.75 33.75 19.29 33.75 17.5C33.75 15.71 32.29 14.25 30.5 14.25ZM30.5 19.25C29.54 19.25 28.75 18.46 28.75 17.5C28.75 16.54 29.54 15.75 30.5 15.75C31.46 15.75 32.25 16.54 32.25 17.5C32.25 18.46 31.46 19.25 30.5 19.25ZM29.26 26.28C28.94 25.92 28.49 25.71 28.01 25.7C27.54 25.68 27.07 25.87 26.73 26.2L24.95 27.94L22.28 25.23C21.94 24.89 21.5 24.71 21 24.71C20.52 24.71 20.06 24.93 19.74 25.28L14.74 30.78C14.25 31.3 14.12 32.06 14.41 32.72C14.69 33.36 15.28 33.75 15.95 33.75H32.07C32.74 33.75 33.33 33.35 33.61 32.72C33.89 32.06 33.77 31.31 33.29 30.79L29.27 26.29L29.26 26.28ZM32.22 32.12C32.18 32.2 32.13 32.25 32.06 32.25H15.94C15.87 32.25 15.81 32.21 15.78 32.12C15.77 32.09 15.71 31.93 15.83 31.8L20.84 26.29C20.9 26.22 20.99 26.21 21.02 26.21C21.06 26.21 21.14 26.22 21.2 26.29L24.4 29.54C24.69 29.83 25.16 29.84 25.46 29.54L27.77 27.27C27.83 27.21 27.9 27.2 27.94 27.2C28.01 27.2 28.06 27.21 28.13 27.28L32.16 31.79C32.16 31.79 32.16 31.79 32.17 31.8C32.29 31.93 32.23 32.09 32.22 32.12Z"></path></svg>',
  "import-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M19.75 8.83V18C19.75 19.52 18.52 20.75 17 20.75H7C5.48 20.75 4.25 19.52 4.25 18V16C4.25 15.59 4.59 15.25 5 15.25C5.41 15.25 5.75 15.59 5.75 16V18C5.75 18.69 6.31 19.25 7 19.25H17C17.69 19.25 18.25 18.69 18.25 18V8.83C18.25 8.5 18.12 8.18 17.88 7.95L15.05 5.12C14.82 4.89 14.5 4.75 14.17 4.75H7C6.31 4.75 5.75 5.31 5.75 6V10C5.75 10.41 5.41 10.75 5 10.75C4.59 10.75 4.25 10.41 4.25 10V6C4.25 4.48 5.48 3.25 7 3.25H14.17C14.9 3.25 15.59 3.54 16.11 4.06L18.94 6.89C19.46 7.41 19.75 8.1 19.75 8.83ZM8.47 15.47C8.18 15.76 8.18 16.24 8.47 16.53C8.62 16.68 8.81 16.75 9 16.75C9.19 16.75 9.38 16.68 9.53 16.53L12.53 13.53C12.6 13.46 12.65 13.38 12.69 13.29C12.77 13.11 12.77 12.9 12.69 12.72C12.65 12.63 12.6 12.55 12.53 12.48L9.53 9.48C9.24 9.19 8.76 9.19 8.47 9.48C8.18 9.77 8.18 10.25 8.47 10.54L10.19 12.26H2C1.59 12.26 1.25 12.6 1.25 13.01C1.25 13.42 1.59 13.76 2 13.76H10.19L8.47 15.48V15.47ZM14 5.25C13.59 5.25 13.25 5.59 13.25 6V7C13.25 8.52 14.48 9.75 16 9.75H17C17.41 9.75 17.75 9.41 17.75 9C17.75 8.59 17.41 8.25 17 8.25H16C15.31 8.25 14.75 7.69 14.75 7V6C14.75 5.59 14.41 5.25 14 5.25Z"></path></svg>',
  "invisible-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20.4449 14.3969C20.7749 14.6469 20.8449 15.1169 20.5949 15.4469C18.5349 18.1769 15.4049 19.7469 11.9949 19.7469C11.3849 19.7469 10.7349 19.6769 10.0149 19.5469C9.60488 19.4669 9.33488 19.0769 9.41488 18.6669C9.49488 18.2569 9.88488 17.9869 10.2949 18.0669C10.9249 18.1869 11.4749 18.2369 11.9949 18.2369C14.9249 18.2369 17.6249 16.8869 19.3949 14.5369C19.6449 14.2069 20.1149 14.1369 20.4449 14.3869V14.3969ZM5.97488 17.7169C6.20488 17.7169 6.42488 17.6169 6.57488 17.4169C6.82488 17.0869 6.76488 16.6169 6.42488 16.3669C5.70488 15.8169 5.08488 15.2069 4.58488 14.5469C4.33488 14.2169 3.86488 14.1469 3.53488 14.3969C3.20488 14.6469 3.13488 15.1169 3.38488 15.4469C3.96488 16.2169 4.68488 16.9269 5.51488 17.5569C5.64488 17.6569 5.80488 17.7069 5.96488 17.7069L5.97488 17.7169ZM11.9649 8.74692C12.3749 8.74692 12.7149 8.40692 12.7049 7.98692C12.6949 7.56692 12.3449 7.21692 11.9449 7.24692C9.35488 7.27692 7.24488 9.40692 7.24488 11.9969C7.24488 12.6069 7.36488 13.2069 7.59488 13.7769C7.71488 14.0669 7.99488 14.2469 8.29488 14.2469C8.38488 14.2469 8.48488 14.2269 8.57488 14.1969C8.95488 14.0369 9.14488 13.6069 8.98488 13.2169C8.82488 12.8269 8.74488 12.4169 8.74488 11.9969C8.74488 10.2269 10.1849 8.76692 11.9649 8.74692ZM12.0249 15.2469C11.6149 15.2469 11.2749 15.5869 11.2849 16.0069C11.2849 16.4169 11.6249 16.7469 12.0349 16.7469C14.6249 16.7169 16.7349 14.5869 16.7349 11.9969C16.7349 11.3869 16.6149 10.7869 16.3849 10.2169C16.2249 9.83692 15.7849 9.64692 15.4049 9.80692C15.0249 9.96692 14.8349 10.3969 14.9949 10.7869C15.1549 11.1769 15.2349 11.5869 15.2349 12.0069C15.2349 13.7769 13.7949 15.2369 12.0149 15.2569L12.0249 15.2469ZM23.6549 11.6469C22.4449 9.34692 20.6849 7.44692 18.5649 6.13692C18.2049 5.91692 17.7449 6.02692 17.5349 6.38692C17.3149 6.73692 17.4249 7.19692 17.7849 7.41692C19.6749 8.57692 21.2449 10.2869 22.3249 12.3469C22.4549 12.5969 22.7249 12.7469 22.9949 12.7469C23.1149 12.7469 23.2349 12.7169 23.3449 12.6569C23.7149 12.4669 23.8549 12.0069 23.6549 11.6469ZM11.9949 5.74692C12.5649 5.74692 13.1449 5.79692 13.7349 5.88692C14.1449 5.94692 14.5249 5.67692 14.5949 5.26692C14.6649 4.85692 14.3849 4.47692 13.9749 4.40692C8.38488 3.49692 3.05488 6.46692 0.334879 11.6469C0.144879 12.0169 0.284879 12.4669 0.644879 12.6569C0.754879 12.7169 0.874879 12.7469 0.994879 12.7469C1.26488 12.7469 1.52488 12.5969 1.66488 12.3469C3.79488 8.27692 7.76488 5.74692 11.9949 5.74692ZM18.4149 2.37692C18.0649 2.14692 17.6049 2.23692 17.3749 2.58692L5.37488 20.5769C5.14488 20.9169 5.23488 21.3869 5.58488 21.6169C5.71488 21.6969 5.85488 21.7469 6.00488 21.7469C6.24488 21.7469 6.48488 21.6269 6.62488 21.4169L18.6149 3.41692C18.8449 3.07692 18.7549 2.60692 18.4049 2.37692H18.4149Z"></path></svg>',
  "language-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M22.67 20.67L16.67 8.67C16.42 8.16 15.58 8.16 15.33 8.67L9.33 20.67C9.14 21.04 9.29 21.49 9.67 21.68C10.04 21.87 10.49 21.72 10.68 21.34L12.98 16.75C12.98 16.75 13 16.75 13.01 16.75H19.01C19.01 16.75 19.03 16.75 19.04 16.75L21.34 21.34C21.47 21.6 21.74 21.76 22.01 21.76C22.12 21.76 22.24 21.73 22.34 21.68C22.71 21.49 22.86 21.04 22.68 20.67H22.67ZM13.71 15.25L16 10.68L18.29 15.25H13.72H13.71ZM10.7 12.23C9.9 11.17 9.36 10.03 8.99 8.88C8.18 11.39 6.56 13.74 3.38 15.65C3.26 15.72 3.13 15.76 3 15.76C2.75 15.76 2.5 15.63 2.36 15.4C2.15 15.04 2.26 14.58 2.62 14.37C6.39 12.11 7.74 9.32 8.12 5.76H3C2.59 5.75 2.25 5.41 2.25 5C2.25 4.59 2.59 4.25 3 4.25H8.22C8.24 3.84 8.25 3.43 8.25 3C8.25 2.57 8.59 2.25 9 2.25C9.41 2.25 9.75 2.59 9.75 3C9.75 3.43 9.76 3.85 9.78 4.25H15C15.41 4.25 15.75 4.59 15.75 5C15.75 5.41 15.41 5.75 15 5.75H9.89C10.15 8.09 10.79 9.84 11.9 11.33C12.15 11.66 12.08 12.13 11.75 12.38C11.42 12.63 10.95 12.56 10.7 12.23Z"></path></svg>',
  "loading-48x48": '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_19679_369428)"><path opacity="0.25" d="M24 40C15.18 40 8 32.82 8 24C8 15.18 15.18 8 24 8C32.82 8 40 15.18 40 24C40 32.82 32.82 40 24 40ZM24 12C17.38 12 12 17.38 12 24C12 30.62 17.38 36 24 36C30.62 36 36 30.62 36 24C36 17.38 30.62 12 24 12Z"></path><path d="M10 26C8.9 26 8 25.1 8 24C8 15.18 15.18 8 24 8C25.1 8 26 8.9 26 10C26 11.1 25.1 12 24 12C17.38 12 12 17.38 12 24C12 25.1 11.1 26 10 26Z"></path></g><defs><clipPath id="clip0_19679_369428"><rect width="32" height="32" fill="white" transform="translate(8 8)"></rect></clipPath></defs></svg>',
  "logic-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M17.53 14.47C17.24 14.18 16.76 14.18 16.47 14.47C16.18 14.76 16.18 15.24 16.47 15.53L18.19 17.25H8.63C8.57 17.05 8.49 16.85 8.39 16.67L16.67 8.39C17.07 8.61 17.52 8.75 18 8.75C19.52 8.75 20.75 7.52 20.75 6C20.75 4.48 19.52 3.25 18 3.25C16.75 3.25 15.7 4.1 15.37 5.25H8.64C8.31 4.1 7.26 3.25 6.01 3.25C4.48 3.25 3.25 4.48 3.25 6C3.25 7.52 4.48 8.75 6 8.75C7.25 8.75 8.3 7.9 8.63 6.75H15.36C15.42 6.95 15.5 7.15 15.6 7.33L7.33 15.61C6.93 15.39 6.48 15.25 6 15.25C4.48 15.25 3.25 16.48 3.25 18C3.25 19.52 4.48 20.75 6 20.75C7.25 20.75 8.3 19.9 8.63 18.75H18.19L16.47 20.47C16.18 20.76 16.18 21.24 16.47 21.53C16.62 21.68 16.81 21.75 17 21.75C17.19 21.75 17.38 21.68 17.53 21.53L20.53 18.53C20.82 18.24 20.82 17.76 20.53 17.47L17.53 14.47ZM6 7.25C5.31 7.25 4.75 6.69 4.75 6C4.75 5.31 5.31 4.75 6 4.75C6.69 4.75 7.25 5.31 7.25 6C7.25 6.69 6.69 7.25 6 7.25ZM18 4.75C18.69 4.75 19.25 5.31 19.25 6C19.25 6.69 18.69 7.25 18 7.25C17.31 7.25 16.75 6.69 16.75 6C16.75 5.31 17.31 4.75 18 4.75ZM6 19.25C5.31 19.25 4.75 18.69 4.75 18C4.75 17.31 5.31 16.75 6 16.75C6.69 16.75 7.25 17.31 7.25 18C7.25 18.69 6.69 19.25 6 19.25Z"></path></svg>',
  "logo-angular-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_17790_388137)"><path fill-rule="evenodd" clip-rule="evenodd" d="M12.17 0L1 3.98L2.71 18.75L12.16 24L21.77 18.68L23.62 3.91L12.17 0ZM16.97 18.27L15.45 14.74H9.23L7.83 18.24L5.23 18.29L12.19 2.81L19.45 18.33L16.97 18.28V18.27ZM10.15 12.69L12.21 7.77L14.56 12.69H10.14H10.15Z" fill="#E23237"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M12.1899 12.69H12.1699V7.85L12.1999 7.77L14.5499 12.69H12.1799H12.1899ZM12.1699 0V2.84L12.1899 2.8L19.4499 18.32L16.9699 18.27L15.4499 14.74H12.1799V24L21.7899 18.68L23.6399 3.91L12.1699 0Z" fill="#B52E31"></path></g><defs><clipPath id="clip0_17790_388137"><rect width="22.63" height="24" fill="white" transform="translate(1)"></rect></clipPath></defs></svg>',
  "logo-jquery-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M23.42 17.5751C23.42 17.5751 20.43 25.5875 10.16 23.7169C7.55997 23.0467 5.16997 21.5963 3.35997 19.6157C3.00997 19.2356 2.67997 18.8354 2.37997 18.4153C-0.130033 14.9643 -1.02003 10.0228 1.51997 6.39164L3.17997 4.30101C0.199966 10.1128 4.07997 17.1649 9.63997 19.7657C14.13 22.0064 20.41 21.5263 23.41 17.5751H23.42ZM8.53997 12.4435C9.86997 14.3741 11.96 15.7845 14.23 16.3747C22.16 17.6851 24 11.6032 24 11.6032C18.31 19.1855 4.80997 10.6529 9.36997 2.07033L8.11997 3.83086C6.30997 6.41165 6.75997 9.96273 8.53997 12.4335V12.4435ZM16.9 9.72266C17.08 9.79268 17.27 9.8527 17.46 9.90272C21.84 10.743 23.03 7.66203 23.35 7.21189C21.99 9.39256 18.24 9.07246 16.2 7.47197C14.28 6.02153 13.09 3.26069 14.34 1C11.47 4.08094 13.21 8.36225 16.9 9.72266Z" fill="#0D61A8"></path></svg>',
  "logo-knockout-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_17790_388139)"><path d="M23.6098 20.0301C23.2398 19.8203 22.8498 19.6805 22.4198 19.6605C20.8398 19.6605 19.6398 19.6605 18.2098 19.6605C16.7898 19.7104 16.6398 18.1121 16.2198 17.0832C15.4698 15.1152 14.8298 13.0973 14.0598 11.1394C15.9698 9.15147 17.8298 7.1136 19.7298 5.12568C20.8498 4.09676 22.2798 2.13881 20.2898 1.17981C18.0898 0.880128 16.8298 3.6772 15.3098 4.90591C13.9298 6.46428 12.4398 7.92276 11.0798 9.48112C13.8898 4.27657 10.8798 -0.208732 5.07985 1.2897C1.39985 2.44849 -1.16015 6.95377 0.529846 10.6399C1.33985 12.2482 3.08985 13.447 4.89985 12.8776C5.75985 12.508 6.36985 11.4291 5.83985 10.55C5.51985 10.1704 5.06985 9.99059 4.61985 9.82077C3.57985 9.38123 3.20985 8.19247 3.47985 7.15356C3.83985 5.06575 7.02985 3.04786 8.43985 5.27553C8.75985 6.34441 8.15985 7.45325 7.80985 8.4522C6.89985 10.7798 5.96985 13.0874 5.04985 15.4049C4.68985 16.5138 3.93985 17.5627 4.09985 18.7714C4.89985 20.4397 6.86985 19.7803 7.55985 18.3518C8.52985 15.9344 9.58985 13.5269 10.4198 11.0795C11.7798 14.5558 12.8498 18.162 14.3298 21.5885C14.8598 22.6074 15.8598 22.957 16.9398 22.997C19.0098 22.997 20.3698 22.997 21.9098 22.997C22.2798 22.997 22.6298 22.8272 22.9898 22.7173C23.9298 22.2378 24.3698 20.8692 23.5998 20.0501L23.6098 20.0301Z" fill="#E42E16"></path></g><defs><clipPath id="clip0_17790_388139"><rect width="24" height="24" fill="white"></rect></clipPath></defs></svg>',
  "logo-react-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M14.1459 11.9624C14.1459 13.1424 13.1855 14.1024 12.005 14.1024C10.8245 14.1024 9.86411 13.1424 9.86411 11.9624C9.86411 10.7824 10.8245 9.8224 12.005 9.8224C13.1855 9.8224 14.1459 10.7824 14.1459 11.9624ZM24 11.9624C24 13.4324 22.2593 14.9224 19.4581 15.8524C19.308 15.9024 19.168 15.9424 19.0079 15.9924C19.0679 16.2124 19.108 16.4224 19.158 16.6324C19.4181 17.9524 19.4581 19.1824 19.278 20.1824C19.0779 21.2424 18.6378 22.0024 17.9975 22.3724C17.6774 22.5624 17.2972 22.6524 16.877 22.6524C15.7165 22.6524 14.2359 21.9524 12.7053 20.6324C12.4852 20.4424 12.2751 20.2524 12.055 20.0424C11.885 20.2024 11.7249 20.3624 11.5548 20.5024C10.5344 21.3924 9.49396 22.0424 8.53356 22.3824C8.03335 22.5624 7.56315 22.6524 7.14298 22.6524C6.7228 22.6524 6.32263 22.5624 6.0025 22.3724C4.77199 21.6624 4.35181 19.6224 4.86203 16.9124C4.91205 16.6324 4.98208 16.3524 5.0521 16.0624C4.82201 16.0024 4.61192 15.9324 4.40183 15.8524C3.1213 15.4124 2.04085 14.8324 1.26053 14.1724C0.440183 13.4724 0 12.7024 0 11.9724C0 10.5524 1.56065 9.1624 4.17174 8.2624C4.46186 8.1624 4.76198 8.0724 5.06211 7.9824C4.99208 7.7124 4.93205 7.4524 4.88203 7.1924C4.63193 5.9024 4.58191 4.7224 4.74198 3.7624C4.92205 2.7224 5.34223 1.9824 5.97249 1.6224C7.24302 0.882403 9.41392 1.6424 11.6148 3.6024C11.7449 3.7224 11.8749 3.8424 12.015 3.9724C12.2151 3.7824 12.4152 3.5924 12.6153 3.4224C13.6057 2.5624 14.6161 1.9224 15.5165 1.5924C16.5069 1.2324 17.3572 1.2324 17.9775 1.5924C19.258 2.3224 19.6782 4.5824 19.0779 7.4724C19.0479 7.6524 18.9979 7.8224 18.9579 8.0024C19.218 8.0824 19.4781 8.1624 19.7282 8.2424C20.9687 8.6724 22.0192 9.2224 22.7595 9.8424C23.5698 10.5124 23.99 11.2524 23.99 11.9824L24 11.9624ZM13.2855 4.1924C13.1055 4.3524 12.9154 4.5224 12.7353 4.6924C13.4156 5.4224 14.0959 6.2824 14.7561 7.2224C15.8866 7.3324 16.9671 7.5024 17.9675 7.7324C18.0075 7.5724 18.0475 7.4124 18.0775 7.2624C18.6378 4.5424 18.1576 2.8724 17.4673 2.4824C17.1171 2.2824 16.5469 2.3024 15.8666 2.5624C15.0763 2.8524 14.1859 3.4224 13.2855 4.2024V4.1924ZM16.3868 11.9824C16.0767 11.3524 15.7266 10.7124 15.3464 10.0524C14.9762 9.4024 14.5861 8.7924 14.1859 8.2024C13.4756 8.1424 12.7453 8.1224 11.995 8.1224C11.2447 8.1224 10.5244 8.1524 9.81409 8.2024C9.40392 8.7924 9.02376 9.4124 8.6436 10.0624C8.27345 10.7024 7.93331 11.3524 7.62318 11.9924C7.93331 12.6424 8.27345 13.2824 8.65361 13.9324C9.03376 14.5824 9.41392 15.1924 9.82409 15.7924C10.5244 15.8324 11.2447 15.8624 11.995 15.8624C12.7453 15.8624 13.4856 15.8324 14.1959 15.7824C14.5861 15.2024 14.9662 14.5824 15.3464 13.9324C15.7165 13.2824 16.0667 12.6324 16.3768 11.9924L16.3868 11.9824ZM16.2368 14.4324C15.9967 14.8524 15.7466 15.2624 15.5065 15.6524C16.2968 15.5624 17.0471 15.4324 17.7474 15.2724C17.5373 14.6024 17.2672 13.8924 16.9371 13.1624C16.717 13.5824 16.4869 14.0124 16.2368 14.4324ZM13.4456 16.8424C12.9654 16.8624 12.4852 16.8724 11.995 16.8724C11.5048 16.8724 11.0546 16.8724 10.5944 16.8424C11.0646 17.4624 11.5548 18.0424 12.035 18.5724C12.5052 18.0524 12.9754 17.4724 13.4456 16.8324V16.8424ZM7.75323 14.4324C7.51313 14.0224 7.28303 13.6124 7.07295 13.1924C6.77282 13.9124 6.51271 14.6224 6.29262 15.3124C6.97291 15.4624 7.71321 15.5824 8.50354 15.6624C8.24343 15.2624 7.99333 14.8424 7.75323 14.4324ZM8.48353 8.3324C7.72322 8.4224 6.99291 8.5524 6.30263 8.7024C6.51271 9.3724 6.77282 10.0724 7.06294 10.7824C7.27303 10.3724 7.50313 9.9524 7.74323 9.5424C7.98333 9.1324 8.22343 8.7224 8.47353 8.3324H8.48353ZM10.5744 7.1224C11.0346 7.1024 11.5048 7.0924 11.985 7.0924C12.4652 7.0924 12.9454 7.1024 13.4156 7.1224C12.9454 6.5024 12.4752 5.9324 12.005 5.4224C11.5248 5.9424 11.0446 6.5124 10.5844 7.1224H10.5744ZM16.917 10.7924C17.2172 10.0824 17.4773 9.3824 17.6874 8.7224C16.9971 8.5624 16.2568 8.4324 15.4965 8.3424C15.7466 8.7324 15.9867 9.1324 16.2268 9.5424C16.4669 9.9624 16.697 10.3824 16.917 10.8024V10.7924ZM6.03251 7.7224C7.03293 7.4924 8.11338 7.3324 9.24385 7.2224C9.89412 6.2924 10.5844 5.4424 11.2847 4.7024C11.1647 4.5824 11.0446 4.4724 10.9246 4.3724C8.84369 2.5224 7.16298 2.1124 6.4727 2.5124C6.12255 2.7124 5.86244 3.2224 5.74239 3.9424C5.60233 4.7724 5.64235 5.8324 5.87245 6.9924C5.92247 7.2324 5.97249 7.4824 6.04252 7.7324L6.03251 7.7224ZM5.30221 15.0624C5.60233 14.0724 6.0025 13.0424 6.4827 11.9924C6.01251 10.9624 5.61234 9.9424 5.31221 8.9624C5.02209 9.0424 4.75198 9.1324 4.49187 9.2224C2.09087 10.0624 1.01042 11.2024 1.01042 11.9724C1.01042 12.7424 2.1709 14.0224 4.71196 14.8824C4.90204 14.9424 5.10213 15.0124 5.30221 15.0624ZM10.8545 19.7424C11.0046 19.6124 11.1546 19.4724 11.3147 19.3224C10.6144 18.5624 9.91413 17.7124 9.25386 16.7724C8.08337 16.6824 6.99291 16.5224 6.02251 16.3024C5.95248 16.5724 5.90246 16.8424 5.84243 17.0924C5.37224 19.5924 5.82243 21.0924 6.4827 21.4724C6.64277 21.5624 6.86286 21.6224 7.12297 21.6224C7.97332 21.6224 9.31388 21.0824 10.8545 19.7324V19.7424ZM18.0175 16.2524C17.0271 16.4824 15.9366 16.6524 14.7662 16.7524C14.1059 17.7124 13.4256 18.5724 12.7553 19.3024C12.9554 19.5024 13.1655 19.6824 13.3656 19.8524C15.2964 21.5124 16.827 21.8724 17.4873 21.4824C18.1776 21.0824 18.6778 19.4624 18.1576 16.8224C18.1175 16.6324 18.0675 16.4424 18.0275 16.2424L18.0175 16.2524ZM22.9696 11.9624C22.9696 11.5524 22.6594 11.0824 22.0992 10.6124C21.4489 10.0724 20.5185 9.5824 19.3881 9.1924C19.158 9.1124 18.9179 9.0424 18.6778 8.9624C18.3877 9.9124 17.9875 10.9324 17.5073 11.9624C18.0075 13.0224 18.4177 14.0424 18.7178 15.0024C18.8579 14.9624 18.9879 14.9124 19.128 14.8724C21.7691 14.0024 22.9696 12.7524 22.9696 11.9624Z" fill="#00D8FF"></path></svg>',
  "logo-surveycreator-48x48": '<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><path d="M31.45 3.5H8.55C4.11 3.5 0.5 7.11 0.5 11.55V25.55C0.5 28.73 2.39 31.57 5.19 32.86C4.82 33.58 4.67 34.39 4.8 35.2C4.96 36.21 5.5 37.09 6.32 37.69C6.98 38.17 7.76 38.42 8.56 38.42C8.76 38.42 8.96 38.4 9.16 38.37C10.17 38.21 11.05 37.67 11.65 36.85L17.99 28.14C19.19 28.41 20.43 28.46 21.65 28.26C24.2 27.86 26.45 26.48 27.97 24.39C29.49 22.3 30.11 19.74 29.7 17.19C29.45 15.59 28.8 14.07 27.81 12.8C27.52 12.43 27.05 12.23 26.6 12.22C26.13 12.22 25.69 12.46 25.41 12.84L22.15 17.31C21.89 17.67 21.38 17.75 21.01 17.49C20.83 17.36 20.72 17.17 20.68 16.96C20.65 16.75 20.7 16.53 20.83 16.35L24.09 11.87C24.37 11.49 24.45 11 24.31 10.54C24.17 10.09 23.83 9.73 23.38 9.57C21.86 9.03 20.22 8.87 18.62 9.13C16.07 9.53 13.82 10.91 12.3 13C10.78 15.09 10.16 17.65 10.57 20.2C10.76 21.42 11.19 22.59 11.81 23.64L6.95 30.32C4.92 29.65 3.49 27.73 3.49 25.55V11.55C3.49 8.77 5.75 6.5 8.54 6.5H31.45C34.23 6.5 36.5 8.76 36.5 11.55V25.55C36.5 28.33 34.24 30.59 31.45 30.59H27.5V34L22.95 30.59H18.25C17.42 30.59 16.75 31.26 16.75 32.09C16.75 32.92 17.42 33.59 18.25 33.59H21.95L30.5 40V33.59H31.45C35.89 33.59 39.5 29.98 39.5 25.55V11.55C39.5 7.11 35.89 3.5 31.45 3.5ZM14.87 24.56C15.26 24.02 15.25 23.29 14.85 22.76C14.17 21.88 13.72 20.83 13.55 19.73C13.27 17.97 13.7 16.2 14.75 14.76C15.8 13.32 17.35 12.37 19.11 12.09C19.46 12.04 19.8 12.01 20.15 12.01C20.2 12.01 20.24 12.01 20.29 12.01L18.42 14.58C17.82 15.4 17.58 16.41 17.74 17.42C17.9 18.43 18.44 19.31 19.26 19.91C20.08 20.51 21.09 20.75 22.1 20.59C23.11 20.43 23.99 19.89 24.59 19.07L26.46 16.5C26.59 16.87 26.68 17.26 26.75 17.65C27.03 19.41 26.6 21.18 25.55 22.62C24.5 24.06 22.95 25.01 21.19 25.29C20.09 25.46 18.95 25.36 17.91 24.98C17.28 24.76 16.58 24.98 16.19 25.51L9.23 35.07C9.1 35.25 8.91 35.36 8.7 35.4C8.48 35.43 8.27 35.38 8.09 35.25C7.91 35.12 7.8 34.93 7.76 34.72C7.73 34.51 7.78 34.29 7.91 34.11L14.87 24.55V24.56Z"></path></svg>',
  "logo-vue-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_17790_388140)"><path d="M19.2 2H24L12 22.7L0 2H9.18L12 6.8L14.76 2H19.2Z" fill="#41B883"></path><path d="M4.74023 2L12.0002 14.48L19.2002 2H14.7602L12.0002 6.8L9.18023 2H4.74023Z" fill="#35495E"></path></g><defs><clipPath id="clip0_17790_388140"><rect width="24" height="20.7" fill="white" transform="translate(0 2)"></rect></clipPath></defs></svg>',
  "maximize-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M13.75 3V7C13.75 7.41 13.41 7.75 13 7.75C12.59 7.75 12.25 7.41 12.25 7V4.81L9.53 7.53C9.38 7.68 9.19 7.75 9 7.75C8.81 7.75 8.62 7.68 8.47 7.53C8.18 7.24 8.18 6.76 8.47 6.47L11.19 3.75H9C8.59 3.75 8.25 3.41 8.25 3C8.25 2.59 8.59 2.25 9 2.25H13C13.1 2.25 13.19 2.27 13.29 2.31C13.47 2.39 13.62 2.53 13.7 2.72C13.74 2.81 13.76 2.91 13.76 3.01L13.75 3ZM7.53 8.47C7.24 8.18 6.76 8.18 6.47 8.47L3.75 11.19V9C3.75 8.59 3.41 8.25 3 8.25C2.59 8.25 2.25 8.59 2.25 9V13C2.25 13.1 2.27 13.19 2.31 13.29C2.39 13.47 2.53 13.62 2.72 13.7C2.81 13.74 2.91 13.76 3.01 13.76H7.01C7.42 13.76 7.76 13.42 7.76 13.01C7.76 12.6 7.42 12.26 7.01 12.26H4.82L7.54 9.54C7.83 9.25 7.83 8.77 7.54 8.48L7.53 8.47Z"></path></svg>',
  "minimize-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M13.75 8C13.75 8.41 13.41 8.75 13 8.75H3C2.59 8.75 2.25 8.41 2.25 8C2.25 7.59 2.59 7.25 3 7.25H13C13.41 7.25 13.75 7.59 13.75 8Z"></path></svg>',
  "minus-32x32": '<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><path d="M30 16H3V17H30V16Z"></path></svg>',
  "minusbox-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M10.75 8C10.75 8.41 10.41 8.75 10 8.75H6C5.59 8.75 5.25 8.41 5.25 8C5.25 7.59 5.59 7.25 6 7.25H10C10.41 7.25 10.75 7.59 10.75 8ZM13.75 4V12C13.75 12.96 12.96 13.75 12 13.75H4C3.04 13.75 2.25 12.96 2.25 12V4C2.25 3.04 3.04 2.25 4 2.25H12C12.96 2.25 13.75 3.04 13.75 4ZM12.25 4C12.25 3.86 12.14 3.75 12 3.75H4C3.86 3.75 3.75 3.86 3.75 4V12C3.75 12.14 3.86 12.25 4 12.25H12C12.14 12.25 12.25 12.14 12.25 12V4Z"></path></svg>',
  "more-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M8 6.25C7.04 6.25 6.25 7.04 6.25 8C6.25 8.96 7.04 9.75 8 9.75C8.96 9.75 9.75 8.96 9.75 8C9.75 7.04 8.96 6.25 8 6.25ZM7.75 8C7.75 7.86 7.86 7.75 8 7.75C8.14 7.75 8.25 7.86 8.25 8C8.25 8.28 7.75 8.28 7.75 8ZM2 6.25C1.04 6.25 0.25 7.04 0.25 8C0.25 8.96 1.04 9.75 2 9.75C2.96 9.75 3.75 8.96 3.75 8C3.75 7.04 2.96 6.25 2 6.25ZM1.75 8C1.75 7.86 1.86 7.75 2 7.75C2.14 7.75 2.25 7.86 2.25 8C2.25 8.28 1.75 8.28 1.75 8ZM14 6.25C13.04 6.25 12.25 7.04 12.25 8C12.25 8.96 13.04 9.75 14 9.75C14.96 9.75 15.75 8.96 15.75 8C15.75 7.04 14.96 6.25 14 6.25ZM13.75 8C13.75 7.86 13.86 7.75 14 7.75C14.14 7.75 14.25 7.86 14.25 8C14.25 8.28 13.75 8.28 13.75 8Z"></path></svg>',
  "more-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 10.25C11.04 10.25 10.25 11.04 10.25 12C10.25 12.96 11.04 13.75 12 13.75C12.96 13.75 13.75 12.96 13.75 12C13.75 11.04 12.96 10.25 12 10.25ZM11.75 12C11.75 11.86 11.86 11.75 12 11.75C12.14 11.75 12.25 11.86 12.25 12C12.25 12.28 11.75 12.28 11.75 12ZM19 10.25C18.04 10.25 17.25 11.04 17.25 12C17.25 12.96 18.04 13.75 19 13.75C19.96 13.75 20.75 12.96 20.75 12C20.75 11.04 19.96 10.25 19 10.25ZM18.75 12C18.75 11.86 18.86 11.75 19 11.75C19.14 11.75 19.25 11.86 19.25 12C19.25 12.28 18.75 12.28 18.75 12ZM5 10.25C4.04 10.25 3.25 11.04 3.25 12C3.25 12.96 4.04 13.75 5 13.75C5.96 13.75 6.75 12.96 6.75 12C6.75 11.04 5.96 10.25 5 10.25ZM4.75 12C4.75 11.86 4.86 11.75 5 11.75C5.14 11.75 5.25 11.86 5.25 12C5.25 12.28 4.75 12.28 4.75 12Z"></path></svg>',
  "navmenu-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M3.25 7C3.25 6.59 3.59 6.25 4 6.25H15C15.41 6.25 15.75 6.59 15.75 7C15.75 7.41 15.41 7.75 15 7.75H4C3.59 7.75 3.25 7.41 3.25 7ZM20 11.25H4C3.59 11.25 3.25 11.59 3.25 12C3.25 12.41 3.59 12.75 4 12.75H20C20.41 12.75 20.75 12.41 20.75 12C20.75 11.59 20.41 11.25 20 11.25ZM9 16.25H4C3.59 16.25 3.25 16.59 3.25 17C3.25 17.41 3.59 17.75 4 17.75H9C9.41 17.75 9.75 17.41 9.75 17C9.75 16.59 9.41 16.25 9 16.25Z"></path></svg>',
  "noimage-48x48": '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><path d="M30.4975 14.2475C28.7075 14.2475 27.2475 15.7075 27.2475 17.4975C27.2475 19.2875 28.7075 20.7475 30.4975 20.7475C32.2875 20.7475 33.7475 19.2875 33.7475 17.4975C33.7475 15.7075 32.2875 14.2475 30.4975 14.2475ZM30.4975 19.2475C29.5375 19.2475 28.7475 18.4575 28.7475 17.4975C28.7475 16.5375 29.5375 15.7475 30.4975 15.7475C31.4575 15.7475 32.2475 16.5375 32.2475 17.4975C32.2475 18.4575 31.4575 19.2475 30.4975 19.2475ZM13.5175 11.2175C13.4375 10.8075 13.7075 10.4175 14.1175 10.3375C14.4275 10.2775 14.7175 10.2475 14.9975 10.2475H32.9975C35.6175 10.2475 37.7475 12.3775 37.7475 14.9975V32.9975C37.7475 33.2775 37.7175 33.5675 37.6575 33.8775C37.5875 34.2375 37.2775 34.4875 36.9175 34.4875C36.8675 34.4875 36.8275 34.4875 36.7775 34.4775C36.3675 34.3975 36.1075 34.0075 36.1775 33.5975C36.2175 33.3775 36.2375 33.1775 36.2375 32.9975V14.9975C36.2375 13.2075 34.7775 11.7475 32.9875 11.7475H14.9975C14.8075 11.7475 14.6175 11.7675 14.3975 11.8075C13.9875 11.8875 13.5975 11.6175 13.5175 11.2075V11.2175ZM34.4775 36.7775C34.5575 37.1875 34.2875 37.5775 33.8775 37.6575C33.5675 37.7175 33.2775 37.7475 32.9975 37.7475H14.9975C12.3775 37.7475 10.2475 35.6175 10.2475 32.9975V14.9975C10.2475 14.7175 10.2775 14.4275 10.3375 14.1175C10.4175 13.7075 10.8075 13.4375 11.2175 13.5175C11.6275 13.5975 11.8875 13.9875 11.8175 14.3975C11.7775 14.6175 11.7575 14.8175 11.7575 14.9975V32.9975C11.7575 34.7875 13.2175 36.2475 15.0075 36.2475H33.0075C33.1975 36.2475 33.3875 36.2275 33.6075 36.1875C34.0075 36.1075 34.4075 36.3775 34.4875 36.7875L34.4775 36.7775ZM15.8275 31.7975C15.6975 31.9375 15.7575 32.0875 15.7775 32.1175C15.8175 32.1975 15.8675 32.2475 15.9375 32.2475H29.8175C30.2275 32.2475 30.5675 32.5875 30.5675 32.9975C30.5675 33.4075 30.2275 33.7475 29.8175 33.7475H15.9375C15.2675 33.7475 14.6775 33.3475 14.3975 32.7175C14.1075 32.0575 14.2375 31.2975 14.7275 30.7775L19.7275 25.2775C20.0475 24.9275 20.5075 24.7175 20.9875 24.7075C21.4875 24.7275 21.9375 24.8875 22.2675 25.2275L25.4675 28.4775C25.7575 28.7675 25.7575 29.2475 25.4675 29.5375C25.1675 29.8275 24.6975 29.8275 24.4075 29.5375L21.2075 26.2875C21.1475 26.2175 21.0675 26.1875 21.0275 26.2075C20.9875 26.2075 20.9075 26.2175 20.8475 26.2875L15.8375 31.7975H15.8275ZM38.5275 38.5275C38.3775 38.6775 38.1875 38.7475 37.9975 38.7475C37.8075 38.7475 37.6175 38.6775 37.4675 38.5275L9.4675 10.5275C9.1775 10.2375 9.1775 9.7575 9.4675 9.4675C9.7575 9.1775 10.2375 9.1775 10.5275 9.4675L38.5275 37.4675C38.8175 37.7575 38.8175 38.2375 38.5275 38.5275Z"></path></svg>',
  "pg-appearance-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M19.75 10.5C19.75 9.72 19.35 9.04 18.75 8.63V3C18.75 2.04 17.96 1.25 17 1.25H7C6.04 1.25 5.25 2.04 5.25 3V8.63C4.65 9.03 4.25 9.72 4.25 10.5C4.25 11.28 4.65 11.96 5.25 12.37V13.14C5.25 14.58 6.42 15.75 7.86 15.75C8.19 15.75 8.48 15.89 8.7 16.13C8.92 16.37 9.01 16.69 8.96 17.01L8.69 18.92C8.55 19.88 8.84 20.86 9.48 21.59C10.12 22.32 11.04 22.75 12.01 22.75C12.98 22.75 13.91 22.33 14.54 21.59C15.18 20.85 15.46 19.88 15.33 18.92L15.06 17.01C15.01 16.69 15.11 16.37 15.32 16.13C15.53 15.89 15.83 15.75 16.16 15.75C17.6 15.75 18.77 14.58 18.77 13.14V12.37C19.37 11.97 19.77 11.28 19.77 10.5H19.75ZM5.75 10.5C5.75 10.09 6.09 9.75 6.5 9.75H17.5C17.91 9.75 18.25 10.09 18.25 10.5C18.25 10.91 17.91 11.25 17.5 11.25H6.5C6.09 11.25 5.75 10.91 5.75 10.5ZM6.75 3C6.75 2.86 6.86 2.75 7 2.75H11.25V4C11.25 4.41 11.59 4.75 12 4.75C12.41 4.75 12.75 4.41 12.75 4V2.75H14.25V5C14.25 5.41 14.59 5.75 15 5.75C15.41 5.75 15.75 5.41 15.75 5V2.75H17C17.14 2.75 17.25 2.86 17.25 3V8.25H6.75V3ZM17.25 13.14C17.25 13.75 16.75 14.25 16.14 14.25C15.38 14.25 14.67 14.58 14.17 15.15C13.67 15.72 13.45 16.48 13.56 17.23L13.83 19.14C13.91 19.67 13.75 20.21 13.4 20.62C12.69 21.43 11.31 21.43 10.6 20.62C10.25 20.21 10.09 19.68 10.17 19.14L10.44 17.23C10.55 16.48 10.32 15.72 9.83 15.15C9.33 14.58 8.62 14.25 7.86 14.25C7.25 14.25 6.75 13.75 6.75 13.14V12.75H17.25V13.14ZM11 19C11 18.45 11.45 18 12 18C12.55 18 13 18.45 13 19C13 19.55 12.55 20 12 20C11.45 20 11 19.55 11 19Z"></path></svg>',
  "pg-background-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M5.47 8.53C5.18 8.24 5.18 7.76 5.47 7.47L7.47 5.47C7.76 5.18 8.24 5.18 8.53 5.47C8.82 5.76 8.82 6.24 8.53 6.53L6.53 8.53C6.38 8.68 6.19 8.75 6 8.75C5.81 8.75 5.62 8.68 5.47 8.53ZM6 13.75C6.19 13.75 6.38 13.68 6.53 13.53L13.53 6.53C13.82 6.24 13.82 5.76 13.53 5.47C13.24 5.18 12.76 5.18 12.47 5.47L5.47 12.47C5.18 12.76 5.18 13.24 5.47 13.53C5.62 13.68 5.81 13.75 6 13.75ZM17.47 5.47L5.47 17.47C5.18 17.76 5.18 18.24 5.47 18.53C5.62 18.68 5.81 18.75 6 18.75C6.19 18.75 6.38 18.68 6.53 18.53L18.53 6.53C18.82 6.24 18.82 5.76 18.53 5.47C18.24 5.18 17.76 5.18 17.47 5.47ZM17.47 10.47L10.47 17.47C10.18 17.76 10.18 18.24 10.47 18.53C10.62 18.68 10.81 18.75 11 18.75C11.19 18.75 11.38 18.68 11.53 18.53L18.53 11.53C18.82 11.24 18.82 10.76 18.53 10.47C18.24 10.18 17.76 10.18 17.47 10.47ZM17.47 15.47L15.47 17.47C15.18 17.76 15.18 18.24 15.47 18.53C15.62 18.68 15.81 18.75 16 18.75C16.19 18.75 16.38 18.68 16.53 18.53L18.53 16.53C18.82 16.24 18.82 15.76 18.53 15.47C18.24 15.18 17.76 15.18 17.47 15.47ZM21.75 5V19C21.75 20.52 20.52 21.75 19 21.75H5C3.48 21.75 2.25 20.52 2.25 19V5C2.25 3.48 3.48 2.25 5 2.25H19C20.52 2.25 21.75 3.48 21.75 5ZM20.25 5C20.25 4.31 19.69 3.75 19 3.75H5C4.31 3.75 3.75 4.31 3.75 5V19C3.75 19.69 4.31 20.25 5 20.25H19C19.69 20.25 20.25 19.69 20.25 19V5Z"></path></svg>',
  "pg-columns-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M18.75 4V20C18.75 20.41 18.41 20.75 18 20.75C17.59 20.75 17.25 20.41 17.25 20V4C17.25 3.59 17.59 3.25 18 3.25C18.41 3.25 18.75 3.59 18.75 4ZM14 3.25C13.59 3.25 13.25 3.59 13.25 4V20C13.25 20.41 13.59 20.75 14 20.75C14.41 20.75 14.75 20.41 14.75 20V4C14.75 3.59 14.41 3.25 14 3.25ZM10 3.25C9.59 3.25 9.25 3.59 9.25 4V20C9.25 20.41 9.59 20.75 10 20.75C10.41 20.75 10.75 20.41 10.75 20V4C10.75 3.59 10.41 3.25 10 3.25ZM6 3.25C5.59 3.25 5.25 3.59 5.25 4V20C5.25 20.41 5.59 20.75 6 20.75C6.41 20.75 6.75 20.41 6.75 20V4C6.75 3.59 6.41 3.25 6 3.25Z"></path></svg>',
  "pg-conditions-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M17.53 14.47C17.24 14.18 16.76 14.18 16.47 14.47C16.18 14.76 16.18 15.24 16.47 15.53L18.19 17.25H8.63C8.57 17.05 8.49 16.85 8.39 16.67L16.67 8.39C17.07 8.61 17.52 8.75 18 8.75C19.52 8.75 20.75 7.52 20.75 6C20.75 4.48 19.52 3.25 18 3.25C16.75 3.25 15.7 4.1 15.37 5.25H8.64C8.31 4.1 7.26 3.25 6.01 3.25C4.48 3.25 3.25 4.48 3.25 6C3.25 7.52 4.48 8.75 6 8.75C7.25 8.75 8.3 7.9 8.63 6.75H15.36C15.42 6.95 15.5 7.15 15.6 7.33L7.33 15.61C6.93 15.39 6.48 15.25 6 15.25C4.48 15.25 3.25 16.48 3.25 18C3.25 19.52 4.48 20.75 6 20.75C7.25 20.75 8.3 19.9 8.63 18.75H18.19L16.47 20.47C16.18 20.76 16.18 21.24 16.47 21.53C16.62 21.68 16.81 21.75 17 21.75C17.19 21.75 17.38 21.68 17.53 21.53L20.53 18.53C20.82 18.24 20.82 17.76 20.53 17.47L17.53 14.47ZM6 7.25C5.31 7.25 4.75 6.69 4.75 6C4.75 5.31 5.31 4.75 6 4.75C6.69 4.75 7.25 5.31 7.25 6C7.25 6.69 6.69 7.25 6 7.25ZM18 4.75C18.69 4.75 19.25 5.31 19.25 6C19.25 6.69 18.69 7.25 18 7.25C17.31 7.25 16.75 6.69 16.75 6C16.75 5.31 17.31 4.75 18 4.75ZM6 19.25C5.31 19.25 4.75 18.69 4.75 18C4.75 17.31 5.31 16.75 6 16.75C6.69 16.75 7.25 17.31 7.25 18C7.25 18.69 6.69 19.25 6 19.25Z"></path></svg>',
  "pg-data-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 2.25C7.58 2.25 4.25 3.86 4.25 6V18C4.25 20.14 7.58 21.75 12 21.75C16.42 21.75 19.75 20.14 19.75 18V6C19.75 3.86 16.42 2.25 12 2.25ZM18.25 14C18.25 14.92 15.82 16.25 12 16.25C8.18 16.25 5.75 14.92 5.75 14V12.27C7.14 13.18 9.37 13.75 12 13.75C14.63 13.75 16.86 13.18 18.25 12.27V14ZM18.25 10C18.25 10.92 15.82 12.25 12 12.25C8.18 12.25 5.75 10.92 5.75 10V8.27C7.14 9.18 9.37 9.75 12 9.75C14.63 9.75 16.86 9.18 18.25 8.27V10ZM12 3.75C15.82 3.75 18.25 5.08 18.25 6C18.25 6.92 15.82 8.25 12 8.25C8.18 8.25 5.75 6.92 5.75 6C5.75 5.08 8.18 3.75 12 3.75ZM12 20.25C8.18 20.25 5.75 18.92 5.75 18V16.27C7.14 17.18 9.37 17.75 12 17.75C14.63 17.75 16.86 17.18 18.25 16.27V18C18.25 18.92 15.82 20.25 12 20.25Z"></path></svg>',
  "pg-design-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M19.67 4.8C19.01 4.53 18.27 4.68 17.76 5.18L5.18 17.76C4.68 18.26 4.53 19.01 4.8 19.67C5.07 20.33 5.71 20.75 6.42 20.75H19.01C19.97 20.75 20.76 19.96 20.76 19V6.41C20.76 5.7 20.34 5.07 19.68 4.79L19.67 4.8ZM19.25 19C19.25 19.14 19.14 19.25 19 19.25H6.41C6.26 19.25 6.2 19.15 6.18 19.1C6.16 19.04 6.13 18.93 6.23 18.83L18.82 6.24C18.88 6.18 18.94 6.16 18.99 6.16C19.03 6.16 19.07 6.17 19.09 6.18C19.15 6.2 19.24 6.26 19.24 6.41V19H19.25ZM17.29 10.31C17.01 10.2 16.69 10.26 16.47 10.47L10.47 16.47C10.26 16.68 10.19 17.01 10.31 17.29C10.43 17.57 10.7 17.75 11 17.75H17C17.41 17.75 17.75 17.41 17.75 17V11C17.75 10.7 17.57 10.42 17.29 10.31ZM16.25 16.25H12.81L16.25 12.81V16.25ZM9 6.25C7.48 6.25 6.25 7.48 6.25 9C6.25 10.52 7.48 11.75 9 11.75C10.52 11.75 11.75 10.52 11.75 9C11.75 7.48 10.52 6.25 9 6.25ZM9 10.25C8.31 10.25 7.75 9.69 7.75 9C7.75 8.31 8.31 7.75 9 7.75C9.69 7.75 10.25 8.31 10.25 9C10.25 9.69 9.69 10.25 9 10.25ZM4.23 13.77C3.67 13.21 3.57 12.36 3.93 11.7C3.75 11.37 3.61 11.03 3.5 10.68C2.78 10.47 2.25 9.79 2.25 9C2.25 8.21 2.78 7.54 3.5 7.32C3.61 6.97 3.75 6.62 3.93 6.3C3.57 5.64 3.67 4.79 4.23 4.23C4.79 3.67 5.64 3.57 6.3 3.93C6.63 3.75 6.97 3.61 7.32 3.5C7.53 2.78 8.21 2.25 9 2.25C9.79 2.25 10.46 2.78 10.68 3.5C11.03 3.61 11.38 3.75 11.7 3.93C12.36 3.57 13.21 3.67 13.77 4.23C14.1 4.56 14.28 5 14.28 5.47C14.28 5.77 14.21 6.06 14.07 6.31C14.19 6.54 14.29 6.79 14.39 7.06C14.53 7.45 14.33 7.88 13.94 8.02C13.55 8.16 13.12 7.96 12.98 7.57C12.85 7.2 12.7 6.91 12.54 6.66C12.34 6.36 12.38 5.97 12.63 5.71L12.7 5.64C12.76 5.58 12.77 5.5 12.77 5.46C12.77 5.42 12.77 5.35 12.7 5.29C12.6 5.19 12.44 5.19 12.35 5.29L12.28 5.36C12.03 5.61 11.63 5.65 11.34 5.45C10.88 5.15 10.38 4.94 9.85 4.83C9.5 4.76 9.25 4.45 9.25 4.09V3.99C9.25 3.71 8.75 3.71 8.75 3.99V4.09C8.75 4.45 8.5 4.75 8.15 4.83C7.62 4.94 7.12 5.15 6.66 5.45C6.36 5.65 5.97 5.61 5.72 5.36L5.65 5.29C5.55 5.19 5.39 5.19 5.3 5.29C5.2 5.39 5.2 5.55 5.3 5.64L5.37 5.71C5.62 5.96 5.66 6.36 5.47 6.65C5.17 7.11 4.96 7.61 4.85 8.14C4.78 8.49 4.47 8.74 4.11 8.74H4.01C3.87 8.74 3.76 8.85 3.76 8.99C3.76 9.13 3.87 9.24 4.01 9.24H4.11C4.47 9.24 4.77 9.49 4.85 9.84C4.96 10.37 5.17 10.87 5.47 11.33C5.67 11.63 5.63 12.02 5.37 12.27L5.3 12.34C5.2 12.44 5.2 12.6 5.3 12.69C5.4 12.79 5.56 12.79 5.65 12.69L5.72 12.62C5.97 12.37 6.37 12.33 6.67 12.53C6.92 12.69 7.21 12.84 7.58 12.97C7.97 13.11 8.17 13.54 8.03 13.93C7.92 14.23 7.63 14.42 7.32 14.42C7.24 14.42 7.15 14.41 7.06 14.38C6.79 14.28 6.54 14.17 6.31 14.06C5.65 14.42 4.77 14.3 4.23 13.76V13.77Z"></path></svg>',
  "pg-general-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M18 3.25H6C4.48 3.25 3.25 4.48 3.25 6V18C3.25 19.52 4.48 20.75 6 20.75H18C19.52 20.75 20.75 19.52 20.75 18V6C20.75 4.48 19.52 3.25 18 3.25ZM19.25 18C19.25 18.69 18.69 19.25 18 19.25H6C5.31 19.25 4.75 18.69 4.75 18V6C4.75 5.31 5.31 4.75 6 4.75H18C18.69 4.75 19.25 5.31 19.25 6V18ZM9.75 9C9.75 9.41 9.41 9.75 9 9.75H8C7.59 9.75 7.25 9.41 7.25 9C7.25 8.59 7.59 8.25 8 8.25H9C9.41 8.25 9.75 8.59 9.75 9ZM16.75 9C16.75 9.41 16.41 9.75 16 9.75H12C11.59 9.75 11.25 9.41 11.25 9C11.25 8.59 11.59 8.25 12 8.25H16C16.41 8.25 16.75 8.59 16.75 9ZM9.75 12C9.75 12.41 9.41 12.75 9 12.75H8C7.59 12.75 7.25 12.41 7.25 12C7.25 11.59 7.59 11.25 8 11.25H9C9.41 11.25 9.75 11.59 9.75 12ZM16.75 12C16.75 12.41 16.41 12.75 16 12.75H12C11.59 12.75 11.25 12.41 11.25 12C11.25 11.59 11.59 11.25 12 11.25H16C16.41 11.25 16.75 11.59 16.75 12ZM9.75 15C9.75 15.41 9.41 15.75 9 15.75H8C7.59 15.75 7.25 15.41 7.25 15C7.25 14.59 7.59 14.25 8 14.25H9C9.41 14.25 9.75 14.59 9.75 15ZM16.75 15C16.75 15.41 16.41 15.75 16 15.75H12C11.59 15.75 11.25 15.41 11.25 15C11.25 14.59 11.59 14.25 12 14.25H16C16.41 14.25 16.75 14.59 16.75 15Z"></path></svg>',
  "pg-header-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M19 3.25H5C3.48 3.25 2.25 4.48 2.25 6V13C2.25 14.52 3.48 15.75 5 15.75H19C20.52 15.75 21.75 14.52 21.75 13V6C21.75 4.48 20.52 3.25 19 3.25ZM6.81 14.25L10 11.06L11.47 12.53C11.76 12.82 12.24 12.82 12.53 12.53L13 12.06L15.19 14.25H6.81ZM20.25 13C20.25 13.69 19.69 14.25 19 14.25H17.31L13.53 10.47C13.24 10.18 12.76 10.18 12.47 10.47L12 10.94L10.53 9.47C10.24 9.18 9.76 9.18 9.47 9.47L4.74 14.2C4.18 14.08 3.75 13.6 3.75 13V6C3.75 5.31 4.31 4.75 5 4.75H19C19.69 4.75 20.25 5.31 20.25 6V13ZM16.5 6.25C15.26 6.25 14.25 7.26 14.25 8.5C14.25 9.74 15.26 10.75 16.5 10.75C17.74 10.75 18.75 9.74 18.75 8.5C18.75 7.26 17.74 6.25 16.5 6.25ZM16.5 9.25C16.09 9.25 15.75 8.91 15.75 8.5C15.75 8.09 16.09 7.75 16.5 7.75C16.91 7.75 17.25 8.09 17.25 8.5C17.25 8.91 16.91 9.25 16.5 9.25ZM15.75 21C15.75 21.41 15.41 21.75 15 21.75H9C8.59 21.75 8.25 21.41 8.25 21C8.25 20.59 8.59 20.25 9 20.25H15C15.41 20.25 15.75 20.59 15.75 21ZM17.75 18C17.75 18.41 17.41 18.75 17 18.75H7C6.59 18.75 6.25 18.41 6.25 18C6.25 17.59 6.59 17.25 7 17.25H17C17.41 17.25 17.75 17.59 17.75 18Z"></path></svg>',
  "pg-language-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M22.67 20.67L16.67 8.67C16.42 8.16 15.58 8.16 15.33 8.67L9.33 20.67C9.14 21.04 9.29 21.49 9.67 21.68C10.04 21.87 10.49 21.72 10.68 21.34L12.98 16.75C12.98 16.75 13 16.75 13.01 16.75H19.01C19.01 16.75 19.03 16.75 19.04 16.75L21.34 21.34C21.47 21.6 21.74 21.76 22.01 21.76C22.12 21.76 22.24 21.73 22.34 21.68C22.71 21.49 22.86 21.04 22.68 20.67H22.67ZM13.71 15.25L16 10.68L18.29 15.25H13.72H13.71ZM10.7 12.23C9.9 11.17 9.36 10.03 8.99 8.88C8.18 11.39 6.56 13.74 3.38 15.65C3.26 15.72 3.13 15.76 3 15.76C2.75 15.76 2.5 15.63 2.36 15.4C2.15 15.04 2.26 14.58 2.62 14.37C6.39 12.11 7.74 9.32 8.12 5.76H3C2.59 5.75 2.25 5.41 2.25 5C2.25 4.59 2.59 4.25 3 4.25H8.22C8.24 3.84 8.25 3.43 8.25 3C8.25 2.57 8.59 2.25 9 2.25C9.41 2.25 9.75 2.59 9.75 3C9.75 3.43 9.76 3.85 9.78 4.25H15C15.41 4.25 15.75 4.59 15.75 5C15.75 5.41 15.41 5.75 15 5.75H9.89C10.15 8.09 10.79 9.84 11.9 11.33C12.15 11.66 12.08 12.13 11.75 12.38C11.42 12.63 10.95 12.56 10.7 12.23Z"></path></svg>',
  "pg-layout-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M19 3.25H5C4.04 3.25 3.25 4.04 3.25 5V9C3.25 9.96 4.04 10.75 5 10.75H19C19.96 10.75 20.75 9.96 20.75 9V5C20.75 4.04 19.96 3.25 19 3.25ZM19.25 9C19.25 9.14 19.14 9.25 19 9.25H5C4.86 9.25 4.75 9.14 4.75 9V5C4.75 4.86 4.86 4.75 5 4.75H19C19.14 4.75 19.25 4.86 19.25 5V9ZM11 12.25H5C4.04 12.25 3.25 13.04 3.25 14V19C3.25 19.96 4.04 20.75 5 20.75H11C11.96 20.75 12.75 19.96 12.75 19V14C12.75 13.04 11.96 12.25 11 12.25ZM11.25 19C11.25 19.14 11.14 19.25 11 19.25H5C4.86 19.25 4.75 19.14 4.75 19V14C4.75 13.86 4.86 13.75 5 13.75H11C11.14 13.75 11.25 13.86 11.25 14V19ZM19 12.25H16C15.04 12.25 14.25 13.04 14.25 14V19C14.25 19.96 15.04 20.75 16 20.75H19C19.96 20.75 20.75 19.96 20.75 19V14C20.75 13.04 19.96 12.25 19 12.25ZM19.25 19C19.25 19.14 19.14 19.25 19 19.25H16C15.86 19.25 15.75 19.14 15.75 19V14C15.75 13.86 15.86 13.75 16 13.75H19C19.14 13.75 19.25 13.86 19.25 14V19Z"></path></svg>',
  "pg-logo-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M18 3.25H6C4.48 3.25 3.25 4.48 3.25 6V18C3.25 19.52 4.48 20.75 6 20.75H18C19.52 20.75 20.75 19.52 20.75 18V6C20.75 4.48 19.52 3.25 18 3.25ZM19.25 18C19.25 18.69 18.69 19.25 18 19.25H6C5.31 19.25 4.75 18.69 4.75 18V6C4.75 5.31 5.31 4.75 6 4.75H18C18.69 4.75 19.25 5.31 19.25 6V18ZM15.5 6.25C14.26 6.25 13.25 7.26 13.25 8.5C13.25 9.74 14.26 10.75 15.5 10.75C16.74 10.75 17.75 9.74 17.75 8.5C17.75 7.26 16.74 6.25 15.5 6.25ZM15.5 9.25C15.09 9.25 14.75 8.91 14.75 8.5C14.75 8.09 15.09 7.75 15.5 7.75C15.91 7.75 16.25 8.09 16.25 8.5C16.25 8.91 15.91 9.25 15.5 9.25ZM14.53 13.47C14.24 13.18 13.76 13.18 13.47 13.47L13 13.94L11.53 12.47C11.24 12.18 10.76 12.18 10.47 12.47L6.47 16.47C6.26 16.68 6.19 17.01 6.31 17.29C6.43 17.57 6.7 17.75 7 17.75H17C17.3 17.75 17.58 17.57 17.69 17.29C17.81 17.01 17.74 16.69 17.53 16.47L14.53 13.47ZM8.81 16.25L11 14.06L12.47 15.53C12.76 15.82 13.24 15.82 13.53 15.53L14 15.06L15.19 16.25H8.81Z"></path></svg>',
  "pg-navigation-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M10.06 8.88C9.63 8.67 9.13 8.71 8.75 9L6.08 11C5.76 11.24 5.58 11.6 5.58 12C5.58 12.4 5.76 12.76 6.08 13L8.75 15C8.97 15.17 9.23 15.25 9.5 15.25C9.69 15.25 9.88 15.21 10.06 15.12C10.49 14.91 10.75 14.48 10.75 14V10C10.75 9.52 10.49 9.09 10.06 8.88ZM9.25 13.5L7.25 12L9.25 10.5V13.5ZM17.92 11L15.25 9C14.87 8.71 14.37 8.67 13.94 8.88C13.51 9.09 13.25 9.52 13.25 10V14C13.25 14.48 13.51 14.91 13.94 15.12C14.12 15.21 14.31 15.25 14.5 15.25C14.76 15.25 15.03 15.17 15.25 15L17.92 13C18.24 12.76 18.42 12.4 18.42 12C18.42 11.6 18.24 11.24 17.92 11ZM14.75 13.5V10.5L16.75 12L14.75 13.5ZM12 2.25C6.62 2.25 2.25 6.62 2.25 12C2.25 17.38 6.62 21.75 12 21.75C17.38 21.75 21.75 17.38 21.75 12C21.75 6.62 17.38 2.25 12 2.25ZM12 20.25C7.45 20.25 3.75 16.55 3.75 12C3.75 7.45 7.45 3.75 12 3.75C16.55 3.75 20.25 7.45 20.25 12C20.25 16.55 16.55 20.25 12 20.25Z"></path></svg>',
  "pg-pages-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M17 2.25H7C5.48 2.25 4.25 3.48 4.25 5V19C4.25 20.52 5.48 21.75 7 21.75H17C18.52 21.75 19.75 20.52 19.75 19V5C19.75 3.48 18.52 2.25 17 2.25ZM18.25 19C18.25 19.69 17.69 20.25 17 20.25H7C6.31 20.25 5.75 19.69 5.75 19V5C5.75 4.31 6.31 3.75 7 3.75H17C17.69 3.75 18.25 4.31 18.25 5V19ZM7.25 6C7.25 5.59 7.59 5.25 8 5.25H10C10.41 5.25 10.75 5.59 10.75 6C10.75 6.41 10.41 6.75 10 6.75H8C7.59 6.75 7.25 6.41 7.25 6ZM16.75 9C16.75 9.41 16.41 9.75 16 9.75H8C7.59 9.75 7.25 9.41 7.25 9C7.25 8.59 7.59 8.25 8 8.25H16C16.41 8.25 16.75 8.59 16.75 9ZM16.75 12C16.75 12.41 16.41 12.75 16 12.75H8C7.59 12.75 7.25 12.41 7.25 12C7.25 11.59 7.59 11.25 8 11.25H16C16.41 11.25 16.75 11.59 16.75 12ZM16.75 15C16.75 15.41 16.41 15.75 16 15.75H8C7.59 15.75 7.25 15.41 7.25 15C7.25 14.59 7.59 14.25 8 14.25H16C16.41 14.25 16.75 14.59 16.75 15ZM16.75 18C16.75 18.41 16.41 18.75 16 18.75H13C12.59 18.75 12.25 18.41 12.25 18C12.25 17.59 12.59 17.25 13 17.25H16C16.41 17.25 16.75 17.59 16.75 18Z"></path></svg>',
  "pg-questiondesign-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20.75 15.01V16.01C20.75 17.53 19.52 18.76 18 18.76H12.31L8.53 22.54C8.39 22.68 8.2 22.76 8 22.76C7.9 22.76 7.81 22.74 7.71 22.7C7.43 22.58 7.25 22.31 7.25 22.01V18.76H6C4.48 18.76 3.25 17.53 3.25 16.01V6.01C3.25 4.49 4.48 3.26 6 3.26H9C9.41 3.26 9.75 3.6 9.75 4.01C9.75 4.42 9.41 4.76 9 4.76H6C5.31 4.76 4.75 5.32 4.75 6.01V16.01C4.75 16.7 5.31 17.26 6 17.26H8C8.41 17.26 8.75 17.6 8.75 18.01V20.2L11.47 17.48C11.61 17.34 11.8 17.26 12 17.26H18C18.69 17.26 19.25 16.7 19.25 16.01V15.01C19.25 14.6 19.59 14.26 20 14.26C20.41 14.26 20.75 14.6 20.75 15.01ZM22.75 8.01C22.75 8.8 22.22 9.47 21.5 9.69C21.39 10.04 21.25 10.38 21.07 10.71C21.21 10.96 21.28 11.25 21.28 11.55C21.28 12.02 21.1 12.46 20.77 12.79C20.44 13.12 20 13.3 19.53 13.3C19.23 13.3 18.95 13.23 18.69 13.09C18.36 13.27 18.02 13.41 17.67 13.52C17.46 14.24 16.78 14.77 15.99 14.77C15.2 14.77 14.53 14.24 14.31 13.52C13.96 13.41 13.62 13.27 13.29 13.09C13.04 13.23 12.75 13.3 12.45 13.3C11.98 13.3 11.54 13.12 11.21 12.79C10.88 12.46 10.7 12.02 10.7 11.55C10.7 11.25 10.77 10.97 10.91 10.71C10.73 10.38 10.59 10.04 10.48 9.69C9.76 9.48 9.23 8.8 9.23 8.01C9.23 7.22 9.76 6.55 10.48 6.33C10.59 5.98 10.73 5.64 10.91 5.31C10.77 5.06 10.7 4.77 10.7 4.47C10.7 4 10.88 3.56 11.21 3.23C11.54 2.9 11.98 2.72 12.45 2.72C12.75 2.72 13.03 2.79 13.29 2.93C13.62 2.75 13.96 2.61 14.31 2.5C14.52 1.78 15.2 1.25 15.99 1.25C16.78 1.25 17.45 1.78 17.67 2.5C18.02 2.61 18.36 2.75 18.69 2.93C18.94 2.79 19.23 2.72 19.53 2.72C20 2.72 20.44 2.9 20.77 3.23C21.1 3.56 21.28 4 21.28 4.47C21.28 4.77 21.21 5.05 21.07 5.31C21.25 5.64 21.39 5.98 21.5 6.33C22.22 6.54 22.75 7.22 22.75 8.01ZM21.25 8.01C21.25 7.87 21.14 7.76 21 7.76H20.9C20.54 7.76 20.24 7.51 20.16 7.16C20.05 6.63 19.84 6.13 19.54 5.67C19.34 5.37 19.38 4.98 19.63 4.73L19.7 4.66C19.76 4.6 19.77 4.52 19.77 4.48C19.77 4.44 19.77 4.37 19.7 4.31C19.63 4.25 19.56 4.24 19.52 4.24C19.52 4.24 19.41 4.24 19.34 4.31L19.27 4.38C19.02 4.63 18.62 4.67 18.33 4.47C17.87 4.17 17.37 3.96 16.84 3.85C16.49 3.78 16.24 3.47 16.24 3.11V3.01C16.24 2.73 15.74 2.73 15.74 3.01V3.11C15.74 3.47 15.49 3.77 15.14 3.85C14.61 3.96 14.11 4.17 13.65 4.47C13.36 4.67 12.96 4.63 12.71 4.38L12.64 4.31C12.52 4.19 12.41 4.18 12.29 4.31C12.23 4.37 12.22 4.45 12.22 4.49C12.22 4.53 12.22 4.6 12.29 4.67L12.36 4.74C12.61 4.99 12.65 5.39 12.45 5.68C12.15 6.14 11.94 6.64 11.83 7.17C11.76 7.52 11.45 7.77 11.09 7.77H10.99C10.85 7.77 10.74 7.88 10.74 8.02C10.74 8.16 10.85 8.27 10.99 8.27H11.09C11.45 8.27 11.75 8.52 11.83 8.87C11.94 9.4 12.15 9.9 12.45 10.36C12.65 10.66 12.61 11.05 12.36 11.3L12.29 11.37C12.23 11.43 12.22 11.51 12.22 11.55C12.22 11.59 12.22 11.66 12.29 11.72C12.36 11.79 12.44 11.79 12.47 11.79C12.51 11.79 12.58 11.79 12.65 11.72L12.72 11.65C12.86 11.51 13.06 11.43 13.25 11.43C13.39 11.43 13.54 11.47 13.66 11.55C14.12 11.85 14.62 12.06 15.15 12.17C15.5 12.24 15.75 12.55 15.75 12.91V13.01C15.75 13.29 16.25 13.29 16.25 13.01V12.91C16.25 12.55 16.5 12.25 16.85 12.17C17.38 12.06 17.88 11.85 18.34 11.55C18.64 11.35 19.03 11.39 19.28 11.64L19.35 11.71C19.47 11.83 19.58 11.84 19.7 11.71C19.76 11.65 19.77 11.57 19.77 11.53C19.77 11.49 19.77 11.42 19.7 11.35L19.63 11.28C19.38 11.03 19.34 10.63 19.54 10.34C19.84 9.88 20.05 9.38 20.16 8.85C20.23 8.5 20.54 8.25 20.9 8.25H21C21.14 8.25 21.25 8.14 21.25 8V8.01ZM18.75 8.01C18.75 9.53 17.52 10.76 16 10.76C14.48 10.76 13.25 9.53 13.25 8.01C13.25 6.49 14.48 5.26 16 5.26C17.52 5.26 18.75 6.49 18.75 8.01ZM17.25 8.01C17.25 7.32 16.69 6.76 16 6.76C15.31 6.76 14.75 7.32 14.75 8.01C14.75 8.7 15.31 9.26 16 9.26C16.69 9.26 17.25 8.7 17.25 8.01Z"></path></svg>',
  "pg-quiz-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M18.69 7.38L19.53 6.54C19.82 6.25 19.82 5.77 19.53 5.48C19.24 5.19 18.76 5.19 18.47 5.48L17.63 6.32C16.11 5.04 14.14 4.26 12 4.26C9.86 4.26 7.89 5.04 6.37 6.32L5.53 5.48C5.24 5.19 4.76 5.19 4.47 5.48C4.18 5.77 4.18 6.25 4.47 6.54L5.31 7.38C4.03 8.9 3.25 10.87 3.25 13.01C3.25 17.84 7.17 21.76 12 21.76C16.83 21.76 20.75 17.84 20.75 13.01C20.75 10.87 19.97 8.9 18.69 7.38ZM12 20.26C8 20.26 4.75 17.01 4.75 13.01C4.75 9.01 8 5.76 12 5.76C16 5.76 19.25 9.01 19.25 13.01C19.25 17.01 16 20.26 12 20.26ZM15.53 9.48C15.82 9.77 15.82 10.25 15.53 10.54L12.53 13.54C12.38 13.69 12.19 13.76 12 13.76C11.81 13.76 11.62 13.69 11.47 13.54C11.18 13.25 11.18 12.77 11.47 12.48L14.47 9.48C14.76 9.19 15.24 9.19 15.53 9.48ZM9.26 2.34C9.18 1.93 9.45 1.54 9.86 1.46C11.31 1.18 12.69 1.18 14.14 1.46C14.55 1.54 14.81 1.93 14.74 2.34C14.67 2.7 14.36 2.95 14 2.95C13.95 2.95 13.91 2.95 13.86 2.94C12.59 2.7 11.41 2.7 10.14 2.94C9.74 3.02 9.34 2.75 9.26 2.34Z"></path></svg>',
  "pg-rows-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M3.25 6C3.25 5.59 3.59 5.25 4 5.25H20C20.41 5.25 20.75 5.59 20.75 6C20.75 6.41 20.41 6.75 20 6.75H4C3.59 6.75 3.25 6.41 3.25 6ZM20 9.25H4C3.59 9.25 3.25 9.59 3.25 10C3.25 10.41 3.59 10.75 4 10.75H20C20.41 10.75 20.75 10.41 20.75 10C20.75 9.59 20.41 9.25 20 9.25ZM20 13.25H4C3.59 13.25 3.25 13.59 3.25 14C3.25 14.41 3.59 14.75 4 14.75H20C20.41 14.75 20.75 14.41 20.75 14C20.75 13.59 20.41 13.25 20 13.25ZM20 17.25H4C3.59 17.25 3.25 17.59 3.25 18C3.25 18.41 3.59 18.75 4 18.75H20C20.41 18.75 20.75 18.41 20.75 18C20.75 17.59 20.41 17.25 20 17.25Z"></path></svg>',
  "pg-specific-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20.75 11V16C20.75 17.52 19.52 18.75 18 18.75H12.31L8.53 22.53C8.39 22.67 8.2 22.75 8 22.75C7.9 22.75 7.81 22.73 7.71 22.69C7.43 22.57 7.25 22.3 7.25 22V18.75H6C4.48 18.75 3.25 17.52 3.25 16V6C3.25 4.48 4.48 3.25 6 3.25H13C13.41 3.25 13.75 3.59 13.75 4C13.75 4.41 13.41 4.75 13 4.75H6C5.31 4.75 4.75 5.31 4.75 6V16C4.75 16.69 5.31 17.25 6 17.25H8C8.41 17.25 8.75 17.59 8.75 18V20.19L11.47 17.47C11.61 17.33 11.8 17.25 12 17.25H18C18.69 17.25 19.25 16.69 19.25 16V11C19.25 10.59 19.59 10.25 20 10.25C20.41 10.25 20.75 10.59 20.75 11ZM21.03 7.03L14.53 13.53C14.43 13.63 14.31 13.69 14.18 13.73L10.18 14.73C10.12 14.74 10.06 14.75 10 14.75C9.8 14.75 9.61 14.67 9.47 14.53C9.28 14.34 9.21 14.07 9.27 13.82L10.27 9.82C10.3 9.69 10.37 9.57 10.47 9.47001L16.97 2.97C18.09 1.85 19.91 1.85 21.03 2.97C22.15 4.09 22.15 5.91001 21.03 7.03ZM17.94 8L16 6.06L11.68 10.38L11.03 12.96L13.61 12.31L17.93 7.99001L17.94 8ZM19.97 4.03C19.43 3.49 18.57 3.49 18.03 4.03L17.06 5L19 6.94L19.97 5.97C20.5 5.43 20.5 4.57 19.97 4.03Z"></path></svg>',
  "pg-thankyyoupage-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M18.5275 17.4675C18.8175 17.7575 18.8175 18.2375 18.5275 18.5275C18.3775 18.6775 18.1875 18.7475 17.9975 18.7475C17.8075 18.7475 17.6175 18.6775 17.4675 18.5275L13.4675 14.5275C13.1775 14.2375 13.1775 13.7575 13.4675 13.4675C13.7575 13.1775 14.2375 13.1775 14.5275 13.4675L18.5275 17.4675ZM22.5275 10.5275L19.5275 13.5275C19.3775 13.6775 19.1875 13.7475 18.9975 13.7475C18.8075 13.7475 18.6175 13.6775 18.4675 13.5275L14.9975 10.0575L6.5275 18.5275C6.3775 18.6775 6.1875 18.7475 5.9975 18.7475C5.8075 18.7475 5.6175 18.6775 5.4675 18.5275C5.1775 18.2375 5.1775 17.7575 5.4675 17.4675L10.9375 11.9975L8.9975 10.0575L5.5275 13.5275C5.3775 13.6775 5.1875 13.7475 4.9975 13.7475C4.8075 13.7475 4.6175 13.6775 4.4675 13.5275L1.4675 10.5275C1.1775 10.2375 1.1775 9.7575 1.4675 9.4675L4.9375 5.9975L4.4675 5.5275C4.1775 5.2375 4.1775 4.7575 4.4675 4.4675C4.7575 4.1775 5.2375 4.1775 5.5275 4.4675L6.5275 5.4675L9.5275 8.4675L11.9975 10.9375L14.4675 8.4675L17.4675 5.4675L18.4675 4.4675C18.7575 4.1775 19.2375 4.1775 19.5275 4.4675C19.8175 4.7575 19.8175 5.2375 19.5275 5.5275L19.0575 5.9975L22.5275 9.4675C22.8175 9.7575 22.8175 10.2375 22.5275 10.5275ZM7.9375 8.9975L5.9975 7.0575L3.0575 9.9975L4.9975 11.9375L7.9375 8.9975ZM20.9375 9.9975L17.9975 7.0575L16.0575 8.9975L18.9975 11.9375L20.9375 9.9975Z"></path></svg>',
  "pg-themes-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M19 2.25H5C3.48 2.25 2.25 3.48 2.25 5V19C2.25 20.52 3.48 21.75 5 21.75H19C20.52 21.75 21.75 20.52 21.75 19V5C21.75 3.48 20.52 2.25 19 2.25ZM20.25 19C20.25 19.69 19.69 20.25 19 20.25H5C4.31 20.25 3.75 19.69 3.75 19V5C3.75 4.31 4.31 3.75 5 3.75H19C19.69 3.75 20.25 4.31 20.25 5V19ZM7 10.75H9C9.96 10.75 10.75 9.96 10.75 9V7C10.75 6.04 9.96 5.25 9 5.25H7C6.04 5.25 5.25 6.04 5.25 7V9C5.25 9.96 6.04 10.75 7 10.75ZM6.75 7C6.75 6.86 6.86 6.75 7 6.75H9C9.14 6.75 9.25 6.86 9.25 7V9C9.25 9.14 9.14 9.25 9 9.25H7C6.86 9.25 6.75 9.14 6.75 9V7ZM17 5.25H14C13.04 5.25 12.25 6.04 12.25 7V10C12.25 10.96 13.04 11.75 14 11.75H17C17.96 11.75 18.75 10.96 18.75 10V7C18.75 6.04 17.96 5.25 17 5.25ZM17.25 10C17.25 10.14 17.14 10.25 17 10.25H14C13.86 10.25 13.75 10.14 13.75 10V7C13.75 6.86 13.86 6.75 14 6.75H17C17.14 6.75 17.25 6.86 17.25 7V10ZM17 13.25H15C14.04 13.25 13.25 14.04 13.25 15V17C13.25 17.96 14.04 18.75 15 18.75H17C17.96 18.75 18.75 17.96 18.75 17V15C18.75 14.04 17.96 13.25 17 13.25ZM17.25 17C17.25 17.14 17.14 17.25 17 17.25H15C14.86 17.25 14.75 17.14 14.75 17V15C14.75 14.86 14.86 14.75 15 14.75H17C17.14 14.75 17.25 14.86 17.25 15V17ZM10 12.25H7C6.04 12.25 5.25 13.04 5.25 14V17C5.25 17.96 6.04 18.75 7 18.75H10C10.96 18.75 11.75 17.96 11.75 17V14C11.75 13.04 10.96 12.25 10 12.25ZM10.25 17C10.25 17.14 10.14 17.25 10 17.25H7C6.86 17.25 6.75 17.14 6.75 17V14C6.75 13.86 6.86 13.75 7 13.75H10C10.14 13.75 10.25 13.86 10.25 14V17Z"></path></svg>',
  "pg-totals-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M19.0008 20.75H5.00076C4.70076 20.75 4.42076 20.57 4.31076 20.29C4.19076 20.01 4.26076 19.69 4.47076 19.47L11.9408 12L4.47076 4.53C4.25076 4.32 4.19076 3.99 4.31076 3.71C4.43076 3.43 4.70076 3.25 5.00076 3.25H19.0008C19.4108 3.25 19.7508 3.59 19.7508 4C19.7508 4.41 19.4108 4.75 19.0008 4.75H6.81076L13.5308 11.47C13.8208 11.76 13.8208 12.24 13.5308 12.53L6.81076 19.25H19.0008C19.4108 19.25 19.7508 19.59 19.7508 20C19.7508 20.41 19.4108 20.75 19.0008 20.75Z"></path></svg>',
  "pg-undefined-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M6.93 5.2475C7.1 5.6275 6.93 6.0675 6.55 6.2375L6.05 6.4575C5.95 6.4975 5.85 6.5175 5.75 6.5175C5.46 6.5175 5.19 6.3475 5.06 6.0675C4.89 5.6875 5.06 5.2475 5.44 5.0775L5.94 4.8575C6.32 4.6875 6.76 4.8575 6.93 5.2375V5.2475ZM8.76 5.1875C8.86 5.1875 8.97 5.1675 9.06 5.1275L9.56 4.9075C9.94 4.7375 10.11 4.2975 9.94 3.9175C9.77 3.5375 9.33 3.3675 8.95 3.5375L8.45 3.7575C8.07 3.9275 7.9 4.3675 8.07 4.7475C8.19 5.0275 8.47 5.1975 8.76 5.1975V5.1875ZM12.53 2.4175L12.3 2.3175C12.11 2.2275 11.88 2.2275 11.69 2.3175L11.46 2.4175C11.08 2.5875 10.91 3.0275 11.08 3.4075C11.24 3.7575 11.64 3.9275 11.99 3.8175C12.07 3.8375 12.14 3.8575 12.22 3.8575C12.51 3.8575 12.78 3.6875 12.91 3.4075C13.08 3.0275 12.91 2.5875 12.53 2.4175ZM15.55 3.7575L15.05 3.5375C14.67 3.3675 14.23 3.5375 14.06 3.9175C13.89 4.2975 14.06 4.7375 14.44 4.9075L14.94 5.1275C15.04 5.1675 15.14 5.1875 15.24 5.1875C15.53 5.1875 15.8 5.0175 15.93 4.7375C16.1 4.3575 15.93 3.9175 15.55 3.7475V3.7575ZM17.45 6.2375L17.95 6.4575C18.05 6.4975 18.15 6.5175 18.25 6.5175C18.54 6.5175 18.81 6.3475 18.94 6.0675C19.11 5.6875 18.94 5.2475 18.56 5.0775L18.06 4.8575C17.68 4.6875 17.24 4.8575 17.07 5.2375C16.9 5.6175 17.07 6.0575 17.45 6.2275V6.2375ZM21.7 6.7375C21.7 6.7375 21.68 6.6875 21.67 6.6675C21.64 6.6075 21.6 6.5575 21.56 6.5075C21.55 6.4875 21.53 6.4775 21.52 6.4575C21.46 6.3975 21.39 6.3475 21.31 6.3175L21.08 6.2175C20.7 6.0475 20.26 6.2175 20.09 6.5975C20.03 6.7275 20.01 6.8675 20.03 7.0075C20.01 7.1375 20.03 7.2775 20.09 7.4175C20.17 7.5975 20.31 7.7175 20.47 7.7875C20.61 7.9275 20.79 8.0075 21 8.0075C21.41 8.0075 21.75 7.6675 21.75 7.2575V7.0075C21.75 6.9175 21.73 6.8275 21.7 6.7475V6.7375ZM14.94 8.8675L14.44 9.0875C14.06 9.2575 13.89 9.6975 14.06 10.0775C14.18 10.3575 14.46 10.5275 14.75 10.5275C14.85 10.5275 14.96 10.5075 15.05 10.4675L15.55 10.2475C15.93 10.0775 16.1 9.6375 15.93 9.2575C15.76 8.8775 15.32 8.7075 14.94 8.8775V8.8675ZM17.95 7.5275L17.45 7.7475C17.07 7.9175 16.9 8.3575 17.07 8.7375C17.19 9.0175 17.47 9.1875 17.76 9.1875C17.86 9.1875 17.97 9.1675 18.06 9.1275L18.56 8.9075C18.94 8.7375 19.11 8.2975 18.94 7.9175C18.77 7.5375 18.32 7.3675 17.95 7.5375V7.5275ZM12 10.1775C11.64 10.0675 11.24 10.2375 11.09 10.5875C10.95 10.8975 11.05 11.2475 11.3 11.4575C11.39 11.7675 11.67 11.9975 12.01 11.9975C12.35 11.9975 12.63 11.7675 12.72 11.4575C12.97 11.2475 13.06 10.8975 12.93 10.5875C12.77 10.2375 12.37 10.0675 12.02 10.1775H12ZM9.56 9.0975L9.06 8.8775C8.68 8.7075 8.24 8.8775 8.07 9.2575C7.9 9.6375 8.07 10.0775 8.45 10.2475L8.95 10.4675C9.05 10.5075 9.15 10.5275 9.25 10.5275C9.54 10.5275 9.81 10.3575 9.94 10.0775C10.11 9.6975 9.94 9.2575 9.56 9.0875V9.0975ZM6.55 7.7575L6.05 7.5375C5.67 7.3675 5.23 7.5375 5.06 7.9175C4.89 8.2975 5.06 8.7375 5.44 8.9075L5.94 9.1275C6.04 9.1675 6.14 9.1875 6.24 9.1875C6.53 9.1875 6.8 9.0175 6.93 8.7375C7.1 8.3575 6.93 7.9175 6.55 7.7475V7.7575ZM21 12.6475C20.59 12.6475 20.25 12.9875 20.25 13.3975V13.9575C20.25 14.3675 20.59 14.7075 21 14.7075C21.41 14.7075 21.75 14.3675 21.75 13.9575V13.3975C21.75 12.9875 21.41 12.6475 21 12.6475ZM21 9.2875C20.59 9.2875 20.25 9.6275 20.25 10.0375V10.5975C20.25 11.0075 20.59 11.3475 21 11.3475C21.41 11.3475 21.75 11.0075 21.75 10.5975V10.0375C21.75 9.6275 21.41 9.2875 21 9.2875ZM21 15.9975C20.66 15.9975 20.38 16.2175 20.28 16.5275C20.03 16.7375 19.95 17.0875 20.08 17.3975C20.2 17.6775 20.48 17.8475 20.77 17.8475C20.87 17.8475 20.98 17.8275 21.07 17.7875L21.3 17.6875C21.57 17.5675 21.75 17.2975 21.75 16.9975V16.7475C21.75 16.3375 21.41 15.9975 21 15.9975ZM14.94 18.8675L14.44 19.0875C14.06 19.2575 13.89 19.6975 14.06 20.0775C14.18 20.3575 14.46 20.5275 14.75 20.5275C14.85 20.5275 14.96 20.5075 15.05 20.4675L15.55 20.2475C15.93 20.0775 16.1 19.6375 15.93 19.2575C15.76 18.8775 15.32 18.7075 14.94 18.8775V18.8675ZM17.95 17.5275L17.45 17.7475C17.07 17.9175 16.9 18.3575 17.07 18.7375C17.19 19.0175 17.47 19.1875 17.76 19.1875C17.86 19.1875 17.97 19.1675 18.06 19.1275L18.56 18.9075C18.94 18.7375 19.11 18.2975 18.94 17.9175C18.77 17.5375 18.32 17.3675 17.95 17.5375V17.5275ZM12.51 20.2075C12.38 20.0775 12.2 19.9975 12 19.9975C11.8 19.9975 11.62 20.0775 11.49 20.2075C11.32 20.2775 11.17 20.4075 11.09 20.5975C10.92 20.9775 11.09 21.4175 11.47 21.5875L11.7 21.6875C11.79 21.7275 11.89 21.7475 12 21.7475C12.11 21.7475 12.21 21.7275 12.3 21.6875L12.53 21.5875C12.91 21.4175 13.08 20.9775 12.91 20.5975C12.83 20.4175 12.68 20.2875 12.51 20.2175V20.2075ZM9.56 19.0975L9.06 18.8775C8.68 18.7075 8.24 18.8775 8.07 19.2575C7.9 19.6375 8.07 20.0775 8.45 20.2475L8.95 20.4675C9.05 20.5075 9.15 20.5275 9.25 20.5275C9.54 20.5275 9.81 20.3575 9.94 20.0775C10.11 19.6975 9.94 19.2575 9.56 19.0875V19.0975ZM6.55 17.7575L6.05 17.5375C5.67 17.3675 5.23 17.5375 5.06 17.9175C4.89 18.2975 5.06 18.7375 5.44 18.9075L5.94 19.1275C6.04 19.1675 6.14 19.1875 6.24 19.1875C6.53 19.1875 6.8 19.0175 6.93 18.7375C7.1 18.3575 6.93 17.9175 6.55 17.7475V17.7575ZM3 15.9975C2.59 15.9975 2.25 16.3375 2.25 16.7475V16.9975C2.25 17.2975 2.42 17.5675 2.7 17.6875L2.93 17.7875C3.03 17.8275 3.13 17.8475 3.23 17.8475C3.52 17.8475 3.79 17.6775 3.92 17.3975C4.06 17.0875 3.97 16.7375 3.72 16.5275C3.63 16.2175 3.34 15.9975 3 15.9975ZM3 14.7075C3.41 14.7075 3.75 14.3675 3.75 13.9575V13.3975C3.75 12.9875 3.41 12.6475 3 12.6475C2.59 12.6475 2.25 12.9875 2.25 13.3975V13.9575C2.25 14.3675 2.59 14.7075 3 14.7075ZM3 11.3475C3.41 11.3475 3.75 11.0075 3.75 10.5975V10.0375C3.75 9.6275 3.41 9.2875 3 9.2875C2.59 9.2875 2.25 9.6275 2.25 10.0375V10.5975C2.25 11.0075 2.59 11.3475 3 11.3475ZM3 7.9975C3.21 7.9975 3.39 7.9175 3.53 7.7775C3.69 7.7075 3.84 7.5775 3.91 7.4075C3.97 7.2775 3.99 7.1375 3.97 6.9975C3.99 6.8675 3.97 6.7275 3.91 6.5875C3.74 6.2075 3.29 6.0375 2.92 6.2075L2.69 6.3075C2.61 6.3475 2.54 6.3975 2.48 6.4475C2.46 6.4675 2.45 6.4775 2.44 6.4975C2.4 6.5475 2.36 6.5975 2.33 6.6575C2.32 6.6775 2.31 6.6975 2.3 6.7275C2.27 6.8075 2.25 6.8975 2.25 6.9875V7.2375C2.25 7.6475 2.59 7.9875 3 7.9875V7.9975ZM12 15.3475C12.41 15.3475 12.75 15.0075 12.75 14.5975V14.0375C12.75 13.6275 12.41 13.2875 12 13.2875C11.59 13.2875 11.25 13.6275 11.25 14.0375V14.5975C11.25 15.0075 11.59 15.3475 12 15.3475ZM11.25 17.9575C11.25 18.3675 11.59 18.7075 12 18.7075C12.41 18.7075 12.75 18.3675 12.75 17.9575V17.3975C12.75 16.9875 12.41 16.6475 12 16.6475C11.59 16.6475 11.25 16.9875 11.25 17.3975V17.9575Z"></path></svg>',
  "pg-validation-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 2.25C6.62 2.25 2.25 6.62 2.25 12C2.25 17.38 6.62 21.75 12 21.75C17.38 21.75 21.75 17.38 21.75 12C21.75 6.62 17.38 2.25 12 2.25ZM12 20.25C7.45 20.25 3.75 16.55 3.75 12C3.75 7.45 7.45 3.75 12 3.75C16.55 3.75 20.25 7.45 20.25 12C20.25 16.55 16.55 20.25 12 20.25ZM16.53 8.53L13.06 12L16.53 15.47C16.82 15.76 16.82 16.24 16.53 16.53C16.38 16.68 16.19 16.75 16 16.75C15.81 16.75 15.62 16.68 15.47 16.53L12 13.06L8.53 16.53C8.38 16.68 8.19 16.75 8 16.75C7.81 16.75 7.62 16.68 7.47 16.53C7.18 16.24 7.18 15.76 7.47 15.47L10.94 12L7.47 8.53C7.18 8.24 7.18 7.76 7.47 7.47C7.76 7.18 8.24 7.18 8.53 7.47L12 10.94L15.47 7.47C15.76 7.18 16.24 7.18 16.53 7.47C16.82 7.76 16.82 8.24 16.53 8.53Z"></path></svg>',
  "pg-webservice-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20.75 14.99V15.99C20.75 17.51 19.52 18.74 18 18.74H12.31L8.53 22.52C8.39 22.66 8.2 22.74 8 22.74C7.9 22.74 7.81 22.72 7.71 22.68C7.43 22.56 7.25 22.29 7.25 21.99V18.74H6C4.48 18.74 3.25 17.51 3.25 15.99V5.99C3.25 4.47 4.48 3.24 6 3.24H9C9.41 3.24 9.75 3.58 9.75 3.99C9.75 4.4 9.41 4.74 9 4.74H6C5.31 4.74 4.75 5.3 4.75 5.99V15.99C4.75 16.68 5.31 17.24 6 17.24H8C8.41 17.24 8.75 17.58 8.75 17.99V20.18L11.47 17.46C11.61 17.32 11.8 17.24 12 17.24H18C18.69 17.24 19.25 16.68 19.25 15.99V14.99C19.25 14.58 19.59 14.24 20 14.24C20.41 14.24 20.75 14.58 20.75 14.99ZM10.25 7.99C10.25 6.41 10.89 4.98 11.93 3.94C11.93 3.94 11.93 3.94 11.93 3.93C11.93 3.92 11.93 3.93 11.94 3.93C12.98 2.89 14.41 2.25 15.99 2.25C17.57 2.25 18.94 2.87 19.98 3.87C20.01 3.89 20.03 3.91 20.06 3.94C20.08 3.96 20.1 3.99 20.12 4.01C21.12 5.05 21.74 6.45 21.74 8C21.74 9.55 21.1 11.01 20.06 12.05C20.06 12.05 20.06 12.05 20.06 12.06C20.06 12.07 20.06 12.06 20.05 12.06C19.01 13.1 17.58 13.74 16 13.74C14.42 13.74 13.01 13.11 11.97 12.09C11.96 12.08 11.94 12.07 11.93 12.06C11.91 12.04 11.89 12.01 11.87 11.99C10.87 10.95 10.25 9.55 10.25 8V7.99ZM11.75 7.99C11.75 8.35 11.81 8.7 11.89 9.03C12.27 8.21 12.85 7.37 13.54 6.59L12.51 5.56C12.03 6.25 11.74 7.08 11.74 7.98L11.75 7.99ZM17.79 5.18C17.1 5.48 16.36 5.99 15.66 6.6L17.38 8.32C17.99 7.62 18.5 6.88 18.8 6.19C19.15 5.38 19.04 5.04 19 4.98C19 4.98 18.9 4.92 18.75 4.92C18.56 4.92 18.25 4.97 17.79 5.17V5.18ZM20.11 6.95C19.73 7.77 19.15 8.61 18.46 9.39L19.49 10.42C19.97 9.73 20.26 8.9 20.26 8C20.26 7.64 20.2 7.29 20.12 6.96L20.11 6.95ZM14.61 7.66C14 8.36 13.49 9.1 13.19 9.79C12.84 10.6 12.95 10.94 12.99 11C13.04 11.05 13.39 11.15 14.2 10.8C14.89 10.5 15.63 9.99 16.33 9.38L14.61 7.66ZM16 12.24C16.9 12.24 17.73 11.95 18.42 11.47L17.39 10.44C16.61 11.14 15.77 11.71 14.95 12.09C15.28 12.17 15.63 12.23 15.99 12.23L16 12.24ZM16 3.74C15.1 3.74 14.27 4.03 13.58 4.51L14.61 5.54C15.39 4.84 16.23 4.27 17.05 3.89C16.72 3.81 16.37 3.75 16.01 3.75L16 3.74Z"></path></svg>',
  "phone-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M15 3.25H9C7.48 3.25 6.25 4.48 6.25 6V18C6.25 19.52 7.48 20.75 9 20.75H15C16.52 20.75 17.75 19.52 17.75 18V6C17.75 4.48 16.52 3.25 15 3.25ZM16.25 18C16.25 18.69 15.69 19.25 15 19.25H9C8.31 19.25 7.75 18.69 7.75 18V6C7.75 5.31 8.31 4.75 9 4.75H15C15.69 4.75 16.25 5.31 16.25 6V18ZM13.75 6C13.75 6.41 13.41 6.75 13 6.75H11C10.59 6.75 10.25 6.41 10.25 6C10.25 5.59 10.59 5.25 11 5.25H13C13.41 5.25 13.75 5.59 13.75 6Z"></path></svg>',
  "plus-32x32": '<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><path d="M30 16H17V3H16V16H3V17H16V30H17V17H30V16Z"></path></svg>',
  "plusbox-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M10.75 8C10.75 8.41 10.41 8.75 10 8.75H8.75V10C8.75 10.41 8.41 10.75 8 10.75C7.59 10.75 7.25 10.41 7.25 10V8.75H6C5.59 8.75 5.25 8.41 5.25 8C5.25 7.59 5.59 7.25 6 7.25H7.25V6C7.25 5.59 7.59 5.25 8 5.25C8.41 5.25 8.75 5.59 8.75 6V7.25H10C10.41 7.25 10.75 7.59 10.75 8ZM13.75 4V12C13.75 12.96 12.96 13.75 12 13.75H4C3.04 13.75 2.25 12.96 2.25 12V4C2.25 3.04 3.04 2.25 4 2.25H12C12.96 2.25 13.75 3.04 13.75 4ZM12.25 4C12.25 3.86 12.14 3.75 12 3.75H4C3.86 3.75 3.75 3.86 3.75 4V12C3.75 12.14 3.86 12.25 4 12.25H12C12.14 12.25 12.25 12.14 12.25 12V4Z"></path></svg>',
  "preview-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 2.25C6.62 2.25 2.25 6.62 2.25 12C2.25 17.38 6.62 21.75 12 21.75C17.38 21.75 21.75 17.38 21.75 12C21.75 6.62 17.38 2.25 12 2.25ZM12 20.25C7.45 20.25 3.75 16.55 3.75 12C3.75 7.45 7.45 3.75 12 3.75C16.55 3.75 20.25 7.45 20.25 12C20.25 16.55 16.55 20.25 12 20.25ZM15.17 10.54L11.97 8.41C11.43 8.05 10.74 8.02 10.17 8.32C9.6 8.62 9.25 9.22 9.25 9.86V14.12C9.25 14.77 9.6 15.36 10.17 15.66C10.43 15.8 10.71 15.87 11 15.87C11.34 15.87 11.68 15.77 11.97 15.58L15.17 13.45C15.66 13.12 15.95 12.58 15.95 11.99C15.95 11.4 15.66 10.86 15.17 10.53V10.54ZM14.34 12.21L11.14 14.34C11.03 14.41 10.93 14.38 10.88 14.35C10.83 14.32 10.75 14.26 10.75 14.13V9.87C10.75 9.74 10.83 9.68 10.88 9.65C10.91 9.64 10.95 9.62 11 9.62C11.04 9.62 11.09 9.63 11.14 9.66L14.34 11.79C14.44 11.85 14.45 11.95 14.45 12C14.45 12.05 14.44 12.14 14.34 12.21Z"></path></svg>',
  "publish-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M16.74 21.18C16.66 21.52 16.35 21.75 16.01 21.75C15.95 21.75 15.89 21.75 15.83 21.73C11.3 20.6 10.63 16.96 10.98 13.09L9.54 14.53C9.25 14.82 8.77 14.82 8.48 14.53C8.19 14.24 8.19 13.76 8.48 13.47L11.48 10.47C11.48 10.47 11.52 10.45 11.53 10.44C11.57 10.41 11.61 10.38 11.65 10.36C11.69 10.34 11.73 10.32 11.78 10.3C11.83 10.29 11.87 10.28 11.92 10.27C11.97 10.27 12.02 10.27 12.07 10.27C12.09 10.27 12.11 10.27 12.13 10.27C12.16 10.27 12.18 10.29 12.21 10.3C12.26 10.31 12.3 10.33 12.35 10.35C12.4 10.37 12.44 10.4 12.48 10.44C12.5 10.46 12.53 10.46 12.54 10.48L15.54 13.48C15.83 13.77 15.83 14.25 15.54 14.54C15.39 14.69 15.2 14.76 15.01 14.76C14.82 14.76 14.63 14.69 14.48 14.54L12.54 12.6C11.91 18.02 13.48 19.6 16.19 20.28C16.59 20.38 16.84 20.79 16.74 21.19V21.18ZM18.6 7.29C18.05 4.94 15.96 3.25 13.51 3.25C11.06 3.25 8.99 4.92 8.43 7.25C6.2 7.29 4.39 9.05 4.26 11.26C2.68 11.12 1.25 12.4 1.25 14C1.25 15.52 2.48 16.75 4 16.75C4.41 16.75 4.75 16.41 4.75 16C4.75 15.59 4.41 15.25 4 15.25C3.31 15.25 2.75 14.69 2.75 14C2.75 13.31 3.31 12.75 4 12.75C4.25 12.75 4.49 12.82 4.7 12.96C4.96 13.13 5.29 13.13 5.55 12.96C5.8 12.78 5.92 12.47 5.85 12.17C5.79 11.92 5.76 11.71 5.76 11.51C5.76 9.99 6.99 8.76 8.51 8.76C8.66 8.76 8.8 8.78 8.94 8.81C9.14 8.84 9.35 8.79 9.52 8.66C9.68 8.53 9.79 8.35 9.81 8.14C10 6.21 11.6 4.76 13.52 4.76C15.44 4.76 17.01 6.19 17.23 8.1C17.27 8.48 17.64 8.76 18.02 8.76C19.81 8.76 21.27 10.22 21.27 12.01C21.27 13.8 19.81 15.26 18.02 15.26C17.61 15.26 17.27 15.6 17.27 16.01C17.27 16.42 17.61 16.76 18.02 16.76C20.64 16.76 22.77 14.63 22.77 12.01C22.77 9.6 20.97 7.61 18.61 7.3L18.6 7.29Z"></path></svg>',
  "questionlock-24x24": '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M11.75 18C11.75 18.41 11.41 18.75 11 18.75H10.31L7.53 21.53C7.39 21.67 7.2 21.75 7 21.75C6.9 21.75 6.81 21.73 6.71 21.69C6.43 21.57 6.25 21.3 6.25 21V18.75H5C3.48 18.75 2.25 17.52 2.25 16V5C2.25 3.48 3.48 2.25 5 2.25H18C19.52 2.25 20.75 3.48 20.75 5V6C20.75 6.41 20.41 6.75 20 6.75C19.59 6.75 19.25 6.41 19.25 6V5C19.25 4.31 18.69 3.75 18 3.75H5C4.31 3.75 3.75 4.31 3.75 5V16C3.75 16.69 4.31 17.25 5 17.25H7C7.41 17.25 7.75 17.59 7.75 18V19.19L9.47 17.47C9.61 17.33 9.8 17.25 10 17.25H11C11.41 17.25 11.75 17.59 11.75 18ZM22.75 14V19C22.75 20.52 21.52 21.75 20 21.75H16C14.48 21.75 13.25 20.52 13.25 19V14C13.25 13.59 13.59 13.25 14 13.25H14.25V12C14.25 9.93 15.93 8.25 18 8.25C20.07 8.25 21.75 9.93 21.75 12V13.25H22C22.41 13.25 22.75 13.59 22.75 14ZM15.75 13.25H20.25V12C20.25 10.76 19.24 9.75 18 9.75C16.76 9.75 15.75 10.76 15.75 12V13.25ZM21.25 14.75H14.75V19C14.75 19.69 15.31 20.25 16 20.25H20C20.69 20.25 21.25 19.69 21.25 19V14.75ZM18 16.25C17.59 16.25 17.25 16.59 17.25 17V18C17.25 18.41 17.59 18.75 18 18.75C18.41 18.75 18.75 18.41 18.75 18V17C18.75 16.59 18.41 16.25 18 16.25Z"></path></svg>',
  "ranking-arrows": '<svg viewBox="0 0 10 24" xmlns="http://www.w3.org/2000/svg"><path d="M10 5L5 0L0 5H4V9H6V5H10Z"></path><path d="M6 19V15H4V19H0L5 24L10 19H6Z"></path></svg>',
  "rankingundefined-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M11.75 8C11.75 8.41 11.41 8.75 11 8.75H5C4.59 8.75 4.25 8.41 4.25 8C4.25 7.59 4.59 7.25 5 7.25H11C11.41 7.25 11.75 7.59 11.75 8Z"></path></svg>',
  "redo-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M21.7067 11.2425C21.7067 11.2425 21.6867 11.2725 21.6767 11.2925C21.6767 11.3125 21.6767 11.3225 21.6667 11.3425C21.6567 11.3725 21.6267 11.3925 21.6067 11.4125C21.5767 11.4525 21.5467 11.4925 21.5167 11.5325C21.4867 11.5625 21.4467 11.5925 21.4067 11.6225C21.3767 11.6425 21.3567 11.6625 21.3367 11.6825L15.3067 14.6825C15.1967 14.7325 15.0867 14.7625 14.9767 14.7625C14.6967 14.7625 14.4367 14.6125 14.3067 14.3425C14.1267 13.9725 14.2767 13.5225 14.6467 13.3325L19.2767 11.0325C13.7467 8.64247 8.45669 8.45247 6.06669 10.6625C4.07669 12.5025 4.72669 15.5225 5.61669 17.7325C5.76669 18.1125 5.58669 18.5525 5.19669 18.7125C5.10669 18.7525 5.00669 18.7625 4.91669 18.7625C4.61669 18.7625 4.33669 18.5825 4.21669 18.2925C2.27669 13.4825 3.58669 10.8825 5.03669 9.55247C7.81669 6.98247 13.4167 7.00247 19.3767 9.45247L17.3067 5.34247C17.1167 4.97247 17.2667 4.52247 17.6367 4.33247C18.0067 4.14247 18.4567 4.29247 18.6467 4.66247L21.6667 10.6625C21.6667 10.6625 21.6667 10.6925 21.6767 10.7125C21.6967 10.7625 21.7067 10.8125 21.7167 10.8625C21.7167 10.9025 21.7367 10.9525 21.7367 10.9925C21.7367 11.0425 21.7367 11.0925 21.7167 11.1425C21.7167 11.1725 21.7167 11.2125 21.7067 11.2425Z"></path></svg>',
  "refresh-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M2 8.75C1.59 8.75 1.25 8.41 1.25 8C1.25 4.28 4.28 1.25 8 1.25C9.69 1.25 11.3 1.89 12.53 3.01L12.69 1.89C12.75 1.48 13.13 1.2 13.54 1.26C13.95 1.32 14.23 1.7 14.17 2.11L13.73 5.11C13.68 5.48 13.36 5.75 12.99 5.75H9.99C9.58 5.75 9.24 5.41 9.24 5C9.24 4.59 9.58 4.25 9.99 4.25H11.66C10.68 3.29 9.37 2.75 7.99 2.75C5.11 2.75 2.75 5.11 2.75 8C2.75 8.41 2.41 8.75 2 8.75ZM14 7.25C13.59 7.25 13.25 7.59 13.25 8C13.25 10.9 10.89 13.25 8 13.25C6.62 13.25 5.31 12.71 4.33 11.75H6C6.41 11.75 6.75 11.41 6.75 11C6.75 10.59 6.41 10.25 6 10.25H3C2.63 10.25 2.31 10.52 2.26 10.89L1.8 13.89C1.74 14.3 2.02 14.68 2.43 14.74C2.47 14.74 2.51 14.74 2.54 14.74C2.9 14.74 3.22 14.47 3.28 14.1L3.45 12.97C4.69 14.1 6.3 14.74 7.99 14.74C11.71 14.74 14.74 11.71 14.74 7.99C14.74 7.58 14.4 7.24 13.99 7.24L14 7.25Z"></path></svg>',
  "remove-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M8 1.25C4.28 1.25 1.25 4.28 1.25 8C1.25 11.72 4.28 14.75 8 14.75C11.72 14.75 14.75 11.72 14.75 8C14.75 4.28 11.72 1.25 8 1.25ZM8 13.25C5.11 13.25 2.75 10.89 2.75 8C2.75 5.11 5.11 2.75 8 2.75C10.89 2.75 13.25 5.11 13.25 8C13.25 10.89 10.89 13.25 8 13.25ZM10.75 8C10.75 8.41 10.41 8.75 10 8.75H6C5.59 8.75 5.25 8.41 5.25 8C5.25 7.59 5.59 7.25 6 7.25H10C10.41 7.25 10.75 7.59 10.75 8Z"></path></svg>',
  "reorder-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M8.9444 10.75H15.0544C15.7144 10.75 16.3144 10.39 16.6144 9.80002C16.9144 9.22002 16.8644 8.52002 16.4844 7.98002L13.4244 3.71002C12.7644 2.79002 11.2344 2.79002 10.5744 3.71002L7.5244 7.99002C7.1444 8.53002 7.0944 9.22002 7.3944 9.81002C7.6944 10.4 8.2944 10.76 8.9544 10.76L8.9444 10.75ZM8.7444 8.86002L11.7944 4.58002C11.8644 4.49002 11.9544 4.48002 11.9944 4.48002C12.0344 4.48002 12.1344 4.49002 12.1944 4.58002L15.2544 8.86002C15.3344 8.97002 15.3044 9.07002 15.2744 9.12002C15.2444 9.17002 15.1844 9.26002 15.0544 9.26002H8.9444C8.8144 9.26002 8.7444 9.18002 8.7244 9.12002C8.7044 9.06002 8.6644 8.97002 8.7444 8.86002ZM15.0544 13.25H8.9444C8.2844 13.25 7.6844 13.61 7.3844 14.2C7.0844 14.78 7.1344 15.48 7.5144 16.02L10.5744 20.3C10.9044 20.76 11.4344 21.03 11.9944 21.03C12.5544 21.03 13.0944 20.76 13.4144 20.3L16.4744 16.02C16.8544 15.48 16.9044 14.79 16.6044 14.2C16.3044 13.61 15.7044 13.25 15.0444 13.25H15.0544ZM15.2644 15.15L12.2044 19.43C12.0744 19.61 11.9244 19.61 11.7944 19.43L8.7344 15.15C8.6544 15.04 8.6844 14.94 8.7144 14.89C8.7444 14.84 8.8044 14.75 8.9344 14.75H15.0444C15.1744 14.75 15.2444 14.83 15.2644 14.89C15.2844 14.95 15.3244 15.04 15.2444 15.15H15.2644Z"></path></svg>',
  "required-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.75 8C14.75 8.41 14.41 8.75 14 8.75H9.81L12.53 11.47C12.82 11.76 12.82 12.24 12.53 12.53C12.38 12.68 12.19 12.75 12 12.75C11.81 12.75 11.62 12.68 11.47 12.53L8.75 9.81V14C8.75 14.41 8.41 14.75 8 14.75C7.59 14.75 7.25 14.41 7.25 14V9.81L4.53 12.53C4.38 12.68 4.19 12.75 4 12.75C3.81 12.75 3.62 12.68 3.47 12.53C3.18 12.24 3.18 11.76 3.47 11.47L6.19 8.75H2C1.59 8.75 1.25 8.41 1.25 8C1.25 7.59 1.59 7.25 2 7.25H6.19L3.47 4.53C3.18 4.24 3.18 3.76 3.47 3.47C3.76 3.18 4.24 3.18 4.53 3.47L7.25 6.19V2C7.25 1.59 7.59 1.25 8 1.25C8.41 1.25 8.75 1.59 8.75 2V6.19L11.47 3.47C11.76 3.18 12.24 3.18 12.53 3.47C12.82 3.76 12.82 4.24 12.53 4.53L9.81 7.25H14C14.41 7.25 14.75 7.59 14.75 8Z"></path></svg>',
  "restore-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20.752 12.0003C20.752 16.8303 16.832 20.7503 12.002 20.7503C10.832 20.7503 9.69203 20.5203 8.61203 20.0703C7.35203 19.5403 6.21203 18.7003 5.32203 17.6503C4.73203 16.9603 4.26203 16.1903 3.91203 15.3503C3.75203 14.9703 3.93203 14.5303 4.31203 14.3703C4.70203 14.2103 5.13203 14.3903 5.29203 14.7703C5.58203 15.4603 5.97203 16.1003 6.46203 16.6803C7.20203 17.5503 8.14203 18.2403 9.19203 18.6803C10.082 19.0503 11.022 19.2403 12.002 19.2403C16.002 19.2403 19.252 15.9903 19.252 11.9903C19.252 7.99028 16.002 4.75028 12.002 4.75028C9.67203 4.75028 7.48203 5.88028 6.12203 7.77028L9.35203 7.80028C9.76203 7.80028 10.102 8.14028 10.092 8.56028C10.092 8.97028 9.75203 9.30028 9.34203 9.30028L4.40203 9.25028C4.01203 9.25028 3.69203 8.95028 3.66203 8.56028L3.27203 3.65028C3.24203 3.23028 3.55203 2.87028 3.96203 2.84028C4.37203 2.83028 4.73203 3.12028 4.77203 3.53028L5.02203 6.74028C6.67203 4.55028 9.25203 3.25028 12.002 3.25028C16.832 3.25028 20.752 7.17028 20.752 12.0003Z"></path></svg>',
  "restoredown-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M7.69 8.71C7.73 8.8 7.75 8.9 7.75 9V13C7.75 13.41 7.41 13.75 7 13.75C6.59 13.75 6.25 13.41 6.25 13V10.81L3.53 13.53C3.38 13.68 3.19 13.75 3 13.75C2.81 13.75 2.62 13.68 2.47 13.53C2.18 13.24 2.18 12.76 2.47 12.47L5.19 9.75H3C2.59 9.75 2.25 9.41 2.25 9C2.25 8.59 2.59 8.25 3 8.25H7C7.1 8.25 7.19 8.27 7.29 8.31C7.47 8.39 7.62 8.53 7.7 8.72L7.69 8.71ZM13 6.25H10.81L13.53 3.53C13.82 3.24 13.82 2.76 13.53 2.47C13.24 2.18 12.76 2.18 12.47 2.47L9.75 5.19V3C9.75 2.59 9.41 2.25 9 2.25C8.59 2.25 8.25 2.59 8.25 3V7C8.25 7.1 8.27 7.19 8.31 7.29C8.39 7.47 8.53 7.62 8.72 7.7C8.81 7.74 8.91 7.76 9.01 7.76H13.01C13.42 7.76 13.76 7.42 13.76 7.01C13.76 6.6 13.42 6.26 13.01 6.26L13 6.25Z"></path></svg>',
  "rotate-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M17.75 13.9975V9.9975C17.75 8.4775 16.52 7.2475 15 7.2475H9C7.48 7.2475 6.25 8.4775 6.25 9.9975V13.9975C6.25 15.5175 7.48 16.7475 9 16.7475H15C16.52 16.7475 17.75 15.5175 17.75 13.9975ZM7.75 13.9975V9.9975C7.75 9.3075 8.31 8.7475 9 8.7475H15C15.69 8.7475 16.25 9.3075 16.25 9.9975V13.9975C16.25 14.6875 15.69 15.2475 15 15.2475H9C8.31 15.2475 7.75 14.6875 7.75 13.9975ZM8 4.7475C5.66 4.7475 3.75 6.6575 3.75 8.9975C3.75 9.4075 3.41 9.7475 3 9.7475C2.59 9.7475 2.25 9.4075 2.25 8.9975C2.25 5.8275 4.83 3.2475 8 3.2475H8.19L7.47 2.5275C7.18 2.2375 7.18 1.7575 7.47 1.4675C7.76 1.1775 8.24 1.1775 8.53 1.4675L10.53 3.4675C10.6 3.5375 10.65 3.6175 10.69 3.7075C10.77 3.8875 10.77 4.0975 10.69 4.2775C10.61 4.4575 10.47 4.6075 10.28 4.6875C10.19 4.7275 10.09 4.7475 9.99 4.7475H7.99H8ZM16 20.7475H15.81L16.53 21.4675C16.82 21.7575 16.82 22.2375 16.53 22.5275C16.38 22.6775 16.19 22.7475 16 22.7475C15.81 22.7475 15.62 22.6775 15.47 22.5275L13.47 20.5275C13.4 20.4575 13.35 20.3775 13.31 20.2875C13.23 20.1075 13.23 19.8975 13.31 19.7175C13.39 19.5375 13.53 19.3875 13.72 19.3075C13.81 19.2675 13.91 19.2475 14.01 19.2475H16.01C18.35 19.2475 20.26 17.3375 20.26 14.9975C20.26 14.5875 20.6 14.2475 21.01 14.2475C21.42 14.2475 21.76 14.5875 21.76 14.9975C21.76 18.1675 19.18 20.7475 16.01 20.7475H16Z"></path></svg>',
  "save-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M18 3.25H6.83C6.1 3.25 5.41 3.54 4.89 4.06L4.06 4.89C3.54 5.41 3.25 6.1 3.25 6.83V18C3.25 19.52 4.48 20.75 6 20.75H18C19.52 20.75 20.75 19.52 20.75 18V6C20.75 4.48 19.52 3.25 18 3.25ZM9.75 4.75H14.25V7C14.25 7.14 14.14 7.25 14 7.25H10C9.86 7.25 9.75 7.14 9.75 7V4.75ZM19.25 18C19.25 18.69 18.69 19.25 18 19.25H6C5.31 19.25 4.75 18.69 4.75 18V6.83C4.75 6.5 4.88 6.18 5.12 5.95L5.95 5.12C6.18 4.89 6.5 4.75 6.83 4.75H8.25V7C8.25 7.96 9.04 8.75 10 8.75H14C14.96 8.75 15.75 7.96 15.75 7V4.75H18C18.69 4.75 19.25 5.31 19.25 6V18ZM12 10.25C10.48 10.25 9.25 11.48 9.25 13C9.25 14.52 10.48 15.75 12 15.75C13.52 15.75 14.75 14.52 14.75 13C14.75 11.48 13.52 10.25 12 10.25ZM12 14.25C11.31 14.25 10.75 13.69 10.75 13C10.75 12.31 11.31 11.75 12 11.75C12.69 11.75 13.25 12.31 13.25 13C13.25 13.69 12.69 14.25 12 14.25Z"></path></svg>',
  "saveas-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20 17.25C19.59 17.25 19.25 17.59 19.25 18C19.25 18.69 18.69 19.25 18 19.25H6C5.31 19.25 4.75 18.69 4.75 18V6.83C4.75 6.5 4.88 6.18 5.12 5.95L5.95 5.12C6.18 4.89 6.5 4.75 6.83 4.75H8.25V7C8.25 7.96 9.04 8.75 10 8.75H14C14.96 8.75 15.75 7.96 15.75 7V4.75H18C18.69 4.75 19.25 5.31 19.25 6V8C19.25 8.41 19.59 8.75 20 8.75C20.41 8.75 20.75 8.41 20.75 8V6C20.75 4.48 19.52 3.25 18 3.25H6.83C6.1 3.25 5.41 3.54 4.89 4.06L4.06 4.89C3.54 5.41 3.25 6.1 3.25 6.83V18C3.25 19.52 4.48 20.75 6 20.75H18C19.52 20.75 20.75 19.52 20.75 18C20.75 17.59 20.41 17.25 20 17.25ZM14.25 7C14.25 7.14 14.14 7.25 14 7.25H10C9.86 7.25 9.75 7.14 9.75 7V4.75H14.25V7ZM12 10.25C10.48 10.25 9.25 11.48 9.25 13C9.25 14.52 10.48 15.75 12 15.75C13.52 15.75 14.75 14.52 14.75 13C14.75 11.48 13.52 10.25 12 10.25ZM12 14.25C11.31 14.25 10.75 13.69 10.75 13C10.75 12.31 11.31 11.75 12 11.75C12.69 11.75 13.25 12.31 13.25 13C13.25 13.69 12.69 14.25 12 14.25ZM22.75 13C22.75 13.41 22.41 13.75 22 13.75H20.75V15C20.75 15.41 20.41 15.75 20 15.75C19.59 15.75 19.25 15.41 19.25 15V13.75H18C17.59 13.75 17.25 13.41 17.25 13C17.25 12.59 17.59 12.25 18 12.25H19.25V11C19.25 10.59 19.59 10.25 20 10.25C20.41 10.25 20.75 10.59 20.75 11V12.25H22C22.41 12.25 22.75 12.59 22.75 13Z"></path></svg>',
  "search-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M13.9975 2.25C9.7275 2.25 6.2475 5.73 6.2475 10C6.2475 11.87 6.9075 13.58 8.0175 14.92L2.4675 20.47C2.1775 20.76 2.1775 21.24 2.4675 21.53C2.6175 21.68 2.8075 21.75 2.9975 21.75C3.1875 21.75 3.3775 21.68 3.5275 21.53L9.0775 15.98C10.4175 17.08 12.1275 17.75 13.9975 17.75C18.2675 17.75 21.7475 14.27 21.7475 10C21.7475 5.73 18.2675 2.25 13.9975 2.25ZM13.9975 16.25C10.5475 16.25 7.7475 13.45 7.7475 10C7.7475 6.55 10.5475 3.75 13.9975 3.75C17.4475 3.75 20.2475 6.55 20.2475 10C20.2475 13.45 17.4475 16.25 13.9975 16.25Z"></path></svg>',
  "selectpage-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M13 7.25H6C4.48 7.25 3.25 8.48 3.25 10V19C3.25 20.52 4.48 21.75 6 21.75H13C14.52 21.75 15.75 20.52 15.75 19V10C15.75 8.48 14.52 7.25 13 7.25ZM14.25 19C14.25 19.69 13.69 20.25 13 20.25H6C5.31 20.25 4.75 19.69 4.75 19V10C4.75 9.31 5.31 8.75 6 8.75H13C13.69 8.75 14.25 9.31 14.25 10V19ZM20.75 5V14C20.75 15.52 19.52 16.75 18 16.75C17.59 16.75 17.25 16.41 17.25 16C17.25 15.59 17.59 15.25 18 15.25C18.69 15.25 19.25 14.69 19.25 14V5C19.25 4.31 18.69 3.75 18 3.75H11C10.31 3.75 9.75 4.31 9.75 5C9.75 5.41 9.41 5.75 9 5.75C8.59 5.75 8.25 5.41 8.25 5C8.25 3.48 9.48 2.25 11 2.25H18C19.52 2.25 20.75 3.48 20.75 5ZM9.75 11C9.75 11.41 9.41 11.75 9 11.75H7C6.59 11.75 6.25 11.41 6.25 11C6.25 10.59 6.59 10.25 7 10.25H9C9.41 10.25 9.75 10.59 9.75 11Z"></path></svg>',
  "settings-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14 10.25H12.63C12.3 9.1 11.25 8.25 10 8.25C8.75 8.25 7.7 9.1 7.37 10.25H2C1.59 10.25 1.25 10.59 1.25 11C1.25 11.41 1.59 11.75 2 11.75H7.37C7.7 12.9 8.75 13.75 10 13.75C11.25 13.75 12.3 12.9 12.63 11.75H14C14.41 11.75 14.75 11.41 14.75 11C14.75 10.59 14.41 10.25 14 10.25ZM10 12.25C9.31 12.25 8.75 11.69 8.75 11C8.75 10.31 9.31 9.75 10 9.75C10.69 9.75 11.25 10.31 11.25 11C11.25 11.69 10.69 12.25 10 12.25ZM2 5.75H3.37C3.7 6.9 4.75 7.75 6 7.75C7.25 7.75 8.3 6.9 8.63 5.75H14C14.41 5.75 14.75 5.41 14.75 5C14.75 4.59 14.41 4.25 14 4.25H8.63C8.3 3.1 7.25 2.25 6 2.25C4.75 2.25 3.7 3.1 3.37 4.25H2C1.59 4.25 1.25 4.59 1.25 5C1.25 5.41 1.59 5.75 2 5.75ZM6 3.75C6.69 3.75 7.25 4.31 7.25 5C7.25 5.69 6.69 6.25 6 6.25C5.31 6.25 4.75 5.69 4.75 5C4.75 4.31 5.31 3.75 6 3.75Z"></path></svg>',
  "settings-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M3 6.75H5.37C5.7 7.9 6.75 8.75 8 8.75C9.25 8.75 10.3 7.9 10.63 6.75H21C21.41 6.75 21.75 6.41 21.75 6C21.75 5.59 21.41 5.25 21 5.25H10.63C10.3 4.1 9.25 3.25 8 3.25C6.75 3.25 5.7 4.1 5.37 5.25H3C2.59 5.25 2.25 5.59 2.25 6C2.25 6.41 2.59 6.75 3 6.75ZM8 4.75C8.69 4.75 9.25 5.31 9.25 6C9.25 6.69 8.69 7.25 8 7.25C7.31 7.25 6.75 6.69 6.75 6C6.75 5.31 7.31 4.75 8 4.75ZM21 11.25H18.63C18.3 10.1 17.25 9.25 16 9.25C14.75 9.25 13.7 10.1 13.37 11.25H3C2.59 11.25 2.25 11.59 2.25 12C2.25 12.41 2.59 12.75 3 12.75H13.37C13.7 13.9 14.75 14.75 16 14.75C17.25 14.75 18.3 13.9 18.63 12.75H21C21.41 12.75 21.75 12.41 21.75 12C21.75 11.59 21.41 11.25 21 11.25ZM16 13.25C15.31 13.25 14.75 12.69 14.75 12C14.75 11.31 15.31 10.75 16 10.75C16.69 10.75 17.25 11.31 17.25 12C17.25 12.69 16.69 13.25 16 13.25ZM21 17.25H10.63C10.3 16.1 9.25 15.25 8 15.25C6.75 15.25 5.7 16.1 5.37 17.25H3C2.59 17.25 2.25 17.59 2.25 18C2.25 18.41 2.59 18.75 3 18.75H5.37C5.7 19.9 6.75 20.75 8 20.75C9.25 20.75 10.3 19.9 10.63 18.75H21C21.41 18.75 21.75 18.41 21.75 18C21.75 17.59 21.41 17.25 21 17.25ZM8 19.25C7.31 19.25 6.75 18.69 6.75 18C6.75 17.31 7.31 16.75 8 16.75C8.69 16.75 9.25 17.31 9.25 18C9.25 18.69 8.69 19.25 8 19.25Z"></path></svg>',
  "smile-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_22171_138835)"><path d="M23.9966 14.16C22.8663 20.95 17.1547 24 12.0033 24C6.85193 24 1.15039 20.96 0.0100771 14.16C-0.0799473 13.62 0.290153 13.1 0.830299 13.01C1.37045 12.91 1.89059 13.29 1.98061 13.83C2.92087 19.47 7.69216 21.99 11.9933 21.99C16.2945 21.99 21.0658 19.47 22.006 13.83C22.0961 13.29 22.6162 12.91 23.1564 13.01C23.6965 13.1 24.0666 13.62 23.9766 14.16H23.9966ZM7.00197 7C7.55212 7 8.00224 6.55 8.00224 6V2C8.00224 1.45 7.55212 1 7.00197 1C6.45182 1 6.0017 1.45 6.0017 2V6C6.0017 6.55 6.45182 7 7.00197 7ZM17.0047 7C17.5548 7 18.005 6.55 18.005 6V2C18.005 1.45 17.5548 1 17.0047 1C16.4545 1 16.0044 1.45 16.0044 2V6C16.0044 6.55 16.4545 7 17.0047 7Z"></path></g><defs><clipPath id="clip0_22171_138835"><rect width="24" height="24" fill="white"></rect></clipPath></defs></svg>',
  "smiley-rate0-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M13.4101 12L22.7101 2.71C23.1001 2.32 23.1001 1.69 22.7101 1.3C22.3201 0.909998 21.6901 0.909998 21.3001 1.3L12.0101 10.59L2.71006 1.29C2.32006 0.899998 1.68006 0.899998 1.29006 1.29C0.900059 1.68 0.900059 2.32 1.29006 2.71L10.5801 12L1.29006 21.29C0.900059 21.68 0.900059 22.31 1.29006 22.7C1.49006 22.9 1.74006 22.99 2.00006 22.99C2.26006 22.99 2.51006 22.89 2.71006 22.7L12.0001 13.41L21.2901 22.7C21.4901 22.9 21.7401 22.99 22.0001 22.99C22.2601 22.99 22.5101 22.89 22.7101 22.7C23.1001 22.31 23.1001 21.68 22.7101 21.29L13.4201 12H13.4101Z"></path></svg>',
  "smiley-rate1-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M4 4.9938C4 4.44362 4.45 3.99348 5 3.99348H6.59L5.3 2.70306C4.91 2.31293 4.91 1.68272 5.3 1.2926C5.69 0.902468 6.32 0.902468 6.71 1.2926L9.71 4.29357C9.8 4.3836 9.88 4.49364 9.93 4.62368C10.03 4.86376 10.03 5.14385 9.93 5.38393C9.88 5.50397 9.81 5.614 9.71 5.71404L6.71 8.71501C6.51 8.91508 6.26 9.00511 6 9.00511C5.74 9.00511 5.49 8.90508 5.29 8.71501C4.9 8.32489 4.9 7.69468 5.29 7.30456L6.58 6.01413H4.99C4.44 6.01413 3.99 5.56399 3.99 5.01381L4 4.9938ZM14.08 5.37393C14.13 5.49397 14.2 5.604 14.3 5.70403L17.3 8.70501C17.5 8.90508 17.75 8.99511 18.01 8.99511C18.27 8.99511 18.52 8.89507 18.72 8.70501C19.11 8.31488 19.11 7.68468 18.72 7.29455L17.43 6.00413H19.02C19.57 6.00413 20.02 5.55399 20.02 5.00381C20.02 4.45363 19.57 4.00348 19.02 4.00348H17.43L18.72 2.71306C19.11 2.32293 19.11 1.69273 18.72 1.3026C18.33 0.912471 17.7 0.912471 17.31 1.3026L14.31 4.30358C14.22 4.39361 14.14 4.50364 14.09 4.63368C13.99 4.87376 13.99 5.15385 14.09 5.39393L14.08 5.37393ZM22 14.9971V20.999C22 22.6496 20.65 24 19 24H5C3.35 24 2 22.6496 2 20.999V14.9971C2 13.3465 3.35 11.9961 5 11.9961H19C20.65 11.9961 22 13.3465 22 14.9971ZM19 13.9967H16V16.9977H20V14.9971C20 14.4469 19.55 13.9967 19 13.9967ZM14 16.9977V13.9967H10V16.9977H14ZM10 18.9984V21.9993H14V18.9984H10ZM4 14.9971V16.9977H8V13.9967H5C4.45 13.9967 4 14.4469 4 14.9971ZM5 21.9993H8V18.9984H4V20.999C4 21.5492 4.45 21.9993 5 21.9993ZM20 20.999V18.9984H16V21.9993H19C19.55 21.9993 20 21.5492 20 20.999Z"></path></svg>',
  "smiley-rate10-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12.01 23C6.85721 23 1.15412 19.9621 0.0134987 13.1669C-0.0765501 12.6272 0.293651 12.1076 0.833944 12.0177C1.38424 11.9277 1.89452 12.2975 1.98457 12.8371C2.92508 18.4732 7.69767 20.9914 12 20.9914C16.3023 20.9914 21.0749 18.4732 22.0154 12.8371C22.1055 12.2975 22.6158 11.9277 23.1661 12.0177C23.7063 12.1076 24.0765 12.6272 23.9865 13.1669C22.8559 19.9521 17.1428 23 11.99 23H12.01ZM21.165 6.15177C22.3056 5.01257 22.3056 3.16386 21.165 2.02465L21.0049 1.85477C19.9143 0.765533 18.1633 0.725561 17.0227 1.71487C15.8821 0.715568 14.1312 0.765533 13.0406 1.85477L12.8705 2.01466C11.7299 3.15386 11.7299 5.00257 12.8705 6.14178L17.0227 10.2889L21.175 6.14178L21.165 6.15177ZM15.742 3.27378L17.0127 4.54289L18.2834 3.27378C18.6436 2.91403 19.2239 2.91403 19.5841 3.27378L19.7442 3.43367C20.1044 3.79342 20.1044 4.37301 19.7442 4.73276L17.0127 7.46086L14.2812 4.73276C13.921 4.37301 13.921 3.79342 14.2812 3.43367L14.4413 3.27378C14.6214 3.09391 14.8515 3.00397 15.0917 3.00397C15.3318 3.00397 15.5619 3.09391 15.742 3.27378ZM11.1595 6.15177C12.3002 5.01257 12.3002 3.16386 11.1595 2.02465L10.9995 1.85477C9.90886 0.765533 8.15792 0.725561 7.0173 1.71487C5.87668 0.715568 4.12573 0.765533 3.03514 1.85477L2.86505 2.01466C1.72443 3.15386 1.72443 5.00257 2.86505 6.14178L7.0173 10.2889L11.1695 6.14178L11.1595 6.15177ZM5.7366 3.27378L7.00729 4.54289L8.27798 3.27378C8.63818 2.91403 9.21849 2.91403 9.57869 3.27378L9.73877 3.43367C10.099 3.79342 10.099 4.37301 9.73877 4.73276L7.00729 7.46086L4.27581 4.73276C3.91562 4.37301 3.91562 3.79342 4.27581 3.43367L4.4359 3.27378C4.61599 3.09391 4.84612 3.00397 5.08625 3.00397C5.32638 3.00397 5.5565 3.09391 5.7366 3.27378Z"></path></svg>',
  "smiley-rate2-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_15894_140103)"><path d="M4.88291 4.51001C4.47291 4.51001 4.08291 4.25001 3.94291 3.84001C3.76291 3.32001 4.03291 2.75001 4.55291 2.57001L8.32291 1.25001C8.84291 1.06001 9.41291 1.34001 9.59291 1.86001C9.77291 2.38001 9.50291 2.95001 8.98291 3.13001L5.20291 4.45001C5.09291 4.49001 4.98291 4.51001 4.87291 4.51001H4.88291ZM19.8129 3.89001C20.0229 3.38001 19.7729 2.79001 19.2629 2.59001L15.5529 1.07001C15.0429 0.860007 14.4529 1.11001 14.2529 1.62001C14.0429 2.13001 14.2929 2.72001 14.8029 2.92001L18.5029 4.43001C18.6229 4.48001 18.7529 4.50001 18.8829 4.50001C19.2729 4.50001 19.6529 4.27001 19.8129 3.88001V3.89001ZM3.50291 6.00001C2.64291 6.37001 1.79291 6.88001 1.00291 7.48001C0.79291 7.64001 0.64291 7.87001 0.59291 8.14001C0.48291 8.73001 0.87291 9.29001 1.45291 9.40001C2.04291 9.51001 2.60291 9.12001 2.71291 8.54001C2.87291 7.69001 3.12291 6.83001 3.50291 5.99001V6.00001ZM21.0429 8.55001C21.6029 10.48 24.2429 8.84001 22.7529 7.48001C21.9629 6.88001 21.1129 6.37001 20.2529 6.00001C20.6329 6.84001 20.8829 7.70001 21.0429 8.55001ZM21.5729 13.2C21.2529 14.2 22.5429 15.09 23.3629 14.39C23.8529 14 23.9229 13.29 23.5429 12.81C21.7429 10.67 22.1329 10.55 21.5829 13.2H21.5729ZM1.75291 11C1.22291 11.79 -0.14709 12.64 0.0129102 13.75C0.15291 14.36 0.75291 14.74 1.35291 14.6C2.98291 14.1 1.80291 12.22 1.75291 11ZM19.8829 17C19.8829 13.14 16.2929 10 11.8829 10C7.47291 10 3.88291 13.14 3.88291 17C3.88291 20.86 7.47291 24 11.8829 24C16.2929 24 19.8829 20.86 19.8829 17ZM17.8829 17C17.8829 19.76 15.1929 22 11.8829 22C8.57291 22 5.88291 19.76 5.88291 17C5.88291 14.24 8.57291 12 11.8829 12C15.1929 12 17.8829 14.24 17.8829 17Z"></path></g><defs><clipPath id="clip0_15894_140103"><rect width="24" height="24" fill="white"></rect></clipPath></defs></svg>',
  "smiley-rate3-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M7.01915 7C6.46961 7 6.01998 6.55 6.01998 6V2C6.01998 1.45 6.46961 1 7.01915 1C7.56869 1 8.01832 1.45 8.01832 2V6C8.01832 6.55 7.56869 7 7.01915 7ZM18.01 6V2C18.01 1.45 17.5604 1 17.0108 1C16.4613 1 16.0117 1.45 16.0117 2V6C16.0117 6.55 16.4613 7 17.0108 7C17.5604 7 18.01 6.55 18.01 6ZM16.4213 21.58L18.01 19.99L19.2989 21.28C19.6886 21.67 20.3181 21.67 20.7077 21.28C21.0974 20.89 21.0974 20.26 20.7077 19.87L19.4188 18.58C18.6395 17.8 17.3705 17.8 16.5912 18.58L15.0025 20.17L13.4138 18.58C12.6345 17.8 11.3655 17.8 10.5862 18.58L8.9975 20.17L7.40883 18.58C6.62948 17.8 5.36053 17.8 4.58118 18.58L3.29226 19.87C2.90258 20.26 2.90258 20.89 3.29226 21.28C3.68193 21.67 4.31141 21.67 4.70108 21.28L5.99001 19.99L7.57868 21.58C8.35803 22.36 9.62698 22.36 10.4063 21.58L11.995 19.99L13.5837 21.58C13.9734 21.97 14.4829 22.16 14.9925 22.16C15.5021 22.16 16.0117 21.97 16.4013 21.58H16.4213Z"></path></svg>',
  "smiley-rate4-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M7.06927 7C6.51927 7 6.06927 6.55 6.06927 6V2C6.06927 1.45 6.51927 1 7.06927 1C7.61927 1 8.06927 1.45 8.06927 2V6C8.06927 6.55 7.61927 7 7.06927 7ZM18.0693 6V2C18.0693 1.45 17.6193 1 17.0693 1C16.5193 1 16.0693 1.45 16.0693 2V6C16.0693 6.55 16.5193 7 17.0693 7C17.6193 7 18.0693 6.55 18.0693 6ZM22.5693 21.9C23.0693 21.66 23.2793 21.07 23.0393 20.57C21.1093 16.52 16.9093 14 12.0693 14C7.22927 14 3.02927 16.52 1.09927 20.57C0.859273 21.07 1.06927 21.67 1.56927 21.9C2.06927 22.14 2.65927 21.93 2.89927 21.43C4.49927 18.08 8.00927 16 12.0593 16C16.1093 16 19.6293 18.08 21.2193 21.43C21.3893 21.79 21.7493 22 22.1193 22C22.2593 22 22.4093 21.97 22.5493 21.9H22.5693Z"></path></svg>',
  "smiley-rate5-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M7.00572 7C6.45572 7 6.00572 6.55 6.00572 6V2C6.00572 1.45 6.45572 1 7.00572 1C7.55572 1 8.00572 1.45 8.00572 2V6C8.00572 6.55 7.55572 7 7.00572 7ZM18.0057 6V2C18.0057 1.45 17.5557 1 17.0057 1C16.4557 1 16.0057 1.45 16.0057 2V6C16.0057 6.55 16.4557 7 17.0057 7C17.5557 7 18.0057 6.55 18.0057 6ZM19.9457 21.33C20.1257 20.81 19.8557 20.24 19.3357 20.05C14.5457 18.35 9.45572 18.35 4.66572 20.05C4.14572 20.23 3.87572 20.81 4.05572 21.33C4.23572 21.85 4.80572 22.12 5.33572 21.94C9.69572 20.4 14.3057 20.4 18.6657 21.94C18.7757 21.98 18.8857 22 18.9957 22C19.4057 22 19.7957 21.74 19.9357 21.33H19.9457Z"></path></svg>',
  "smiley-rate6-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M7 7C6.45 7 6 6.55 6 6V2C6 1.45 6.45 1 7 1C7.55 1 8 1.45 8 2V6C8 6.55 7.55 7 7 7ZM18 6V2C18 1.45 17.55 1 17 1C16.45 1 16 1.45 16 2V6C16 6.55 16.45 7 17 7C17.55 7 18 6.55 18 6ZM21 21C21 20.45 20.55 20 20 20H4C3.45 20 3 20.45 3 21C3 21.55 3.45 22 4 22H20C20.55 22 21 21.55 21 21Z"></path></svg>',
  "smiley-rate7-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12.0022 23.99C11.452 23.99 11.0018 23.5402 11.0018 22.9904C11.0018 22.4407 11.452 21.9909 12.0022 21.9909C16.3137 21.9909 21.0755 19.472 22.0158 13.8344C22.1058 13.2947 22.616 12.9248 23.1662 13.0148C23.7064 13.1047 24.0765 13.6245 23.9865 14.1643C22.8561 20.9513 17.144 24 11.9922 24L12.0022 23.99ZM8.00072 5.99783V1.99957C8.00072 1.4498 7.55056 1 7.00036 1C6.45016 1 6 1.4498 6 1.99957V5.99783C6 6.54759 6.45016 6.99739 7.00036 6.99739C7.55056 6.99739 8.00072 6.54759 8.00072 5.99783ZM18.0043 5.99783V1.99957C18.0043 1.4498 17.5542 1 17.004 1C16.4538 1 16.0036 1.4498 16.0036 1.99957V5.99783C16.0036 6.54759 16.4538 6.99739 17.004 6.99739C17.5542 6.99739 18.0043 6.54759 18.0043 5.99783Z"></path></svg>',
  "smiley-rate8-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12.01 24C6.85721 24 1.15412 20.96 0.0134987 14.16C-0.0765501 13.62 0.293651 13.1 0.833944 13.01C1.38424 12.92 1.89452 13.29 1.98457 13.83C2.92508 19.47 7.69767 21.99 12 21.99C16.3023 21.99 21.0749 19.47 22.0154 13.83C22.1055 13.29 22.6158 12.92 23.1661 13.01C23.7063 13.1 24.0765 13.62 23.9865 14.16C22.8559 20.95 17.1428 24 11.99 24H12.01ZM8.00783 6V2C8.00783 1.45 7.55759 1 7.00729 1C6.45699 1 6.00675 1.45 6.00675 2V6C6.00675 6.55 6.45699 7 7.00729 7C7.55759 7 8.00783 6.55 8.00783 6ZM18.0133 6V2C18.0133 1.45 17.563 1 17.0127 1C16.4624 1 16.0122 1.45 16.0122 2V6C16.0122 6.55 16.4624 7 17.0127 7C17.563 7 18.0133 6.55 18.0133 6Z"></path></svg>',
  "smiley-rate9-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12.01 24C6.85767 24 1.15509 20.96 0.0145752 14.16C-0.0354475 13.87 0.0445888 13.57 0.234675 13.35C0.424761 13.13 0.704888 13 0.995019 13H23.005C23.2951 13 23.5752 13.13 23.7653 13.35C23.9554 13.57 24.0354 13.87 23.9854 14.16C22.8549 20.95 17.1423 24 11.99 24H12.01ZM2.25559 15C3.61621 19.82 8.0182 22 12.01 22C16.0018 22 20.4038 19.82 21.7644 15H2.25559ZM8.00819 6V2C8.00819 1.45 7.55799 1 7.00774 1C6.45749 1 6.00729 1.45 6.00729 2V6C6.00729 6.55 6.45749 7 7.00774 7C7.55799 7 8.00819 6.55 8.00819 6ZM18.0127 6V2C18.0127 1.45 17.5625 1 17.0123 1C16.462 1 16.0118 1.45 16.0118 2V6C16.0118 6.55 16.462 7 17.0123 7C17.5625 7 18.0127 6.55 18.0127 6Z"></path></svg>',
  "speechbubble-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M13 2.25H3C2.04 2.25 1.25 3.04 1.25 4V11C1.25 11.96 2.04 12.75 3 12.75H4.25V15C4.25 15.3 4.43 15.58 4.71 15.69C4.8 15.73 4.9 15.75 5 15.75C5.2 15.75 5.39 15.67 5.53 15.53L8.31 12.75H13C13.96 12.75 14.75 11.96 14.75 11V4C14.75 3.04 13.96 2.25 13 2.25ZM13.25 11C13.25 11.14 13.14 11.25 13 11.25H8C7.8 11.25 7.61 11.33 7.47 11.47L5.75 13.19V12C5.75 11.59 5.41 11.25 5 11.25H3C2.86 11.25 2.75 11.14 2.75 11V4C2.75 3.86 2.86 3.75 3 3.75H13C13.14 3.75 13.25 3.86 13.25 4V11Z"></path></svg>',
  "switchoff-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M5 6.25C4.04 6.25 3.25 7.04 3.25 8C3.25 8.96 4.04 9.75 5 9.75C5.96 9.75 6.75 8.96 6.75 8C6.75 7.04 5.96 6.25 5 6.25ZM4.75 8C4.75 7.86 4.86 7.75 5 7.75C5.14 7.75 5.25 7.86 5.25 8C5.25 8.28 4.75 8.28 4.75 8ZM11 3.25H5C2.38 3.25 0.25 5.38 0.25 8C0.25 10.62 2.38 12.75 5 12.75H11C13.62 12.75 15.75 10.62 15.75 8C15.75 5.38 13.62 3.25 11 3.25ZM11 11.25H5C3.21 11.25 1.75 9.79 1.75 8C1.75 6.21 3.21 4.75 5 4.75H11C12.79 4.75 14.25 6.21 14.25 8C14.25 9.79 12.79 11.25 11 11.25Z"></path></svg>',
  "switchon-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M11 6.25C10.04 6.25 9.25 7.04 9.25 8C9.25 8.96 10.04 9.75 11 9.75C11.96 9.75 12.75 8.96 12.75 8C12.75 7.04 11.96 6.25 11 6.25ZM10.75 8C10.75 7.86 10.86 7.75 11 7.75C11.14 7.75 11.25 7.86 11.25 8C11.25 8.28 10.75 8.28 10.75 8ZM11 3.25H5C2.38 3.25 0.25 5.38 0.25 8C0.25 10.62 2.38 12.75 5 12.75H11C13.62 12.75 15.75 10.62 15.75 8C15.75 5.38 13.62 3.25 11 3.25ZM11 11.25H5C3.21 11.25 1.75 9.79 1.75 8C1.75 6.21 3.21 4.75 5 4.75H11C12.79 4.75 14.25 6.21 14.25 8C14.25 9.79 12.79 11.25 11 11.25Z"></path></svg>',
  "tablet-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M19 4.25H5C3.48 4.25 2.25 5.48 2.25 7V17C2.25 18.52 3.48 19.75 5 19.75H19C20.52 19.75 21.75 18.52 21.75 17V7C21.75 5.48 20.52 4.25 19 4.25ZM20.25 17C20.25 17.69 19.69 18.25 19 18.25H5C4.31 18.25 3.75 17.69 3.75 17V7C3.75 6.31 4.31 5.75 5 5.75H19C19.69 5.75 20.25 6.31 20.25 7V17ZM15.75 16C15.75 16.41 15.41 16.75 15 16.75H9C8.59 16.75 8.25 16.41 8.25 16C8.25 15.59 8.59 15.25 9 15.25H15C15.41 15.25 15.75 15.59 15.75 16Z"></path></svg>',
  "textedit-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20.12 10.06L19.95 9.89C18.91 8.85 17.1 8.85 16.06 9.89L9.47 16.48C9.37 16.58 9.31 16.7 9.27 16.83L8.27 20.83C8.21 21.08 8.28 21.36 8.47 21.54C8.61 21.68 8.8 21.76 9 21.76C9.06 21.76 9.12 21.76 9.18 21.74L13.18 20.74C13.31 20.71 13.43 20.64 13.53 20.54L20.12 13.95C20.64 13.43 20.93 12.74 20.93 12.01C20.93 11.28 20.64 10.59 20.12 10.07V10.06ZM12.62 19.32L10.04 19.97L10.69 17.39L15.01 13.07L16.95 15.01L12.63 19.33L12.62 19.32ZM19.06 12.88L18 13.94L16.06 12L17.12 10.94C17.61 10.45 18.4 10.45 18.89 10.94L19.06 11.11C19.55 11.6 19.55 12.39 19.06 12.88ZM4.25 4C4.25 3.59 4.59 3.25 5 3.25H18C18.41 3.25 18.75 3.59 18.75 4C18.75 4.41 18.41 4.75 18 4.75H5C4.59 4.75 4.25 4.41 4.25 4ZM4.25 7C4.25 6.59 4.59 6.25 5 6.25H15C15.41 6.25 15.75 6.59 15.75 7C15.75 7.41 15.41 7.75 15 7.75H5C4.59 7.75 4.25 7.41 4.25 7ZM4.25 10C4.25 9.59 4.59 9.25 5 9.25H12C12.41 9.25 12.75 9.59 12.75 10C12.75 10.41 12.41 10.75 12 10.75H5C4.59 10.75 4.25 10.41 4.25 10ZM9 13.75H5C4.59 13.75 4.25 13.41 4.25 13C4.25 12.59 4.59 12.25 5 12.25H9C9.41 12.25 9.75 12.59 9.75 13C9.75 13.41 9.41 13.75 9 13.75Z"></path></svg>',
  "theme-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 2.25C7.65 2.25 4.25 4.34 4.25 7V17C4.25 19.66 7.65 21.75 12 21.75C16.35 21.75 19.75 19.66 19.75 17V7C19.75 4.34 16.35 2.25 12 2.25ZM12 3.75C15.39 3.75 18.25 5.24 18.25 7C18.25 8.04 17.23 8.79 16.63 9.14C15.77 9.64 15.25 10.51 15.25 11.47V15.5C15.25 15.91 14.91 16.25 14.5 16.25C14.09 16.25 13.75 15.91 13.75 15.5V15C13.75 14.04 13 13.28 12.05 13.25C11.32 13.23 10.75 12.68 10.75 12V11.64C10.75 10.83 10.21 10.14 9.44 9.95C7.23 9.41 5.75 8.23 5.75 7C5.75 5.24 8.61 3.75 12 3.75ZM12 20.25C8.61 20.25 5.75 18.76 5.75 17V9.82C6.58 10.52 7.71 11.08 9.09 11.41C9.18 11.43 9.25 11.53 9.25 11.65V12.01C9.25 13.51 10.46 14.72 12.01 14.76C12.14 14.76 12.25 14.88 12.25 15.01V15.51C12.25 16.75 13.26 17.76 14.5 17.76C15.74 17.76 16.75 16.75 16.75 15.51V11.48C16.75 11.07 16.99 10.68 17.39 10.45C17.71 10.26 17.99 10.06 18.25 9.84V17.01C18.25 18.77 15.39 20.26 12 20.26V20.25ZM12 8.75C14.29 8.75 16.75 8.05 16.75 6.5C16.75 4.95 14.29 4.25 12 4.25C9.71 4.25 7.25 4.95 7.25 6.5C7.25 8.05 9.71 8.75 12 8.75ZM12 5.75C13.88 5.75 14.97 6.24 15.22 6.5C14.97 6.76 13.88 7.25 12 7.25C10.12 7.25 9.03 6.76 8.78 6.5C9.03 6.24 10.12 5.75 12 5.75Z"></path></svg>',
  "toolbox-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20.23 6.78L17.76 5.54C17.38 5.35 16.96 5.25 16.53 5.25H15.75V4C15.75 3.04 14.96 2.25 14 2.25H10C9.04 2.25 8.25 3.04 8.25 4V5.25H7.47C7.05 5.25 6.62 5.35 6.24 5.54L3.77 6.78C2.83 7.25 2.25 8.19 2.25 9.24V18C2.25 19.52 3.48 20.75 5 20.75H19C20.52 20.75 21.75 19.52 21.75 18V9.24C21.75 8.19 21.17 7.25 20.23 6.78ZM9.75 4C9.75 3.86 9.86 3.75 10 3.75H14C14.14 3.75 14.25 3.86 14.25 4V5.25H9.75V4ZM4.44 8.12L6.91 6.88C7.08 6.79 7.28 6.75 7.47 6.75H16.53C16.72 6.75 16.92 6.8 17.09 6.88L19.56 8.12C19.99 8.33 20.25 8.76 20.25 9.24V13.25H18.75V13C18.75 12.04 17.96 11.25 17 11.25H16C15.04 11.25 14.25 12.04 14.25 13V13.25H9.75V13C9.75 12.04 8.96 11.25 8 11.25H7C6.04 11.25 5.25 12.04 5.25 13V13.25H3.75V9.24C3.75 8.76 4.01 8.33 4.44 8.12ZM15.75 13C15.75 12.86 15.86 12.75 16 12.75H17C17.14 12.75 17.25 12.86 17.25 13V15C17.25 15.14 17.14 15.25 17 15.25H16C15.86 15.25 15.75 15.14 15.75 15V13ZM6.75 13C6.75 12.86 6.86 12.75 7 12.75H8C8.14 12.75 8.25 12.86 8.25 13V15C8.25 15.14 8.14 15.25 8 15.25H7C6.86 15.25 6.75 15.14 6.75 15V13ZM19 19.25H5C4.31 19.25 3.75 18.69 3.75 18V14.75H5.25V15C5.25 15.96 6.04 16.75 7 16.75H8C8.96 16.75 9.75 15.96 9.75 15V14.75H14.25V15C14.25 15.96 15.04 16.75 16 16.75H17C17.96 16.75 18.75 15.96 18.75 15V14.75H20.25V18C20.25 18.69 19.69 19.25 19 19.25Z"></path></svg>',
  "toolbox-boolean-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M11 3.25H5C2.38 3.25 0.25 5.38 0.25 8C0.25 10.62 2.38 12.75 5 12.75H11C13.62 12.75 15.75 10.62 15.75 8C15.75 5.38 13.62 3.25 11 3.25ZM11 11.25H5C3.21 11.25 1.75 9.79 1.75 8C1.75 6.21 3.21 4.75 5 4.75H11C12.79 4.75 14.25 6.21 14.25 8C14.25 9.79 12.79 11.25 11 11.25ZM11 5.25C9.48 5.25 8.25 6.48 8.25 8C8.25 9.52 9.48 10.75 11 10.75C12.52 10.75 13.75 9.52 13.75 8C13.75 6.48 12.52 5.25 11 5.25ZM11 9.25C10.31 9.25 9.75 8.69 9.75 8C9.75 7.31 10.31 6.75 11 6.75C11.69 6.75 12.25 7.31 12.25 8C12.25 8.69 11.69 9.25 11 9.25Z"></path></svg>',
  "toolbox-boolean-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M17 17.75H7C3.83 17.75 1.25 15.17 1.25 12C1.25 8.83 3.83 6.25 7 6.25H17C20.17 6.25 22.75 8.83 22.75 12C22.75 15.17 20.17 17.75 17 17.75ZM7 7.75C4.66 7.75 2.75 9.66 2.75 12C2.75 14.34 4.66 16.25 7 16.25H17C19.34 16.25 21.25 14.34 21.25 12C21.25 9.66 19.34 7.75 17 7.75H7ZM17 14.75C15.48 14.75 14.25 13.52 14.25 12C14.25 10.48 15.48 9.25 17 9.25C18.52 9.25 19.75 10.48 19.75 12C19.75 13.52 18.52 14.75 17 14.75ZM17 10.75C16.31 10.75 15.75 11.31 15.75 12C15.75 12.69 16.31 13.25 17 13.25C17.69 13.25 18.25 12.69 18.25 12C18.25 11.31 17.69 10.75 17 10.75Z"></path></svg>',
  "toolbox-checkbox-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M13 1.25H3C2.04 1.25 1.25 2.04 1.25 3V13C1.25 13.96 2.04 14.75 3 14.75H13C13.96 14.75 14.75 13.96 14.75 13V3C14.75 2.04 13.96 1.25 13 1.25ZM13.25 13C13.25 13.14 13.14 13.25 13 13.25H3C2.86 13.25 2.75 13.14 2.75 13V3C2.75 2.86 2.86 2.75 3 2.75H13C13.14 2.75 13.25 2.86 13.25 3V13ZM11.53 5.47C11.82 5.76 11.82 6.24 11.53 6.53L7.53 10.53C7.38 10.68 7.19 10.75 7 10.75C6.81 10.75 6.62 10.68 6.47 10.53L4.47 8.53C4.18 8.24 4.18 7.76 4.47 7.47C4.76 7.18 5.24 7.18 5.53 7.47L7 8.94L10.47 5.47C10.76 5.18 11.24 5.18 11.53 5.47Z"></path></svg>',
  "toolbox-checkbox-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M18 20.75H6C4.48 20.75 3.25 19.52 3.25 18V6C3.25 4.48 4.48 3.25 6 3.25H18C19.52 3.25 20.75 4.48 20.75 6V18C20.75 19.52 19.52 20.75 18 20.75ZM6 4.75C5.31 4.75 4.75 5.31 4.75 6V18C4.75 18.69 5.31 19.25 6 19.25H18C18.69 19.25 19.25 18.69 19.25 18V6C19.25 5.31 18.69 4.75 18 4.75H6ZM10.53 15.53L16.53 9.53C16.82 9.24 16.82 8.76 16.53 8.47C16.24 8.18 15.76 8.18 15.47 8.47L10 13.94L8.53 12.47C8.24 12.18 7.76 12.18 7.47 12.47C7.18 12.76 7.18 13.24 7.47 13.53L9.47 15.53C9.62 15.68 9.81 15.75 10 15.75C10.19 15.75 10.38 15.68 10.53 15.53Z"></path></svg>',
  "toolbox-customquestion-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M5 15.75C4.9 15.75 4.81 15.73 4.71 15.69C4.43 15.57 4.25 15.3 4.25 15V12.75H3C2.04 12.75 1.25 11.96 1.25 11V3C1.25 2.04 2.04 1.25 3 1.25H13C13.96 1.25 14.75 2.04 14.75 3V11C14.75 11.96 13.96 12.75 13 12.75H8.31L5.53 15.53C5.39 15.67 5.2 15.75 5 15.75ZM3 2.75C2.86 2.75 2.75 2.86 2.75 3V11C2.75 11.14 2.86 11.25 3 11.25H5C5.41 11.25 5.75 11.59 5.75 12V13.19L7.47 11.47C7.61 11.33 7.8 11.25 8 11.25H13C13.14 11.25 13.25 11.14 13.25 11V3C13.25 2.86 13.14 2.75 13 2.75H3Z"></path></svg>',
  "toolbox-customquestion-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M18 3.25H6C4.48 3.25 3.25 4.48 3.25 6V16C3.25 17.52 4.48 18.75 6 18.75H7.25V22C7.25 22.3 7.43 22.58 7.71 22.69C7.8 22.73 7.9 22.75 8 22.75C8.2 22.75 8.39 22.67 8.53 22.53L12.31 18.75H18C19.52 18.75 20.75 17.52 20.75 16V6C20.75 4.48 19.52 3.25 18 3.25ZM19.25 16C19.25 16.69 18.69 17.25 18 17.25H12C11.8 17.25 11.61 17.33 11.47 17.47L8.75 20.19V18C8.75 17.59 8.41 17.25 8 17.25H6C5.31 17.25 4.75 16.69 4.75 16V6C4.75 5.31 5.31 4.75 6 4.75H18C18.69 4.75 19.25 5.31 19.25 6V16Z"></path></svg>',
  "toolbox-dropdown-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M13 1.25H3C2.04 1.25 1.25 2.04 1.25 3V13C1.25 13.96 2.04 14.75 3 14.75H13C13.96 14.75 14.75 13.96 14.75 13V3C14.75 2.04 13.96 1.25 13 1.25ZM2.75 3C2.75 2.86 2.86 2.75 3 2.75H13C13.14 2.75 13.25 2.86 13.25 3V5.25H2.75V3ZM13.25 13C13.25 13.14 13.14 13.25 13 13.25H3C2.86 13.25 2.75 13.14 2.75 13V6.75H13.25V13ZM4.25 9C4.25 8.59 4.59 8.25 5 8.25H11C11.41 8.25 11.75 8.59 11.75 9C11.75 9.41 11.41 9.75 11 9.75H5C4.59 9.75 4.25 9.41 4.25 9ZM4.25 11C4.25 10.59 4.59 10.25 5 10.25H11C11.41 10.25 11.75 10.59 11.75 11C11.75 11.41 11.41 11.75 11 11.75H5C4.59 11.75 4.25 11.41 4.25 11ZM12.75 4C12.75 4.41 12.41 4.75 12 4.75H11C10.59 4.75 10.25 4.41 10.25 4C10.25 3.59 10.59 3.25 11 3.25H12C12.41 3.25 12.75 3.59 12.75 4Z"></path></svg>',
  "toolbox-dropdown-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M17.75 6C17.75 6.41 17.41 6.75 17 6.75H16C15.59 6.75 15.25 6.41 15.25 6C15.25 5.59 15.59 5.25 16 5.25H17C17.41 5.25 17.75 5.59 17.75 6ZM7 12.75H17C17.41 12.75 17.75 12.41 17.75 12C17.75 11.59 17.41 11.25 17 11.25H7C6.59 11.25 6.25 11.59 6.25 12C6.25 12.41 6.59 12.75 7 12.75ZM7 15.75H17C17.41 15.75 17.75 15.41 17.75 15C17.75 14.59 17.41 14.25 17 14.25H7C6.59 14.25 6.25 14.59 6.25 15C6.25 15.41 6.59 15.75 7 15.75ZM20.75 5V19C20.75 20.52 19.52 21.75 18 21.75H6C4.48 21.75 3.25 20.52 3.25 19V5C3.25 3.48 4.48 2.25 6 2.25H18C19.52 2.25 20.75 3.48 20.75 5ZM4.75 8.25H19.25V5C19.25 4.31 18.69 3.75 18 3.75H6C5.31 3.75 4.75 4.31 4.75 5V8.25ZM19.25 9.75H4.75V19C4.75 19.69 5.31 20.25 6 20.25H18C18.69 20.25 19.25 19.69 19.25 19V9.75ZM7 18.75H17C17.41 18.75 17.75 18.41 17.75 18C17.75 17.59 17.41 17.25 17 17.25H7C6.59 17.25 6.25 17.59 6.25 18C6.25 18.41 6.59 18.75 7 18.75Z"></path></svg>',
  "toolbox-dynamicmatrix-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M13 1.25H3C2.04 1.25 1.25 2.04 1.25 3V5C1.25 5.96 2.04 6.75 3 6.75H13C13.96 6.75 14.75 5.96 14.75 5V3C14.75 2.04 13.96 1.25 13 1.25ZM2.75 5V3C2.75 2.86 2.86 2.75 3 2.75H7.25V5.25H3C2.86 5.25 2.75 5.14 2.75 5ZM13.25 5C13.25 5.14 13.14 5.25 13 5.25H8.75V2.75H13C13.14 2.75 13.25 2.86 13.25 3V5ZM10 11.65H8.75V12.9C8.75 13.31 8.41 13.65 8 13.65C7.59 13.65 7.25 13.31 7.25 12.9V11.65H6C5.59 11.65 5.25 11.31 5.25 10.9C5.25 10.49 5.59 10.15 6 10.15H7.25V9C7.25 8.59 7.59 8.25 8 8.25C8.41 8.25 8.75 8.59 8.75 9V10.15H10C10.41 10.15 10.75 10.49 10.75 10.9C10.75 11.31 10.41 11.65 10 11.65ZM14.75 9V13C14.75 13.96 13.96 14.75 13 14.75H11C10.59 14.75 10.25 14.41 10.25 14C10.25 13.59 10.59 13.25 11 13.25H13C13.14 13.25 13.25 13.14 13.25 13V9C13.25 8.86 13.14 8.75 13 8.75H11C10.59 8.75 10.25 8.41 10.25 8C10.25 7.59 10.59 7.25 11 7.25H13C13.96 7.25 14.75 8.04 14.75 9ZM5.75 14C5.75 14.41 5.41 14.75 5 14.75H3C2.04 14.75 1.25 13.96 1.25 13V9C1.25 8.04 2.04 7.25 3 7.25H5C5.41 7.25 5.75 7.59 5.75 8C5.75 8.41 5.41 8.75 5 8.75H3C2.86 8.75 2.75 8.86 2.75 9V13C2.75 13.14 2.86 13.25 3 13.25H5C5.41 13.25 5.75 13.59 5.75 14Z"></path></svg>',
  "toolbox-dynamicmatrix-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M19 2.25H5C3.48 2.25 2.25 3.48 2.25 5V7C2.25 8.52 3.48 9.75 5 9.75H19C20.52 9.75 21.75 8.52 21.75 7V5C21.75 3.48 20.52 2.25 19 2.25ZM14.25 3.75V8.25H9.75V3.75H14.25ZM3.75 7V5C3.75 4.31 4.31 3.75 5 3.75H8.25V8.25H5C4.31 8.25 3.75 7.69 3.75 7ZM20.25 7C20.25 7.69 19.69 8.25 19 8.25H15.75V3.75H19C19.69 3.75 20.25 4.31 20.25 5V7ZM21.75 15V19C21.75 20.52 20.52 21.75 19 21.75H15C14.59 21.75 14.25 21.41 14.25 21C14.25 20.59 14.59 20.25 15 20.25H19C19.69 20.25 20.25 19.69 20.25 19V15C20.25 14.31 19.69 13.75 19 13.75H15C14.59 13.75 14.25 13.41 14.25 13C14.25 12.59 14.59 12.25 15 12.25H19C20.52 12.25 21.75 13.48 21.75 15ZM9.75 21C9.75 21.41 9.41 21.75 9 21.75H5C3.48 21.75 2.25 20.52 2.25 19V15C2.25 13.48 3.48 12.25 5 12.25H9C9.41 12.25 9.75 12.59 9.75 13C9.75 13.41 9.41 13.75 9 13.75H5C4.31 13.75 3.75 14.31 3.75 15V19C3.75 19.69 4.31 20.25 5 20.25H9C9.41 20.25 9.75 20.59 9.75 21ZM12.75 17.75V20C12.75 20.41 12.41 20.75 12 20.75C11.59 20.75 11.25 20.41 11.25 20V17.75H9C8.59 17.75 8.25 17.41 8.25 17C8.25 16.59 8.59 16.25 9 16.25H11.25V14C11.25 13.59 11.59 13.25 12 13.25C12.41 13.25 12.75 13.59 12.75 14V16.25H15C15.41 16.25 15.75 16.59 15.75 17C15.75 17.41 15.41 17.75 15 17.75H12.75Z"></path></svg>',
  "toolbox-dynamicpanel-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M13 1.25H3C2.04 1.25 1.25 2.04 1.25 3V13C1.25 13.96 2.04 14.75 3 14.75H13C13.96 14.75 14.75 13.96 14.75 13V3C14.75 2.04 13.96 1.25 13 1.25ZM13.25 13C13.25 13.14 13.14 13.25 13 13.25H3C2.86 13.25 2.75 13.14 2.75 13V3C2.75 2.86 2.86 2.75 3 2.75H13C13.14 2.75 13.25 2.86 13.25 3V13ZM10.75 8C10.75 8.41 10.41 8.75 10 8.75H8.75V10C8.75 10.41 8.41 10.75 8 10.75C7.59 10.75 7.25 10.41 7.25 10V8.75H6C5.59 8.75 5.25 8.41 5.25 8C5.25 7.59 5.59 7.25 6 7.25H7.25V6C7.25 5.59 7.59 5.25 8 5.25C8.41 5.25 8.75 5.59 8.75 6V7.25H10C10.41 7.25 10.75 7.59 10.75 8Z"></path></svg>',
  "toolbox-dynamicpanel-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M18 3.25H6C4.48 3.25 3.25 4.48 3.25 6V18C3.25 19.52 4.48 20.75 6 20.75H18C19.52 20.75 20.75 19.52 20.75 18V6C20.75 4.48 19.52 3.25 18 3.25ZM19.25 18C19.25 18.69 18.69 19.25 18 19.25H6C5.31 19.25 4.75 18.69 4.75 18V6C4.75 5.31 5.31 4.75 6 4.75H18C18.69 4.75 19.25 5.31 19.25 6V18ZM15.75 12C15.75 12.41 15.41 12.75 15 12.75H12.75V15C12.75 15.41 12.41 15.75 12 15.75C11.59 15.75 11.25 15.41 11.25 15V12.75H9C8.59 12.75 8.25 12.41 8.25 12C8.25 11.59 8.59 11.25 9 11.25H11.25V9C11.25 8.59 11.59 8.25 12 8.25C12.41 8.25 12.75 8.59 12.75 9V11.25H15C15.41 11.25 15.75 11.59 15.75 12Z"></path></svg>',
  "toolbox-expression-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M6.75 4V7.25H8C8.41 7.25 8.75 7.59 8.75 8C8.75 8.41 8.41 8.75 8 8.75H6.75V12C6.75 13.52 5.52 14.75 4 14.75C2.48 14.75 1.25 13.52 1.25 12C1.25 11.59 1.59 11.25 2 11.25C2.41 11.25 2.75 11.59 2.75 12C2.75 12.69 3.31 13.25 4 13.25C4.69 13.25 5.25 12.69 5.25 12V8.75H4C3.59 8.75 3.25 8.41 3.25 8C3.25 7.59 3.59 7.25 4 7.25H5.25V4C5.25 2.48 6.48 1.25 8 1.25C9.52 1.25 10.75 2.48 10.75 4C10.75 4.41 10.41 4.75 10 4.75C9.59 4.75 9.25 4.41 9.25 4C9.25 3.31 8.69 2.75 8 2.75C7.31 2.75 6.75 3.31 6.75 4ZM14.53 13.47L13.03 11.97L14.44 10.53C14.73 10.23 14.72 9.76 14.43 9.47C14.13 9.18 13.66 9.19 13.37 9.48L11.97 10.91L10.53 9.47C10.24 9.18 9.76 9.18 9.47 9.47C9.18 9.76 9.18 10.24 9.47 10.53L10.92 11.98L9.46 13.48C9.17 13.78 9.18 14.25 9.47 14.54C9.62 14.68 9.8 14.75 9.99 14.75C10.18 14.75 10.38 14.67 10.53 14.52L11.97 13.04L13.46 14.53C13.61 14.68 13.8 14.75 13.99 14.75C14.18 14.75 14.37 14.68 14.52 14.53C14.81 14.24 14.81 13.76 14.52 13.47H14.53Z"></path></svg>',
  "toolbox-expression-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M8.75 5.5V9.25H10C10.41 9.25 10.75 9.59 10.75 10C10.75 10.41 10.41 10.75 10 10.75H8.75V18.5C8.75 20.29 7.29 21.75 5.5 21.75C3.71 21.75 2.25 20.29 2.25 18.5V18C2.25 17.59 2.59 17.25 3 17.25C3.41 17.25 3.75 17.59 3.75 18V18.5C3.75 19.46 4.54 20.25 5.5 20.25C6.46 20.25 7.25 19.46 7.25 18.5V10.75H6C5.59 10.75 5.25 10.41 5.25 10C5.25 9.59 5.59 9.25 6 9.25H7.25V5.5C7.25 3.71 8.71 2.25 10.5 2.25C12.29 2.25 13.75 3.71 13.75 5.5V6C13.75 6.41 13.41 6.75 13 6.75C12.59 6.75 12.25 6.41 12.25 6V5.5C12.25 4.54 11.46 3.75 10.5 3.75C9.54 3.75 8.75 4.54 8.75 5.5ZM17.06 16L19.53 13.53C19.82 13.24 19.82 12.76 19.53 12.47C19.24 12.18 18.76 12.18 18.47 12.47L16 14.94L13.53 12.47C13.24 12.18 12.76 12.18 12.47 12.47C12.18 12.76 12.18 13.24 12.47 13.53L14.94 16L12.47 18.47C12.18 18.76 12.18 19.24 12.47 19.53C12.62 19.68 12.81 19.75 13 19.75C13.19 19.75 13.38 19.68 13.53 19.53L16 17.06L18.47 19.53C18.62 19.68 18.81 19.75 19 19.75C19.19 19.75 19.38 19.68 19.53 19.53C19.82 19.24 19.82 18.76 19.53 18.47L17.06 16Z"></path></svg>',
  "toolbox-file-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M13 2.25H7.75V2C7.75 1.04 6.96 0.25 6 0.25H3C2.04 0.25 1.25 1.04 1.25 2V13C1.25 13.96 2.04 14.75 3 14.75H5C5.41 14.75 5.75 14.41 5.75 14C5.75 13.59 5.41 13.25 5 13.25H3C2.86 13.25 2.75 13.14 2.75 13V6.75H13.25V13C13.25 13.14 13.14 13.25 13 13.25H11C10.59 13.25 10.25 13.59 10.25 14C10.25 14.41 10.59 14.75 11 14.75H13C13.96 14.75 14.75 13.96 14.75 13V4C14.75 3.04 13.96 2.25 13 2.25ZM2.75 5.25V2C2.75 1.86 2.86 1.75 3 1.75H6C6.14 1.75 6.25 1.86 6.25 2V3C6.25 3.41 6.59 3.75 7 3.75H13C13.14 3.75 13.25 3.86 13.25 4V5.25H2.75ZM10.63 11.63C10.48 11.78 10.29 11.85 10.1 11.85C9.91 11.85 9.72 11.78 9.57 11.63L8.75 10.81V15C8.75 15.41 8.41 15.75 8 15.75C7.59 15.75 7.25 15.41 7.25 15V10.81L6.43 11.63C6.14 11.92 5.66 11.92 5.37 11.63C5.08 11.34 5.08 10.86 5.37 10.57L7.47 8.47C7.54 8.4 7.62 8.35 7.71 8.31C7.89 8.23 8.1 8.23 8.28 8.31C8.37 8.35 8.45 8.4 8.52 8.47L10.62 10.57C10.91 10.86 10.91 11.34 10.62 11.63H10.63Z"></path></svg>',
  "toolbox-file-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M18 4.25H10.65C10.32 3.1 9.26 2.25 8 2.25H6C4.48 2.25 3.25 3.48 3.25 5V18C3.25 19.52 4.48 20.75 6 20.75H9C9.41 20.75 9.75 20.41 9.75 20C9.75 19.59 9.41 19.25 9 19.25H6C5.31 19.25 4.75 18.69 4.75 18V9.75H19.25V18C19.25 18.69 18.69 19.25 18 19.25H15C14.59 19.25 14.25 19.59 14.25 20C14.25 20.41 14.59 20.75 15 20.75H18C19.52 20.75 20.75 19.52 20.75 18V7C20.75 5.48 19.52 4.25 18 4.25ZM4.75 8.25V5C4.75 4.31 5.31 3.75 6 3.75H8C8.69 3.75 9.25 4.31 9.25 5C9.25 5.41 9.59 5.75 10 5.75H18C18.69 5.75 19.25 6.31 19.25 7V8.25H4.75ZM12.75 14.81V23C12.75 23.41 12.41 23.75 12 23.75C11.59 23.75 11.25 23.41 11.25 23V14.81L9.53 16.53C9.24 16.82 8.76 16.82 8.47 16.53C8.18 16.24 8.18 15.76 8.47 15.47L11.47 12.47C11.54 12.4 11.62 12.35 11.71 12.31C11.89 12.23 12.1 12.23 12.28 12.31C12.37 12.35 12.45 12.4 12.52 12.47L15.52 15.47C15.81 15.76 15.81 16.24 15.52 16.53C15.37 16.68 15.18 16.75 14.99 16.75C14.8 16.75 14.61 16.68 14.46 16.53L12.74 14.81H12.75Z"></path></svg>',
  "toolbox-html-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M5.5275 5.53444L3.0575 8.00444L5.5275 10.4744C5.8175 10.7644 5.8175 11.2444 5.5275 11.5344C5.3775 11.6844 5.1875 11.7544 4.9975 11.7544C4.8075 11.7544 4.6175 11.6844 4.4675 11.5344L1.4675 8.53444C1.1775 8.24444 1.1775 7.76444 1.4675 7.47444L4.4675 4.47444C4.7575 4.18444 5.2375 4.18444 5.5275 4.47444C5.8175 4.76444 5.8175 5.24444 5.5275 5.53444ZM14.5275 7.47444L11.5275 4.47444C11.2375 4.18444 10.7575 4.18444 10.4675 4.47444C10.1775 4.76444 10.1775 5.24444 10.4675 5.53444L12.9375 8.00444L10.4675 10.4744C10.1775 10.7644 10.1775 11.2444 10.4675 11.5344C10.6175 11.6844 10.8075 11.7544 10.9975 11.7544C11.1875 11.7544 11.3775 11.6844 11.5275 11.5344L14.5275 8.53444C14.8175 8.24444 14.8175 7.76444 14.5275 7.47444ZM9.1475 2.26444C8.7375 2.18444 8.3475 2.44444 8.2675 2.85444L6.2675 12.8544C6.1875 13.2644 6.4475 13.6544 6.8575 13.7344C6.9075 13.7344 6.9575 13.7444 7.0075 13.7444C7.3575 13.7444 7.6675 13.4944 7.7375 13.1444L9.7375 3.15444C9.8175 2.74444 9.5575 2.35444 9.1475 2.27444V2.26444Z"></path></svg>',
  "toolbox-html-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M6.5275 8.53263L3.0575 12.0026L6.5275 15.4726C6.8175 15.7626 6.8175 16.2426 6.5275 16.5326C6.3775 16.6826 6.1875 16.7526 5.9975 16.7526C5.8075 16.7526 5.6175 16.6826 5.4675 16.5326L1.4675 12.5326C1.1775 12.2426 1.1775 11.7626 1.4675 11.4726L5.4675 7.47263C5.7575 7.18263 6.2375 7.18263 6.5275 7.47263C6.8175 7.76263 6.8175 8.24263 6.5275 8.53263ZM22.5275 11.4726L18.5275 7.47263C18.2375 7.18263 17.7575 7.18263 17.4675 7.47263C17.1775 7.76263 17.1775 8.24263 17.4675 8.53263L20.9375 12.0026L17.4675 15.4726C17.1775 15.7626 17.1775 16.2426 17.4675 16.5326C17.6175 16.6826 17.8075 16.7526 17.9975 16.7526C18.1875 16.7526 18.3775 16.6826 18.5275 16.5326L22.5275 12.5326C22.8175 12.2426 22.8175 11.7626 22.5275 11.4726ZM14.1775 3.27263C13.7775 3.17263 13.3675 3.41263 13.2675 3.82263L9.2675 19.8226C9.1675 20.2226 9.4075 20.6326 9.8175 20.7326C9.8775 20.7526 9.9375 20.7526 9.9975 20.7526C10.3375 20.7526 10.6375 20.5226 10.7275 20.1826L14.7275 4.18263C14.8275 3.78263 14.5875 3.37263 14.1775 3.27263Z"></path></svg>',
  "toolbox-image-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M13 1.25H3C2.04 1.25 1.25 2.04 1.25 3V13C1.25 13.96 2.04 14.75 3 14.75H13C13.96 14.75 14.75 13.96 14.75 13V3C14.75 2.04 13.96 1.25 13 1.25ZM13.25 13C13.25 13.14 13.14 13.25 13 13.25H3C2.86 13.25 2.75 13.14 2.75 13V3C2.75 2.86 2.86 2.75 3 2.75H13C13.14 2.75 13.25 2.86 13.25 3V13ZM10.5 6.75C11.19 6.75 11.75 6.19 11.75 5.5C11.75 4.81 11.19 4.25 10.5 4.25C9.81 4.25 9.25 4.81 9.25 5.5C9.25 6.19 9.81 6.75 10.5 6.75ZM10.5 5.25C10.64 5.25 10.75 5.36 10.75 5.5C10.75 5.78 10.25 5.78 10.25 5.5C10.25 5.36 10.36 5.25 10.5 5.25ZM12.53 10.47C12.82 10.76 12.82 11.24 12.53 11.53C12.38 11.68 12.19 11.75 12 11.75C11.81 11.75 11.62 11.68 11.47 11.53L10 10.06L9.53 10.53C9.24 10.82 8.76 10.82 8.47 10.53L7 9.06L4.53 11.53C4.24 11.82 3.76 11.82 3.47 11.53C3.18 11.24 3.18 10.76 3.47 10.47L6.47 7.47C6.76 7.18 7.24 7.18 7.53 7.47L9 8.94L9.47 8.47C9.76 8.18 10.24 8.18 10.53 8.47L12.53 10.47Z"></path></svg>',
  "toolbox-image-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M18 3.25H6C4.48 3.25 3.25 4.48 3.25 6V18C3.25 19.52 4.48 20.75 6 20.75H18C19.52 20.75 20.75 19.52 20.75 18V6C20.75 4.48 19.52 3.25 18 3.25ZM19.25 18C19.25 18.69 18.69 19.25 18 19.25H6C5.31 19.25 4.75 18.69 4.75 18V6C4.75 5.31 5.31 4.75 6 4.75H18C18.69 4.75 19.25 5.31 19.25 6V18ZM15.5 10.75C16.74 10.75 17.75 9.74 17.75 8.5C17.75 7.26 16.74 6.25 15.5 6.25C14.26 6.25 13.25 7.26 13.25 8.5C13.25 9.74 14.26 10.75 15.5 10.75ZM15.5 7.75C15.91 7.75 16.25 8.09 16.25 8.5C16.25 8.91 15.91 9.25 15.5 9.25C15.09 9.25 14.75 8.91 14.75 8.5C14.75 8.09 15.09 7.75 15.5 7.75ZM18.53 16.47C18.82 16.76 18.82 17.24 18.53 17.53C18.38 17.68 18.19 17.75 18 17.75C17.81 17.75 17.62 17.68 17.47 17.53L15 15.06L13.53 16.53C13.24 16.82 12.76 16.82 12.47 16.53L10 14.06L6.53 17.53C6.24 17.82 5.76 17.82 5.47 17.53C5.18 17.24 5.18 16.76 5.47 16.47L9.47 12.47C9.76 12.18 10.24 12.18 10.53 12.47L13 14.94L14.47 13.47C14.76 13.18 15.24 13.18 15.53 13.47L18.53 16.47Z"></path></svg>',
  "toolbox-imagepicker-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_22761_58206)"><path d="M2.25 4V12C2.25 12.96 3.04 13.75 4 13.75H12C12.96 13.75 13.75 12.96 13.75 12V4C13.75 3.04 12.96 2.25 12 2.25H4C3.04 2.25 2.25 3.04 2.25 4ZM12.25 4V12C12.25 12.14 12.14 12.25 12 12.25H4C3.86 12.25 3.75 12.14 3.75 12V4C3.75 3.86 3.86 3.75 4 3.75H12C12.14 3.75 12.25 3.86 12.25 4ZM10.5 6.75C11.19 6.75 11.75 6.19 11.75 5.5C11.75 4.81 11.19 4.25 10.5 4.25C9.81 4.25 9.25 4.81 9.25 5.5C9.25 6.19 9.81 6.75 10.5 6.75ZM10.5 5.25C10.64 5.25 10.75 5.36 10.75 5.5C10.75 5.78 10.25 5.78 10.25 5.5C10.25 5.36 10.36 5.25 10.5 5.25ZM4.47 10.53C4.18 10.24 4.18 9.76 4.47 9.47L6.47 7.47C6.76 7.18 7.24 7.18 7.53 7.47L9 8.94L9.47 8.47C9.76 8.18 10.24 8.18 10.53 8.47L11.53 9.47C11.82 9.76 11.82 10.24 11.53 10.53C11.38 10.68 11.19 10.75 11 10.75C10.81 10.75 10.62 10.68 10.47 10.53L10 10.06L9.53 10.53C9.24 10.82 8.76 10.82 8.47 10.53L7 9.06L5.53 10.53C5.24 10.82 4.76 10.82 4.47 10.53ZM0.25 5V4C0.25 1.93 1.93 0.25 4 0.25H5C5.41 0.25 5.75 0.59 5.75 1C5.75 1.41 5.41 1.75 5 1.75H4C2.76 1.75 1.75 2.76 1.75 4V5C1.75 5.41 1.41 5.75 1 5.75C0.59 5.75 0.25 5.41 0.25 5ZM5.75 15C5.75 15.41 5.41 15.75 5 15.75H4C1.93 15.75 0.25 14.07 0.25 12V11C0.25 10.59 0.59 10.25 1 10.25C1.41 10.25 1.75 10.59 1.75 11V12C1.75 13.24 2.76 14.25 4 14.25H5C5.41 14.25 5.75 14.59 5.75 15ZM15.75 11V12C15.75 14.07 14.07 15.75 12 15.75H11C10.59 15.75 10.25 15.41 10.25 15C10.25 14.59 10.59 14.25 11 14.25H12C13.24 14.25 14.25 13.24 14.25 12V11C14.25 10.59 14.59 10.25 15 10.25C15.41 10.25 15.75 10.59 15.75 11ZM15.75 4V5C15.75 5.41 15.41 5.75 15 5.75C14.59 5.75 14.25 5.41 14.25 5V4C14.25 2.76 13.24 1.75 12 1.75H11C10.59 1.75 10.25 1.41 10.25 1C10.25 0.59 10.59 0.25 11 0.25H12C14.07 0.25 15.75 1.93 15.75 4Z"></path></g><defs><clipPath id="clip0_22761_58206"><rect width="16" height="16" fill="white"></rect></clipPath></defs></svg>',
  "toolbox-imagepicker-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M4.25 7V17C4.25 18.52 5.48 19.75 7 19.75H17C18.52 19.75 19.75 18.52 19.75 17V7C19.75 5.48 18.52 4.25 17 4.25H7C5.48 4.25 4.25 5.48 4.25 7ZM18.25 7V17C18.25 17.69 17.69 18.25 17 18.25H7C6.31 18.25 5.75 17.69 5.75 17V7C5.75 6.31 6.31 5.75 7 5.75H17C17.69 5.75 18.25 6.31 18.25 7ZM8.75 22C8.75 22.41 8.41 22.75 8 22.75H7C3.83 22.75 1.25 20.17 1.25 17V16C1.25 15.59 1.59 15.25 2 15.25C2.41 15.25 2.75 15.59 2.75 16V17C2.75 19.34 4.66 21.25 7 21.25H8C8.41 21.25 8.75 21.59 8.75 22ZM22.75 16V17C22.75 20.17 20.17 22.75 17 22.75H16C15.59 22.75 15.25 22.41 15.25 22C15.25 21.59 15.59 21.25 16 21.25H17C19.34 21.25 21.25 19.34 21.25 17V16C21.25 15.59 21.59 15.25 22 15.25C22.41 15.25 22.75 15.59 22.75 16ZM22.75 7V8C22.75 8.41 22.41 8.75 22 8.75C21.59 8.75 21.25 8.41 21.25 8V7C21.25 4.66 19.34 2.75 17 2.75H16C15.59 2.75 15.25 2.41 15.25 2C15.25 1.59 15.59 1.25 16 1.25H17C20.17 1.25 22.75 3.83 22.75 7ZM1.25 8V7C1.25 3.83 3.83 1.25 7 1.25H8C8.41 1.25 8.75 1.59 8.75 2C8.75 2.41 8.41 2.75 8 2.75H7C4.66 2.75 2.75 4.66 2.75 7V8C2.75 8.41 2.41 8.75 2 8.75C1.59 8.75 1.25 8.41 1.25 8ZM14.5 11.75C15.74 11.75 16.75 10.74 16.75 9.5C16.75 8.26 15.74 7.25 14.5 7.25C13.26 7.25 12.25 8.26 12.25 9.5C12.25 10.74 13.26 11.75 14.5 11.75ZM14.5 8.75C14.91 8.75 15.25 9.09 15.25 9.5C15.25 9.91 14.91 10.25 14.5 10.25C14.09 10.25 13.75 9.91 13.75 9.5C13.75 9.09 14.09 8.75 14.5 8.75ZM6.47 15.47L9.47 12.47C9.76 12.18 10.24 12.18 10.53 12.47L13 14.94L14.47 13.47C14.76 13.18 15.24 13.18 15.53 13.47L17.53 15.47C17.82 15.76 17.82 16.24 17.53 16.53C17.38 16.68 17.19 16.75 17 16.75C16.81 16.75 16.62 16.68 16.47 16.53L15 15.06L13.53 16.53C13.24 16.82 12.76 16.82 12.47 16.53L10 14.06L7.53 16.53C7.24 16.82 6.76 16.82 6.47 16.53C6.18 16.24 6.18 15.76 6.47 15.47Z"></path></svg>',
  "toolbox-longtext-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M13 1.25H3C2.04 1.25 1.25 2.04 1.25 3V13C1.25 13.96 2.04 14.75 3 14.75H13C13.96 14.75 14.75 13.96 14.75 13V3C14.75 2.04 13.96 1.25 13 1.25ZM13.25 13C13.25 13.14 13.14 13.25 13 13.25H3C2.86 13.25 2.75 13.14 2.75 13V3C2.75 2.86 2.86 2.75 3 2.75H13C13.14 2.75 13.25 2.86 13.25 3V13ZM11.75 5C11.75 5.41 11.41 5.75 11 5.75H5C4.59 5.75 4.25 5.41 4.25 5C4.25 4.59 4.59 4.25 5 4.25H11C11.41 4.25 11.75 4.59 11.75 5ZM11.75 8C11.75 8.41 11.41 8.75 11 8.75H5C4.59 8.75 4.25 8.41 4.25 8C4.25 7.59 4.59 7.25 5 7.25H11C11.41 7.25 11.75 7.59 11.75 8ZM8.75 11C8.75 11.41 8.41 11.75 8 11.75H5C4.59 11.75 4.25 11.41 4.25 11C4.25 10.59 4.59 10.25 5 10.25H8C8.41 10.25 8.75 10.59 8.75 11Z"></path></svg>',
  "toolbox-longtext-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M19 4.25H5C3.48 4.25 2.25 5.48 2.25 7V17C2.25 18.52 3.48 19.75 5 19.75H19C20.52 19.75 21.75 18.52 21.75 17V7C21.75 5.48 20.52 4.25 19 4.25ZM20.25 17C20.25 17.69 19.69 18.25 19 18.25H5C4.31 18.25 3.75 17.69 3.75 17V7C3.75 6.31 4.31 5.75 5 5.75H19C19.69 5.75 20.25 6.31 20.25 7V17ZM17.75 9C17.75 9.41 17.41 9.75 17 9.75H7C6.59 9.75 6.25 9.41 6.25 9C6.25 8.59 6.59 8.25 7 8.25H17C17.41 8.25 17.75 8.59 17.75 9ZM17.75 12C17.75 12.41 17.41 12.75 17 12.75H7C6.59 12.75 6.25 12.41 6.25 12C6.25 11.59 6.59 11.25 7 11.25H17C17.41 11.25 17.75 11.59 17.75 12ZM12.75 15C12.75 15.41 12.41 15.75 12 15.75H7C6.59 15.75 6.25 15.41 6.25 15C6.25 14.59 6.59 14.25 7 14.25H12C12.41 14.25 12.75 14.59 12.75 15Z"></path></svg>',
  "toolbox-matrix-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M11.5 7.75C13.29 7.75 14.75 6.29 14.75 4.5C14.75 2.71 13.29 1.25 11.5 1.25C9.71 1.25 8.25 2.71 8.25 4.5C8.25 6.29 9.71 7.75 11.5 7.75ZM11.5 2.75C12.46 2.75 13.25 3.54 13.25 4.5C13.25 5.46 12.46 6.25 11.5 6.25C10.54 6.25 9.75 5.46 9.75 4.5C9.75 3.54 10.54 2.75 11.5 2.75ZM11.5 5.75C12.19 5.75 12.75 5.19 12.75 4.5C12.75 3.81 12.19 3.25 11.5 3.25C10.81 3.25 10.25 3.81 10.25 4.5C10.25 5.19 10.81 5.75 11.5 5.75ZM11.5 4.25C11.64 4.25 11.75 4.36 11.75 4.5C11.75 4.78 11.25 4.78 11.25 4.5C11.25 4.36 11.36 4.25 11.5 4.25ZM4.5 1.25C2.71 1.25 1.25 2.71 1.25 4.5C1.25 6.29 2.71 7.75 4.5 7.75C6.29 7.75 7.75 6.29 7.75 4.5C7.75 2.71 6.29 1.25 4.5 1.25ZM4.5 6.25C3.54 6.25 2.75 5.46 2.75 4.5C2.75 3.54 3.54 2.75 4.5 2.75C5.46 2.75 6.25 3.54 6.25 4.5C6.25 5.46 5.46 6.25 4.5 6.25ZM4.5 8.25C2.71 8.25 1.25 9.71 1.25 11.5C1.25 13.29 2.71 14.75 4.5 14.75C6.29 14.75 7.75 13.29 7.75 11.5C7.75 9.71 6.29 8.25 4.5 8.25ZM4.5 13.25C3.54 13.25 2.75 12.46 2.75 11.5C2.75 10.54 3.54 9.75 4.5 9.75C5.46 9.75 6.25 10.54 6.25 11.5C6.25 12.46 5.46 13.25 4.5 13.25ZM4.5 10.25C3.81 10.25 3.25 10.81 3.25 11.5C3.25 12.19 3.81 12.75 4.5 12.75C5.19 12.75 5.75 12.19 5.75 11.5C5.75 10.81 5.19 10.25 4.5 10.25ZM4.25 11.5C4.25 11.36 4.36 11.25 4.5 11.25C4.64 11.25 4.75 11.36 4.75 11.5C4.75 11.78 4.25 11.78 4.25 11.5ZM11.5 8.25C9.71 8.25 8.25 9.71 8.25 11.5C8.25 13.29 9.71 14.75 11.5 14.75C13.29 14.75 14.75 13.29 14.75 11.5C14.75 9.71 13.29 8.25 11.5 8.25ZM11.5 13.25C10.54 13.25 9.75 12.46 9.75 11.5C9.75 10.54 10.54 9.75 11.5 9.75C12.46 9.75 13.25 10.54 13.25 11.5C13.25 12.46 12.46 13.25 11.5 13.25Z"></path></svg>',
  "toolbox-matrix-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M6.5 2.25C4.16 2.25 2.25 4.16 2.25 6.5C2.25 8.84 4.16 10.75 6.5 10.75C8.84 10.75 10.75 8.84 10.75 6.5C10.75 4.16 8.84 2.25 6.5 2.25ZM6.5 9.25C4.98 9.25 3.75 8.02 3.75 6.5C3.75 4.98 4.98 3.75 6.5 3.75C8.02 3.75 9.25 4.98 9.25 6.5C9.25 8.02 8.02 9.25 6.5 9.25ZM17.5 10.75C19.84 10.75 21.75 8.84 21.75 6.5C21.75 4.16 19.84 2.25 17.5 2.25C15.16 2.25 13.25 4.16 13.25 6.5C13.25 8.84 15.16 10.75 17.5 10.75ZM17.5 3.75C19.02 3.75 20.25 4.98 20.25 6.5C20.25 8.02 19.02 9.25 17.5 9.25C15.98 9.25 14.75 8.02 14.75 6.5C14.75 4.98 15.98 3.75 17.5 3.75ZM6.5 13.25C4.16 13.25 2.25 15.16 2.25 17.5C2.25 19.84 4.16 21.75 6.5 21.75C8.84 21.75 10.75 19.84 10.75 17.5C10.75 15.16 8.84 13.25 6.5 13.25ZM6.5 20.25C4.98 20.25 3.75 19.02 3.75 17.5C3.75 15.98 4.98 14.75 6.5 14.75C8.02 14.75 9.25 15.98 9.25 17.5C9.25 19.02 8.02 20.25 6.5 20.25ZM17.5 13.25C15.16 13.25 13.25 15.16 13.25 17.5C13.25 19.84 15.16 21.75 17.5 21.75C19.84 21.75 21.75 19.84 21.75 17.5C21.75 15.16 19.84 13.25 17.5 13.25ZM17.5 20.25C15.98 20.25 14.75 19.02 14.75 17.5C14.75 15.98 15.98 14.75 17.5 14.75C19.02 14.75 20.25 15.98 20.25 17.5C20.25 19.02 19.02 20.25 17.5 20.25ZM16 6.5C16 5.67 16.67 5 17.5 5C18.33 5 19 5.67 19 6.5C19 7.33 18.33 8 17.5 8C16.67 8 16 7.33 16 6.5ZM8 17.5C8 18.33 7.33 19 6.5 19C5.67 19 5 18.33 5 17.5C5 16.67 5.67 16 6.5 16C7.33 16 8 16.67 8 17.5Z"></path></svg>',
  "toolbox-multimatrix-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M13 1.25H3C2.04 1.25 1.25 2.04 1.25 3V13C1.25 13.96 2.04 14.75 3 14.75H13C13.96 14.75 14.75 13.96 14.75 13V3C14.75 2.04 13.96 1.25 13 1.25ZM13.25 3V7.25H8.75V2.75H13C13.14 2.75 13.25 2.86 13.25 3ZM3 2.75H7.25V7.25H2.75V3C2.75 2.86 2.86 2.75 3 2.75ZM2.75 13V8.75H7.25V13.25H3C2.86 13.25 2.75 13.14 2.75 13ZM13 13.25H8.75V8.75H13.25V13C13.25 13.14 13.14 13.25 13 13.25Z"></path></svg>',
  "toolbox-multimatrix-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M19 2.25H5C3.48 2.25 2.25 3.48 2.25 5V19C2.25 20.52 3.48 21.75 5 21.75H19C20.52 21.75 21.75 20.52 21.75 19V5C21.75 3.48 20.52 2.25 19 2.25ZM9.75 14.25V9.75H14.25V14.25H9.75ZM14.25 15.75V20.25H9.75V15.75H14.25ZM3.75 9.75H8.25V14.25H3.75V9.75ZM9.75 8.25V3.75H14.25V8.25H9.75ZM15.75 9.75H20.25V14.25H15.75V9.75ZM20.25 5V8.25H15.75V3.75H19C19.69 3.75 20.25 4.31 20.25 5ZM5 3.75H8.25V8.25H3.75V5C3.75 4.31 4.31 3.75 5 3.75ZM3.75 19V15.75H8.25V20.25H5C4.31 20.25 3.75 19.69 3.75 19ZM19 20.25H15.75V15.75H20.25V19C20.25 19.69 19.69 20.25 19 20.25Z"></path></svg>',
  "toolbox-multipletext-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M13 2.25H3C2.04 2.25 1.25 3.04 1.25 4V6C1.25 6.96 2.04 7.75 3 7.75H13C13.96 7.75 14.75 6.96 14.75 6V4C14.75 3.04 13.96 2.25 13 2.25ZM13.25 6C13.25 6.14 13.14 6.25 13 6.25H3C2.86 6.25 2.75 6.14 2.75 6V4C2.75 3.86 2.86 3.75 3 3.75H13C13.14 3.75 13.25 3.86 13.25 4V6ZM8.75 5C8.75 5.41 8.41 5.75 8 5.75H5C4.59 5.75 4.25 5.41 4.25 5C4.25 4.59 4.59 4.25 5 4.25H8C8.41 4.25 8.75 4.59 8.75 5ZM13 8.25H3C2.04 8.25 1.25 9.04 1.25 10V12C1.25 12.96 2.04 13.75 3 13.75H13C13.96 13.75 14.75 12.96 14.75 12V10C14.75 9.04 13.96 8.25 13 8.25ZM13.25 12C13.25 12.14 13.14 12.25 13 12.25H3C2.86 12.25 2.75 12.14 2.75 12V10C2.75 9.86 2.86 9.75 3 9.75H13C13.14 9.75 13.25 9.86 13.25 10V12ZM10.75 11C10.75 11.41 10.41 11.75 10 11.75H5C4.59 11.75 4.25 11.41 4.25 11C4.25 10.59 4.59 10.25 5 10.25H10C10.41 10.25 10.75 10.59 10.75 11Z"></path></svg>',
  "toolbox-multipletext-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M18 3.25H6C4.48 3.25 3.25 4.48 3.25 6V8C3.25 9.52 4.48 10.75 6 10.75H18C19.52 10.75 20.75 9.52 20.75 8V6C20.75 4.48 19.52 3.25 18 3.25ZM19.25 8C19.25 8.69 18.69 9.25 18 9.25H6C5.31 9.25 4.75 8.69 4.75 8V6C4.75 5.31 5.31 4.75 6 4.75H18C18.69 4.75 19.25 5.31 19.25 6V8ZM18 13.25H6C4.48 13.25 3.25 14.48 3.25 16V18C3.25 19.52 4.48 20.75 6 20.75H18C19.52 20.75 20.75 19.52 20.75 18V16C20.75 14.48 19.52 13.25 18 13.25ZM19.25 18C19.25 18.69 18.69 19.25 18 19.25H6C5.31 19.25 4.75 18.69 4.75 18V16C4.75 15.31 5.31 14.75 6 14.75H18C18.69 14.75 19.25 15.31 19.25 16V18ZM12.75 7C12.75 7.41 12.41 7.75 12 7.75H7C6.59 7.75 6.25 7.41 6.25 7C6.25 6.59 6.59 6.25 7 6.25H12C12.41 6.25 12.75 6.59 12.75 7ZM15.75 17C15.75 17.41 15.41 17.75 15 17.75H7C6.59 17.75 6.25 17.41 6.25 17C6.25 16.59 6.59 16.25 7 16.25H15C15.41 16.25 15.75 16.59 15.75 17Z"></path></svg>',
  "toolbox-panel-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M13 14.75H3C2.04 14.75 1.25 13.96 1.25 13V3C1.25 2.04 2.04 1.25 3 1.25H13C13.96 1.25 14.75 2.04 14.75 3V13C14.75 13.96 13.96 14.75 13 14.75ZM3 2.75C2.86 2.75 2.75 2.86 2.75 3V13C2.75 13.14 2.86 13.25 3 13.25H13C13.14 13.25 13.25 13.14 13.25 13V3C13.25 2.86 13.14 2.75 13 2.75H3Z"></path></svg>',
  "toolbox-panel-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M18 20.75H6C4.48 20.75 3.25 19.52 3.25 18V6C3.25 4.48 4.48 3.25 6 3.25H18C19.52 3.25 20.75 4.48 20.75 6V18C20.75 19.52 19.52 20.75 18 20.75ZM6 4.75C5.31 4.75 4.75 5.31 4.75 6V18C4.75 18.69 5.31 19.25 6 19.25H18C18.69 19.25 19.25 18.69 19.25 18V6C19.25 5.31 18.69 4.75 18 4.75H6Z"></path></svg>',
  "toolbox-radiogroup-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M8 1.25C4.28 1.25 1.25 4.28 1.25 8C1.25 11.72 4.28 14.75 8 14.75C11.72 14.75 14.75 11.72 14.75 8C14.75 4.28 11.72 1.25 8 1.25ZM8 13.25C5.11 13.25 2.75 10.89 2.75 8C2.75 5.11 5.11 2.75 8 2.75C10.89 2.75 13.25 5.11 13.25 8C13.25 10.89 10.89 13.25 8 13.25ZM8 5.25C6.48 5.25 5.25 6.48 5.25 8C5.25 9.52 6.48 10.75 8 10.75C9.52 10.75 10.75 9.52 10.75 8C10.75 6.48 9.52 5.25 8 5.25ZM8 9.25C7.31 9.25 6.75 8.69 6.75 8C6.75 7.31 7.31 6.75 8 6.75C8.69 6.75 9.25 7.31 9.25 8C9.25 8.69 8.69 9.25 8 9.25Z"></path></svg>',
  "toolbox-radiogroup-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 21.75C6.62 21.75 2.25 17.38 2.25 12C2.25 6.62 6.62 2.25 12 2.25C17.38 2.25 21.75 6.62 21.75 12C21.75 17.38 17.38 21.75 12 21.75ZM12 3.75C7.45 3.75 3.75 7.45 3.75 12C3.75 16.55 7.45 20.25 12 20.25C16.55 20.25 20.25 16.55 20.25 12C20.25 7.45 16.55 3.75 12 3.75ZM12 14.75C10.48 14.75 9.25 13.52 9.25 12C9.25 10.48 10.48 9.25 12 9.25C13.52 9.25 14.75 10.48 14.75 12C14.75 13.52 13.52 14.75 12 14.75ZM12 10.75C11.31 10.75 10.75 11.31 10.75 12C10.75 12.69 11.31 13.25 12 13.25C12.69 13.25 13.25 12.69 13.25 12C13.25 11.31 12.69 10.75 12 10.75Z"></path></svg>',
  "toolbox-ranking-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.75 2C14.75 2.41 14.41 2.75 14 2.75H2C1.59 2.75 1.25 2.41 1.25 2C1.25 1.59 1.59 1.25 2 1.25H14C14.41 1.25 14.75 1.59 14.75 2ZM12 4.25H2C1.59 4.25 1.25 4.59 1.25 5C1.25 5.41 1.59 5.75 2 5.75H12C12.41 5.75 12.75 5.41 12.75 5C12.75 4.59 12.41 4.25 12 4.25ZM10 7.25H2C1.59 7.25 1.25 7.59 1.25 8C1.25 8.41 1.59 8.75 2 8.75H10C10.41 8.75 10.75 8.41 10.75 8C10.75 7.59 10.41 7.25 10 7.25ZM8 10.25H2C1.59 10.25 1.25 10.59 1.25 11C1.25 11.41 1.59 11.75 2 11.75H8C8.41 11.75 8.75 11.41 8.75 11C8.75 10.59 8.41 10.25 8 10.25ZM6 13.25H2C1.59 13.25 1.25 13.59 1.25 14C1.25 14.41 1.59 14.75 2 14.75H6C6.41 14.75 6.75 14.41 6.75 14C6.75 13.59 6.41 13.25 6 13.25Z"></path></svg>',
  "toolbox-ranking-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M8 20.75H4C3.59 20.75 3.25 20.41 3.25 20C3.25 19.59 3.59 19.25 4 19.25H8C8.41 19.25 8.75 19.59 8.75 20C8.75 20.41 8.41 20.75 8 20.75ZM11.75 16C11.75 15.59 11.41 15.25 11 15.25H4C3.59 15.25 3.25 15.59 3.25 16C3.25 16.41 3.59 16.75 4 16.75H11C11.41 16.75 11.75 16.41 11.75 16ZM14.75 12C14.75 11.59 14.41 11.25 14 11.25H4C3.59 11.25 3.25 11.59 3.25 12C3.25 12.41 3.59 12.75 4 12.75H14C14.41 12.75 14.75 12.41 14.75 12ZM17.75 8C17.75 7.59 17.41 7.25 17 7.25H4C3.59 7.25 3.25 7.59 3.25 8C3.25 8.41 3.59 8.75 4 8.75H17C17.41 8.75 17.75 8.41 17.75 8ZM20.75 4C20.75 3.59 20.41 3.25 20 3.25H4C3.59 3.25 3.25 3.59 3.25 4C3.25 4.41 3.59 4.75 4 4.75H20C20.41 4.75 20.75 4.41 20.75 4Z"></path></svg>',
  "toolbox-rating-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_22761_58146)"><path d="M11.5406 15.23C11.2506 15.23 10.9506 15.15 10.6806 15L8.00057 13.49L5.32057 15C4.72057 15.34 3.99057 15.3 3.44057 14.89C2.88057 14.48 2.62057 13.81 2.75057 13.13L3.35057 10.08L1.06057 7.97C0.560569 7.5 0.370569 6.8 0.590569 6.15C0.800569 5.49 1.36057 5.04 2.05057 4.96L5.12057 4.59L6.41057 1.78C6.70057 1.15 7.31057 0.760002 8.00057 0.760002C8.69057 0.760002 9.30057 1.15 9.59057 1.78L10.8806 4.59L13.9506 4.96C14.6306 5.04 15.1906 5.5 15.4106 6.15C15.6206 6.81 15.4406 7.5 14.9406 7.97L12.6606 10.09L13.2606 13.14C13.3906 13.82 13.1306 14.49 12.5706 14.9C12.2606 15.12 11.9006 15.23 11.5506 15.23H11.5406ZM7.99057 11.88C8.12057 11.88 8.24057 11.91 8.36057 11.98L11.4106 13.7C11.5306 13.77 11.6306 13.72 11.6806 13.68C11.7306 13.64 11.8006 13.57 11.7806 13.43L11.1006 9.97C11.0506 9.72 11.1306 9.45 11.3206 9.28L13.9006 6.88C14.0006 6.79 13.9806 6.68 13.9706 6.62C13.9606 6.56 13.9006 6.47 13.7606 6.45L10.2806 6.03C10.0206 6 9.80057 5.84 9.69057 5.6L8.23057 2.41C8.17057 2.28 8.06057 2.26 8.00057 2.26C7.94057 2.26 7.83057 2.28 7.77057 2.41L6.31057 5.6C6.20057 5.84 5.98057 6 5.72057 6.03L2.24057 6.45C2.10057 6.47 2.05057 6.56 2.03057 6.62C2.01057 6.68 1.99057 6.79 2.10057 6.88L4.68057 9.28C4.87057 9.46 4.96057 9.72 4.90057 9.97L4.22057 13.43C4.19057 13.57 4.27057 13.64 4.32057 13.68C4.37057 13.72 4.47057 13.76 4.59057 13.7L7.64057 11.98C7.75057 11.92 7.88057 11.88 8.01057 11.88H7.99057Z"></path></g><defs><clipPath id="clip0_22761_58146"><rect width="16" height="16" fill="white"></rect></clipPath></defs></svg>',
  "toolbox-rating-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M17.2532 21.7227C16.9432 21.7227 16.6332 21.6427 16.3432 21.4827L12.0032 19.0327L7.66319 21.4827C7.02319 21.8427 6.26319 21.8027 5.66319 21.3727C5.07319 20.9427 4.79319 20.2327 4.93319 19.5127L5.90319 14.5827L2.23319 11.1627C1.70319 10.6627 1.50319 9.9227 1.73319 9.2327C1.96319 8.5427 2.55319 8.0527 3.27319 7.9627L8.23319 7.3727L10.3232 2.8227C10.6332 2.1527 11.2732 1.7427 12.0032 1.7427C12.7332 1.7427 13.3832 2.1527 13.6832 2.8227L15.7732 7.3727L20.7332 7.9627C21.4532 8.0527 22.0532 8.5327 22.2732 9.2327C22.5032 9.9227 22.3132 10.6627 21.7732 11.1627L18.1032 14.5827L19.0732 19.5127C19.2132 20.2327 18.9332 20.9427 18.3432 21.3727C18.0132 21.6127 17.6332 21.7327 17.2632 21.7327L17.2532 21.7227ZM11.9932 17.4227C12.1232 17.4227 12.2432 17.4527 12.3632 17.5227L17.0732 20.1727C17.2532 20.2727 17.4032 20.1927 17.4532 20.1527C17.5032 20.1127 17.6332 20.0027 17.5932 19.8027L16.5432 14.4627C16.4932 14.2127 16.5732 13.9427 16.7632 13.7727L20.7432 10.0727C20.8932 9.9327 20.8632 9.7727 20.8332 9.7027C20.8132 9.6427 20.7432 9.4827 20.5432 9.4627L15.1732 8.8227C14.9132 8.7927 14.6932 8.6327 14.5832 8.3927L12.3232 3.4627C12.2432 3.2727 12.0732 3.2527 12.0032 3.2527C11.9332 3.2527 11.7632 3.2727 11.6832 3.4627L9.42319 8.3927C9.31319 8.6327 9.09319 8.7927 8.83319 8.8227L3.46319 9.4627C3.26319 9.4827 3.19319 9.6427 3.17319 9.7027C3.15319 9.7627 3.12319 9.9327 3.26319 10.0727L7.24319 13.7727C7.43319 13.9527 7.52319 14.2127 7.46319 14.4627L6.41319 19.8027C6.37319 20.0027 6.49319 20.1127 6.55319 20.1527C6.61319 20.1927 6.75319 20.2727 6.93319 20.1727L11.6432 17.5227C11.7532 17.4627 11.8832 17.4227 12.0132 17.4227H11.9932Z"></path></svg>',
  "toolbox-signature-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.52 7.47L8.52 1.47C7.68 0.629996 6.3 0.629996 5.46 1.47C4.8 2.13 4.66 3.1 5.03 3.9L3.4 5.53C2.68 6.25 2.2 7.21 2.06 8.22L1.25 13.9C1.25 13.9 1.25 13.93 1.25 13.95C1.25 14.03 1.25 14.1 1.27 14.18C1.27 14.21 1.27 14.24 1.29 14.27C1.33 14.37 1.38 14.47 1.46 14.55C1.53 14.62 1.61 14.68 1.71 14.71C1.8 14.75 1.9 14.77 1.99 14.77C2.03 14.77 2.06 14.77 2.1 14.77L7.78 13.96C8.79 13.82 9.75 13.34 10.47 12.62L12.1 10.99C12.39 11.12 12.69 11.19 13 11.19C13.55 11.19 14.11 10.98 14.53 10.56C15.37 9.72 15.37 8.34 14.53 7.5L14.52 7.47ZM9.4 11.53C8.91 12.02 8.25 12.35 7.56 12.45L4.11 12.94L5.52 11.53C5.52 11.53 5.52 11.53 5.52 11.52C5.82 11.66 6.14 11.75 6.49 11.75C7.73 11.75 8.74 10.74 8.74 9.5C8.74 8.26 7.73 7.25 6.49 7.25C5.25 7.25 4.24 8.26 4.24 9.5C4.24 9.84 4.32 10.17 4.46 10.46C4.46 10.46 4.46 10.46 4.45 10.46L3.04 11.87L3.53 8.42C3.63 7.73 3.95 7.08 4.45 6.58L5.98 5.05L10.92 9.99L9.39 11.52L9.4 11.53ZM5.75 9.5C5.75 9.09 6.09 8.75 6.5 8.75C6.91 8.75 7.25 9.09 7.25 9.5C7.25 9.91 6.91 10.25 6.5 10.25C6.09 10.25 5.75 9.91 5.75 9.5ZM13.46 9.47C13.21 9.72 12.77 9.72 12.52 9.47L6.52 3.47C6.39 3.34 6.33 3.18 6.33 3C6.33 2.82 6.4 2.66 6.52 2.53C6.64 2.4 6.81 2.34 6.99 2.34C7.17 2.34 7.33 2.41 7.46 2.53L13.46 8.53C13.59 8.66 13.65 8.82 13.65 9C13.65 9.18 13.58 9.34 13.46 9.47Z"></path></svg>',
  "toolbox-signature-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M16.035 16.03L18.105 13.96C18.395 14.09 18.695 14.16 19.005 14.16C19.555 14.16 20.115 13.95 20.535 13.53C21.375 12.69 21.375 11.31 20.535 10.47L12.535 2.47C11.695 1.63 10.315 1.63 9.47501 2.47C8.81501 3.13 8.67501 4.1 9.04501 4.9L6.97501 6.97C5.89501 8.04 5.12501 9.39 4.72501 10.85L2.27501 19.81C2.27501 19.81 2.27501 19.85 2.27501 19.87C2.25501 19.96 2.25501 20.05 2.27501 20.14C2.27501 20.17 2.27501 20.2 2.29501 20.23C2.33501 20.34 2.38501 20.45 2.47501 20.54C2.54501 20.61 2.63501 20.67 2.72501 20.7C2.81501 20.74 2.91501 20.76 3.00501 20.76C3.07501 20.76 3.13501 20.76 3.20501 20.73L12.155 18.29C13.625 17.89 14.965 17.11 16.035 16.04V16.03ZM10.535 3.53C10.665 3.4 10.825 3.34 11.005 3.34C11.185 3.34 11.345 3.41 11.475 3.53L19.475 11.53C19.605 11.66 19.665 11.82 19.665 12C19.665 12.18 19.595 12.34 19.475 12.47C19.225 12.72 18.785 12.72 18.535 12.47L10.535 4.47C10.405 4.34 10.345 4.18 10.345 4C10.345 3.82 10.415 3.66 10.535 3.53ZM5.52501 18.54L8.52501 15.54C8.52501 15.54 8.59501 15.44 8.62501 15.38C9.02501 15.61 9.49501 15.76 9.99501 15.76C11.515 15.76 12.745 14.53 12.745 13.01C12.745 11.49 11.515 10.26 9.99501 10.26C8.47501 10.26 7.24501 11.49 7.24501 13.01C7.24501 13.51 7.38501 13.97 7.62501 14.38C7.57501 14.41 7.51501 14.44 7.46501 14.48L4.46501 17.48L6.16501 11.25C6.49501 10.04 7.14501 8.92 8.03501 8.03L10.005 6.06L16.945 13L14.975 14.97C14.085 15.86 12.975 16.51 11.755 16.84L5.52501 18.54ZM8.75501 13C8.75501 12.31 9.31501 11.75 10.005 11.75C10.695 11.75 11.255 12.31 11.255 13C11.255 13.69 10.695 14.25 10.005 14.25C9.31501 14.25 8.75501 13.69 8.75501 13ZM21.275 21.83C19.815 22.4 18.835 22.76 18.135 22.76C17.765 22.76 17.485 22.66 17.255 22.44C16.875 22.07 16.815 21.61 16.975 20.88C15.475 22.07 14.735 22.28 14.145 22.17C13.545 22.06 13.275 21.6 13.125 21.31C12.945 21.42 12.625 21.66 12.105 22.14C11.805 22.42 11.325 22.41 11.045 22.1C10.765 21.8 10.775 21.32 11.085 21.04C12.235 19.97 12.885 19.61 13.505 19.73C14.085 19.84 14.315 20.32 14.445 20.58C14.455 20.61 14.475 20.65 14.495 20.68C14.765 20.61 15.615 20.22 17.965 18.04C18.215 17.81 18.595 17.77 18.885 17.96C19.175 18.15 19.295 18.5 19.195 18.83L19.035 19.3C18.785 20.04 18.535 20.8 18.445 21.24C19.025 21.11 20.155 20.68 20.755 20.45C21.145 20.3 21.575 20.49 21.725 20.88C21.875 21.27 21.685 21.7 21.295 21.85L21.275 21.83Z"></path></svg>',
  "toolbox-singleline-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M10.75 14C10.75 14.41 10.41 14.75 10 14.75H9C8.21 14.75 7.5 14.41 7 13.88C6.5 14.42 5.79 14.75 5 14.75H4C3.59 14.75 3.25 14.41 3.25 14C3.25 13.59 3.59 13.25 4 13.25H5C5.69 13.25 6.25 12.69 6.25 12V4C6.25 3.31 5.69 2.75 5 2.75H4C3.59 2.75 3.25 2.41 3.25 2C3.25 1.59 3.59 1.25 4 1.25H5C5.79 1.25 6.5 1.59 7 2.12C7.5 1.58 8.21 1.25 9 1.25H10C10.41 1.25 10.75 1.59 10.75 2C10.75 2.41 10.41 2.75 10 2.75H9C8.31 2.75 7.75 3.31 7.75 4V12C7.75 12.69 8.31 13.25 9 13.25H10C10.41 13.25 10.75 13.59 10.75 14ZM4.75 11C4.75 10.59 4.41 10.25 4 10.25H3C2.86 10.25 2.75 10.14 2.75 10V6C2.75 5.86 2.86 5.75 3 5.75H4C4.41 5.75 4.75 5.41 4.75 5C4.75 4.59 4.41 4.25 4 4.25H3C2.04 4.25 1.25 5.04 1.25 6V10C1.25 10.96 2.04 11.75 3 11.75H4C4.41 11.75 4.75 11.41 4.75 11ZM13 4.25H10C9.59 4.25 9.25 4.59 9.25 5C9.25 5.41 9.59 5.75 10 5.75H13C13.14 5.75 13.25 5.86 13.25 6V10C13.25 10.14 13.14 10.25 13 10.25H10C9.59 10.25 9.25 10.59 9.25 11C9.25 11.41 9.59 11.75 10 11.75H13C13.96 11.75 14.75 10.96 14.75 10V6C14.75 5.04 13.96 4.25 13 4.25Z"></path></svg>',
  "toolbox-singleline-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20.75 10V14C20.75 15.52 19.52 16.75 18 16.75H13C12.59 16.75 12.25 16.41 12.25 16C12.25 15.59 12.59 15.25 13 15.25H18C18.69 15.25 19.25 14.69 19.25 14V10C19.25 9.31 18.69 8.75 18 8.75H13C12.59 8.75 12.25 8.41 12.25 8C12.25 7.59 12.59 7.25 13 7.25H18C19.52 7.25 20.75 8.48 20.75 10ZM7.75 16C7.75 15.59 7.41 15.25 7 15.25H6C5.31 15.25 4.75 14.69 4.75 14V10C4.75 9.31 5.31 8.75 6 8.75H7C7.41 8.75 7.75 8.41 7.75 8C7.75 7.59 7.41 7.25 7 7.25H6C4.48 7.25 3.25 8.48 3.25 10V14C3.25 15.52 4.48 16.75 6 16.75H7C7.41 16.75 7.75 16.41 7.75 16ZM13 19.25H12C11.31 19.25 10.75 18.69 10.75 18V6C10.75 5.31 11.31 4.75 12 4.75H13C13.41 4.75 13.75 4.41 13.75 4C13.75 3.59 13.41 3.25 13 3.25H12C11.21 3.25 10.5 3.59 10 4.12C9.5 3.58 8.79 3.25 8 3.25H7C6.59 3.25 6.25 3.59 6.25 4C6.25 4.41 6.59 4.75 7 4.75H8C8.69 4.75 9.25 5.31 9.25 6V18C9.25 18.69 8.69 19.25 8 19.25H7C6.59 19.25 6.25 19.59 6.25 20C6.25 20.41 6.59 20.75 7 20.75H8C8.79 20.75 9.5 20.41 10 19.88C10.5 20.42 11.21 20.75 12 20.75H13C13.41 20.75 13.75 20.41 13.75 20C13.75 19.59 13.41 19.25 13 19.25Z"></path></svg>',
  "toolbox-tagbox-16x16": '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M13 1.25H3C2.04 1.25 1.25 2.04 1.25 3V13C1.25 13.96 2.04 14.75 3 14.75H13C13.96 14.75 14.75 13.96 14.75 13V3C14.75 2.04 13.96 1.25 13 1.25ZM2.75 3C2.75 2.86 2.86 2.75 3 2.75H13C13.14 2.75 13.25 2.86 13.25 3V5.25H2.75V3ZM13.25 13C13.25 13.14 13.14 13.25 13 13.25H3C2.86 13.25 2.75 13.14 2.75 13V6.75H13.25V13ZM7.25 9C7.25 8.59 7.59 8.25 8 8.25H11C11.41 8.25 11.75 8.59 11.75 9C11.75 9.41 11.41 9.75 11 9.75H8C7.59 9.75 7.25 9.41 7.25 9ZM7.25 11C7.25 10.59 7.59 10.25 8 10.25H11C11.41 10.25 11.75 10.59 11.75 11C11.75 11.41 11.41 11.75 11 11.75H8C7.59 11.75 7.25 11.41 7.25 11ZM4.47 9.53C4.33 9.39 4.25 9.2 4.25 9C4.25 8.9 4.27 8.81 4.31 8.71C4.35 8.62 4.4 8.54 4.47 8.47C4.68 8.26 5.01 8.19 5.29 8.31C5.38 8.35 5.46 8.4 5.53 8.47C5.6 8.54 5.66 8.62 5.69 8.71C5.73 8.81 5.75 8.9 5.75 9C5.75 9.2 5.67 9.39 5.53 9.53C5.46 9.6 5.38 9.65 5.29 9.69C5.2 9.73 5.1 9.75 5 9.75C4.8 9.75 4.61 9.67 4.47 9.53ZM4.31 11.29C4.27 11.2 4.25 11.1 4.25 11C4.25 10.9 4.27 10.81 4.31 10.71C4.35 10.62 4.4 10.54 4.47 10.47C4.68 10.26 5.01 10.19 5.29 10.31C5.38 10.35 5.46 10.4 5.53 10.47C5.6 10.54 5.66 10.62 5.69 10.71C5.73 10.81 5.75 10.9 5.75 11C5.75 11.1 5.73 11.2 5.69 11.29C5.66 11.38 5.6 11.46 5.53 11.53C5.46 11.6 5.38 11.65 5.29 11.69C5.2 11.73 5.1 11.75 5 11.75C4.8 11.75 4.61 11.67 4.47 11.53C4.4 11.46 4.35 11.38 4.31 11.29ZM12.75 4C12.75 4.41 12.41 4.75 12 4.75H11C10.59 4.75 10.25 4.41 10.25 4C10.25 3.59 10.59 3.25 11 3.25H12C12.41 3.25 12.75 3.59 12.75 4Z"></path></svg>',
  "toolbox-tagbox-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M10.25 12C10.25 11.59 10.59 11.25 11 11.25H17C17.41 11.25 17.75 11.59 17.75 12C17.75 12.41 17.41 12.75 17 12.75H11C10.59 12.75 10.25 12.41 10.25 12ZM11 15.75H17C17.41 15.75 17.75 15.41 17.75 15C17.75 14.59 17.41 14.25 17 14.25H11C10.59 14.25 10.25 14.59 10.25 15C10.25 15.41 10.59 15.75 11 15.75ZM17 5.25H16C15.59 5.25 15.25 5.59 15.25 6C15.25 6.41 15.59 6.75 16 6.75H17C17.41 6.75 17.75 6.41 17.75 6C17.75 5.59 17.41 5.25 17 5.25ZM20.75 5V19C20.75 20.52 19.52 21.75 18 21.75H6C4.48 21.75 3.25 20.52 3.25 19V5C3.25 3.48 4.48 2.25 6 2.25H18C19.52 2.25 20.75 3.48 20.75 5ZM4.75 8.25H19.25V5C19.25 4.31 18.69 3.75 18 3.75H6C5.31 3.75 4.75 4.31 4.75 5V8.25ZM19.25 9.75H4.75V19C4.75 19.69 5.31 20.25 6 20.25H18C18.69 20.25 19.25 19.69 19.25 19V9.75ZM11 18.75H17C17.41 18.75 17.75 18.41 17.75 18C17.75 17.59 17.41 17.25 17 17.25H11C10.59 17.25 10.25 17.59 10.25 18C10.25 18.41 10.59 18.75 11 18.75ZM7 18.75H8C8.41 18.75 8.75 18.41 8.75 18C8.75 17.59 8.41 17.25 8 17.25H7C6.59 17.25 6.25 17.59 6.25 18C6.25 18.41 6.59 18.75 7 18.75ZM7 15.75H8C8.41 15.75 8.75 15.41 8.75 15C8.75 14.59 8.41 14.25 8 14.25H7C6.59 14.25 6.25 14.59 6.25 15C6.25 15.41 6.59 15.75 7 15.75ZM7 12.75H8C8.41 12.75 8.75 12.41 8.75 12C8.75 11.59 8.41 11.25 8 11.25H7C6.59 11.25 6.25 11.59 6.25 12C6.25 12.41 6.59 12.75 7 12.75Z"></path></svg>',
  "undo-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M19.79 18.2825C19.67 18.5725 19.39 18.7525 19.09 18.7525C19 18.7525 18.9 18.7325 18.81 18.7025C18.43 18.5425 18.24 18.1125 18.39 17.7225C19.28 15.5125 19.92 12.4925 17.94 10.6525C15.56 8.45247 10.26 8.64247 4.73001 11.0225L9.36001 13.3225C9.73001 13.5025 9.88001 13.9525 9.70001 14.3325C9.57001 14.5925 9.30001 14.7525 9.03001 14.7525C8.92001 14.7525 8.80001 14.7225 8.70001 14.6725L2.67001 11.6725C2.67001 11.6725 2.63001 11.6325 2.60001 11.6225C2.56001 11.5925 2.51001 11.5625 2.48001 11.5225C2.44001 11.4925 2.42001 11.4525 2.39001 11.4025C2.37001 11.3725 2.35001 11.3525 2.33001 11.3225C2.33001 11.3025 2.33001 11.2925 2.32001 11.2725C2.32001 11.2525 2.30001 11.2425 2.29001 11.2225C2.28001 11.1925 2.29001 11.1525 2.28001 11.1225C2.28001 11.0725 2.26001 11.0225 2.26001 10.9725C2.26001 10.9225 2.26001 10.8825 2.28001 10.8425C2.28001 10.7925 2.30001 10.7425 2.32001 10.6925C2.32001 10.6725 2.32001 10.6625 2.33001 10.6425L5.35001 4.66247C5.54001 4.29247 5.99001 4.14247 6.36001 4.33247C6.73001 4.52247 6.88001 4.97247 6.69001 5.34247L4.62001 9.45247C10.58 6.99247 16.18 6.98247 18.96 9.55247C20.4 10.8825 21.72 13.4825 19.79 18.2825Z"></path></svg>',
  "visible-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M23.3513 12.66C23.2413 12.72 23.1213 12.75 23.0013 12.75C22.7313 12.75 22.4713 12.6 22.3313 12.35C20.1913 8.28 16.2313 5.75 11.9913 5.75C7.75126 5.75 3.80126 8.28 1.66126 12.35C1.47126 12.72 1.02126 12.86 0.651255 12.66C0.281255 12.47 0.141255 12.01 0.341255 11.65C2.74126 7.09 7.21126 4.25 12.0013 4.25C16.7913 4.25 21.2613 7.09 23.6613 11.65C23.8513 12.02 23.7113 12.47 23.3513 12.66ZM12.0013 16.75C9.38126 16.75 7.25126 14.62 7.25126 12C7.25126 9.38 9.38126 7.25 12.0013 7.25C14.6213 7.25 16.7513 9.38 16.7513 12C16.7513 14.62 14.6213 16.75 12.0013 16.75ZM12.0013 15.25C13.7913 15.25 15.2513 13.79 15.2513 12C15.2513 10.21 13.7913 8.75 12.0013 8.75C10.2113 8.75 8.75126 10.21 8.75126 12C8.75126 13.79 10.2113 15.25 12.0013 15.25ZM13.0013 12C13.0013 11.45 12.5513 11 12.0013 11C11.4513 11 11.0013 11.45 11.0013 12C11.0013 12.55 11.4513 13 12.0013 13C12.5513 13 13.0013 12.55 13.0013 12ZM19.4013 14.55C17.6313 16.9 14.9313 18.25 12.0013 18.25C9.07125 18.25 6.37125 16.9 4.60125 14.55C4.35125 14.22 3.88125 14.15 3.55125 14.4C3.22126 14.65 3.15126 15.12 3.40126 15.45C5.46126 18.18 8.59126 19.75 12.0013 19.75C15.4113 19.75 18.5413 18.18 20.6013 15.45C20.8513 15.12 20.7813 14.65 20.4513 14.4C20.1213 14.15 19.6513 14.21 19.4013 14.55Z"></path></svg>',
  "wand-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M2.9975 21.75C2.8075 21.75 2.6175 21.68 2.4675 21.53C2.1775 21.24 2.1775 20.76 2.4675 20.47L10.4675 12.47C10.7575 12.18 11.2375 12.18 11.5275 12.47C11.8175 12.76 11.8175 13.24 11.5275 13.53L3.5275 21.53C3.3775 21.68 3.1875 21.75 2.9975 21.75ZM14.7475 6V3C14.7475 2.59 14.4075 2.25 13.9975 2.25C13.5875 2.25 13.2475 2.59 13.2475 3V6C13.2475 6.41 13.5875 6.75 13.9975 6.75C14.4075 6.75 14.7475 6.41 14.7475 6ZM14.7475 19V14C14.7475 13.59 14.4075 13.25 13.9975 13.25C13.5875 13.25 13.2475 13.59 13.2475 14V19C13.2475 19.41 13.5875 19.75 13.9975 19.75C14.4075 19.75 14.7475 19.41 14.7475 19ZM10.7475 10C10.7475 9.59 10.4075 9.25 9.9975 9.25H6.9975C6.5875 9.25 6.2475 9.59 6.2475 10C6.2475 10.41 6.5875 10.75 6.9975 10.75H9.9975C10.4075 10.75 10.7475 10.41 10.7475 10ZM22.7475 10C22.7475 9.59 22.4075 9.25 21.9975 9.25H17.9975C17.5875 9.25 17.2475 9.59 17.2475 10C17.2475 10.41 17.5875 10.75 17.9975 10.75H21.9975C22.4075 10.75 22.7475 10.41 22.7475 10ZM17.5275 7.53L19.4775 5.58C19.7675 5.29 19.7675 4.81 19.4775 4.52C19.1875 4.23 18.7075 4.23 18.4175 4.52L16.4675 6.47C16.1775 6.76 16.1775 7.24 16.4675 7.53C16.6175 7.68 16.8075 7.75 16.9975 7.75C17.1875 7.75 17.3775 7.68 17.5275 7.53ZM19.4775 15.48C19.7675 15.19 19.7675 14.71 19.4775 14.42L17.5275 12.47C17.2375 12.18 16.7575 12.18 16.4675 12.47C16.1775 12.76 16.1775 13.24 16.4675 13.53L18.4175 15.48C18.5675 15.63 18.7575 15.7 18.9475 15.7C19.1375 15.7 19.3275 15.63 19.4775 15.48ZM11.5275 7.53C11.8175 7.24 11.8175 6.76 11.5275 6.47L8.5275 3.47C8.2375 3.18 7.7575 3.18 7.4675 3.47C7.1775 3.76 7.1775 4.24 7.4675 4.53L10.4675 7.53C10.6175 7.68 10.8075 7.75 10.9975 7.75C11.1875 7.75 11.3775 7.68 11.5275 7.53Z"></path></svg>',
  "warning-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M21.7818 16.57L14.3518 4.40997C13.8518 3.58997 12.9718 3.08997 12.0018 3.08997C11.0318 3.08997 10.1618 3.57997 9.65175 4.40997L2.22175 16.57C1.69175 17.43 1.67175 18.47 2.17175 19.35C2.66175 20.23 3.56175 20.75 4.57175 20.75H19.4418C20.4518 20.75 21.3518 20.22 21.8418 19.35C22.3318 18.47 22.3118 17.43 21.7918 16.57H21.7818ZM20.5218 18.62C20.3018 19.02 19.8918 19.26 19.4318 19.26H4.57175C4.11175 19.26 3.70175 19.02 3.48175 18.62C3.26175 18.22 3.27175 17.75 3.50175 17.36L10.9318 5.18997C11.1618 4.80997 11.5518 4.58997 12.0018 4.58997C12.4518 4.58997 12.8318 4.80997 13.0718 5.18997L20.5018 17.35C20.7418 17.74 20.7518 18.21 20.5218 18.61V18.62ZM11.2518 12V8.99997C11.2518 8.58997 11.5918 8.24997 12.0018 8.24997C12.4118 8.24997 12.7518 8.58997 12.7518 8.99997V12C12.7518 12.41 12.4118 12.75 12.0018 12.75C11.5918 12.75 11.2518 12.41 11.2518 12ZM13.0018 16C13.0018 16.55 12.5518 17 12.0018 17C11.4518 17 11.0018 16.55 11.0018 16C11.0018 15.45 11.4518 15 12.0018 15C12.5518 15 13.0018 15.45 13.0018 16Z"></path></svg>',
  "wrench-24x24": '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M4.99752 21.8701C4.99752 21.8701 4.89752 21.8701 4.85752 21.8701C4.04752 21.8301 3.28752 21.4501 2.77752 20.8101C1.85752 19.6901 1.97752 17.9601 3.05752 16.8801L7.76752 12.1701C7.24752 10.8701 7.11752 9.4601 7.38752 8.0701C7.94752 5.2301 10.2375 2.9501 13.0775 2.3901C14.0075 2.2101 14.9475 2.2001 15.8675 2.3801C16.4875 2.5001 16.9875 2.9501 17.1775 3.5601C17.3675 4.1901 17.2075 4.8701 16.7375 5.3301L14.1275 7.9401C13.5875 8.4801 13.5075 9.3201 13.9475 9.8601C14.1975 10.1701 14.5575 10.3501 14.9475 10.3701C15.3475 10.3901 15.7175 10.2401 15.9875 9.9701L18.6875 7.2701C19.1475 6.8101 19.8275 6.6401 20.4575 6.8301C21.0675 7.0201 21.5175 7.5201 21.6375 8.1401C21.8175 9.0601 21.8075 9.9901 21.6275 10.9301C21.0675 13.7701 18.7875 16.0501 15.9475 16.6101C14.5475 16.8901 13.1475 16.7501 11.8475 16.2301L7.04752 21.0301C6.50752 21.5701 5.77752 21.8701 5.01752 21.8701H4.99752ZM14.4975 3.7501C14.1175 3.7501 13.7375 3.7901 13.3575 3.8601C11.1075 4.3001 9.29752 6.1101 8.85752 8.3601C8.60752 9.6101 8.77752 10.8701 9.32752 12.0101C9.46752 12.3001 9.40752 12.6401 9.18752 12.8701L4.11752 17.9401C3.57752 18.4801 3.49752 19.3201 3.93752 19.8601C4.18752 20.1701 4.54752 20.3501 4.93752 20.3701C5.34752 20.3901 5.70752 20.2401 5.97752 19.9701L11.1375 14.8101C11.3675 14.5801 11.7075 14.5201 11.9975 14.6701C13.1375 15.2201 14.3975 15.3901 15.6475 15.1401C17.8975 14.7001 19.7075 12.8901 20.1475 10.6401C20.2975 9.9001 20.2975 9.1501 20.1575 8.4301C20.1375 8.3501 20.0875 8.3001 20.0075 8.2701C19.9675 8.2601 19.8475 8.2301 19.7375 8.3301L17.0375 11.0301C16.4675 11.6001 15.6475 11.9001 14.8675 11.8701C14.0575 11.8301 13.2975 11.4501 12.7875 10.8101C11.8675 9.6901 11.9875 7.9601 13.0675 6.8801L15.6775 4.2701C15.7775 4.1701 15.7475 4.0401 15.7375 4.0001C15.7075 3.9201 15.6575 3.8701 15.5775 3.8501C15.2275 3.7801 14.8675 3.7501 14.5075 3.7501H14.4975Z"></path></svg>',
  "zoomin-24x24": '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M21.53 20.47L15.98 14.92C17.08 13.58 17.75 11.87 17.75 10C17.75 5.73 14.27 2.25 10 2.25C5.73 2.25 2.25 5.73 2.25 10C2.25 14.27 5.73 17.75 10 17.75C11.87 17.75 13.58 17.09 14.92 15.98L20.47 21.53C20.62 21.68 20.81 21.75 21 21.75C21.19 21.75 21.38 21.68 21.53 21.53C21.82 21.24 21.82 20.76 21.53 20.47ZM3.75 10C3.75 6.55 6.55 3.75 10 3.75C13.45 3.75 16.25 6.55 16.25 10C16.25 13.45 13.45 16.25 10 16.25C6.55 16.25 3.75 13.45 3.75 10ZM13.75 10C13.75 10.41 13.41 10.75 13 10.75H10.75V13C10.75 13.41 10.41 13.75 10 13.75C9.59 13.75 9.25 13.41 9.25 13V10.75H7C6.59 10.75 6.25 10.41 6.25 10C6.25 9.59 6.59 9.25 7 9.25H9.25V7C9.25 6.59 9.59 6.25 10 6.25C10.41 6.25 10.75 6.59 10.75 7V9.25H13C13.41 9.25 13.75 9.59 13.75 10Z"></path></svg>',
  "zoomout-24x24": '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M21.53 20.47L15.98 14.92C17.08 13.58 17.75 11.87 17.75 10C17.75 5.73 14.27 2.25 10 2.25C5.73 2.25 2.25 5.73 2.25 10C2.25 14.27 5.73 17.75 10 17.75C11.87 17.75 13.58 17.09 14.92 15.98L20.47 21.53C20.62 21.68 20.81 21.75 21 21.75C21.19 21.75 21.38 21.68 21.53 21.53C21.82 21.24 21.82 20.76 21.53 20.47ZM10 16.25C6.55 16.25 3.75 13.45 3.75 10C3.75 6.55 6.55 3.75 10 3.75C13.45 3.75 16.25 6.55 16.25 10C16.25 13.45 13.45 16.25 10 16.25ZM13.75 10C13.75 10.41 13.41 10.75 13 10.75H7C6.59 10.75 6.25 10.41 6.25 10C6.25 9.59 6.59 9.25 7 9.25H13C13.41 9.25 13.75 9.59 13.75 10Z"></path></svg>'
};
var svgBundle = {};
var iconsV1 = iconsV1Data;
var iconsV2 = iconsV2Data;
addIconsToThemeSet("v1", iconsV1);
addIconsToThemeSet("v2", iconsV2);
SvgRegistry.registerIcons(iconsV2);
var CreatorAction = class extends Action {
};
var FooterToolbarActionContainer = class extends ActionContainer {
  getDefaultCssClasses() {
    const defaultCss2 = super.getDefaultCssClasses();
    return {
      root: defaultCss2.root + " svc-toolbar sv-action-bar sv-action-bar--default-size-mode",
      item: defaultCss2.item + " svc-toolbar__item",
      itemWithTitle: defaultCss2.itemWithTitle + " svc-toolbar__item--with-text",
      itemAsIcon: defaultCss2.itemAsIcon + " svc-toolbar__item--icon",
      itemActive: defaultCss2.itemActive + " svc-toolbar__item--active",
      itemPressed: defaultCss2.itemPressed + " svc-toolbar__item--pressed",
      itemIcon: defaultCss2.itemIcon + " svc-toolbar-item__icon",
      itemTitle: defaultCss2.itemTitle + " svc-toolbar-item__title",
      itemTitleWithIcon: defaultCss2.itemTitleWithIcon + " svc-toolbar-item__title--with-icon"
    };
  }
};
var ToolbarActionContainer = class extends FooterToolbarActionContainer {
  constructor(creator) {
    super();
    this.creator = creator;
  }
  getRenderedActions() {
    let actions = this.actions;
    const expandAction = this.creator.sidebar.getExpandAction();
    var index = actions.indexOf(expandAction);
    if (index !== -1) {
      actions.splice(index, 1);
      actions.push(expandAction);
    }
    return actions;
  }
};
var CreatorEvent = class extends EventBase {
};
var SurveyCreatorModel = class extends Base {
  //ILocalizableOwner
  getMarkdownHtml(text, name) {
    return null;
  }
  getRenderer(name) {
    return null;
  }
  getRendererContext(locStr) {
    return locStr;
  }
  getProcessedText(text) {
    return text;
  }
  getLocale() {
    return this.locale;
  }
  /**
   * Specifies whether to display the Preview tab.
   *
   * Default value: `true`
   * @see activeTab
   * @see onSurveyInstanceCreated
   */
  get showPreviewTab() {
    return this.showTestSurveyTab;
  }
  set showPreviewTab(val) {
    this.showTestSurveyTab = val;
  }
  /**
   * @deprecated Use the [`inplaceEditChoiceValues`](https://surveyjs.io/survey-creator/documentation/api-reference/survey-creator#inplaceEditChoiceValues) property instead.
   */
  get inplaceEditForValues() {
    return this.inplaceEditChoiceValues;
  }
  set inplaceEditForValues(val) {
    this.inplaceEditChoiceValues = val;
  }
  get showOneCategoryInPropertyGrid() {
    return this._showOneCategoryInPropertyGrid;
  }
  set showOneCategoryInPropertyGrid(newValue) {
    this._showOneCategoryInPropertyGrid = newValue;
    Object.keys(this.plugins).forEach((name) => {
      const plugin = this.plugins[name];
      if (!!plugin && "showOneCategoryInPropertyGrid" in plugin) {
        plugin.showOneCategoryInPropertyGrid = newValue;
      }
    });
  }
  /**
   * Specifies how users navigate categories in the Property Grid.
   *
   * Accepted values:
   *
   * - `"accordion"`
   * The Property Grid displays a stacked list of categories that users can expand or collapse to reveal nested properties.
   *
   * - `"buttons"` (default)
   * The Property Grid displays the properties of a currently selected category. Users can switch between categories using buttons on the right side of the Property Grid.
   */
  get propertyGridNavigationMode() {
    return this.showOneCategoryInPropertyGrid ? "buttons" : "accordion";
  }
  set propertyGridNavigationMode(newValue) {
    this.showOneCategoryInPropertyGrid = newValue === "buttons";
  }
  get allowEditSurveyTitle() {
    return this.getPropertyValue("allowEditSurveyTitle", true);
  }
  set allowEditSurveyTitle(val) {
    this.setPropertyVisibility("survey", val, "title", "description", "logo", "logoFit", "showTitle", "logoWidth", "logoHeight");
    this.setPropertyValue("allowEditSurveyTitle", val);
    this.designerPropertyGrid && this.designerPropertyGrid.refresh();
  }
  /**
   * Specifies whether users can see and edit the survey header and related survey properties.
   *
   * Default value: `true`
   */
  get showSurveyHeader() {
    return this.allowEditSurveyTitle;
  }
  set showSurveyHeader(val) {
    this.allowEditSurveyTitle = val;
  }
  /**
   * @deprecated Use the [`showSurveyHeader`](https://surveyjs.io/survey-creator/documentation/api-reference/survey-creator#showSurveyHeader) property instead.
   */
  get showSurveyTitle() {
    return this.allowEditSurveyTitle;
  }
  set showSurveyTitle(val) {
    this.allowEditSurveyTitle = val;
  }
  get haveCommercialLicense() {
    return !!hasLicense && hasLicense(1);
  }
  set haveCommercialLicense(val) {
    console.warn("As of v1.9.101, the haveCommercialLicense property is not supported. To activate your license, use the setLicenseKey(key) method as shown on the following page: https://surveyjs.io/remove-alert-banner");
  }
  get licenseText() {
    return this.getLocString("survey.license");
  }
  slk(val) {
    slk(val);
  }
  /**
   * @deprecated Use the [`autoSaveEnabled`](https://surveyjs.io/survey-creator/documentation/api-reference/survey-creator#autoSaveEnabled) property instead.
   */
  get isAutoSave() {
    return this.autoSaveEnabled;
  }
  set isAutoSave(val) {
    this.autoSaveEnabled = val;
  }
  set startEditTitleOnQuestionAdded(value) {
    this.startEditTitleOnQuestionAddedValue = value;
  }
  get startEditTitleOnQuestionAdded() {
    return !this.isMobileView && !((this.currentOS == "iOS" || this.currentOS == "Mac OS") && this.isTouch) && !this.toolbox.searchManager.filterString && this.startEditTitleOnQuestionAddedValue;
  }
  changePageModifications(allow = false) {
    this.setPropertyVisibility("survey", allow, "pages");
    this.setPropertyVisibility("question", allow, "page");
    this.setPropertyVisibility("panel", allow, "page");
    this.showJSONEditorTab = this.options.showJSONEditorTab === true;
  }
  /**
   * Specifies how Survey Creator users edit survey pages.
   *
   * Accepted values:
   *
   * - `"standard"` (default)
   * Questions and panels are divided between pages. Users can scroll the design surface to reach a required page.
   *
   * - `"single"`
   * All questions and panels belong to a single page. Users cannot add or remove pages.
   *
   * - `"bypage"`
   * Questions and panels are divided between pages. Users can use the page navigator to switch to a required page.
   * @see allowModifyPages
   */
  get pageEditMode() {
    return this.pageEditModeValue;
  }
  set pageEditMode(val) {
    this.pageEditModeValue = val;
    const allowModifyPages = this.pageEditModeValue !== "single";
    this.changePageModifications(allowModifyPages);
    settings.allowShowEmptyTitleInDesignMode = allowModifyPages;
    settings.allowShowEmptyDescriptionInDesignMode = allowModifyPages;
    if (this.pageEditModeValue === "bypage") {
      this.showPageNavigator = true;
    }
  }
  get toolbarItems() {
    return this.toolbarValue.actions;
  }
  get toolbar() {
    return this.toolbarValue;
  }
  _findAction(id) {
    return this.toolbarItems.filter((a) => a.id === id)[0];
  }
  get viewType() {
    return this.getPropertyValue("viewType");
  }
  set viewType(val) {
    val = this.fixPluginName(val);
    this.setPropertyValue("viewType", val);
  }
  get showingViewName() {
    return this.activeTab;
  }
  get isDesignerShowing() {
    return this.activeTab === "designer";
  }
  showDesigner() {
    this.activeTab = "designer";
  }
  get isTestSurveyShowing() {
    return this.isPreviewShowing;
  }
  get isPreviewShowing() {
    return this.activeTab === "preview";
  }
  showTestSurvey() {
    this.showPreview();
  }
  showPreview() {
    this.activeTab = "preview";
  }
  /**
   * @deprecated Use the [`addTab(tabOptions)`](https://surveyjs.io/survey-creator/documentation/api-reference/survey-creator#addTab) method instead.
   */
  addPluginTab(name, plugin, title, componentName, index) {
    this.tabbedMenu.addTab(name, plugin, title, void 0, componentName, index);
    this.addPlugin(name, plugin);
  }
  /**
   * Adds a custom tab to Survey Creator.
   *
   * This method accepts an `ITabOptions` object with the following properties:
   *
   * - `name`: `string`\
   * A unique tab ID.
   *
   * - `plugin`: `ICreatorPlugin`\
   * An object that allows you to handle user interactions with the tab.
   *
   * - `title`: `string`\
   * *(Optional)* A tab caption. If `title` is undefined, the `name` property value is displayed instead. To localize the caption, add its translations to the `ed` object within [localization dictionaries](https://github.com/surveyjs/survey-creator/tree/90de47d2c9da49b06a7f97414026d70f7acf05c6/packages/survey-creator-core/src/localization) and pass `ed.propertyName` as the `title` property.
   *
   * - `iconName`: `string`\
   * *(Optional)* An [icon name](https://surveyjs.io/form-library/documentation/icons). Icons are used when the tab bar doesn't have enough width to display tab titles.
   *
   * - `componentName`: `string`\
   * *(Optional)* The name of the component that renders tab markup. Default value: `"svc-tab-" + name`.
   *
   * - `index`: `number`\
   * *(Optional)* A zero-based index that specifies the tab's position relative to other tabs.
   *
   * [View Demo](https://surveyjs.io/survey-creator/examples/modify-tab-bar/ (linkStyle))
   * @param tabOptions An object that configures the custom tab.
   */
  addTab(tabOptions) {
    let {
      name,
      plugin,
      title,
      iconName,
      componentName,
      index
    } = tabOptions;
    if (!name || !plugin) {
      throw new Error("Plugin or name is not set");
    }
    this.tabbedMenu.addTab(name, plugin, title, iconName, componentName, index);
    this.addPlugin(name, plugin);
  }
  addPlugin(name, plugin) {
    this.plugins[name] = plugin;
  }
  removePlugin(name) {
    const plugin = this.getPlugin(name);
    if (!plugin) return;
    let index = this.getTabIndex(name);
    if (index > -1) {
      this.tabs.splice(index, 1);
    }
    delete this.plugins[name];
    if (plugin.dispose) {
      plugin.dispose();
    }
  }
  getTabIndex(id) {
    for (let i = 0; i < this.tabs.length; i++) {
      if (this.tabs[i].id === id) return i;
    }
    return -1;
  }
  getPlugin(name) {
    const pluginName = this.fixPluginName(name);
    return this.plugins[pluginName];
  }
  fixPluginName(pluginName) {
    if (pluginName === "test") {
      return "preview";
    } else if (pluginName === "editor") {
      return "json";
    }
    return pluginName;
  }
  /**
   * @deprecated Use the [`logicMaxItemsInCondition`](https://surveyjs.io/survey-creator/documentation/api-reference/survey-creator#logicMaxItemsInCondition) property instead.
   */
  get maxLogicItemsInCondition() {
    return this.logicMaxItemsInCondition;
  }
  set maxLogicItemsInCondition(val) {
    this.logicMaxItemsInCondition = val;
  }
  /**
   * @deprecated Use the [`logicAllowTextEditExpressions`](https://surveyjs.io/survey-creator/documentation/api-reference/survey-creator#logicAllowTextEditExpressions) property instead.
   */
  get allowEditExpressionsInTextEditor() {
    return this.logicAllowTextEditExpressions;
  }
  set allowEditExpressionsInTextEditor(val) {
    this.logicAllowTextEditExpressions = val;
  }
  /**
   * @deprecated Use the [`maxColumns`](https://surveyjs.io/survey-creator/documentation/api-reference/survey-creator#maxColumns) property instead.
   */
  get maximumColumnsCount() {
    return this.maxColumns;
  }
  set maximumColumnsCount(val) {
    this.maxColumns = val;
  }
  /**
   * @deprecated Use the [`maxChoices`](https://surveyjs.io/survey-creator/documentation/api-reference/survey-creator#maxChoices) property instead.
   */
  get maximumChoicesCount() {
    return this.maxChoices;
  }
  set maximumChoicesCount(val) {
    this.maxChoices = val;
  }
  /**
   * @deprecated Use the [`minChoices`](https://surveyjs.io/survey-creator/documentation/api-reference/survey-creator#minChoices) property instead.
   */
  get minimumChoicesCount() {
    return this.minChoices;
  }
  set minimumChoicesCount(val) {
    this.minChoices = val;
  }
  /**
   * @deprecated Use the [`maxRows`](https://surveyjs.io/survey-creator/documentation/api-reference/survey-creator#maxRows) property instead.
   */
  get maximumRowsCount() {
    return this.maxRows;
  }
  set maximumRowsCount(val) {
    this.maxRows = val;
  }
  /**
   * @deprecated Use the [`maxRateValues`](https://surveyjs.io/survey-creator/documentation/api-reference/survey-creator#maxRateValues) property instead.
   */
  get maximumRateValues() {
    return this.maxRateValues;
  }
  set maximumRateValues(val) {
    this.maxRateValues = val;
  }
  /**
   * Specifies whether to show a page selector at the bottom of the Preview tab.
   *
   * Default value: `true`
   */
  get previewAllowSelectPage() {
    return this.showPagesInTestSurveyTab;
  }
  set previewAllowSelectPage(val) {
    this.showPagesInTestSurveyTab = val;
  }
  /**
   * @deprecated Use the [`previewAllowSelectPage`](https://surveyjs.io/survey-creator/documentation/api-reference/survey-creator#previewAllowSelectPage) property instead.
   */
  get showPagesInPreviewTab() {
    return this.showPagesInTestSurveyTab;
  }
  set showPagesInPreviewTab(val) {
    this.showPagesInTestSurveyTab = val;
  }
  /**
   * Specifies whether the Preview tab displays a Device button that allows users to preview the survey on different device types.
   *
   * Default value: `true`
   */
  get previewAllowSimulateDevices() {
    return this.showSimulatorInTestSurveyTab;
  }
  set previewAllowSimulateDevices(val) {
    this.showSimulatorInTestSurveyTab = val;
  }
  /**
   * @deprecated Use the [`previewAllowSimulateDevices`](https://surveyjs.io/survey-creator/documentation/api-reference/survey-creator#previewAllowSimulateDevices) property instead.
   */
  get showSimulatorInPreviewTab() {
    return this.showSimulatorInTestSurveyTab;
  }
  set showSimulatorInPreviewTab(val) {
    this.showSimulatorInTestSurveyTab = val;
  }
  /**
   * @deprecated Use the [`previewTheme`](https://surveyjs.io/survey-creator/documentation/api-reference/survey-creator#previewTheme) property instead.
   */
  get themeForPreview() {
    return this.previewTheme;
  }
  set themeForPreview(val) {
    this.previewTheme = val;
  }
  //#region Theme
  /**
   * An object that enables you to manage UI themes. Refer to the following API section for information on available properties, methods, and events: [`ThemeTabPlugin`](https://surveyjs.io/survey-creator/documentation/api-reference/themetabplugin).
   * @see showThemeTab
   * @see saveThemeFunc
   */
  get themeEditor() {
    return this.getPlugin("theme");
  }
  /**
   * A function that is called each time users click the [Save button](https://surveyjs.io/survey-creator/documentation/api-reference/survey-creator#showSaveButton) or [auto-save](https://surveyjs.io/survey-creator/documentation/api-reference/survey-creator#autoSaveEnabled) is triggered to save a theme JSON object.
   *
   * For more information, refer to the [Save and Load Custom Themes](https://surveyjs.io/survey-creator/documentation/theme-editor#save-and-load-custom-themes) help topic.
   * @see showThemeTab
   * @see themeEditor
   * @see saveSurveyFunc
   */
  get saveThemeFunc() {
    return this.saveThemeFuncValue;
  }
  set saveThemeFunc(value) {
    this.saveThemeFuncValue = value;
  }
  /**
   * Gets or sets a [theme](https://surveyjs.io/form-library/documentation/api-reference/itheme) for the survey being configured.
   *
   * [Theme Editor](https://surveyjs.io/survey-creator/documentation/theme-editor (linkStyle))
   * @see showThemeTab
   * @see themeEditor
   * @see saveThemeFunc
   */
  get theme() {
    return this._theme;
  }
  set theme(newTheme) {
    this._theme = newTheme;
    this.hasPendingThemeChanges = true;
    if (this.activeTab !== "theme") {
      this.updatePlugin(this.activeTab);
    }
    if (!!newTheme && newTheme.headerView) {
      this.survey.headerView = newTheme.headerView;
    }
  }
  _doSaveThemeCore(onSaveComplete) {
    this.setState("saving");
    if (this.saveThemeFunc) {
      this.saveNo++;
      this.saveThemeFunc(this.saveNo, (no, isSuccess) => {
        if (this.saveNo !== no) return;
        if (isSuccess) {
          this.setState("saved");
          this.hasPendingThemeChanges = false;
        } else {
          this.setState("modified");
          if (this.showErrorOnFailedSave) {
            this.notify(this.getLocString("ed.saveError"), "error");
          }
        }
        onSaveComplete && onSaveComplete();
      });
    }
  }
  /**
   * Calls the [`saveThemeFunc`](https://surveyjs.io/survey-creator/documentation/api-reference/survey-creator#saveThemeFunc) function to save the theme JSON schema.
   * @see saveSurvey
   * @see save
   */
  saveTheme() {
    this._doSaveThemeCore();
  }
  saveThemeActionHandler() {
    if (this.syncSaveButtons) {
      this.save();
    } else {
      this.saveTheme();
    }
  }
  /**
   * Specifies whether users can add, edit, and delete survey pages.
   *
   * Default value: `true`
   * @see pageEditMode
   */
  get allowModifyPages() {
    return this._allowModifyPages;
  }
  set allowModifyPages(val) {
    this._allowModifyPages = val;
    this.changePageModifications(val);
  }
  /**
   * Specifies whether the Preview tab displays a language selector.
   *
   * Accepted values:
   *
   * - `"auto"` (default)
   * Display the language selector only if the survey is translated into more than one language.
   *
   * - `true`
   * Always display the language selector regardless of how many languages the survey uses.
   *
   * - `false`
   * Never display the language selector.
   *
   * - `"all"`
   * Always display the language selector with [all supported languages](https://github.com/surveyjs/survey-creator/tree/90de47d2c9da49b06a7f97414026d70f7acf05c6/packages/survey-creator-core/src/localization).
   *
   * [Localization & Globalization](https://surveyjs.io/survey-creator/documentation/survey-localization-translate-surveys-to-different-languages (linkStyle))
   */
  get previewAllowSelectLanguage() {
    return this.showDefaultLanguageInTestSurveyTab;
  }
  set previewAllowSelectLanguage(val) {
    this.showDefaultLanguageInTestSurveyTab = val;
  }
  /**
   * @deprecated Use the [`previewAllowSelectLanguage`](https://surveyjs.io/survey-creator/documentation/api-reference/survey-creator#previewAllowSelectLanguage) property instead.
   */
  get showDefaultLanguageInPreviewTab() {
    return this.showDefaultLanguageInTestSurveyTab;
  }
  set showDefaultLanguageInPreviewTab(val) {
    this.showDefaultLanguageInTestSurveyTab = val;
  }
  /**
   * Specifies whether the Preview tab displays a toggle that allows users to show or hide invisible survey elements.
   *
   * Default value: `true`
   */
  get previewAllowHiddenElements() {
    return this.showInvisibleElementsInTestSurveyTab;
  }
  set previewAllowHiddenElements(val) {
    this.showInvisibleElementsInTestSurveyTab = val;
  }
  /**
   * @deprecated Use the [`previewAllowHiddenElements`](https://surveyjs.io/survey-creator/documentation/api-reference/survey-creator#previewAllowHiddenElements) property instead.
   */
  get showInvisibleElementsInPreviewTab() {
    return this.showInvisibleElementsInTestSurveyTab;
  }
  set showInvisibleElementsInPreviewTab(val) {
    this.showInvisibleElementsInTestSurveyTab = val;
  }
  /**
   * @deprecated Use the [`previewAllowSelectTheme`](https://surveyjs.io/survey-creator/documentation/api-reference/survey-creator#previewAllowSelectTheme) property instead.
   */
  get allowChangeThemeInPreview() {
    return this.previewAllowSelectTheme;
  }
  set allowChangeThemeInPreview(val) {
    this.previewAllowSelectTheme = val;
  }
  get tabResponsivenessMode() {
    return this._tabResponsivenessMode;
  }
  set tabResponsivenessMode(val) {
    this._tabResponsivenessMode = val;
    this.tabbedMenu.updateResponsivenessMode();
  }
  get tabs() {
    return this.tabbedMenu.actions;
  }
  set tabs(val) {
    this.tabbedMenu.actions = val;
  }
  getLocString(str) {
    return editorLocalization.getString(str);
  }
  onSetReadOnly(newVal) {
  }
  /**
   * Specifies the locale of the Survey Creator UI.
   *
   * Default value: `""` (inherited from `editorLocalization.currentLocale`)
   *
   * [Localization & Globalization](https://surveyjs.io/survey-creator/documentation/survey-localization-translate-surveys-to-different-languages (linkStyle))
   */
  get locale() {
    return this.getPropertyValue("locale", editorLocalization.currentLocale);
  }
  set locale(value) {
    if (editorLocalization.currentLocale === value) return;
    editorLocalization.currentLocale = value;
    this.setPropertyValue("locale", value);
    this.updateLocalizedStrings();
    this.onLocaleChanded.fire(this, {
      locale: value
    });
  }
  updateLocalizedStrings() {
    this.toolbox.updateTitles();
    this.refreshPlugin();
    const selEl = this.selectedElement;
    if (!!selEl) {
      this.selectElement(null);
      this.selectElement(selEl);
    }
    this.locStrsChanged();
  }
  locStrsChanged() {
    super.locStrsChanged();
    this.tabbedMenu.locStrsChanged();
    this.toolbar.locStrsChanged();
  }
  refreshPlugin() {
    const plugin = this.currentPlugin;
    if (!!plugin) {
      if (plugin.deactivate) {
        plugin.deactivate();
      }
      const viewType = this.viewType;
      this.viewType = "";
      plugin.activate();
      this.viewType = viewType;
    }
  }
  /**
   * Enables the read-only mode. If you set this property to `true`, users cannot change the initial survey configuration.
   *
   * Default value: `false`
   */
  get readOnly() {
    return this.getPropertyValue("readOnly", false);
  }
  set readOnly(newVal) {
    const text = this.text;
    this.setPropertyValue("readOnly", newVal);
    this.onSetReadOnly(newVal);
    this.text = text;
  }
  /**
   * Specifies whether to enable support for right-to-left languages.
   *
   * Default value: `false`
   */
  get isRTL() {
    return this.isRTLValue;
  }
  set isRTL(value) {
    this.isRTLValue = value;
  }
  /**
   * Gets or sets the currently displayed tab.
   *
   * Accepted values:
   *
   * - [`"designer"`](#showDesignerTab)
   * - [`"preview"`](#showPreviewTab)
   * - [`"theme"`](#showThemeTab)
   * - [`"json"`](#showJSONEditorTab)
   * - [`"logic"`](#showLogicTab)
   * - [`"translation"`](#showLogicTab)
   * @see switchTab
   */
  get activeTab() {
    return this.viewType;
  }
  set activeTab(val) {
    this.switchTab(val);
  }
  /**
   * Switches the [active tab](#activeTab). Returns `false` if the tab cannot be switched.
   * @param tabName A tab that you want to make active: `"designer"`, `"preview"`, `"theme"`, `"json"`, `"logic"`, or `"translation"`.
   * @returns `false` if the active tab cannot be switched, `true` otherwise.
   */
  switchTab(tabName) {
    if (tabName == this.viewType) return false;
    const plugin = this.currentPlugin;
    if (!!plugin && !!plugin.canDeactivateAsync) {
      plugin.canDeactivateAsync(() => {
        this.switchViewType(tabName);
      });
      return void 0;
    }
    return this.switchViewType(tabName);
  }
  /**
   * @deprecated Use the [`switchTab`](https://surveyjs.io/survey-creator/documentation/api-reference/survey-creator#switchTab) method instead.
   */
  makeNewViewActive(tabName) {
    return this.switchTab(tabName);
  }
  switchViewType(viewName) {
    var _a, _b, _c;
    viewName = this.fixPluginName(viewName);
    let allow = true;
    if (!!((_a = this.currentPlugin) === null || _a === void 0 ? void 0 : _a.defaultAllowingDeactivate)) {
      allow = this.currentPlugin.defaultAllowingDeactivate();
      if (allow === void 0) return false;
    }
    const chaningOptions = {
      tabName: viewName,
      allow,
      model: (_b = this.currentPlugin) === null || _b === void 0 ? void 0 : _b.model
    };
    this.onActiveTabChanging.fire(this, chaningOptions);
    if (!chaningOptions.allow) return;
    if (!!((_c = this.currentPlugin) === null || _c === void 0 ? void 0 : _c.deactivate) && !this.currentPlugin.deactivate()) return;
    const plugin = this.activatePlugin(viewName);
    this.viewType = viewName;
    this.onActiveTabChanged.fire(this, {
      tabName: viewName,
      plugin,
      model: !!plugin ? plugin.model : void 0
    });
    return true;
  }
  activatePlugin(newType) {
    const plugin = this.getPlugin(newType);
    if (!!plugin) {
      plugin.activate();
    }
    return plugin;
  }
  get currentPlugin() {
    return this.getPlugin(this.activeTab);
  }
  get toolboxCategories() {
    return this.toolbox.categories;
  }
  constructor(options = {}, options2) {
    var _a;
    super();
    this.options = options;
    this.startEditTitleOnQuestionAddedValue = true;
    this.isRTLValue = false;
    this.alwaySaveTextInPropertyEditorsValue = false;
    this.pageEditModeValue = "standard";
    this.newQuestions = [];
    this.newPanels = [];
    this.plugins = {};
    this.onElementDeleting = this.addCreatorEvent();
    this.onPropertyGetReadOnly = this.addCreatorEvent();
    this.onGetPropertyReadOnly = this.onPropertyGetReadOnly;
    this.onSurveyInstanceCreated = this.addCreatorEvent();
    this.onElementGetDisplayName = this.addCreatorEvent();
    this.onGetObjectDisplayName = this.onElementGetDisplayName;
    this.onHtmlToMarkdown = this.addCreatorEvent();
    this.onElementGetExpandCollapseState = this.addCreatorEvent();
    this.onElementAllowOperations = this.addCreatorEvent();
    this.onElementGetActions = this.addCreatorEvent();
    this.onDefineElementMenuItems = this.onElementGetActions;
    this.onPropertyShowing = this.addCreatorEvent();
    this.onCanShowProperty = this.onPropertyShowing;
    this.onShowingProperty = this.onPropertyShowing;
    this.onPropertyGridSurveyCreated = this.addCreatorEvent();
    this.onPropertyEditorCreated = this.addCreatorEvent();
    this.onPropertyEditorUpdateTitleActions = this.addCreatorEvent();
    this.onPropertyGridShowPopup = this.addCreatorEvent();
    this.onPropertyGridShowModal = this.onPropertyGridShowPopup;
    this.onCanDeleteItem = this.addCreatorEvent();
    this.onCollectionItemDeleting = this.addCreatorEvent();
    this.onCollectionItemAllowOperations = this.addCreatorEvent();
    this.onItemValueAdded = this.addCreatorEvent();
    this.onFastEntryFinished = this.addCreatorEvent();
    this.onMatrixColumnAdded = this.addCreatorEvent();
    this.onSetPropertyEditorOptions = this.addCreatorEvent();
    this.onConfigureTablePropertyEditor = this.addCreatorEvent();
    this.onGenerateNewName = this.addCreatorEvent();
    this.onPropertyDisplayCustomError = this.addCreatorEvent();
    this.onPropertyValidationCustomError = this.onPropertyDisplayCustomError;
    this.onBeforePropertyChanged = this.addCreatorEvent();
    this.onPropertyValueChanging = this.onBeforePropertyChanged;
    this.onAfterPropertyChanged = this.addCreatorEvent();
    this.onSurveyPropertyValueChanged = this.onAfterPropertyChanged;
    this.onConditionGetQuestionList = this.addCreatorEvent();
    this.onConditionQuestionsGetList = this.onConditionGetQuestionList;
    this.onConditionGetTitle = this.addCreatorEvent();
    this.onGetConditionOperator = this.addCreatorEvent();
    this.onLogicRuleGetDisplayText = this.addCreatorEvent();
    this.onLogicItemDisplayText = this.onLogicRuleGetDisplayText;
    this.onModified = this.addCreatorEvent();
    this.onQuestionAdded = this.addCreatorEvent();
    this.onPanelAdded = this.addCreatorEvent();
    this.onPageAdded = this.addCreatorEvent();
    this.onQuestionConverting = this.addCreatorEvent();
    this.onPageGetFooterActions = this.addCreatorEvent();
    this.onGetPageActions = this.onPageGetFooterActions;
    this.onDesignerSurveyCreated = this.addCreatorEvent();
    this.onPreviewSurveyCreated = this.addCreatorEvent();
    this.onTestSurveyCreated = this.onPreviewSurveyCreated;
    this.onNotify = this.addCreatorEvent();
    this.onElementSelecting = this.addCreatorEvent();
    this.onSelectedElementChanging = this.onElementSelecting;
    this.onElementSelected = this.addCreatorEvent();
    this.onSelectedElementChanged = this.onElementSelected;
    this.onOpenFileChooser = this.addCreatorEvent();
    this.onUploadFile = this.addCreatorEvent();
    this.onTranslationStringVisibility = this.addCreatorEvent();
    this.onTranslationLocaleInitiallySelected = this.addCreatorEvent();
    this.onTranslationImportItem = this.addCreatorEvent();
    this.onTranslationImported = this.addCreatorEvent();
    this.onTranslationExportItem = this.addCreatorEvent();
    this.onMachineTranslate = this.addCreatorEvent();
    this.onTranslationItemChanging = this.addCreatorEvent();
    this.onDragDropAllow = this.addCreatorEvent();
    this.onDragOverLocationCalculating = this.addCreatorEvent();
    this.onCreateCustomMessagePanel = this.addCreatorEvent();
    this.onCreatorThemePropertyChanged = this.addCreatorEvent();
    this.onCreatorThemeSelected = this.addCreatorEvent();
    this.logicMaxItemsInCondition = -1;
    this.showObjectTitles = false;
    this.showTitlesInExpressions = false;
    this.useElementTitles = false;
    this.maxVisibleChoices = 10;
    this.logicAllowTextEditExpressions = true;
    this.maxColumns = settings2.propertyGrid.maximumColumnsCount || settings2.propertyGrid.maxColumns;
    this.maxChoices = settings2.propertyGrid.maximumChoicesCount || settings2.propertyGrid.maxChoices;
    this.minChoices = settings2.propertyGrid.minimumChoicesCount || settings2.propertyGrid.minChoices;
    this.maxRows = settings2.propertyGrid.maximumRowsCount || settings2.propertyGrid.maxRows;
    this.maxRateValues = settings2.propertyGrid.maximumRateValues || settings2.propertyGrid.maxRateValues;
    this.maxNestedPanels = -1;
    this.showPagesInTestSurveyTab = true;
    this.showSimulatorInTestSurveyTab = true;
    this.previewTheme = "default";
    this.hasPendingThemeChanges = false;
    this._theme = {
      cssVariables: {}
    };
    this._allowModifyPages = true;
    this.showDefaultLanguageInTestSurveyTab = "auto";
    this.showInvisibleElementsInTestSurveyTab = true;
    this.previewAllowSelectTheme = true;
    this._tabResponsivenessMode = "icons";
    this.showErrorOnFailedSave = true;
    this.onLocaleChanded = this.addCreatorEvent();
    this.onActiveTabChanging = this.addCreatorEvent();
    this.onActiveTabChanged = this.addCreatorEvent();
    this.showSidebarValue = true;
    this.onShowSidebarVisibilityChanged = this.addCreatorEvent();
    this.onShowPropertyGridVisiblityChanged = this.addCreatorEvent();
    this.onBeforeUndo = this.addCreatorEvent();
    this.onBeforeRedo = this.addCreatorEvent();
    this.onPageAdding = this.addCreatorEvent();
    this.onDragStart = this.addCreatorEvent();
    this.onBeforeDrop = this.onDragStart;
    this.onDragEnd = this.addCreatorEvent();
    this.onAfterDrop = this.onDragEnd;
    this.onDragClear = this.addCreatorEvent();
    this.animationEnabled = true;
    this.onStateChanged = this.addCreatorEvent();
    this.expandCollapseManager = new ExpandCollapseManager(this);
    this.notifier = new Notifier({
      root: "svc-notifier",
      rootWithButtons: "",
      info: "svc-notifier--info",
      error: "svc-notifier--error",
      success: "svc-notifier--success",
      button: "",
      shown: "svc-notifier--shown"
    });
    this.addNewQuestionLast = true;
    this.onKeyDownHandler = (event) => {
      this.findSuitableShortcuts(event).forEach((shortcut) => {
        if ((event.keyCode < 48 || event.keyCode == 89 || event.keyCode == 90) && isTextInput(event.target)) return;
        shortcut.execute(this.selectedElement);
      });
    };
    this.shortcuts = {};
    this.hiddenProperties = {};
    this.translationLocalesOrder = [];
    this.autoSaveDelay = settings2.autoSave.delay;
    this.autoSaveTimerId = null;
    this.saveNo = 0;
    this._syncSaveActions = (sender, options3) => {
      const saveAction = this._findAction("svd-save");
      const saveThemeAction = this._findAction("svd-save-theme");
      if (!saveAction || !saveThemeAction) {
        return;
      }
      if (sender === this) {
        saveThemeAction.enabled = saveAction.enabled;
      } else {
        saveAction.enabled = saveThemeAction.enabled;
      }
    };
    this.showTabsDefault = settings2.layout.showTabs;
    this.showToolbarDefault = settings2.layout.showToolbar;
    this.collapsePages = false;
    this.collapsePanels = false;
    this.collapseQuestions = false;
    this.expandOnDragTimeOut = 1e3;
    this.themeVariables = {};
    this.preferredColorPalette = "light";
    this._allowDragPages = true;
    this.collapseOnDrag = false;
    if (!!options2 || typeof this.options === "string" || this.options instanceof String) {
      this.options = !!options2 ? options2 : {};
      SurveyHelper.warnText("Creator constructor has one parameter, as creator options, in V2.");
    }
    SvgRegistry.registerIcons(SvgThemeSets["v2"]);
    this.previewDevice = (_a = options.previewDevice) !== null && _a !== void 0 ? _a : "desktop";
    this.previewOrientation = options.previewOrientation;
    this.toolbarValue = new ToolbarActionContainer(this);
    this.toolbarValue.locOwner = this;
    this.tabbedMenu = new TabbedMenuContainer(this);
    this.tabbedMenu.locOwner = this;
    this.selectionHistoryControllerValue = new SelectionHistory(this);
    this.sidebar = new SidebarModel(this);
    this.setOptions(this.options);
    this.patchMetadata();
    this.initSurveyWithJSON(void 0, false);
    this.toolbox = new QuestionToolbox(this.options && this.options.questionTypes ? this.options.questionTypes : null, this, true);
    this.updateToolboxIsCompact();
    this.initDragDrop();
    this.initTabs();
    this.syncSaveButtons = this.options.saveSurveyAndTheme !== void 0 ? this.options.saveSurveyAndTheme : this.options.syncSaveButtons;
    this.isTouch = IsTouch;
    this.currentOS = getOS();
    const expandAction = this.sidebar.getExpandAction();
    !!expandAction && this.toolbar.actions.push(expandAction);
  }
  addCreatorEvent() {
    return this.addEvent();
  }
  updateToolboxIsCompact(newVal) {
    if (!this.toolbox) return;
    const hasValue = newVal != void 0 && newVal != null;
    if (this.toolbox.forceCompact !== void 0) {
      this.toolbox.isCompact = this.toolbox.forceCompact;
    } else if (this.toolboxLocation == "right") {
      this.toolbox.isCompact = this.showSidebar || hasValue && newVal;
    } else if (hasValue && this.toolbox.isCompact !== newVal) {
      this.toolbox.isCompact = newVal;
    }
  }
  get showToolbox() {
    return this.showToolboxValue && this.allowShowToolbox;
  }
  /**
   * Specifies whether to show the Toolbox.
   *
   * Default value: `true`
   *
   * [Toolbox Customization](https://surveyjs.io/survey-creator/documentation/toolbox-customization (linkStyle))
   * @see toolbox
   * @see toolboxLocation
   */
  set showToolbox(val) {
    if (val !== true && val !== false) {
      SurveyHelper.warnText("showToolbox is a boolean property now.");
    }
    if (val === "none" || val === false || val === "top") {
      this.showToolboxValue = false;
    } else if (val === true) {
      this.showToolboxValue = true;
    } else {
      this.toolboxLocation = val;
      this.showToolboxValue = true;
    }
  }
  /**
   * Specifies whether to show the sidebar that displays the Property Grid.
   *
   * Default value: `true`
   * @see sidebarLocation
   */
  get showSidebar() {
    return this.showSidebarValue;
  }
  set showSidebar(val) {
    if (val !== true && val !== false) {
      SurveyHelper.warnText("showSidebar is a boolean property now.");
      return;
    }
    if (this.showSidebar === val) return;
    this.setShowSidebar(val, true);
    if (!this.onShowPropertyGridVisiblityChanged.isEmpty) {
      SurveyHelper.warnNonSupported("onShowPropertyGridVisiblityChanged", "onShowSidebarVisibilityChanged");
      this.onShowPropertyGridVisiblityChanged.fire(this, {
        show: val
      });
    }
  }
  setShowSidebar(value, isManualMode = false) {
    this.showSidebarValue = value;
    if (isManualMode) {
      if (value) {
        this.sidebar.expandedManually = true;
      } else {
        this.sidebar.collapsedManually = true;
      }
    }
    this.updateToolboxIsCompact();
    this.onShowSidebarVisibilityChanged.fire(this, {
      show: value
    });
  }
  get showPropertyGrid() {
    SurveyHelper.warnNonSupported("showPropertyGrid", "showSidebar");
    return this.showSidebar;
  }
  set showPropertyGrid(val) {
    SurveyHelper.warnNonSupported("showPropertyGrid", "showSidebar");
    if (val !== true && val !== false) {
      SurveyHelper.warnText("showSidebar is a boolean property.");
      return;
    }
    this.showSidebar = val;
  }
  rightContainerActiveItem(name) {
    SurveyHelper.warnNonSupported("rightContainerActiveItem");
  }
  leftContainerActiveItem(name) {
    SurveyHelper.warnNonSupported("leftContainerActiveItem");
  }
  get undoRedoManager() {
    const plugin = this.getPlugin("undoredo");
    return plugin && plugin.model.undoRedoManager;
  }
  get undoRedoController() {
    const plugin = this.getPlugin("undoredo");
    return plugin && plugin.model;
  }
  startUndoRedoTransaction(name) {
    this.undoRedoController && this.undoRedoController.startTransaction(name);
  }
  stopUndoRedoTransaction() {
    this.undoRedoController && this.undoRedoController.stopTransaction();
  }
  /**
   * Returns `true` if an undo or redo operation is in progress.
   * @see undo
   * @see redo
   */
  get isProcessingUndoRedo() {
    return this.undoRedoManager && this.undoRedoManager.isProcessingUndoRedo;
  }
  /**
   * Cancels the last change if possible.
   * @see redo
   * @see onBeforeUndo
   */
  undo() {
    this.undoRedoController && this.undoRedoController.undo();
  }
  /**
   * Repeats the last undone action if possible.
   * @see undo
   * @see onBeforeRedo
   */
  redo() {
    this.undoRedoController && this.undoRedoController.redo();
  }
  //#endregion Undo/Redo
  get selectionHistoryController() {
    return this.selectionHistoryControllerValue;
  }
  get currentPage() {
    return this.survey.currentPage;
  }
  set currentPage(value) {
    this.survey.currentPage = value;
  }
  canAddPage(pageToAdd) {
    const options = {
      page: pageToAdd,
      allow: true
    };
    this.onPageAdding.fire(this, options);
    return options.allow;
  }
  addPage(pageToAdd, changeSelection = true, beforeAdd) {
    if (!this.canAddPage(pageToAdd)) {
      return null;
    }
    if (beforeAdd !== void 0) {
      if (!beforeAdd()) {
        return;
      }
    }
    let page = pageToAdd;
    if (!page) {
      page = this.addNewPageIntoSurvey();
    } else {
      this.survey.addPage(page);
      page.questions.forEach((question) => {
        this.doOnQuestionAdded(question, page);
      });
    }
    if (changeSelection) {
      this.selectElement(page);
    }
    return page;
  }
  addNewPageIntoSurvey() {
    const name = SurveyHelper.getNewPageName(this.survey.pages);
    return this.survey.addNewPage(name);
  }
  initTabs() {
    this.initPlugins();
    this.initFooterToolbar();
  }
  getTabsInfo() {
    return {
      designer: () => new TabDesignerPlugin(this),
      preview: () => new TabTestPlugin(this),
      theme: () => new ThemeTabPlugin(this),
      //TODO change name
      logic: () => new TabLogicPlugin(this),
      json: () => TabJsonEditorAcePlugin.hasAceEditor() ? new TabJsonEditorAcePlugin(this) : new TabJsonEditorTextareaPlugin(this),
      translation: () => new TabTranslationPlugin(this)
    };
  }
  getAvailableTabNames() {
    const res = [];
    const tabInfo = this.getTabsInfo();
    for (let key in tabInfo) {
      res.push(key);
    }
    return res;
  }
  getTabNames() {
    const tabNames = this.getAvailableTabNames();
    const res = [];
    this.tabs.forEach((tab) => {
      const name = this.fixPluginName(tab.id);
      if (tabNames.indexOf(name) > -1) {
        res.push(name);
      }
    });
    return res;
  }
  //TODO-presets
  setTabs(tabNames) {
    if (!Array.isArray(tabNames)) return;
    const tabInfo = this.getTabsInfo();
    for (let i = tabNames.length - 1; i >= 0; i--) {
      if (!tabInfo[tabNames[i]]) tabNames.splice(i, 1);
    }
    if (tabNames.length === 0) return;
    for (let i = this.tabs.length - 1; i >= 0; i--) {
      const tabId = this.tabs[i].id;
      const id = this.fixPluginName(tabId);
      if (tabNames.indexOf(id) < 0) {
        this.removePlugin(tabId);
      }
    }
    tabNames.forEach((id) => {
      if (tabInfo[id] && this.getTabIndex(id) < 0) {
        tabInfo[id]();
      }
    });
    for (let i = 0; i < tabNames.length; i++) {
      const index = this.getTabIndex(tabNames[i]);
      if (index > -1 && index !== i) {
        const item = this.tabs[index];
        this.tabs.splice(index, 1);
        this.tabs.splice(i, 0, item);
      }
    }
    if (this.tabs.length > 0) {
      this.switchTab(this.tabs[0].id);
    }
  }
  initPlugins() {
    this.addPlugin("undoredo", new UndoRedoPlugin(this));
    const tabs = [];
    if (this.showDesignerTab) {
      tabs.push("designer");
    }
    if (this.showPreviewTab) {
      tabs.push("preview");
    }
    if (this.showThemeTab) {
      tabs.push("theme");
    }
    if (this.showLogicTab) {
      tabs.push("logic");
    }
    if (this.showJSONEditorTab) {
      tabs.push("json");
    }
    if (this.showTranslationTab) {
      tabs.push("translation");
    }
    this.setTabs(tabs);
  }
  initFooterToolbar() {
    if (!this.footerToolbar) {
      this.footerToolbar = new FooterToolbarActionContainer();
      ["designer", "undoredo", "preview", "theme"].forEach((pluginKey) => {
        const plugin = this.getPlugin(pluginKey);
        if (!!plugin && !!plugin["addFooterActions"]) {
          plugin["addFooterActions"]();
        }
      });
    }
  }
  getOptions() {
    return this.options || {};
  }
  setOptions(options) {
    if (!options) options = {};
    const obsoleteOptions = {};
    obsoleteOptions["showTestSurveyTab"] = "showPreviewTab";
    obsoleteOptions["showDefaultLanguageInTestSurveyTab"] = "showDefaultLanguageInPreviewTab";
    obsoleteOptions["showInvisibleElementsInPreviewTab"] = "showInvisibleElementsInTestSurveyTab";
    for (let key in obsoleteOptions) {
      if (options[key] === void 0) continue;
      const newKey = obsoleteOptions[key];
      if (options[newKey] === void 0) {
        options[newKey] = options[key];
        delete options[key];
      }
    }
    this.options = options;
    for (let key in options) {
      this[key] = options[key];
    }
  }
  setPropertyVisibility(className, visible, ...properties) {
    if (!Array.isArray(properties)) return;
    for (var i = 0; i < properties.length; i++) {
      const prop = Serializer.findProperty(className, properties[i]);
      if (!!prop) {
        if (!visible) {
          this.hiddenProperties[prop.id] = true;
        } else {
          delete this.hiddenProperties[prop.id];
        }
      }
    }
  }
  patchMetadata() {
    this.setPropertyVisibility("survey", false, "logoPosition");
  }
  isCanModifyProperty(obj, propertyName) {
    const property2 = Serializer.findProperty(obj.getType(), propertyName);
    let parentObj, parentProperty;
    if (obj instanceof ItemValue) {
      parentObj = obj.locOwner;
      parentProperty = Serializer.findProperty(parentObj.getType(), obj.ownerPropertyName || propertyName);
      let allowEdit = true;
      if (parentObj instanceof QuestionSelectBase) allowEdit = parentObj.isItemInList(obj);
      const allowQuestionOperations = this.getElementAllowOperations(parentObj);
      if (allowQuestionOperations.allowEdit === false) return false;
      const options = {
        allowDelete: true,
        allowEdit,
        allowAdd: true
      };
      this.onCollectionItemAllowingCallback(parentObj, property2, parentObj.getPropertyValue(parentProperty === null || parentProperty === void 0 ? void 0 : parentProperty.name), obj, options);
      if (options.allowEdit === false) {
        return false;
      }
      if (this.onIsPropertyReadOnlyCallback(parentObj, parentProperty, parentProperty === null || parentProperty === void 0 ? void 0 : parentProperty.readOnly, null, null)) {
        return false;
      }
    }
    if (obj instanceof SurveyElement) {
      const allowElementOperations = this.getElementAllowOperations(obj);
      if (allowElementOperations.allowEdit === false) return false;
    }
    return !property2 || !this.onIsPropertyReadOnlyCallback(obj, property2, property2.readOnly, parentObj, parentProperty);
  }
  onIsPropertyReadOnlyCallback(obj, property2, readOnly, parentObj, parentProperty, creatorReadOnly) {
    if (!property2) return false;
    if (creatorReadOnly === void 0) {
      creatorReadOnly = this.readOnly;
    }
    const proposedValue = creatorReadOnly || readOnly;
    if (this.onPropertyGetReadOnly.isEmpty) return proposedValue;
    const options = {
      obj,
      element: obj,
      property: property2,
      readOnly: proposedValue,
      propertyName: property2.name,
      parentObj,
      parentElement: parentObj,
      parentProperty
    };
    this.onPropertyGetReadOnly.fire(this, options);
    return options.readOnly;
  }
  /**
   * A [survey](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model) being configured in the Designer tab.
   * @see onSurveyInstanceCreated
   */
  get survey() {
    return this.surveyValue;
  }
  /**
   * Adds new items to the [`pages`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#pages), [`triggers`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#triggers), [`calculatedValues`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#calculatedValues), and [`completedHtmlOnCondition`](https://surveyjs.io/form-library/documentation/api-reference/survey-data-model#completedHtmlOnCondition) arrays in the existing survey JSON schema.
   *
   * Use this method to merge the collection properties of two survey JSON schemas:
   *
   * ```js
   * import { SurveyCreatorModel } from "survey-creator-core";
   * const creatorOptions = { ... };
   * const creator = new SurveyCreatorModel(creatorOptions);
   *
   * const surveyJson1 = { ... };
   * const surveyJson2 = { ... };
   *
   * creator.JSON = surveyJson1;
   * creator.addCollectionItemsJson(surveyJson2);
   * // `creator.JSON` contains the merged survey JSON schema
   * ```
   * @param json A JSON object that contains the `pages`, `triggers`, `calculatedValues`, and/or `completedHtmlOnCondition` array(s).
   * @param insertPageIndex A zero-based index at which to insert new pages.
   */
  addCollectionItemsJson(json2, insertPageIndex) {
    const survey = new SurveyModel(json2);
    this.updateAddingSurvey(survey);
    this.addSurveyPages(survey, insertPageIndex);
  }
  updateAddingSurvey(survey) {
    this.updateAddingPages(survey);
    this.updateAddingPanels(survey);
    this.updateAddingQuestions(survey);
    this.updateAddingCalculatedValules(survey);
    this.updateAddingArrays(survey);
  }
  updateAddingPages(survey) {
    this.updateAddingElements(survey, survey.pages, this.survey.pages, (el, allElements) => {
      el.name = SurveyHelper.getNewPageName(allElements);
    });
  }
  updateAddingExistingElements() {
    return [].concat(this.survey.getAllQuestions(false, true)).concat(this.survey.getAllPanels());
  }
  updateAddingPanels(survey) {
    this.updateAddingElements(survey, survey.getAllPanels(), this.updateAddingExistingElements(), (el, allElements) => {
      el.name = SurveyHelper.getNewPanelName(allElements);
    });
  }
  updateAddingQuestions(survey) {
    const logic = new SurveyLogic(survey, this);
    this.updateAddingElements(survey, survey.getAllQuestions(false, true), this.updateAddingExistingElements(), (el, allElements) => {
      const oldName = el.name;
      el.name = SurveyHelper.getNewQuestionName(allElements);
      logic.renameQuestion(oldName, el.name);
    });
  }
  updateAddingCalculatedValules(survey) {
    const logic = new SurveyLogic(survey, this);
    this.updateAddingElements(survey, survey.calculatedValues, this.survey.calculatedValues, (el, allElements) => {
      const oldName = el.name;
      el.name = SurveyHelper.getNewName(allElements, "var");
      logic.renameQuestion(oldName, el.name);
    });
  }
  updateAddingArrays(survey) {
    survey.triggers.forEach((item) => this.survey.triggers.push(item));
    survey.completedHtmlOnCondition.forEach((item) => this.survey.completedHtmlOnCondition.push(item));
    survey.calculatedValues.forEach((item) => this.survey.calculatedValues.push(item));
  }
  updateAddingElements(survey, changingElements, existingElements, onChange) {
    const elementsToChange = [];
    const hash = {};
    existingElements.forEach((el) => {
      if (!!el.name) {
        hash[el.name] = el;
      }
    });
    changingElements.forEach((el) => {
      if (!!el.name && !!hash[el.name]) {
        elementsToChange.push(el);
      }
    });
    const allElements = existingElements.concat(changingElements);
    elementsToChange.forEach((el) => {
      onChange(el, allElements);
    });
  }
  addSurveyPages(survey, indexPage) {
    if (indexPage === void 0 || indexPage >= this.survey.pages.length) {
      indexPage = -1;
    }
    for (let i = 0; i < survey.pages.length; i++) {
      if (indexPage < 0) {
        this.survey.pages.push(survey.pages[i]);
      } else {
        this.survey.pages.splice(indexPage + i, 0, survey.pages[i]);
      }
    }
  }
  getSurfaceCss() {
    const result = JSON.parse(JSON.stringify(defaultCss));
    result.header += " svc-surface-header";
    return result;
  }
  /**
   * Returns true if initial survey was empty. It was not set via JSON property and default new survey is empty as well.
   * @returns true if initial survey doesn't have any elements or properties
   */
  initSurveyWithJSON(json2, clearState) {
    if (!json2) {
      json2 = {
        "headerView": "advanced"
      };
    }
    this.existingPages = {};
    const survey = this.createSurvey({}, "designer", void 0, (survey2) => {
      survey2.skeletonHeight = 188;
      survey2.css = this.getSurfaceCss();
      survey2.setIsMobile(!!this.isMobileView);
      survey2.setDesignMode(true);
      survey2.lazyRenderEnabled = true;
      survey2.setJsonObject(json2);
      if (survey2.isEmpty) {
        survey2.setJsonObject(this.getDefaultSurveyJson());
      }
    });
    survey.pages.forEach((page) => {
      this.existingPages[page.id] = true;
    });
    survey.onQuestionAdded.add((sender, options) => {
      this.doOnQuestionAdded(options.question, options.parentPanel);
    });
    survey.onPanelAdded.add((sender, options) => {
      this.doOnPanelAdded(options.panel, options.parentPanel);
    });
    survey.onPageAdded.add((sender, options) => {
      if (!!this.existingPages[options.page.id]) return;
      this.existingPages[options.page.id] = true;
      this.doOnPageAdded(options.page);
    });
    survey.onDragDropAllow.add((sender, options) => {
      options.survey = sender;
      this.onDragDropAllow.fire(this, options);
    });
    this.setSurvey(survey);
    this.expandCollapseManager.expandCollapseElements("loading", false);
    this.updatePlugin(this.activeTab);
    if (this.activeTab !== "designer") {
      this.updatePlugin("designer");
    }
    if (!!this.undoRedoController) {
      this.undoRedoController.updateSurvey();
    }
  }
  updatePlugin(name) {
    const plugin = this.getPlugin(this.activeTab);
    if (!!plugin && !!plugin.update) {
      plugin.update();
    }
  }
  initDragDrop() {
    this.initDragDropSurveyElements();
    this.initDragDropChoices();
  }
  initDragDropSurveyElements() {
    DragDropSurveyElements.restrictDragQuestionBetweenPages = settings2.dragDrop.restrictDragQuestionBetweenPages;
    this.dragDropSurveyElements = new DragDropSurveyElements(null, this);
    this.dragDropSurveyElements.onGetMaxNestedPanels = () => {
      return this.maxNestedPanels;
    };
    this.dragDropSurveyElements.onDragOverLocationCalculating = (options) => {
      this.onDragOverLocationCalculating.fire(this, options);
    };
    let isDraggedFromToolbox = false;
    this.dragDropSurveyElements.onDragStart.add((sender, options) => {
      var _a;
      const element = sender.draggedElement;
      isDraggedFromToolbox = !element.parent && !element.isPage;
      if (!!element && (element.isPage || this.collapseOnDrag)) {
        (_a = this.designerStateManager) === null || _a === void 0 ? void 0 : _a.suspend();
        this.collapseAllPagesOnDragStart(element);
      }
      this.onDragStart.fire(this, options);
      this.startUndoRedoTransaction("drag drop");
    });
    this.dragDropSurveyElements.onDragEnd.add((sender, options) => {
      this.stopUndoRedoTransaction();
      const editTitle = isDraggedFromToolbox && this.startEditTitleOnQuestionAdded;
      if (!options.draggedElement) return;
      this.selectElement(options.draggedElement, void 0, true, editTitle);
      this.onDragEnd.fire(this, options);
      if (!options.fromElement && !options.draggedElement.isPage) {
        this.setModified({
          type: "ADDED_FROM_TOOLBOX",
          question: options.draggedElement
        });
      }
    });
    this.dragDropSurveyElements.onDragClear.add((sender, options) => {
      var _a;
      isDraggedFromToolbox = false;
      this.stopUndoRedoTransaction();
      if (!!options.draggedElement && (options.draggedElement.isPage || this.collapseOnDrag)) {
        (_a = this.designerStateManager) === null || _a === void 0 ? void 0 : _a.release();
        this.restoreElementsState();
      }
      this.onDragClear.fire(this, options);
    });
  }
  get designerStateManager() {
    var _a;
    return (_a = this.getPlugin("designer")) === null || _a === void 0 ? void 0 : _a.designerStateManager;
  }
  collapseAllPagesOnDragStart(element) {
    this.expandCollapseManager.expandCollapseElements("drag-start", true, this.survey.pages.filter((p) => !element || element.isPage || p !== element.page));
  }
  getElementExpandCollapseState(element, reason, defaultValue) {
    if (this.expandCollapseButtonVisibility == "never") return false;
    if (reason === "loading") {
      if (element instanceof Question) defaultValue = this.collapseQuestions;
      if (element instanceof PanelModel) defaultValue = this.collapsePanels;
      if (element instanceof PageModel) defaultValue = this.collapsePages;
    }
    const options = {
      element,
      reason,
      collapsed: defaultValue
    };
    if (reason) this.onElementGetExpandCollapseState.fire(this, options);
    return options.collapsed;
  }
  restoreState(element) {
    const state = this.getElementExpandCollapseState(element, "drag-end", void 0);
    if (state !== void 0) {
      const adorner = SurveyElementAdornerBase.GetAdorner(element);
      if (!!adorner) {
        adorner.collapsed = state;
      }
    }
    SurveyElementAdornerBase.RestoreStateFor(element);
  }
  restoreElementsState() {
    this.survey.pages.forEach((element) => {
      if (element["draggedFrom"] !== void 0) {
        const adorner = SurveyElementAdornerBase.GetAdorner(element);
        adorner === null || adorner === void 0 ? void 0 : adorner.blockAnimations();
        this.restoreState(element);
        adorner === null || adorner === void 0 ? void 0 : adorner.releaseAnimations();
      } else {
        this.restoreState(element);
      }
    });
  }
  initDragDropChoices() {
    this.dragDropChoices = new DragDropChoices(null, this);
    this.dragDropChoices.onDragStart.add((sender, options) => {
      this.startUndoRedoTransaction("drag drop");
    });
    this.dragDropChoices.onDragEnd.add((sender, options) => {
      this.selectElement(options.draggedElement, void 0, false);
    });
    this.dragDropChoices.onDragClear.add((sender, options) => {
      this.stopUndoRedoTransaction();
    });
  }
  updateElementsOnLocaleChanged(obj, propertyName) {
    if (obj.getType() !== "survey" || propertyName !== "locale") return;
    const pages = this.survey.pages;
    for (var i = 0; i < pages.length; i++) {
      pages[i].locStrsChanged();
    }
  }
  updateConditionsOnNameChanged(obj, propertyName, oldValue) {
    if (this.isObjQuestion(obj)) {
      if (propertyName === "name" && !obj["valueName"]) {
        this.updateLogicOnQuestionNameChanged(oldValue, obj["name"]);
      }
      if (propertyName === "valueName") {
        const oldName = !!oldValue ? oldValue : obj["name"];
        const newName = !!obj["valueName"] ? obj["valueName"] : obj["name"];
        this.updateLogicOnQuestionNameChanged(oldName, newName);
      }
      if (propertyName === "name" && obj.isDescendantOf("selectbase")) {
        this.updateChoicesFromQuestionOnColumnNameChanged(oldValue, obj["name"]);
      }
    }
    if (propertyName === "name" && obj.isDescendantOf("matrixdropdowncolumn")) {
      this.updateLogicOnColumnNameChanged(obj, oldValue, obj["name"]);
    }
  }
  getSurveyLogicForUpdate() {
    if (!!this.surveyLogicForUpdate && this.surveyLogicForUpdate.survey !== this.survey) {
      this.surveyLogicForUpdate = void 0;
    }
    if (!this.surveyLogicForUpdate) {
      this.surveyLogicForUpdate = this.createSurveyLogicForUpdate();
    }
    return this.surveyLogicForUpdate;
  }
  clearSurveyLogicForUpdate(obj, propertyName, value) {
    if (this.surveyLogicRenaming || !this.surveyLogicForUpdate || !obj || !propertyName) return;
    if (this.needClearSurveyLogicForUpdate(obj, propertyName, value)) {
      this.surveyLogicForUpdate = void 0;
    }
  }
  needClearSurveyLogicForUpdate(obj, propertyName, value) {
    if (Array.isArray(value)) {
      return true;
    }
    const prop = Serializer.findProperty(obj.getType(), propertyName);
    return !!prop && ["expression", "condition", "questionvalue", "question"].indexOf(prop.type) > -1;
  }
  updateSurveyLogicValues(obj, propertyName, oldValue) {
    if (!obj || !propertyName || Helpers.isValueEmpty(oldValue)) return;
    if (propertyName === "value" && obj.isDescendantOf("itemvalue")) {
      this.updateSurveyLogicItemValue(obj, oldValue);
    }
  }
  updateSurveyLogicItemValue(item, oldValue) {
    if (!item.locOwner || !settings2.logic.updateExpressionsOnChanging.choiceValue) return;
    if (["choices", "rateValues", "columns", "rows"].indexOf(item.ownerPropertyName) < 0) return;
    this.surveyLogicRenaming = true;
    const logicUpdater = this.getSurveyLogicForUpdate();
    if (item.ownerPropertyName === "rows") {
      logicUpdater.renameRowValue(item, oldValue);
    } else {
      logicUpdater.renameItemValue(item, oldValue);
    }
    this.surveyLogicRenaming = false;
  }
  createSurveyLogicForUpdate() {
    return new SurveyLogic(this.survey, this);
  }
  updateLogicOnQuestionNameChanged(oldName, newName) {
    if (oldName === newName || !settings2.logic.updateExpressionsOnChanging.questionName) return;
    this.surveyLogicRenaming = true;
    this.getSurveyLogicForUpdate().renameQuestion(oldName, newName);
    this.surveyLogicRenaming = false;
  }
  updateLogicOnColumnNameChanged(column, oldName, newName) {
    if (!oldName || oldName === newName || !settings2.logic.updateExpressionsOnChanging.columnName) return;
    this.surveyLogicRenaming = true;
    this.getSurveyLogicForUpdate().renameColumn(column, oldName);
    this.surveyLogicRenaming = false;
  }
  updateChoicesFromQuestionOnColumnNameChanged(oldName, newName) {
    const questions = this.getAllQuestions();
    questions.forEach((q) => {
      if (q.choicesFromQuestion === oldName) {
        q.choicesFromQuestion = newName;
      }
    });
  }
  isObjQuestion(obj) {
    return this.isObjThisType(obj, "question");
  }
  isObjPage(obj) {
    return this.isObjThisType(obj, "page");
  }
  isObjThisType(obj, typeName) {
    var classInfo = Serializer.findClass(obj.getType());
    while (!!classInfo && !!classInfo.parentName) {
      if (classInfo.name === typeName) return true;
      classInfo = Serializer.findClass(classInfo.parentName);
    }
    return !!classInfo && classInfo.name === typeName;
  }
  onDragDropItemStart() {
    this.addNewElementReason = "DROPPED_FROM_TOOLBOX";
  }
  doOnQuestionAdded(question, parentPanel) {
    question.name = this.generateUniqueName(question, question.name);
    var page = this.getPageByElement(question);
    if (!page) return;
    var options = {
      question,
      page,
      reason: this.addNewElementReason
    };
    this.addNewElementReason = void 0;
    this.onQuestionAdded.fire(this, options);
  }
  doOnPanelAdded(panel, parentPanel) {
    var page = this.getPageByElement(panel);
    var options = {
      panel,
      page,
      reason: this.addNewElementReason
    };
    this.onPanelAdded.fire(this, options);
    this.addNewElementReason = void 0;
  }
  doOnPageAdded(page) {
    var options = {
      page
    };
    this.onPageAdded.fire(this, options);
    const pType = this.isCopyingPage ? "ELEMENT_COPIED" : "PAGE_ADDED";
    this.setModified({
      type: pType,
      newValue: options.page
    });
  }
  getPageByElement(obj) {
    return this.survey.getPageByElement(obj);
  }
  getDefaultSurveyJson() {
    var json2 = settings2.defaultNewSurveyJSON;
    if (json2["pages"] && json2["pages"]["length"] > 0 && json2["pages"][0]["name"]) {
      json2["pages"][0]["name"] = editorLocalization.getString("ed.newPageName") + "1";
    }
    return json2;
  }
  setSurvey(survey) {
    if (!!this.surveyValue) {
      this.surveyValue.dispose();
    }
    this.surveyValue = survey;
    this.selectElement(survey);
    this.selectionHistoryController.reset();
  }
  getSurveyTextFromDesigner() {
    if (!this.survey) return "";
    var json2 = this.survey.toJSON();
    json2 = this.singlePageJSON(json2);
    this.moveElementsToTheEnd(json2);
    const indent = settings2.jsonEditor.indentation;
    if (this.generateValidJSON) {
      return JSON.stringify(json2, null, indent);
    }
    return new SurveyJSON5().stringify(json2, null, indent);
  }
  moveElementsToTheEnd(json2) {
    if (!json2) return;
    if (Array.isArray(json2)) {
      json2.forEach((el) => this.moveElementsToTheEnd(el));
    } else {
      if (typeof json2 === "object") {
        if (!!json2["elements"]) {
          const els = json2["elements"];
          delete json2["elements"];
          json2["elements"] = els;
        }
        Object.keys(json2).forEach((key) => this.moveElementsToTheEnd(json2[key]));
      }
    }
  }
  setTextValue(value) {
    if (!!this.setSurveyJSONTextCallback) {
      this.setSurveyJSONTextCallback(value);
    }
  }
  changeText(value, clearState = false, trustJSON) {
    this.setTextValue(value);
    if (!value) {
      this.initSurveyWithJSON(void 0, clearState);
    } else {
      let jsonValue = trustJSON ? this.parseJSON(value) : void 0;
      if (!trustJSON) {
        const textWorker = new SurveyTextWorker(value);
        if (textWorker.isJsonCorrect) {
          jsonValue = this.parseJSON(value);
        } else if (!!textWorker.survey) {
          jsonValue = textWorker.survey.toJSON();
        }
      }
      if (!!jsonValue) {
        this.initSurveyWithJSON(jsonValue, clearState);
      } else {
        this.viewType = "json";
      }
    }
  }
  parseJSON(val) {
    return new SurveyJSON5().parse(val);
  }
  /**
   * A survey JSON schema as a string.
   *
   * This property allows you to get or set the JSON schema of a survey being configured. Alternatively, you can use the [`JSON`](#JSON) property.
   */
  get text() {
    if (!!this.getSurveyJSONTextCallback) {
      return this.getSurveyJSONTextCallback().text;
    }
    return this.getSurveyTextFromDesigner();
  }
  set text(value) {
    this.changeText(value, true);
  }
  getSurveyJSON() {
    if (this.viewType != "json") {
      return new JsonObject().toJsonObject(this.survey);
    }
    var surveyJsonText = this.text;
    var textWorker = new SurveyTextWorker(surveyJsonText);
    if (textWorker.isJsonCorrect) {
      return new JsonObject().toJsonObject(textWorker.survey);
    }
    return null;
  }
  getObjectDisplayName(obj, area, reason = void 0, displayName = void 0) {
    if (!displayName) {
      displayName = SurveyHelper.getObjectName(obj, this.useElementTitles || this.showObjectTitles);
    }
    var options = {
      obj,
      element: obj,
      displayName,
      area,
      reason
    };
    this.onElementGetDisplayName.fire(this, options);
    return options.displayName;
  }
  createSurvey(json2, reason, model, callback, area) {
    var _a;
    const survey = this.createSurveyCore(json2, reason);
    if (reason !== "designer" && reason !== "preview" && reason !== "theme") {
      survey.fitToContainer = false;
      survey.applyTheme(designTabSurveyThemeJSON);
      survey.gridLayoutEnabled = false;
    }
    if (reason === "designer" || reason === "modal-question-editor") {
      initializeDesignTimeSurveyModel(survey, this);
    }
    survey["needRenderIcons"] = false;
    if (reason != "designer" && reason != "preview" && reason !== "theme") {
      survey.locale = editorLocalization.currentLocale;
      if (!json2["clearInvisibleValues"]) {
        survey.clearInvisibleValues = "onComplete";
      }
    }
    if (callback) {
      callback(survey);
    }
    area = area || this.getSurveyInstanceCreatedArea(reason);
    const element = area === "property-grid" && model ? model.obj : void 0;
    this.onSurveyInstanceCreated.fire(this, {
      survey,
      reason,
      area,
      model: !!model ? model : (_a = this.currentPlugin) === null || _a === void 0 ? void 0 : _a.model,
      obj: element,
      element
    });
    if (reason === "designer") {
      this.onDesignerSurveyCreated.fire(this, {
        survey
      });
    }
    if (reason === "preview" || reason === "theme") {
      this.onPreviewSurveyCreated.fire(this, {
        survey
      });
    }
    survey.onPopupVisibleChanged.add((_, options) => {
      if (!options.popup.getAreaCallback) options.popup.getAreaCallback = () => {
        return this.rootElement;
      };
    });
    return survey;
  }
  getSurveyInstanceCreatedArea(reason) {
    const hash = {};
    hash["designer"] = "designer-tab";
    hash["test"] = "preview-tab";
    hash["preview"] = "preview-tab";
    hash["default-value"] = "default-value-popup-editor";
    hash["condition-builder"] = "logic-rule:condition-editor";
    hash["logic-item-editor"] = "logic-rule:action-editor";
    hash["logic-items"] = "logic-tab:condition-list";
    hash["theme"] = "theme-tab";
    hash["translation_settings"] = "translation-tab:language-list";
    hash["translation_strings"] = "translation-tab:table";
    hash["translation_strings_header"] = "translation-tab:table-header";
    hash["cells-editor"] = "matrix-cell-values-popup-editor";
    hash["fast-entry"] = "table-values-popup-editor";
    hash["modal-question-editor"] = "matrix-cell-question-popup-editor";
    const res = hash[reason];
    return !!res ? res : reason;
  }
  createSurveyCore(json2 = {}, reason) {
    return new SurveyModel(json2);
  }
  /**
   * Indicates the state of Survey Creator.
   *
   * Accepted values:
   *
   * - `""` - Survey Creator doesn't have unsaved changes.
   * - `"modified"` - Survey Creator has unsaved changes.
   * - `"saving"` - Changes are being saved.
   * - `"saved"` - Changes are successfully saved.
   * @see onModified
   */
  get state() {
    return !!this._stateValue ? this._stateValue : "";
  }
  setState(value) {
    this._stateValue = value;
    this.onStateChanged.fire(this, {
      val: value
    });
    if (!!value) {
      this.notify(this.getLocString("ed." + value));
      this._updateSaveActions();
    }
  }
  setModified(options = null) {
    this.setState("modified");
    this.onModified.fire(this, options);
    this.isAutoSave && this.doAutoSave();
  }
  notifySurveyPropertyChanged(options) {
    this.clearSurveyLogicForUpdate(options.target, options.name, options.newValue);
    this.updateSurveyLogicValues(options.target, options.name, options.oldValue);
    const plugin = this.currentPlugin;
    if (!!plugin && !!plugin.onDesignerSurveyPropertyChanged) {
      plugin.onDesignerSurveyPropertyChanged(options.target, options.name);
    }
    if (!this.onAfterPropertyChanged.isEmpty) {
      options.propertyName = options.name;
      options.obj = options.target;
      options.element = options.target;
      options.value = options.newValue;
      this.onAfterPropertyChanged.fire(this, options);
    }
    options.type = "PROPERTY_CHANGED";
    this.setModified(options);
  }
  notifySurveyItemMoved(options) {
    options.type = "ELEMENT_REORDERED";
    this.setModified(options);
  }
  notifySurveyItemConverted(newElement, oldElement) {
    const options = {
      oldValue: oldElement,
      newValue: newElement
    };
    options.type = "QUESTION_CONVERTED";
    options.className = newElement.getType();
    this.setModified(options);
  }
  /**
   * Displays a toast notification with a specified message.
   *
   * If you want to implement custom toast notification from scratch, handle the [`onNotify`](https://surveyjs.io/survey-creator/documentation/api-reference/survey-creator#onNotify) event.
   * @param message A message to display.
   * @param type A notification type: `"info"` (default) or `"error"`.
   */
  notify(message, type = "info") {
    if (this.onNotify.isEmpty) {
      this.notifier.notify(message, type);
    } else {
      this.onNotify.fire(this, {
        message,
        type
      });
    }
  }
  convertQuestion(obj, className, defaultJSON = null) {
    const objJSON = QuestionConverter.getObjJSON(obj, this.getDefaultElementJSON(obj.getType()));
    const options = {
      sourceQuestion: obj,
      targetType: className,
      json: objJSON
    };
    this.onQuestionConverting.fire(this, options);
    const newQuestion = QuestionConverter.convertObject(obj, className, options.json, this.getDefaultElementJSON(className), defaultJSON);
    return newQuestion;
  }
  getDefaultElementJSON(elType) {
    var _a;
    if (!this.toolbox) return null;
    const json2 = (_a = this.toolbox.getItemByName(elType)) === null || _a === void 0 ? void 0 : _a.json;
    return !!json2 ? Helpers.createCopy(json2) : null;
  }
  singlePageJSON(json2) {
    if (this.pageEditMode === "single") {
      const pages = json2.pages;
      if (Array.isArray(pages) && pages.length > 0) {
        if (pages[0].elements !== void 0) {
          json2.elements = pages[0].elements;
        }
        delete json2.pages;
      }
    }
    if (this.storeSjsVersion) {
      json2["sjsVersion"] = settings.version;
    }
    return json2;
  }
  get storeSjsVersion() {
    return this.storeSjsVersionValue === true;
  }
  set storeSjsVersion(val) {
    this.storeSjsVersionValue = val;
  }
  /**
   * A survey JSON schema.
   *
   * This property allows you to get or set the JSON schema of a survey being configured. Alternatively, you can use the [`text`](#text) property.
   */
  get JSON() {
    const json2 = this.survey.toJSON();
    return this.singlePageJSON(json2);
  }
  set JSON(val) {
    if (this.viewType == "json") {
      this.setTextValue(JSON.stringify(val));
    } else {
      this.initSurveyWithJSON(val, true);
    }
  }
  loadSurvey(surveyId) {
    console.warn("Self-hosted Form Library no longer supports integration with SurveyJS Demo Service. Learn more: https://surveyjs.io/stay-updated/release-notes/v2.0.0#form-library-removes-apis-for-integration-with-surveyjs-demo-service");
  }
  doClickQuestionCore(element, modifiedType = "ADDED_FROM_TOOLBOX", index = -1, panel = null) {
    if (this.survey.pageCount == 0) {
      this.addNewPageIntoSurvey();
    }
    var parent = this.currentPage;
    if (this.pageEditMode === "bypage") {
      const desigerTab = this.getPlugin("designer").model;
      const pagesController = desigerTab.pagesController;
      parent = pagesController.page2Display;
    }
    var selectedElement = this.getSelectedSurveyElement();
    if (selectedElement && selectedElement.parent && selectedElement["page"] == parent && selectedElement !== panel) {
      if (!panel) {
        while (!!selectedElement.parent && selectedElement.parent.isPanel) {
          if (!!selectedElement.parentQuestion) {
            selectedElement = selectedElement.parentQuestion;
          } else {
            selectedElement = selectedElement.parent;
          }
        }
      }
      parent = selectedElement.parent;
      if (index < 0) {
        if (this.addNewQuestionLast && modifiedType === "ADDED_FROM_PAGEBUTTON") {
          index = parent.elements.length;
        } else {
          index = parent.elements.indexOf(selectedElement);
          if (index > -1) index++;
        }
      }
    }
    if (panel) {
      parent = panel;
    }
    this.addNewElementReason = modifiedType;
    element.setVisibleIndex(-1);
    parent.addElement(element, index);
    this.addNewElementReason = "";
    this.setModified({
      type: modifiedType,
      question: element
    });
  }
  setNewNames(element) {
    this.newQuestions = [];
    this.newPanels = [];
    this.newQuestionChangedNames = {};
    this.setNewNamesCore(element);
    this.updateNewElementExpressions(element);
  }
  updateNewElementExpressions(element) {
    const survey = this.createSurvey({}, "updateNewElementExpressions", void 0, (survey2) => {
      survey2.setDesignMode(true);
      if (element.isPage) {
        survey2.addPage(element);
      } else {
        survey2.addNewPage("p1");
        survey2.pages[0].addElement(element);
      }
    });
    const logic = new SurveyLogic(survey);
    for (var key in this.newQuestionChangedNames) {
      logic.renameQuestion(key, this.newQuestionChangedNames[key]);
    }
  }
  getAllQuestions(includeNewItems = true) {
    return this.getAllElements(false, includeNewItems);
  }
  getAllPanels(includeNewItems = true) {
    return this.getAllElements(true, includeNewItems);
  }
  getAllElements(isPanel, includeNewItems) {
    const result = SurveyHelper.getAllElements(this.survey, isPanel);
    if (includeNewItems) {
      SurveyHelper.addElements(this.newPanels, isPanel, result);
      SurveyHelper.addElements(this.newQuestions, isPanel, result);
    }
    return result;
  }
  getNewName(type, isPanel) {
    if (type == "page") return SurveyHelper.getNewPageName(this.survey.pages);
    if (isPanel) return this.getNewPanelName();
    return this.getNewQuestionName();
  }
  getNewQuestionName() {
    return SurveyHelper.getNewQuestionName(this.getAllQuestions());
  }
  getNewPanelName() {
    return SurveyHelper.getNewPanelName(this.getAllPanels());
  }
  setNewNamesCore(element) {
    var elType = element["getType"]();
    var newName = this.getNewName(elType, element.isPanel);
    if (newName != element.name) {
      this.newQuestionChangedNames[element.name] = newName;
      element.name = newName;
    }
    if (element.isPanel || element.isPage) {
      if (element.isPanel) {
        this.newPanels.push(element);
      }
      var panel = element;
      panel.elements.forEach((el) => this.setNewNamesCore(el));
    } else {
      this.newQuestions.push(element);
      const els = Array.isArray(element["templateElements"]) ? element["templateElements"] : Array.isArray(element["detailElements"]) ? element["detailElements"] : void 0;
      if (els) {
        els.forEach((el) => this.setNewNamesCore(el));
      }
    }
  }
  createNewElement(json2) {
    const newElement = Serializer.createClass(json2["type"]);
    new JsonObject().toObject(json2, newElement);
    let needNewName = true;
    if (!!json2.name) {
      if (newElement.isPage) {
        needNewName = !!this.survey.getPageByName(newElement.name);
      } else {
        if (newElement.isPanel) {
          needNewName = !!this.survey.getPanelByName(newElement.name);
        } else {
          needNewName = !!this.survey.getQuestionByName(newElement.name);
        }
      }
    }
    if (needNewName) {
      this.setNewNames(newElement);
    }
    return newElement;
  }
  copyElement(element) {
    var json2 = new JsonObject().toJsonObject(element);
    json2.type = element.getType();
    return this.createNewElement(json2);
  }
  /**
   * Creates a copy of a specified question, inserts the copy next to this question, and (optionally) selects it on the design surface.
   * @param question A question to copy.
   * @param selectCopy *(Optional)* Pass `true` if you want to select the copy on the design surface. Default value: `false`.
   * @returns The instance of a new question.
   */
  copyQuestion(question, selectCopy) {
    var newElement = this.copyElement(question);
    var index = !!question["parent"] ? question["parent"].elements.indexOf(question) + 1 : -1;
    if (index > -1) {
      const elements = question.parent.elements;
      if (index < elements.length && elements[index].startWithNewLine === false) {
        newElement.startWithNewLine = false;
      }
    }
    this.doClickQuestionCore(newElement, "ELEMENT_COPIED", index, question["parent"]);
    if (selectCopy) {
      this.selectElement(newElement);
    }
    return newElement;
  }
  /**
   * @deprecated Use the [`copyQuestion`](https://surveyjs.io/survey-creator/documentation/api-reference/survey-creator#copyQuestion) method instead.
   */
  fastCopyQuestion(question, selectCopy) {
    return this.copyQuestion(question, selectCopy);
  }
  /**
   * Gets or sets the selected survey element: a question, panel, page, or the survey itself.
   * @see onElementSelecting
   * @see onElementSelected
   */
  get selectedElement() {
    return this.selectedElementValue;
  }
  set selectedElement(val) {
    this.selectElement(val);
  }
  /**
   * Refreshes the Designer tab.
   *
   * `refreshDesigner()` is useful if the Designer tab UI depends on an external variable. Call this method each time this variable changes to update the UI.
   */
  refreshDesigner() {
    if (this.activeTab !== "designer") return;
    this.changeText(this.text);
  }
  deleteCurrentObject() {
    this.deleteCurrentElement();
  }
  deleteCurrentElement() {
    this.deleteObject(this.selectedElement);
  }
  /**
   * Deletes a survey element: a question, panel, or page.
   *
   * If you want to delete the focused element, pass the [`selectedElement`](#selectedElement) property value to this method.
   * @param element A survey element to delete.
   * @see onElementDeleting
   */
  deleteElement(element) {
    this.deleteObject(element);
  }
  /**
   * Creates a copy of a specified page and inserts the copy next to this page.
   * @param page A [page](https://surveyjs.io/form-library/documentation/api-reference/page-model) to copy.
   * @returns The [instance of a new page](https://surveyjs.io/form-library/documentation/api-reference/page-model).
   * @see onPageAdding
   * @see onPageAdded
   */
  copyPage(page) {
    this.isCopyingPage = true;
    var newPage = this.copyElement(page);
    var index = this.survey.pages.indexOf(page);
    if (index > -1) {
      this.survey.pages.splice(index + 1, 0, newPage);
    } else {
      this.survey.pages.push(newPage);
    }
    this.isCopyingPage = false;
    newPage.questions.forEach((q) => {
      this.addNewElementReason = "ELEMENT_COPIED";
      this.doOnQuestionAdded(q, q.parent);
    });
    const panels = newPage.getPanels();
    if (Array.isArray(panels)) panels.forEach((p) => this.doOnPanelAdded(p, p.parent));
    this.addNewElementReason = "";
    return newPage;
  }
  deleteObjectCore(obj) {
    if (obj.isPage) {
      var newPage = this.getNextPage(obj);
      this.survey.removePage(obj);
      this.selectElement(!!newPage ? newPage : this.survey);
    } else {
      if (this.survey.pageCount === 1) {
        const page = this.survey.pages[0];
        if (page.elements.length === 1 && obj === page.elements[0] && !SurveyHelper.isPagePropertiesAreModified(page)) {
          this.deleteObjectCore(page);
          return;
        }
      }
      this.deletePanelOrQuestion(obj);
    }
    this.setModified({
      type: "OBJECT_DELETED",
      target: obj
    });
    this.updateConditionsOnRemove(obj);
  }
  getNextPage(page) {
    var index = this.survey.pages.indexOf(page);
    if (index < 0 || this.survey.pages.length == 1) return null;
    if (index == this.survey.pages.length - 1) index--;
    else index++;
    if (index < 0 || index > this.survey.pages.length - 1) return null;
    return this.survey.pages[index];
  }
  deleteObject(obj) {
    if (!this.checkOnElementDeleting(obj)) return;
    this.deleteObjectCore(obj);
  }
  updateConditionsOnRemove(obj) {
    if (!settings2.logic.updateExpressionsOnDeleting.question) return;
    var objType = SurveyHelper.getObjectType(obj);
    var questions;
    if (objType == ObjType.Question) {
      questions = [obj];
    } else {
      var questions = obj.questions;
    }
    if (!questions) return;
    var logic = new SurveyLogic(this.survey, this);
    for (var i = 0; i < questions.length; i++) {
      logic.removeQuestion(questions[i].getValueName());
    }
  }
  checkOnElementDeleting(obj) {
    const options = {
      element: obj,
      elementType: SurveyHelper.getObjectType(obj),
      allowing: true,
      allow: true
    };
    this.onElementDeleting.fire(this, options);
    return options.allowing && options.allow;
  }
  isElementSelected(element) {
    if (!element || element.isDisposed) return false;
    return element.getPropertyValue("isSelectedInDesigner");
  }
  selectElement(element, propertyName, focus = true, startEdit = false) {
    if (!!element && (element.isDisposed || !element.getSurvey() || (element.isQuestion || element.isPanel) && !element.parent)) return;
    var oldValue = this.selectedElement;
    if (oldValue !== element) {
      this.selectedElementValue = this.onSelectingElement(element);
      if (oldValue !== this.selectedElementValue) {
        if (!!oldValue && !oldValue.isDisposed) {
          oldValue.setPropertyValue("isSelectedInDesigner", false);
        }
        if (!!this.selectedElementValue) {
          this.selectedElementValue.setPropertyValue("isSelectedInDesigner", true);
        }
      }
    }
    if (oldValue !== element || !!propertyName) {
      this.selectionChanged(this.selectedElement, propertyName, !!focus);
    }
    var selEl = this.getSelectedSurveyElement();
    if (oldValue !== element && !!document && !!selEl) {
      this.focusElement(element, focus, selEl, propertyName, startEdit);
    }
  }
  focusElement(element, focus, selEl = null, propertyName = null, startEdit = null) {
    if (!selEl) selEl = this.getSelectedSurveyElement();
    if (!selEl) return;
    clearInterval(this.currentFocusInterval);
    clearTimeout(this.currentFocusTimeout);
    this.currentFocusTimeout = setTimeout(() => {
      this.currentFocusInterval = setInterval(() => {
        var _a, _b;
        const el = document.getElementById(selEl.id);
        if (!!selEl && (focus || startEdit && (!selEl.hasTitle || selEl.isPanel))) {
          if (!el || this.rootElement.getAnimations({
            subtree: true
          }).filter((animation) => animation.effect.getComputedTiming().activeDuration !== Infinity && (animation.pending || animation.playState !== "finished"))[0]) return;
          clearInterval(this.currentFocusInterval);
          if (!!el) {
            const isNeedScroll = SurveyHelper.isNeedScrollIntoView((_a = el.parentElement) !== null && _a !== void 0 ? _a : el, true);
            if (!!isNeedScroll) {
              const elementPage = this.getPageByElement(selEl);
              const scrollIntoViewOptions = {
                block: "start",
                behavior: this.animationEnabled ? "smooth" : void 0
              };
              if (!!elementPage) {
                this.survey.scrollElementToTop(selEl, void 0, elementPage, selEl.id, true, scrollIntoViewOptions, this.rootElement);
              } else {
                SurveyHelper.scrollIntoViewIfNeeded((_b = el.parentElement) !== null && _b !== void 0 ? _b : el, () => {
                  return scrollIntoViewOptions;
                }, true);
              }
            }
            if (!propertyName && el.parentElement) {
              let elToFocus = typeof focus === "string" ? el.parentElement.querySelector(focus) : el.parentElement;
              elToFocus && elToFocus.focus({
                preventScroll: true
              });
            }
          }
        } else {
          clearInterval(this.currentFocusInterval);
        }
        if (startEdit && !!element) {
          StringEditorConnector.get(element.locTitle).activateEditor();
        }
      }, 1);
    }, 100);
  }
  getSelectedSurveyElement() {
    var sel = this.selectedElement;
    if (!sel || sel.getType() == "survey") return null;
    return sel.isInteractiveDesignElement && sel.id ? sel : null;
  }
  onSelectingElement(val) {
    var options = {
      element: val,
      newSelectedElement: val
    };
    this.onElementSelecting.fire(this, options);
    if (options.element != val) return options.element;
    if (options.newSelectedElement != val) return options.newSelectedElement;
    return val;
  }
  /**
   * Opens [Survey Creator theme](https://surveyjs.io/survey-creator/documentation/api-reference/survey-creator#creatorTheme) settings in Property Grid. Applies only if [`propertyGridNavigationMode`](https://surveyjs.io/survey-creator/documentation/api-reference/survey-creator#propertyGridNavigationMode) is `"buttons"`.
   * @see closeCreatorThemeSettings
   * @see showCreatorThemeSettings
   */
  openCreatorThemeSettings() {
    const designerPlugin = this.getPlugin("designer");
    if (designerPlugin) {
      designerPlugin.openCreatorThemeSettings();
    }
  }
  /**
   * Closes [Survey Creator theme](https://surveyjs.io/survey-creator/documentation/api-reference/survey-creator#creatorTheme) settings in Property Grid. Applies only if [`propertyGridNavigationMode`](https://surveyjs.io/survey-creator/documentation/api-reference/survey-creator#propertyGridNavigationMode) is `"buttons"`.
   * @see openCreatorThemeSettings
   * @see showCreatorThemeSettings
   */
  closeCreatorThemeSettings() {
    const designerPlugin = this.getPlugin("designer");
    if (designerPlugin) {
      designerPlugin.closeCreatorThemeSettings();
    }
  }
  /**
   * Activates a specified category in Property Grid. Applies only if [`propertyGridNavigationMode`](https://surveyjs.io/survey-creator/documentation/api-reference/survey-creator#propertyGridNavigationMode) is `"buttons"`.
   * @param name A [category name](https://surveyjs.io/form-library/documentation/customize-question-types/add-custom-properties-to-a-form#category).
   */
  activatePropertyGridCategory(name) {
    if (!!this.designerPropertyGrid) {
      this.designerPropertyGrid.activateCategory(name);
    }
  }
  //#region Obsolete designerPropertyGrid
  get designerPropertyGrid() {
    const propertyGridTab = this.sidebar.getPageById("propertyGrid");
    if (!propertyGridTab) return null;
    return propertyGridTab.componentData ? propertyGridTab.componentData.propertyGridModel : null;
  }
  get propertyGrid() {
    return this.designerPropertyGrid.survey;
  }
  /**
   * Collapses a specified category in Property Grid. Applies only if [`propertyGridNavigationMode`](https://surveyjs.io/survey-creator/documentation/api-reference/survey-creator#propertyGridNavigationMode) is `"accordion"`.
   * @param name A [category name](https://surveyjs.io/form-library/documentation/customize-question-types/add-custom-properties-to-a-form#category).
   * @see expandPropertyGridCategory
   */
  collapsePropertyGridCategory(name) {
    if (!!this.designerPropertyGrid) {
      this.designerPropertyGrid.collapseCategory(name);
    }
  }
  /**
   * Expands a specified category in Property Grid. Applies only if [`propertyGridNavigationMode`](https://surveyjs.io/survey-creator/documentation/api-reference/survey-creator#propertyGridNavigationMode) is `"accordion"`.
   * @param name A [category name](https://surveyjs.io/form-library/documentation/customize-question-types/add-custom-properties-to-a-form#category).
   * @see collapsePropertyGridCategory
   * @see activatePropertyGridCategory
   */
  expandPropertyGridCategory(name) {
    if (!!this.designerPropertyGrid) {
      this.designerPropertyGrid.expandCategory(name);
    }
  }
  /**
   * Collapses all categories in Property Grid. Applies only if [`propertyGridNavigationMode`](https://surveyjs.io/survey-creator/documentation/api-reference/survey-creator#propertyGridNavigationMode) is `"accordion"`.
   * @see expandAllPropertyGridCategories
   */
  collapseAllPropertyGridCategories() {
    if (!!this.designerPropertyGrid) {
      this.designerPropertyGrid.collapseAllCategories();
    }
  }
  /**
   * Expands all categories in Property Grid. Applies only if [`propertyGridNavigationMode`](https://surveyjs.io/survey-creator/documentation/api-reference/survey-creator#propertyGridNavigationMode) is `"accordion"`.
   * @see collapseAllPropertyGridCategories
   */
  expandAllPropertyGridCategories() {
    if (!!this.designerPropertyGrid) {
      this.designerPropertyGrid.expandAllCategories();
    }
  }
  collapseAllPropertyTabs() {
    this.collapseAllPropertyGridCategories();
  }
  expandAllPropertyTabs() {
    this.expandAllPropertyGridCategories();
  }
  expandPropertyTab(name) {
    this.expandPropertyGridCategory(name);
  }
  collapsePropertyTab(name) {
    this.collapsePropertyGridCategory(name);
  }
  //#endregion Obsolete designerPropertyGrid
  /**
   * Validates the property values of the [focused element](#selectedElement).
   * @returns `true` if all property values of the focused element are valid or if no element is focused, `false` otherwise.
   * @see onElementSelecting
   * @see onElementSelected
   */
  validateSelectedElement() {
    var isValid = true;
    if (!this.selectedElement) return isValid;
    if (!!this.designerPropertyGrid) {
      isValid = this.designerPropertyGrid.validate();
    }
    return isValid;
  }
  /**
   * Deletes all custom translation strings for a specified locale from Survey Creator and from the generated survey JSON schema.
   * @param locale A locale code (for example, "en").
   * @see locale
   */
  deleteLocaleStrings(locale) {
    const translation = new Translation(this.survey);
    translation.deleteLocaleStrings(locale);
  }
  getPropertyGridDefinition() {
    return this.propertyGridDefinition;
  }
  setPropertyGridDefinition(val) {
    this.propertyGridDefinition = val;
    if (this.designerPropertyGrid) {
      this.designerPropertyGrid.setPropertyGridDefinition(val);
    }
  }
  expandCategoryIfNeeded() {
    if (!this.survey.isEmpty) {
      this.designerPropertyGrid.expandCategoryIfNeeded();
    }
  }
  selectionChanged(element, propertyName, focus = true) {
    this.survey.currentPage = this.getCurrentPageByElement(element);
    this.selectionHistoryController.onObjSelected(element);
    if (this.designerPropertyGrid) {
      this.designerPropertyGrid.obj = element;
      if (!propertyName) {
        propertyName = this.designerPropertyGrid.currentlySelectedProperty;
      }
      if (!!propertyName) {
        this.sidebar.executeOnExpand(() => {
          this.designerPropertyGrid.selectProperty(propertyName, focus || !this.selectFromStringEditor);
        });
      }
      this.expandCategoryIfNeeded();
      this.selectFromStringEditor = false;
    }
    var options = {
      newSelectedElement: element,
      element
    };
    this.onElementSelected.fire(this, options);
  }
  getCurrentPageByElement(element) {
    if (!element) return void 0;
    if (element["isPage"]) return element;
    if (!!element["page"]) return element["page"];
    if (!!element["parentQuestion"]) return this.getCurrentPageByElement(element["parentQuestion"]);
    return void 0;
  }
  clickToolboxItem(newElement, panel = null, modifiedType = "ADDED_FROM_TOOLBOX") {
    if (!this.readOnly) {
      if (newElement["getType"] === void 0) {
        newElement = this.createNewElement(newElement);
      }
      this.survey.lazyRenderEnabled = false;
      this.doClickQuestionCore(newElement, modifiedType, -1, panel);
      this.selectElement(newElement, null, !this.toolbox.searchManager.filterString, this.startEditTitleOnQuestionAdded);
    }
  }
  getJSONForNewElement(json2) {
    var newElement = this.createNewElement(json2);
    json2 = newElement.toJSON();
    json2["type"] = newElement.getType();
    return json2;
  }
  /**
   * Opens a dialog window for users to select files.
   * @param input A [file input HTML element](https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement).
   * @param callback A callback function that you can use to process selected files. Accepts an array of JavaScript <a href="https://developer.mozilla.org/en-US/docs/Web/API/File" target="_blank">File</a> objects.
   * @see onOpenFileChooser
   * @see onUploadFile
   */
  chooseFiles(input, callback, context) {
    if (this.onOpenFileChooser.isEmpty) {
      chooseFiles(input, callback);
    } else {
      this.onOpenFileChooser.fire(this, {
        input,
        element: context && context.element || this.survey,
        elementType: context && context.elementType,
        item: context && context.item,
        propertyName: context && context.propertyName,
        callback,
        context
      });
    }
  }
  /**
   * Uploads files to a server.
   * @param files An array of JavaScript <a href="https://developer.mozilla.org/en-US/docs/Web/API/File" target="_blank">File</a> objects that represent files to upload.
   * @param question A [question instance](https://surveyjs.io/form-library/documentation/api-reference/question) for which files are uploaded.
   * @param callback A callback function that indicates the upload status&mdash;"success" or "error"&mdash;as the first argument. If a file is uploaded successfully, the second argument contains the file's URL.
   * @see onUploadFile
   */
  uploadFiles(files, question, callback, context) {
    if (this.onUploadFile.isEmpty) {
      let fileReader = new FileReader();
      fileReader.onload = (e) => {
        callback("success", fileReader.result);
      };
      fileReader.readAsDataURL(files[0]);
    } else {
      this.onUploadFile.fire(this, {
        question,
        files: files || [],
        callback,
        element: context && context.element || this.survey,
        elementType: context && context.elementType,
        propertyName: context && context.propertyName,
        context
      });
    }
  }
  get rootElement() {
    return this._rootElementValue;
  }
  setRootElement(element) {
    this._rootElementValue = element;
    this.initKeyboardShortcuts(element);
    this.initResponsivityManager(element);
  }
  unsubscribeRootElement() {
    this.removeKeyboardShortcuts(this._rootElementValue);
    this.resetResponsivityManager();
  }
  initKeyboardShortcuts(rootNode) {
    if (!!rootNode) {
      rootNode.addEventListener("keydown", this.onKeyDownHandler);
    }
  }
  removeKeyboardShortcuts(rootNode) {
    if (!!rootNode) {
      rootNode.removeEventListener("keydown", this.onKeyDownHandler);
    }
  }
  findSuitableShortcuts(event) {
    const shortcuts = [];
    const availableShortcuts = Object.keys(this.shortcuts || {}).map((key) => this.shortcuts[key]).filter((shortcut) => !shortcut.affectedTab || shortcut.affectedTab === this.activeTab);
    availableShortcuts.forEach((shortcut) => {
      const hotKey = event.metaKey ? shortcut.macOsHotkey : shortcut.hotKey;
      if (!hotKey) return;
      if (!!hotKey.ctrlKey !== !!event.ctrlKey) return;
      if (!!hotKey.shiftKey !== !!event.shiftKey) return;
      if (hotKey.keyCode !== event.keyCode) return;
      shortcuts.push(shortcut);
    });
    return shortcuts;
  }
  registerShortcut(name, shortcut) {
    this.shortcuts[name] = shortcut;
  }
  unRegisterShortcut(name) {
    delete this.shortcuts[name];
  }
  deletePanelOrQuestion(obj) {
    const changeSelection = obj === this.selectedElement;
    var parent = obj["parent"];
    const elements = parent.elements;
    var objIndex = elements.indexOf(obj);
    if (objIndex == elements.length - 1) {
      objIndex--;
    }
    if (obj["questions"]) {
      obj["questions"].forEach((q) => this.updateConditionsOnRemove(q));
    }
    obj["delete"](false);
    if (parent.isPage && (this.pageEditMode === "single" || elements.length === 0)) {
      parent = this.survey;
    }
    if (changeSelection) {
      this.selectElement(objIndex > -1 ? elements[objIndex] : parent);
    }
  }
  onCanShowObjectProperty(object, property2, showMode, parentObj, parentProperty) {
    if (this.hiddenProperties[property2.id]) return false;
    var options = {
      obj: object,
      element: object,
      property: property2,
      canShow: true,
      show: true,
      showMode,
      parentObj,
      parentElement: parentObj,
      parentProperty
    };
    this.onCanShowProperty.fire(this, options);
    return options.canShow && options.show;
  }
  canDeleteItem(object, item, allowDelete) {
    var options = {
      obj: object,
      item,
      canDelete: allowDelete
    };
    this.onCanDeleteItem.fire(this, options);
    return options.canDelete;
  }
  getErrorOnPropertyChanging(obj, propertyName, value) {
    if (propertyName !== "name") return null;
    if (SurveyHelper.getObjectType(obj) === ObjType.Unknown) return null;
    var hasError = false;
    if (SurveyHelper.getObjectType(obj) === ObjType.Column) {
      hasError = !!obj.colOwner ? !this.isNameUniqueInArray(obj.colOwner.columns, obj, value) : false;
    } else {
      hasError = this.generateUniqueName(obj, value) !== value;
    }
    return hasError ? this.getLocString("pe.propertyNameIsNotUnique") : null;
  }
  generateUniqueName(el, newName) {
    const options = {
      element: el,
      name: newName,
      isDone: true
    };
    const list = [];
    do {
      this.generateUniqueNameCore(options);
      if (!options.isDone && list.indexOf(options.name) > -1) {
        options.name = this.checkForUniqueName(el, options.name);
        break;
      }
      list.push(options.name);
    } while (!options.isDone);
    return options.name;
  }
  generateUniqueNameCore(options) {
    options.name = this.checkForUniqueName(options.element, options.name);
    const evnOptions = {
      element: options.element,
      name: options.name
    };
    this.onGenerateNewName.fire(this, evnOptions);
    if (options.name !== evnOptions.name) {
      options.name = evnOptions.name;
      options.name = this.checkForUniqueName(options.element, options.name);
      options.isDone = options.name === evnOptions.name;
    }
  }
  checkForUniqueName(el, newName) {
    while (!this.isNameUnique(el, newName, false)) {
      newName = SurveyHelper.generateNewName(newName);
    }
    return newName;
  }
  isNameUnique(el, newName, includeNewItems = true) {
    if (!this.isNameUniqueInArray(this.survey.pages, el, newName)) return false;
    if (!this.isNameUniqueInArray(this.getAllPanels(includeNewItems), el, newName)) return false;
    return this.isNameUniqueInArray(this.getAllQuestions(includeNewItems), el, newName);
  }
  isNameUniqueInArray(elements, el, newName) {
    if (!Array.isArray(elements)) return true;
    newName = newName.toLowerCase();
    for (var i = 0; i < elements.length; i++) {
      if (elements[i] != el && elements[i].name.toLowerCase() == newName) return false;
    }
    return true;
  }
  doPropertyGridChanged() {
  }
  //implements ISurveyCreatorOptions
  get alwaySaveTextInPropertyEditors() {
    return this.alwaySaveTextInPropertyEditorsValue;
  }
  set alwaySaveTextInPropertyEditors(value) {
    this.alwaySaveTextInPropertyEditorsValue = value;
  }
  getElementAddornerCssCallback(obj, className) {
    return className;
  }
  onCanShowPropertyCallback(object, property2, showMode = null, parentObj, parentProperty) {
    return this.onCanShowObjectProperty(object, property2, showMode, parentObj, parentProperty);
  }
  onPropertyGridSurveyCreatedCallback(object, survey) {
    const options = {
      obj: object,
      survey
    };
    this.onPropertyGridSurveyCreated.fire(this, options);
  }
  onPropertyEditorCreatedCallback(object, property2, editor) {
    const options = {
      obj: object,
      element: object,
      property: property2,
      editor
    };
    this.onPropertyEditorCreated.fire(this, options);
  }
  onPropertyEditorUpdateTitleActionsCallback(object, property2, editor, titleActions) {
    const options = {
      obj: object,
      element: object,
      property: property2,
      editor,
      titleActions
    };
    this.onPropertyEditorUpdateTitleActions.fire(this, options);
  }
  onPropertyGridShowModalCallback(object, property2, editor, popupEditor, popupModel) {
    const options = {
      obj: object,
      element: object,
      property: property2,
      editor,
      popupEditor,
      popupModel
    };
    this.onPropertyGridShowPopup.fire(this, options);
  }
  onCanDeleteItemCallback(object, item, allowDelete) {
    if (!!item && item["isPage"]) {
      if (this.pageEditMode === "bypage") return item !== this.survey.currentPage;
      if (this.pageEditMode === "single") return false;
    }
    return this.canDeleteItem(object, item, allowDelete);
  }
  onCollectionItemDeletingCallback(obj, property2, collection, item) {
    if ((item === null || item === void 0 ? void 0 : item.isPage) && !this.checkOnElementDeleting(item)) return false;
    if (this.onCollectionItemDeleting.isEmpty) return true;
    const options = {
      obj,
      property: property2,
      propertyName: property2.name,
      collection,
      item,
      allowDelete: true
    };
    this.onCollectionItemDeleting.fire(this, options);
    return options.allowDelete;
  }
  onCollectionItemAllowingCallback(obj, property2, collection, item, itemOptions) {
    if (this.onCollectionItemAllowOperations.isEmpty) return;
    var options = {
      obj,
      element: obj,
      property: property2,
      propertyName: property2 && property2.name,
      collection,
      item,
      allowEdit: itemOptions.allowEdit,
      allowDelete: itemOptions.allowDelete,
      allowAdd: itemOptions.allowAdd
    };
    this.onCollectionItemAllowOperations.fire(this, options);
    itemOptions.allowEdit = options.allowEdit;
    itemOptions.allowDelete = options.allowDelete;
    itemOptions.allowAdd = options.allowAdd;
  }
  onItemValueAddedCallback(obj, propertyName, itemValue, itemValues) {
    var options = {
      obj,
      element: obj,
      propertyName,
      newItem: itemValue,
      itemValues
    };
    this.onItemValueAdded.fire(this, options);
  }
  onFastEntryCallback(items, lines) {
    const options = {
      items,
      lines
    };
    this.onFastEntryFinished.fire(this, options);
    return options.items;
  }
  onMatrixDropdownColumnAddedCallback(matrix, column, columns) {
    var options = {
      newColumn: column,
      matrix,
      columns
    };
    this.onMatrixColumnAdded.fire(this, options);
  }
  onSetPropertyEditorOptionsCallback(propertyName, obj, editorOptions) {
    const options = {
      propertyName,
      obj,
      element: obj,
      editorOptions,
      allowAddRemoveItems: editorOptions.allowAddRemoveItems,
      allowRemoveAllItems: editorOptions.allowRemoveAllItems,
      allowBatchEdit: editorOptions.allowBatchEdit
    };
    const keys = ["allowAddRemoveItems", "allowRemoveAllItems", "allowBatchEdit"];
    keys.forEach((key) => options[key] = editorOptions[key]);
    this.onSetPropertyEditorOptions.fire(this, options);
    this.onConfigureTablePropertyEditor.fire(this, options);
    keys.forEach((key) => editorOptions[key] = editorOptions[key] && options[key]);
  }
  onGetErrorTextOnValidationCallback(propertyName, obj, value) {
    var error = this.getErrorOnPropertyChanging(obj, propertyName, value);
    if (!!error) return error;
    var options = {
      propertyName,
      obj,
      element: obj,
      value,
      error: ""
    };
    this.onPropertyDisplayCustomError.fire(this, options);
    return options.error;
  }
  onValueChangingCallback(options) {
    options.element = options.obj;
    options.oldValue = options.value;
    this.onBeforePropertyChanged.fire(this, options);
  }
  onGetElementEditorTitleCallback(obj, title) {
    return title;
  }
  onConditionQuestionsGetListCallback(propertyName, obj, editor, list, variables) {
    if (this.onConditionGetQuestionList.isEmpty) return settings2.logic.questionSortOrder;
    var options = {
      propertyName,
      obj,
      element: obj,
      editor,
      sortOrder: "asc",
      list,
      variables
    };
    this.onConditionGetQuestionList.fire(this, options);
    if (options.list !== list) {
      list.splice(0, list.length);
      for (var i = 0; i < options.list.length; i++) {
        list.push(options.list[i]);
      }
    }
    return options.sortOrder;
  }
  isConditionOperatorEnabled(questionName, question, operator, isEnabled) {
    if (this.onGetConditionOperator.isEmpty) return isEnabled;
    const options = {
      questionName,
      question,
      questionType: !!question ? question.getType() : "",
      operator,
      show: isEnabled
    };
    this.onGetConditionOperator.fire(this, options);
    return options.show;
  }
  onLogicGetTitleCallback(expression, expressionText, text, logicItem) {
    if (this.onLogicRuleGetDisplayText.isEmpty) return text;
    var options = {
      expression,
      expressionText,
      text,
      logicItem
    };
    this.onLogicRuleGetDisplayText.fire(this, options);
    return options.text;
  }
  getProcessedTranslationItemText(locale, locString, newText, obj) {
    if (this.onTranslationItemChanging.isEmpty) return newText;
    const options = {
      locale,
      obj,
      element: obj,
      locString,
      newText
    };
    this.onTranslationItemChanging.fire(this, options);
    return options.newText;
  }
  getTranslationExportedText(obj, name, locString, locale, text) {
    if (this.onTranslationExportItem.isEmpty) return text;
    const options = {
      obj,
      element: obj,
      name,
      locString,
      locale,
      text
    };
    this.onTranslationExportItem.fire(this, options);
    return options.text;
  }
  getHasMachineTranslation() {
    return !this.onMachineTranslate.isEmpty;
  }
  doMachineTranslation(fromLocale, toLocale, strings, callback) {
    if (!this.getHasMachineTranslation()) {
      callback(void 0);
    } else {
      this.onMachineTranslate.fire(this, {
        fromLocale,
        toLocale,
        strings,
        callback
      });
    }
  }
  doAutoSave() {
    const saveFunc = () => this.doSave();
    if (this.autoSaveDelay <= 0) {
      saveFunc();
      return;
    }
    if (!!this.autoSaveTimerId) {
      clearTimeout(this.autoSaveTimerId);
    }
    var self2 = this;
    this.autoSaveTimerId = setTimeout(function() {
      clearTimeout(self2.autoSaveTimerId);
      self2.autoSaveTimerId = null;
      saveFunc();
    }, this.autoSaveDelay);
  }
  _doSaveCore(onSaveComplete) {
    this.setState("saving");
    if (this.saveSurveyFunc) {
      this.saveNo++;
      this.saveSurveyFunc(this.saveNo, (no, isSuccess) => {
        if (this.saveNo !== no) return;
        if (isSuccess) {
          this.setState("saved");
        } else {
          this.setState("modified");
          if (this.showErrorOnFailedSave) {
            this.notify(this.getLocString("ed.saveError"), "error");
          }
        }
        onSaveComplete && onSaveComplete();
      });
    }
  }
  /**
   * Calls the [`saveSurveyFunc`](https://surveyjs.io/survey-creator/documentation/api-reference/survey-creator#saveSurveyFunc) function to save the survey JSON schema.
   * @see saveTheme
   * @see save
   */
  saveSurvey() {
    this._doSaveCore();
  }
  doSave() {
    this._doSaveCore();
  }
  saveSurveyActionHandler() {
    if (this.syncSaveButtons) {
      this.save();
    } else {
      this.saveSurvey();
    }
  }
  _updateSaveActions() {
    const action = this._findAction("svd-save");
    if (action) {
      action.enabled = this.state === "modified";
      action.active = this.state === "modified";
    }
    if (this.syncSaveButtons) {
      const action2 = this._findAction("svd-save-theme");
      if (action2) {
        action2.enabled = this.hasPendingThemeChanges;
        action2.active = this.hasPendingThemeChanges;
      }
    }
  }
  /**
   * Calls the [`saveSurveyFunc`](https://surveyjs.io/survey-creator/documentation/api-reference/survey-creator#saveSurveyFunc) and [`saveThemeFunc`](https://surveyjs.io/survey-creator/documentation/api-reference/survey-creator#saveThemeFunc) functions to save the survey and theme JSON schemas.
   * @see saveSurvey
   * @see saveTheme
   */
  save() {
    const themeSaveHandler = () => {
      if (this.hasPendingThemeChanges) {
        this._doSaveThemeCore(() => {
          this._updateSaveActions();
        });
      }
    };
    if (this.state === "modified") {
      this._doSaveCore(() => {
        themeSaveHandler();
      });
    } else themeSaveHandler();
  }
  /**
   * A function that is called each time users click the [Save button](https://surveyjs.io/survey-creator/documentation/api-reference/survey-creator#showSaveButton) or [auto-save](https://surveyjs.io/survey-creator/documentation/api-reference/survey-creator#autoSaveEnabled) is triggered to save a survey JSON schema.
   *
   * For more information, refer to the Save and Load Survey Model Schemas help topic for your framework: [Angular](https://surveyjs.io/survey-creator/documentation/get-started-angular#save-and-load-survey-model-schemas) | [Vue](https://surveyjs.io/survey-creator/documentation/get-started-vue#save-and-load-survey-model-schemas) | [React](https://surveyjs.io/survey-creator/documentation/get-started-react#save-and-load-survey-model-schemas) | [HTML/CSS/JavaScript](https://surveyjs.io/survey-creator/documentation/get-started-html-css-javascript#save-and-load-survey-model-schemas).
   * @see saveThemeFunc
   */
  get saveSurveyFunc() {
    return this.saveSurveyFuncValue;
  }
  set saveSurveyFunc(value) {
    this.saveSurveyFuncValue = value;
    this.showSaveButton = value != null && !this.isAutoSave;
  }
  convertCurrentQuestion(newType, defaultJSON = null) {
    var el = this.selectedElement;
    if (!el || el.getType() === newType && !defaultJSON) return;
    const objType = SurveyHelper.getObjectType(el);
    if (objType !== ObjType.Question && objType !== ObjType.Panel) return;
    this.addNewElementReason = "ELEMENT_CONVERTED";
    el = this.convertQuestion(el, newType, defaultJSON);
    this.selectElement(el, null, "#convertTo button");
  }
  getAddNewQuestionText(currentAddQuestionType = null) {
    if (!currentAddQuestionType) currentAddQuestionType = this.currentAddQuestionType;
    if (!!currentAddQuestionType) {
      const str = this.getLocString("ed.addNewTypeQuestion");
      const items = this.toolbox.items.filter((item) => item.name == currentAddQuestionType);
      if (Array.isArray(items) && items.length > 0 && !!str && !!str["format"]) {
        return str["format"](items[0].title);
      }
    }
    return this.getLocString("ed.addNewQuestion");
  }
  get addNewQuestionText() {
    return this.getAddNewQuestionText();
  }
  getAvailableToolboxItems(element, isAddNew = true) {
    const res = [].concat(this.toolbox.items);
    if (!element || this.maxNestedPanels < 0) return res;
    if (!isAddNew && element.isPanel) return res;
    if (this.maxNestedPanels < SurveyHelper.getElementDeepLength(element)) {
      for (let i = res.length - 1; i >= 0; i--) {
        if (res[i].isPanel) {
          res.splice(i, 1);
        }
      }
    }
    return res;
  }
  getQuestionTypeSelectorModel(beforeAdd, element) {
    let panel = !!element && element.isPanel ? element : null;
    const onSelectQuestionType = (questionType2, json2) => {
      this.currentAddQuestionType = questionType2;
      this.addNewQuestionInPage(beforeAdd, panel, questionType2, json2);
      newAction.popupModel.hide();
    };
    const getActions = () => {
      const availableTypes = this.getAvailableToolboxItems(element).map((item) => {
        return this.createIActionBarItemByClass(item, item.needSeparator, onSelectQuestionType);
      });
      return availableTypes;
    };
    const newAction = createDropdownActionModel({
      iconName: "icon-more",
      title: this.getLocString("ed.addNewQuestion")
    }, {
      items: [],
      allowSelection: false,
      cssClass: "svc-creator-popup",
      cssClasses: listComponentCss,
      verticalPosition: "bottom",
      horizontalPosition: "center",
      displayMode: this.isTouch ? "overlay" : "popup"
    });
    newAction.popupModel.getTargetCallback = void 0;
    newAction.popupModel.onVisibilityChanged.add((_, opt) => {
      if (opt.isVisible) {
        const listModel = newAction.popupModel.contentComponentData.model;
        listModel.setItems(getActions());
      }
    });
    return newAction;
  }
  getUpdatedPageAdornerFooterActions(pageAdorner, actions) {
    const options = {
      page: pageAdorner.page,
      addNewQuestion: (type) => {
        pageAdorner.addNewQuestion(pageAdorner, void 0, type);
      },
      actions
    };
    this.onPageGetFooterActions.fire(this, options);
    return options.actions;
  }
  addNewQuestionInPage(beforeAdd, panel = null, type = null, initJson = null) {
    if (!type) type = this.currentAddQuestionType;
    if (!type) type = settings2.designer.defaultAddQuestionType;
    beforeAdd(type);
    let json2 = initJson;
    if (!json2) {
      const toolboxItem = this.toolbox.getItemByName(type);
      if (!!toolboxItem && !!toolboxItem.json) {
        json2 = toolboxItem.json;
      } else {
        json2 = {
          type
        };
      }
    }
    let newElement = this.createNewElement(json2);
    this.clickToolboxItem(newElement, panel, "ADDED_FROM_PAGEBUTTON");
  }
  createIActionBarItemByClass(item, needSeparator, onSelectQuestionType) {
    const action = new Action({
      title: item.title,
      id: item.name,
      iconName: item.iconName,
      iconSize: "auto",
      visible: item.visible,
      enabled: item.enabled,
      needSeparator
    });
    action.action = () => {
      onSelectQuestionType(item.typeName, item.json);
    };
    if (!!item.items && item.items.length > 0 && this.toolbox.showSubitems) {
      const innerItems = item.items.map((i) => new Action({
        id: i.id,
        title: i.title,
        action: () => {
          action.hidePopup();
          onSelectQuestionType(item.typeName, i.json);
        }
      }));
      action.setSubItems({
        items: innerItems,
        cssClasses: listComponentCss
      });
    }
    return action;
  }
  onElementMenuItemsChanged(element, items) {
    this.onElementGetActions.fire(this, {
      obj: element,
      element,
      items,
      actions: items
    });
  }
  getElementAllowOperations(element) {
    const allowDragDefault = !!element && (!element.isPage || element.isPage && this.allowDragPages);
    var options = {
      obj: element,
      element,
      allowDelete: true,
      allowCopy: true,
      allowDragging: allowDragDefault,
      allowDrag: allowDragDefault,
      allowChangeType: true,
      allowChangeInputType: true,
      allowChangeRequired: true,
      allowShowSettings: void 0,
      allowEdit: void 0,
      allowExpandCollapse: void 0
    };
    this.onElementAllowOperations.fire(this, options);
    options.allowDrag = options.allowDragging = options.allowDrag && options.allowDragging;
    return options;
  }
  getChoicesItemBaseTitle() {
    return this.getLocString("ed.choices_Item") || surveyLocalization.getString("choices_Item");
  }
  getNextItemValue(question) {
    const itemText = this.getChoicesItemBaseTitle();
    return getNextItemValue(itemText, question.choices);
  }
  createNewItemValue(question, callEvent = true, callback) {
    const nextValue = this.getNextItemValue(question);
    const res = question.createItemValue(nextValue);
    res.text = getNextItemText(question.choices);
    question.choices.push(res);
    if (callback) {
      callback(res);
    }
    if (callEvent) {
      const propName = !!res.ownerPropertyName ? res.ownerPropertyName : "choices";
      this.onItemValueAddedCallback(question, propName, res, question.choices);
    }
    return res;
  }
  onPropertyValueChanged(name, oldValue, newValue) {
    super.onPropertyValueChanged(name, oldValue, newValue);
    if (name === "viewType") {
      this.tabs.forEach((tab) => {
        const isActive = this.viewType === tab.id;
        tab.active = isActive;
        tab.disableHide = isActive;
      });
    }
  }
  initResponsivityManager(container) {
    this.responsivityManager = new CreatorResponsivityManager(container, this);
  }
  resetResponsivityManager() {
    if (!!this.responsivityManager) {
      this.responsivityManager.dispose();
      this.responsivityManager = void 0;
    }
  }
  get showPageNavigator() {
    return this.showPageNavigatorValue && this.allowShowPageNavigator;
  }
  set showPageNavigator(val) {
    this.showPageNavigatorValue = val;
  }
  /**
   * Collapses all survey elements in the design surface.
   * @see expandAll
   * @see collapseElement
   */
  collapseAll() {
    this.expandCollapseManager.expandCollapseElements(null, true);
  }
  /**
   * Expands all survey elements on the design surface.
   * @see collapseAll
   * @see expandElement
   */
  expandAll() {
    this.expandCollapseManager.expandCollapseElements(null, false);
  }
  /**
   * Collapses an individual survey element on the design surface.
   * @param element A survey element to collapse.
   * @see expandElement
   * @see collapseAll
   */
  collapseElement(element) {
    SurveyElementAdornerBase.GetAdorner(element).collapsed = true;
  }
  /**
   * Expands an individual survey element on the design surface.
   * @param element A survey element to expand.
   * @see collapseElement
   * @see expandAll
   */
  expandElement(element) {
    SurveyElementAdornerBase.GetAdorner(element).collapsed = false;
  }
  dispose() {
    this.isCreatorDisposed = true;
    this.tabs = [];
    Object.keys(this.plugins).forEach((pluginName) => {
      const plugin = this.plugins[pluginName];
      if (typeof plugin.deactivate === "function") {
        plugin.deactivate();
      }
      if (typeof plugin.dispose === "function") {
        plugin.dispose();
      }
    });
    super.dispose();
  }
  getRootCss() {
    return new CssClassBuilder().append("svc-creator").append("svc-creator--mobile", this.isMobileView).append("svc-creator--touch", this.isTouch).append("svc-creator--disable-animations", !this.animationEnabled).toString();
  }
  /**
   * Applies a specified UI theme to Survey Creator.
   * @param theme An `ICreatorTheme` object with theme settings.
   * @see creatorTheme
   * @see showCreatorThemeSettings
   */
  applyCreatorTheme(theme) {
    this.syncTheme(theme);
    const designerPlugin = this.getPlugin("designer");
    if (designerPlugin) {
      designerPlugin.setTheme();
    }
  }
  syncTheme(theme, isLight) {
    if (!theme) return;
    this.creatorTheme = theme;
    const newCssVariable = {};
    assign(newCssVariable, theme === null || theme === void 0 ? void 0 : theme.cssVariables);
    const designerPlugin = this.getPlugin("designer");
    if (designerPlugin) {
      designerPlugin.model.updateSurfaceCssVariables();
    }
    this.themeVariables = newCssVariable;
    const iconsSetName = this.creatorTheme && this.creatorTheme["iconSet"] ? this.creatorTheme["iconSet"] : "v2";
    SvgRegistry.registerIcons(SvgThemeSets[iconsSetName]);
    if (isLight !== void 0) {
      this.preferredColorPalette = isLight ? "light" : "dark";
    }
  }
  /**
   * Specifies whether users can drag and drop pages on the design surface.
   *
   * Default value: `true` if [`pageEditMode`](https://surveyjs.io/survey-creator/documentation/api-reference/survey-creator#pageEditMode) is `"standard"`; `false` otherwise.
   * @see collapseOnDrag
   */
  get allowDragPages() {
    return this._allowDragPages && this.pageEditMode !== "single" && this.pageEditMode !== "bypage";
  }
  set allowDragPages(newValue) {
    this._allowDragPages = newValue;
  }
};
__decorate2([property({
  defaultValue: true
})], SurveyCreatorModel.prototype, "showDesignerTab", void 0);
__decorate2([property({
  defaultValue: true
})], SurveyCreatorModel.prototype, "showJSONEditorTab", void 0);
__decorate2([property({
  defaultValue: true
})], SurveyCreatorModel.prototype, "showTestSurveyTab", void 0);
__decorate2([property({
  defaultValue: false
})], SurveyCreatorModel.prototype, "showThemeTab", void 0);
__decorate2([property({
  defaultValue: true
})], SurveyCreatorModel.prototype, "showCreatorThemeSettings", void 0);
__decorate2([property({
  defaultValue: true
})], SurveyCreatorModel.prototype, "allowZoom", void 0);
__decorate2([property({
  defaultValue: false
})], SurveyCreatorModel.prototype, "showTranslationTab", void 0);
__decorate2([property({
  defaultValue: true
})], SurveyCreatorModel.prototype, "showLogicTab", void 0);
__decorate2([property({
  defaultValue: false
})], SurveyCreatorModel.prototype, "useTableViewInLogicTab", void 0);
__decorate2([property({
  defaultValue: 0
})], SurveyCreatorModel.prototype, "pageHoverDelay", void 0);
__decorate2([property({
  defaultValue: false
})], SurveyCreatorModel.prototype, "inplaceEditChoiceValues", void 0);
__decorate2([property({
  defaultValue: true
})], SurveyCreatorModel.prototype, "previewShowResults", void 0);
__decorate2([property({
  defaultValue: true
})], SurveyCreatorModel.prototype, "_showOneCategoryInPropertyGrid", void 0);
__decorate2([property({
  defaultValue: false
})], SurveyCreatorModel.prototype, "autoSaveEnabled", void 0);
__decorate2([property()], SurveyCreatorModel.prototype, "showOptions", void 0);
__decorate2([property({
  defaultValue: false
})], SurveyCreatorModel.prototype, "showSearch", void 0);
__decorate2([property({
  defaultValue: true
})], SurveyCreatorModel.prototype, "generateValidJSON", void 0);
__decorate2([property({
  defaultValue: ""
})], SurveyCreatorModel.prototype, "currentAddQuestionType", void 0);
__decorate2([property({
  defaultValue: "landscape"
})], SurveyCreatorModel.prototype, "previewOrientation", void 0);
__decorate2([property()], SurveyCreatorModel.prototype, "surveyValue", void 0);
__decorate2([property({
  defaultValue: true
})], SurveyCreatorModel.prototype, "allowShowToolbox", void 0);
__decorate2([property({
  defaultValue: true
})], SurveyCreatorModel.prototype, "showToolboxValue", void 0);
__decorate2([property()], SurveyCreatorModel.prototype, "showSidebarValue", void 0);
__decorate2([undoRedoTransaction()], SurveyCreatorModel.prototype, "addPage", null);
__decorate2([ignoreUndoRedo()], SurveyCreatorModel.prototype, "doOnQuestionAdded", null);
__decorate2([ignoreUndoRedo()], SurveyCreatorModel.prototype, "doOnPanelAdded", null);
__decorate2([ignoreUndoRedo()], SurveyCreatorModel.prototype, "doOnPageAdded", null);
__decorate2([undoRedoTransaction()], SurveyCreatorModel.prototype, "deleteObject", null);
__decorate2([property({
  defaultValue: false,
  onSet(val, target) {
    let themeTabPlugin = target.getPlugin("theme");
    if (!themeTabPlugin) {
      return;
    }
    if (val) {
      target.onModified.add(target._syncSaveActions);
      themeTabPlugin.onThemePropertyChanged.add(target._syncSaveActions);
      themeTabPlugin.onThemeSelected.add(target._syncSaveActions);
    } else {
      target.onModified.remove(target._syncSaveActions);
      themeTabPlugin.onThemePropertyChanged.remove(target._syncSaveActions);
      themeTabPlugin.onThemeSelected.remove(target._syncSaveActions);
    }
  }
})], SurveyCreatorModel.prototype, "syncSaveButtons", void 0);
__decorate2([property({
  defaultValue: false
})], SurveyCreatorModel.prototype, "showSaveButton", void 0);
__decorate2([undoRedoTransaction()], SurveyCreatorModel.prototype, "convertCurrentQuestion", null);
__decorate2([undoRedoTransaction()], SurveyCreatorModel.prototype, "addNewQuestionInPage", null);
__decorate2([property({
  defaultValue: false
})], SurveyCreatorModel.prototype, "showHeaderInEmptySurvey", void 0);
__decorate2([property({
  defaultValue: true
})], SurveyCreatorModel.prototype, "allowShowPageNavigator", void 0);
__decorate2([property({
  defaultValue: true
})], SurveyCreatorModel.prototype, "allowShowSurfaceToolbar", void 0);
__decorate2([property({
  defaultValue: true
})], SurveyCreatorModel.prototype, "showPageNavigatorValue", void 0);
__decorate2([property({
  getDefaultValue: (obj) => {
    return obj.showTabsDefault;
  }
})], SurveyCreatorModel.prototype, "showTabs", void 0);
__decorate2([property({
  getDefaultValue: (obj) => {
    return obj.showToolbarDefault;
  }
})], SurveyCreatorModel.prototype, "showToolbar", void 0);
__decorate2([property({
  getDefaultValue: () => {
    return settings2.layout.allowCollapseSidebar;
  }
})], SurveyCreatorModel.prototype, "allowCollapseSidebar", void 0);
__decorate2([property({
  getDefaultValue: () => {
    return settings2.designer.showAddQuestionButton;
  }
})], SurveyCreatorModel.prototype, "showAddQuestionButton", void 0);
__decorate2([property({
  defaultValue: false,
  onSet: (val, creator) => {
    creator.survey.setIsMobile(!!val);
  }
})], SurveyCreatorModel.prototype, "isMobileView", void 0);
__decorate2([property({
  defaultValue: false
})], SurveyCreatorModel.prototype, "isTouch", void 0);
__decorate2([property({
  defaultValue: "left",
  onSet: (newValue, target) => {
    if (!target.toolbox) return;
    target.toolbox.setLocation(newValue);
    target.updateToolboxIsCompact();
  }
})], SurveyCreatorModel.prototype, "toolboxLocation", void 0);
__decorate2([property({
  defaultValue: "right"
})], SurveyCreatorModel.prototype, "sidebarLocation", void 0);
__decorate2([property({
  defaultValue: "onhover"
})], SurveyCreatorModel.prototype, "expandCollapseButtonVisibility", void 0);
__decorate2([property({
  defaultValue: false,
  onSet: (newValue, target) => {
    if (!newValue) {
      throw new Error("Creator is disposed");
    }
  }
})], SurveyCreatorModel.prototype, "isCreatorDisposed", void 0);
__decorate2([property({
  defaultValue: true
})], SurveyCreatorModel.prototype, "enableLinkFileEditor", void 0);
__decorate2([property({
  defaultValue: {}
})], SurveyCreatorModel.prototype, "themeVariables", void 0);
__decorate2([property()], SurveyCreatorModel.prototype, "creatorTheme", void 0);
var CreatorBase = class extends SurveyCreatorModel {
};
function initializeDesignTimeSurveyModel(model, creator) {
  model.creator = creator;
  model.isPopupEditorContent = false;
  model.onElementWrapperComponentName.add((_, opt) => {
    const compName = opt.componentName;
    if (opt.wrapperName === "component") {
      opt.componentName = getElementWrapperComponentName(opt.element, opt.reason, model.isPopupEditorContent);
    }
    if (opt.wrapperName === "content-component") {
      opt.componentName = getQuestionContentWrapperComponentName(opt.element);
    }
    if (opt.wrapperName === "row") {
      opt.componentName = "svc-row";
    }
    if (opt.wrapperName === "itemvalue") {
      opt.componentName = getItemValueWrapperComponentName(opt.item, opt.element);
    }
    opt.componentName = opt.componentName || compName;
  });
  model.onElementWrapperComponentData.add((_, opt) => {
    const data = opt.data;
    if (opt.wrapperName === "component") {
      opt.data = getElementWrapperComponentData(opt.element, opt.reason, creator);
    }
    if (opt.wrapperName === "row") {
      opt.data = {
        creator,
        row: opt.element
      };
    }
    if (opt.wrapperName === "itemvalue") {
      opt.data = getItemValueWrapperComponentData(opt.item, opt.element, creator);
    }
    opt.data = opt.data || data;
  });
  model.getRendererForString = (element, name) => {
    if (!creator.readOnly && isStringEditable(element)) {
      return editableStringRendererName;
    }
    return void 0;
  };
  model.getRendererContextForString = (element, locStr) => {
    if (!creator.readOnly && isStringEditable(element, locStr.name)) {
      return {
        creator,
        element,
        locStr
      };
    }
    return locStr;
  };
  model.locTitle.placeholder = "pe.surveyTitlePlaceholder";
  model.locDescription.placeholder = "pe.surveyDescriptionPlaceholder";
}
function isContentElement(element) {
  let current = element;
  while (!!current) {
    if (current.isContentElement) {
      return true;
    }
    current = current.parentQuestion;
  }
  return false;
}
function getQuestionFromElement(element) {
  if (!element) return null;
  if (!!element.row) return element.row.data;
  if (!!element.column) return element.column.colOwner;
  return null;
}
var editableStringRendererName = "svc-string-editor";
function getElementWrapperComponentName(element, reason, isPopupEditorContent) {
  if (reason === "logo-image") {
    return "svc-logo-image";
  }
  if (reason === "cell" || reason === "column-header" || reason === "row-header") {
    if (isContentElement(getQuestionFromElement(element))) return void 0;
    return "svc-matrix-cell";
  }
  if (!isContentElement(element)) {
    if (element instanceof Question) {
      const isDropdown = element.isDescendantOf("dropdown") || element.isDescendantOf("tagbox");
      if (isPopupEditorContent) {
        return isDropdown ? "svc-cell-dropdown-question" : "svc-cell-question";
      }
      if (element.customWidget) {
        return "svc-widget-question";
      }
      if (isDropdown) {
        return "svc-dropdown-question";
      }
      if (element.isDescendantOf("image")) {
        return "svc-image-question";
      }
      return "svc-question";
    }
    if (element instanceof PanelModel) {
      return "svc-panel";
    }
  }
  return void 0;
}
function getQuestionContentWrapperComponentName(element) {
  if (element.isDescendantOf("rating") && !isContentElement(element)) {
    return "svc-rating-question-content";
  }
  return void 0;
}
function getElementWrapperComponentData(element, reason, creator) {
  if (reason === "logo-image") return creator;
  if (reason === "cell" || reason === "column-header" || reason === "row-header") {
    return {
      creator,
      element,
      question: element.question,
      row: element.row,
      column: element.column
    };
  }
  const hasWrapper = getElementWrapperComponentName(element, reason, false);
  if (!hasWrapper) return void 0;
  if (element instanceof Question) return creator;
  if (element instanceof PanelModel) return creator;
  return null;
}
function getItemValueWrapperComponentName(item, question) {
  if (isContentElement(question)) {
    return SurveyModel.TemplateRendererComponentName;
  }
  if (question.isDescendantOf("imagepicker")) {
    return "svc-image-item-value";
  }
  return "svc-item-value";
}
function getItemValueWrapperComponentData(item, question, creator) {
  if (question.isContentElement) {
    return item;
  }
  return {
    creator,
    question,
    item
  };
}
function isStringEditable(element, name) {
  if (element.parentQuestion instanceof QuestionMatrixDropdownModelBase) {
    if (!!element.data || isContentElement(element.parentQuestion)) return false;
  }
  return !isContentElement(element) || element.isEditableTemplateElement;
}
function isTextInput(target) {
  if (!target.tagName) return false;
  const tagName = target.tagName.toLowerCase();
  if (["input", "textarea"].indexOf(tagName) !== -1) return true;
  if (["span", "div"].indexOf(tagName) !== -1) {
    return target.isContentEditable;
  }
  return false;
}
function registerAdorner(name, adorner) {
  SurveyHelper.warnNonSupported("registerAdorner", "This functionality is no longer supported.");
}
function removeAdorners(names = void 0) {
  SurveyHelper.warnNonSupported("removeAdorners", "This functionality is no longer supported.");
}
var ToolboxToolViewModel = class extends Base {
  constructor(item, creator, model) {
    super();
    this.item = item;
    this.creator = creator;
    this.model = model;
    this.click = (event) => {
      if (!this.allowAdd) return;
      this.creator.clickToolboxItem(this.item.json);
      this.hidePopup();
    };
    this.onPointerUp = (pointerUpEvent) => {
      this.hidePopup();
      this.toolboxItem.isPressed = false;
      document.removeEventListener("pointerup", this.onPointerUp);
    };
    this.startDragToolboxItem = (pointerDownEvent, currentTarget) => {
      var json2 = this.creator.getJSONForNewElement(this.item.json);
      this.dragDropHelper.startDragToolboxItem(pointerDownEvent, json2, this.item);
      return true;
    };
    this.dragOrClickHelper = new DragOrClickHelper(this.startDragToolboxItem);
    if (!this.isDotsItem()) {
      const popup = item.popupModel;
      if (!!popup) {
        const className = new CssClassBuilder().append(popup.cssClass).append("svc-toolbox-subtypes").toString();
        popup.cssClass = className;
        popup.isFocusedContainer = false;
        popup.contentComponentName = "svc-toolbox-list";
        popup.contentComponentData["creator"] = creator;
        popup.isFocusedContent = false;
      }
    }
  }
  get toolboxItem() {
    return this.item;
  }
  get itemComponent() {
    if (!!this.creator && !this.creator.toolbox.showSubitems && this.toolboxItem.hasSubItems) {
      return QuestionToolbox.defaultItemComponent;
    }
    return this.item.component || QuestionToolbox.defaultItemComponent;
  }
  get allowAdd() {
    return !this.creator.readOnly;
  }
  onMouseOver(itemValue, mouseoverEvent) {
    this.model.mouseOverHandler(itemValue);
  }
  onMouseLeave(itemValue, mouseoverEvent) {
    itemValue.hidePopupDelayed(this.creator.toolbox.subItemsHideDelay);
  }
  onPointerDown(pointerDownEvent) {
    var _a;
    pointerDownEvent.stopPropagation();
    if (!this.allowAdd) return;
    if (this.isDotsItem()) return true;
    this.dragOrClickHelper.onPointerDown(pointerDownEvent);
    this.toolboxItem.isPressed = true;
    document.addEventListener("pointerup", this.onPointerUp);
    (_a = this.creator) === null || _a === void 0 ? void 0 : _a.onDragDropItemStart();
  }
  isDotsItem() {
    return this.item.id.indexOf("dotsItem-id") === 0;
  }
  hidePopup() {
    this.toolboxItem.hidePopup();
    this.toolboxItem.isHovered = false;
  }
  get dragDropHelper() {
    return this.creator.dragDropSurveyElements;
  }
};
var PageNavigatorViewModel = class _PageNavigatorViewModel extends Base {
  constructor(pagesController, pageEditMode) {
    super();
    this.pagesController = pagesController;
    this.pageEditMode = pageEditMode;
    this.pagesChangedFunc = (sender, options) => {
      this.buildItems();
    };
    this.currentPagesChangedFunc = (sender, options) => {
      this.currentPage = this.pagesController.currentPage;
    };
    this.pcPropertyChangedHandler = (sender, options) => {
      if (options.name === "toolboxLocation") {
        if (this.pagesController.creator["toolboxLocation"] == "sidebar") {
          this.popupModel.horizontalPosition = "right";
        } else {
          this.popupModel.horizontalPosition = this.pagesController.creator["toolboxLocation"];
        }
      }
    };
    this.togglePageSelector = (event) => this.popupModel.toggleVisibility();
    this.icon = "icon-select-page";
    this.pagesController.onPagesChanged.add(this.pagesChangedFunc);
    this.pagesController.onCurrentPageChanged.add(this.currentPagesChangedFunc);
    this.pageListModel = new ListModel({
      items: [],
      onSelectionChanged: (item) => {
        this.pagesController.selectPage(item.data);
        this.popupModel.hide();
      },
      cssClasses: listComponentCss,
      allowSelection: true
    });
    this.popupModel = new PopupModel("sv-list", {
      model: this.pageListModel
    }, {
      cssClass: "svc-creator-popup"
    });
    !!this.pagesController && (this.popupModel.horizontalPosition = this.pagesController.creator["toolboxLocation"]);
    this.popupModel.onShow = () => {
      this.pageListModel.selectedItem = this.getActionBarByPage(this.pagesController.currentPage);
      this.isPopupOpened = true;
    };
    this.popupModel.onHide = () => {
      this.isPopupOpened = false;
    };
    if (!!this.pagesController.creator["onPropertyChanged"]) {
      this.pagesController.creator["onPropertyChanged"].add(this.pcPropertyChangedHandler);
    }
    this.buildItems();
  }
  dispose() {
    super.dispose();
    this.stopItemsContainerHeightObserver();
    this.pagesController.onPagesChanged.remove(this.pagesChangedFunc);
    this.pagesController.onCurrentPageChanged.remove(this.currentPagesChangedFunc);
    if (!!this.pagesController.creator["onPropertyChanged"]) {
      this.pagesController.creator["onPropertyChanged"].remove(this.pcPropertyChangedHandler);
      this.pcPropertyChangedHandler = void 0;
    }
    if (this.pageListModel) {
      this.pageListModel.dispose();
    }
    if (this.popupModel) {
      this.popupModel.dispose();
    }
    this._scrollableContainer = void 0;
    this._itemsContainer = void 0;
  }
  getActionBarByPage(page) {
    for (var i = 0; i < this.items.length; i++) {
      if (this.items[i].data === page) return this.items[i];
    }
    return null;
  }
  setItems(items) {
    this.items = items;
    this.pageListModel.setItems(items);
    this.updateVisibility();
  }
  buildItems() {
    this.currentPage = this.pagesController.currentPage || this.pagesController.pages[0];
    var items = [];
    var pages = this.pagesController.pages;
    for (var i = 0; i < pages.length; i++) {
      items.push(this.createActionBarItem(pages[i]));
    }
    if (this.pagesController.creator["pageEditMode"] === "bypage") {
      const newPage = this.pagesController["creator"].getPlugin("designer").model.newPage;
      if (!!newPage) {
        items.push(this.createActionBarItem(newPage));
      }
    }
    this.setItems(items);
  }
  patchContainerOffset(el) {
    while (!!el) {
      if (el.className.indexOf("svc-tab-designer--with-surface-tools") !== -1) {
        el.offsetParent.scrollTop = 0;
        return;
      }
      el = el.parentElement;
    }
  }
  createActionBarItem(page) {
    const item = {
      id: page.id,
      title: new ComputedUpdater(() => {
        var pageName = page.name;
        var pageTitle = page.title;
        return this.pagesController ? this.pagesController.getDisplayName(page) : pageTitle || pageName;
      })
    };
    item.active = new ComputedUpdater(() => page === this.currentPage);
    item.action = (item2) => {
      this.scrollToPage(page);
    };
    item.data = page;
    return this.createActionBarCore(item);
  }
  get isByPageMode() {
    return this.pagesController.creator["pageEditMode"] === "bypage";
  }
  scrollToPage(page) {
    if (this.pageEditMode === "bypage") {
      this.pagesController.currentPage = page;
      this.currentPage = page;
      this.pagesController.creator.selectElement(this.pagesController.currentPage);
      return;
    }
    const el = document.getElementById(page.id);
    if (!!el) {
      const isLastPage = this.pagesController.pages.indexOf(page) === this.pagesController.pages.length - 1;
      if (!!this._scrollableContainer) {
        this._scrollableContainer.scrollTo(this._scrollableContainer.scrollLeft, el.offsetTop - 20);
        this.patchContainerOffset(el);
        if (isLastPage) {
          setTimeout(() => {
            this._scrollableContainer.scrollTo(this._scrollableContainer.scrollLeft, el.offsetTop - 20);
            this.patchContainerOffset(el);
          }, 50);
        }
      } else {
        el.scrollIntoView({
          block: "start"
        });
        this.patchContainerOffset(el);
        if (isLastPage) {
          setTimeout(() => {
            el.scrollIntoView({
              block: "start"
            });
            this.patchContainerOffset(el);
          }, 50);
        }
      }
    }
  }
  createActionBarCore(item) {
    return new Action(item);
  }
  get pageSelectorCaption() {
    return getLocString("ed.selectPage");
  }
  onContainerScroll(viewPort) {
    const viewPortTop = viewPort.scrollTop;
    const viewPortHeight = viewPort.clientHeight;
    const viewPortBottom = viewPortTop + viewPortHeight;
    const visiblePages = [];
    let maxVisiblePage = void 0;
    let maxVisiblePagePart = 0;
    this.pagesController.pages.forEach((page) => {
      const pageElement = document.getElementById(page.id);
      if (!!pageElement) {
        const pageTop = pageElement.offsetTop;
        const pageBottom = pageTop + pageElement.clientHeight;
        const possiblyVisible = pageTop < viewPortBottom || pageBottom > viewPortTop;
        if (!possiblyVisible) return;
        const deltaTop = pageTop - viewPortTop;
        const deltaBottom = viewPortBottom - pageBottom;
        let visiblePart = pageElement.clientHeight;
        if (deltaTop < 0) {
          visiblePart += deltaTop;
        }
        if (deltaBottom < 0) {
          visiblePart += deltaBottom;
        }
        visiblePart = visiblePart / pageElement.clientHeight;
        if (visiblePart > 0) {
          visiblePages.push({
            page,
            visiblePart
          });
          if (visiblePart > maxVisiblePagePart) {
            maxVisiblePagePart = visiblePart;
            maxVisiblePage = page;
          }
        }
      }
    });
    this.currentPage = maxVisiblePage;
    return visiblePages;
  }
  stopItemsContainerHeightObserver() {
    this._itemsContainer = void 0;
    if (!!this._resizeObserver) {
      this._resizeObserver.disconnect();
      this._resizeObserver = void 0;
    }
    if (!this.isDisposed) {
      this.visibleItemsStartIndex = 0;
      this.visibleItemsCount = Number.MAX_VALUE;
    }
  }
  setScrollableContainer(scrollableContainer) {
    if (!!this._scrollableContainer) {
      this._scrollableContainer.onscroll = void 0;
    }
    this._scrollableContainer = scrollableContainer;
  }
  setItemsContainer(itemsContainer) {
    this.stopItemsContainerHeightObserver();
    this._itemsContainer = itemsContainer;
    this._resizeObserver = new ResizeObserver((entries, observer) => this.updateVisibleItems(entries[0].contentBoxSize[0].blockSize));
    this._resizeObserver.observe(itemsContainer);
  }
  updateVisibleItems(allAvailableHeight) {
    this.updateVisibility();
    if (this.isByPageMode) {
      return;
    }
    const itemsAvailableHeight = allAvailableHeight - _PageNavigatorViewModel.PAGE_NAVIGATION_MENU_ITEM_HEIGHT;
    this.visibleItemsCount = Math.floor(itemsAvailableHeight / _PageNavigatorViewModel.PAGE_NAVIGATION_ITEM_HEIGHT);
    const currantPageIndex = this.pagesController.pages.indexOf(this.currentPage);
    let visibleStart = 0;
    if (currantPageIndex >= this.visibleItemsCount) {
      visibleStart = this.items.length - currantPageIndex - 1 < this.visibleItemsCount / 2 ? this.items.length - this.visibleItemsCount : currantPageIndex - Math.floor(this.visibleItemsCount / 2);
    }
    this.visibleItemsStartIndex = visibleStart;
  }
  _updateVisibility() {
    this.hasScrolling = !this._scrollableContainer || this._scrollableContainer.scrollHeight > this._scrollableContainer.clientHeight;
    this.visible = this.items.length > 1 && (this.hasScrolling || this.isByPageMode);
    if (this.isByPageMode) {
      this.visibleItemsStartIndex = 0;
      this.visibleItemsCount = this.items.length;
    }
  }
  updateVisibility() {
    setTimeout(() => {
      this._updateVisibility();
    }, 10);
  }
  get visibleItems() {
    if (this.items.length <= this.visibleItemsCount) {
      return this.items;
    }
    return this.items.slice(this.visibleItemsStartIndex, this.visibleItemsStartIndex + this.visibleItemsCount);
  }
  attachToUI(el) {
    if (!!el) {
      const scrollableContainer = el.parentElement.parentElement.parentElement.parentElement.parentElement;
      const self2 = this;
      scrollableContainer.onscroll = function(ev) {
        return self2.onContainerScroll(ev.currentTarget);
      };
      this.setItemsContainer(el.parentElement);
      this.setScrollableContainer(scrollableContainer);
    }
  }
};
PageNavigatorViewModel.PAGE_NAVIGATION_MENU_ITEM_HEIGHT = 44;
PageNavigatorViewModel.PAGE_NAVIGATION_ITEM_HEIGHT = 36;
__decorate2([property({
  defaultValue: true
})], PageNavigatorViewModel.prototype, "hasScrolling", void 0);
__decorate2([propertyArray()], PageNavigatorViewModel.prototype, "items", void 0);
__decorate2([property({
  defaultValue: false
})], PageNavigatorViewModel.prototype, "visible", void 0);
__decorate2([property({
  defaultValue: false
})], PageNavigatorViewModel.prototype, "isPopupOpened", void 0);
__decorate2([property({
  onSet: (page, navigator2) => {
    const currantPageIndex = navigator2.pagesController.pages.indexOf(page);
    if (currantPageIndex >= navigator2.visibleItemsStartIndex && currantPageIndex < navigator2.visibleItemsStartIndex + navigator2.visibleItemsCount) {
      return;
    }
    let newVisibleItemsStartIndex = navigator2.visibleItemsStartIndex;
    if (currantPageIndex < navigator2.visibleItemsStartIndex) {
      newVisibleItemsStartIndex = currantPageIndex;
    }
    if (currantPageIndex >= navigator2.visibleItemsStartIndex + navigator2.visibleItemsCount) {
      newVisibleItemsStartIndex = currantPageIndex - navigator2.visibleItemsCount + 1;
    }
    if (navigator2.visibleItemsStartIndex !== newVisibleItemsStartIndex) {
      if (navigator2.visible && !!navigator2._itemsContainer) {
        const itemsHolder = navigator2._itemsContainer.querySelectorAll(".svc-page-navigator__selector + div")[0];
        if (!!itemsHolder) {
          const cssClass = "svc-page-navigator__items--" + (navigator2.visibleItemsStartIndex < newVisibleItemsStartIndex ? "up" : "down");
          itemsHolder.className = cssClass;
          setTimeout(() => {
            itemsHolder.className = "";
            navigator2.visibleItemsStartIndex = newVisibleItemsStartIndex;
          }, 250);
        }
      } else {
        navigator2.visibleItemsStartIndex = newVisibleItemsStartIndex;
      }
    }
  }
})], PageNavigatorViewModel.prototype, "currentPage", void 0);
__decorate2([property({
  defaultValue: 0
})], PageNavigatorViewModel.prototype, "visibleItemsStartIndex", void 0);
__decorate2([property({
  defaultValue: Number.MAX_VALUE
})], PageNavigatorViewModel.prototype, "visibleItemsCount", void 0);
var PageAdorner = class extends SurveyElementAdornerBase {
  updateDragTypeOverMe() {
    var _a;
    if (!this.isDisposed) {
      this.dragTypeOverMe = (_a = this.page) === null || _a === void 0 ? void 0 : _a.dragTypeOverMe;
    }
  }
  updateIsDragMe() {
    var _a;
    if (!this.isDisposed) {
      this.isDragMe = (_a = this.page) === null || _a === void 0 ? void 0 : _a.isDragMe;
    }
  }
  updateShowPlaceholder(visibleRows) {
    this.showPlaceholder = !this.isGhost && (visibleRows || this.page.visibleRows).length === 0;
  }
  constructor(creator, page) {
    super(creator, page);
    this.addGhostPage = (selectCurrentPage = true) => {
      const currentPage = this.page;
      if (this.isGhost) {
        const addedPage = !!this.creator.addPage(currentPage, selectCurrentPage, () => {
          currentPage.unRegisterFunctionOnPropertiesValueChanged(["title", "description"], "add_ghost");
          currentPage.name = SurveyHelper.getNewPageName(this.creator.survey.pages);
          return true;
        });
        if (addedPage) {
          this.creator.survey.currentPage = currentPage;
        }
      }
      if (selectCurrentPage) {
        this.creator.selectElement(currentPage);
      }
    };
    this.addNewQuestion = (model, event, type) => {
      this.isGhost;
      this.page;
      this.creator.addNewQuestionInPage((type2) => {
        this.addGhostPage(false);
        this.creator.survey.currentPage = this.page;
      }, null, type || this.currentAddQuestionType || settings2.designer.defaultAddQuestionType);
    };
    this.creatorPropertyChanged = (sender, options) => {
      if (options.name === "isMobileView" && this.isActionContainerCreated) {
        this.actionContainer.alwaysShrink = options.newValue;
      }
    };
    this.startDragSurveyElement = (event) => {
      const element = this.surveyElement;
      const isElementSelected = this.creator.selectedElement === element;
      this.dragDropHelper.startDragSurveyElement(event, element, isElementSelected);
      return true;
    };
    this.questionTypeSelectorModel = this.creator.getQuestionTypeSelectorModel((type) => {
      this.currentAddQuestionType = type;
      this.addGhostPage(false);
      this.creator.survey.currentPage = this.page;
    });
    this.dragOrClickHelper = new DragOrClickHelper(this.startDragSurveyElement);
    this.creator.onPropertyChanged.add(this.creatorPropertyChanged);
  }
  dispose() {
    this.creator.onPropertyChanged.remove(this.creatorPropertyChanged);
    super.dispose();
  }
  updateActionVisibility(id, isVisible) {
    super.updateActionVisibility(id, !this.isGhost && isVisible);
  }
  get dragInsideCollapsedContainer() {
    return this.collapsed;
  }
  getAllowExpandCollapse(options) {
    return !this.isGhost && super.getAllowExpandCollapse(options);
  }
  attachElement(surveyElement) {
    super.attachElement(surveyElement);
    this.dragTypeOverMe = null;
    if (!!surveyElement) {
      surveyElement["surveyChangedCallback"] = () => {
        this.isPageLive = !!surveyElement.survey;
      };
      if (this.isGhost) {
        this.addGhostPageSubsribes(surveyElement);
      }
      surveyElement.registerFunctionOnPropertiesValueChanged(["dragTypeOverMe"], () => {
        this.updateDragTypeOverMe();
      }, "dragOver");
      surveyElement.registerFunctionOnPropertiesValueChanged(["isDragMe"], () => {
        this.updateIsDragMe();
      }, "dragOver");
      surveyElement.registerFunctionOnPropertiesValueChanged(["visibleRows"], (newValue) => {
        this.updateShowPlaceholder(newValue);
      }, "updatePlaceholder");
      this.updateShowPlaceholder();
      surveyElement.onFirstRendering();
      surveyElement.updateCustomWidgets();
      surveyElement.setWasShown(true);
      this.checkActionProperties();
      this.dragTypeOverMe = surveyElement.dragTypeOverMe;
      this.isDragMe = surveyElement.isDragMe;
      if (this.creator.pageEditMode !== "single") {
        surveyElement.locTitle.placeholder = () => {
          return surveyElement.isStartPage ? "pe.startPageTitlePlaceholder" : "pe.pageTitlePlaceholder";
        };
        surveyElement.locDescription.placeholder = "pe.pageDescriptionPlaceholder";
      }
    }
  }
  detachElement(surveyElement) {
    if (!!surveyElement) {
      delete surveyElement.locTitle.placeholder;
      delete surveyElement.locDescription.placeholder;
      surveyElement.unRegisterFunctionOnPropertiesValueChanged(["elements"], "updatePlaceholder");
      surveyElement.unRegisterFunctionOnPropertiesValueChanged(["dragTypeOverMe", "isDragMe"], "dragOver");
      surveyElement.unRegisterFunctionOnPropertiesValueChanged(["title", "description"], "add_ghost");
      surveyElement.unRegisterFunctionOnPropertiesValueChanged(["visibleRows"], "updatePlaceholder");
      surveyElement["surveyChangedCallback"] = void 0;
    }
    super.detachElement(surveyElement);
    if (!this.isDisposed) {
      this.dragTypeOverMe = null;
    }
  }
  onElementSelectedChanged(isSelected) {
    super.onElementSelectedChanged(isSelected);
    this.isSelected = isSelected;
    if (isSelected && this.creator.pageEditMode === "bypage") {
      this.setSurveyElement(this.creator.selectedElement);
    }
    if (isSelected) {
      this.onPageSelected();
    }
  }
  patchPageForDragDrop(page, addGhostPage) {
    page["_isGhost"] = true;
    page["_addGhostPageViewModel"] = () => {
      delete page["_isGhost"];
      delete page["_addGhostPageViewModel"];
      addGhostPage();
    };
  }
  addGhostPageSubsribes(surveyElement) {
    surveyElement.registerFunctionOnPropertiesValueChanged(["title", "description"], () => {
      this.addGhostPage();
      this.updateShowPlaceholder();
    }, "add_ghost");
    this.patchPageForDragDrop(this.surveyElement, this.addGhostPage);
  }
  get placeholderText() {
    if (this.creator.isMobileView) return getLocString("ed.pagePlaceHolderMobile");
    return getLocString("ed.pagePlaceHolder");
  }
  isOperationsAllow() {
    return super.isOperationsAllow() && !this.isGhost && this.creator.pageEditMode !== "single" && this.creator.allowModifyPages;
  }
  getPage() {
    return this.surveyElement;
  }
  get page() {
    return this.getPage();
  }
  createActionContainer() {
    const container = super.createActionContainer();
    container.alwaysShrink = this.creator.isMobileView;
    container.sizeMode = "small";
    container.cssClasses = this.containerCssClasses();
    container.dotsItem.iconSize = "auto";
    container.dotsItem.cssClasses.itemIcon += " svc-page-toolbar-item__icon";
    return container;
  }
  createTopActionContainer() {
    const container = super.createTopActionContainer();
    container.cssClasses = Object.assign({}, this.containerCssClasses());
    container.cssClasses.root += " svc-page-toolbar--collapse";
    return container;
  }
  containerCssClasses() {
    return {
      root: "svc-page-toolbar sv-action-bar",
      item: "svc-page-toolbar__item",
      itemWithTitle: "svc-page-toolbar__item--with-text",
      itemActive: "svc-page-toolbar__item--active",
      itemPressed: "svc-page-toolbar__item--pressed",
      itemIcon: "svc-page-toolbar-item__icon",
      itemTitle: "svc-page-toolbar-item__title",
      itemTitleWithIcon: "svc-page-toolbar-item__title--with-icon"
    };
  }
  allowExpandCollapseByDblClick(element) {
    return element.classList.contains("svc-page__content") || element.classList.contains("sd-page") || element.classList.contains("svc-page-toolbar") || element.classList.contains("svc-page__content-actions") || element.closest(".svc-question__drag-area") && !element.closest(".svc-page__content-actions") || (element.closest(".sd-page__title") || element.closest(".sd-page__description")) && !element.closest(".svc-string-editor");
  }
  getExpandCollapseAction() {
    const action = super.getExpandCollapseAction();
    action.needSeparator = true;
    return action;
  }
  select(model, event) {
    if (!model.isGhost) {
      if (model.creator.pageEditMode !== "single") {
        model.creator.selectElement(model.page, void 0, false);
        this.onPageSelected();
      } else {
        model.creator.selectElement(model.creator.survey, void 0, false);
      }
    }
    event.stopPropagation();
    event.cancelBubble = true;
  }
  get css() {
    let result = super.getCss();
    if (this.dragDropHelper.draggedElement && this.dragDropHelper.draggedElement.isPage) {
      if (this.dragTypeOverMe === DragTypeOverMeEnum.Top) {
        result += " svc-question__content--drag-over-top";
      }
      if (this.dragTypeOverMe === DragTypeOverMeEnum.Bottom) {
        result += " svc-question__content--drag-over-bottom";
      }
    } else {
      if (!!this.dragTypeOverMe && this.showPlaceholder) {
        result = "svc-question__content--drag-over-inside";
      } else if (!!this.dragTypeOverMe && this.page.elements.length === 0 && this.creator.survey.pages.length > 0) {
        result = "svc-page--drag-over-empty";
        if (!!this.creator && !this.creator.showAddQuestionButton) {
          result += " svc-page--drag-over-empty-no-add-button";
        }
      }
      if (!!this.dragTypeOverMe && this.collapsed) {
        this.dragIn();
        result += " svc-page__content--collapsed-drag-over-inside";
      } else {
        this.dragOut();
      }
    }
    if (this.allowExpandCollapse || this.page["isGhost"]) {
      result += " svc-page__content--collapse-" + this.creator.expandCollapseButtonVisibility;
      if (this.renderedCollapsed || this.page["isGhost"]) result += " svc-page__content--collapsed";
      if (this.expandCollapseAnimationRunning) result += " svc-page__content--animation-running";
    }
    if (this.isDragMe) {
      result += " svc-page__content--dragged";
    }
    if (this.isGhost) {
      return result + " svc-page__content--new";
    }
    if (this.creator.isElementSelected(this.page)) {
      result += " svc-page__content--selected";
    }
    if (settings.designMode.showEmptyTitles === false) {
      result += " svc-page__content--no-header";
    }
    return result.trim();
  }
  hoverStopper(event, element) {
    event["__svc_question_processed"] = true;
  }
  duplicate() {
    var newElement = this.creator.copyPage(this.page);
    this.creator.selectElement(newElement);
  }
  delete() {
    this.creator.deleteElement(this.page);
  }
  get addNewQuestionText() {
    if (!this.currentAddQuestionType && this.creator) return this.creator.getLocString("ed.addNewQuestion");
    return !!this.creator ? this.creator.getAddNewQuestionText(this.currentAddQuestionType) : "";
  }
  get footerActionsBar() {
    if (!this._footerActionsBar) {
      this._footerActionsBar = new ActionContainer();
      this._footerActionsBar.containerCss = "svc-page__footer";
      this._footerActionsBar.cssClasses = {
        item: "svc-btn",
        itemTitle: "svc-add-new-item-button__text"
      };
      let footerActions = [{
        css: "svc-add-new-question-action",
        visible: new ComputedUpdater(() => this.showAddQuestionButton),
        component: "svc-add-new-question-btn",
        data: this
      }];
      footerActions = this.creator.getUpdatedPageAdornerFooterActions(this, footerActions);
      this.footerActionsBar.setItems(footerActions);
    }
    return this._footerActionsBar;
  }
  getAnimatedElement() {
    var _a;
    const cssClasses = this.surveyElement.cssClasses.page;
    if (cssClasses === null || cssClasses === void 0 ? void 0 : cssClasses.description) {
      return (_a = this.rootElement) === null || _a === void 0 ? void 0 : _a.querySelector(`:scope ${classesToSelector(cssClasses.description)}`);
    }
    return null;
  }
  getInnerAnimatedElements() {
    var _a;
    const cssClasses = this.surveyElement.cssClasses;
    if (cssClasses.pageRow) return [].slice.call((_a = this.rootElement) === null || _a === void 0 ? void 0 : _a.querySelectorAll(`:scope .svc-page__footer, :scope .svc-page__placeholder_frame, :scope ${classesToSelector(this.surveyElement.cssRoot)} > .svc-row`));
    return null;
  }
  onPageSelected() {
  }
  getAllowDragging(options) {
    return this.creator.allowDragPages && super.getAllowDragging(options);
  }
  get dragDropHelper() {
    return this.creator.dragDropSurveyElements;
  }
  onPointerDown(pointerDownEvent) {
    this.dragOrClickHelper.onPointerDown(pointerDownEvent);
  }
  get dropTargetName() {
    if (!this.isGhost && !!this.page) {
      return this.page.name;
    }
    return null;
  }
};
__decorate2([property({
  defaultValue: false
})], PageAdorner.prototype, "isSelected", void 0);
__decorate2([property({
  defaultValue: true
})], PageAdorner.prototype, "isPageLive", void 0);
__decorate2([property()], PageAdorner.prototype, "showPlaceholder", void 0);
__decorate2([property({
  defaultValue: ""
})], PageAdorner.prototype, "currentAddQuestionType", void 0);
__decorate2([property({
  defaultValue: null
})], PageAdorner.prototype, "dragTypeOverMe", void 0);
__decorate2([property({
  defaultValue: false
})], PageAdorner.prototype, "isDragMe", void 0);
__decorate2([property({
  onSet(val, target, prevVal) {
    if (val != prevVal) {
      target.updateShowPlaceholder();
      target.updateActionsProperties();
      if (val && target.surveyElement) {
        target.addGhostPageSubsribes(target.surveyElement);
      }
    }
  }
})], PageAdorner.prototype, "isGhost", void 0);
var RowViewModel = class extends Base {
  constructor(creator, row, templateData) {
    super();
    this.creator = creator;
    this.row = row;
    this.templateData = templateData;
    this.rowDragTypeOverMeChanged = (s, o) => {
      if (o.name == "dragTypeOverMe") this.dragTypeOverMe = o.newValue;
    };
    this.dragTypeOverMe = this.row.dragTypeOverMe;
  }
  subscribeElementChanges() {
    this.row.onPropertyChanged.add(this.rowDragTypeOverMeChanged);
  }
  unsubscribeElementChanges() {
    this.row.onPropertyChanged.remove(this.rowDragTypeOverMeChanged);
  }
  get cssClasses() {
    let result = "svc-row";
    let ghostClass = " svc-row--ghost";
    if (this.row.elements.length === 1 && this.row.elements[0].name === "sv-drag-drop-ghost-survey-element-name") {
      result += ghostClass;
    }
    if (this.dragTypeOverMe === DragTypeOverMeEnum.Top) {
      result += " svc-row--drag-over-top";
    }
    if (this.dragTypeOverMe === DragTypeOverMeEnum.Bottom) {
      result += " svc-row--drag-over-bottom";
    }
    return result;
  }
  dispose() {
    super.dispose();
    this.unsubscribeElementChanges();
    this.rowDragTypeOverMeChanged = void 0;
  }
};
__decorate2([property()], RowViewModel.prototype, "dragTypeOverMe", void 0);
var QuestionAdornerViewModel = class extends SurveyElementAdornerBase {
  constructor(creator, surveyElement, templateData) {
    super(creator, surveyElement);
    this.templateData = templateData;
    this.startDragSurveyElement = (event) => {
      const element = this.surveyElement;
      const isElementSelected = this.creator.selectedElement === element;
      this.dragDropHelper.startDragSurveyElement(event, element, isElementSelected);
      return true;
    };
    this.addNewQuestion = () => {
      this.creator.addNewQuestionInPage((type) => {
      }, this.surveyElement instanceof PanelModelBase ? this.surveyElement : null, this.currentAddQuestionType || settings2.designer.defaultAddQuestionType);
    };
    this.questionTypeSelectorModel = this.creator.getQuestionTypeSelectorModel((type) => {
      this.currentAddQuestionType = type;
    }, this.surveyElement);
    if (surveyElement.isQuestion && !!surveyElement["setCanShowOptionItemCallback"]) {
      surveyElement.setCanShowOptionItemCallback((item) => {
        if (creator.readOnly) return false;
        if (item !== this.surveyElement.newItem) return true;
        return creator.maximumChoicesCount < 1 || surveyElement["choices"].length < creator.maximumChoicesCount;
      });
    }
    this.checkActionProperties();
    this.dragOrClickHelper = new DragOrClickHelper(this.startDragSurveyElement);
    StringItemsNavigatorBase.setQuestion(this);
  }
  canSelectElement() {
    return super.canSelectElement() && this.surveyElement.isInteractiveDesignElement;
  }
  select(model, event) {
    if (!model.canSelectElement()) return;
    const creator = model.creator;
    const selEl = model.surveyElement;
    const el = document === null || document === void 0 ? void 0 : document.activeElement;
    if (creator.selectedElement !== selEl && !!el && !!el.blur && el.tagName.toLocaleLowerCase() === "input") {
      el.blur();
    }
    event.stopPropagation();
    event.cancelBubble = true;
    creator.selectElement(selEl, void 0, false);
    return true;
  }
  rootCss() {
    const isStartWithNewLine = this.surveyElement.isQuestion && !this.surveyElement.startWithNewLine;
    return new CssClassBuilder().append(super.getCss()).append("svc-question__adorner").append("svc-question__adorner--selected", !!this.creator.isElementSelected(this.surveyElement)).append("svc-question__adorner--collapsed", this.renderedCollapsed).append("svc-question__adorner--start-with-new-line", isStartWithNewLine).append("svc-question__adorner--collapse-" + this.creator.expandCollapseButtonVisibility, true).toString();
  }
  css() {
    if (!this.surveyElement.isInteractiveDesignElement) return "";
    let result = "svc-question__content";
    result += typeof this.surveyElement.getType === "function" ? " svc-question__content--" + this.surveyElement.getType() : "";
    if (this.creator.isElementSelected(this.surveyElement)) {
      result += " svc-question__content--selected";
    }
    if (this.isEmptyElement) {
      result += " svc-question__content--empty";
    }
    if (this.isEmptyTemplate) {
      result += " svc-question__content--empty-template";
    }
    if (this.renderedCollapsed) {
      result += " svc-question__content--collapsed";
    }
    if (!this.surveyElement.hasTitle || !this.surveyElement.isPanel && this.surveyElement.getTitleLocation() === "hidden") {
      result += " svc-question__content--title-hidden";
    }
    if (this.surveyElement.hasTitleOnBottom) {
      result += " svc-question__content--title-bottom";
    }
    if (this.isDragMe) {
      result += " svc-question__content--dragged";
    }
    if (!!this.dragTypeOverMe && this.canExpandOnDrag && this.dragInsideCollapsedContainer) {
      this.dragIn();
      result += " svc-question__content--collapsed-drag-over-inside";
    } else {
      this.dragOut();
    }
    if (this.dragTypeOverMe === DragTypeOverMeEnum.InsideEmptyPanel) {
      result += " svc-question__content--drag-over-inside";
    }
    if (!this.dragInsideCollapsedContainer) {
      if (this.dragTypeOverMe === DragTypeOverMeEnum.Left) {
        result += " svc-question__content--drag-over-left";
      }
      if (this.dragTypeOverMe === DragTypeOverMeEnum.Right) {
        result += " svc-question__content--drag-over-right";
      }
      if (this.dragTypeOverMe === DragTypeOverMeEnum.Top) {
        result += " svc-question__content--drag-over-top";
      }
      if (this.dragTypeOverMe === DragTypeOverMeEnum.Bottom) {
        result += " svc-question__content--drag-over-bottom";
      }
      if (this.creator) {
        result = this.creator.getElementAddornerCssCallback(this.surveyElement, result);
      }
    }
    return result;
  }
  get isTitleLeft() {
    return !this.surveyElement.isPanel && this.surveyElement.getTitleLocation() === "left";
  }
  getAnimatedElement() {
    var _a, _b;
    const cssClasses = this.surveyElement.isPanel ? this.surveyElement.cssClasses.panel : this.surveyElement.cssClasses;
    let cssContent = cssClasses.content;
    if (this.surveyElement.isDescendantOf("rating")) {
      cssContent = "svc-rating-question-content";
    }
    if (this.isTitleLeft) {
      return (_a = this.rootElement) === null || _a === void 0 ? void 0 : _a.querySelector(`:scope ${classesToSelector(this.surveyElement.getRootCss())}`);
    }
    if (cssContent) {
      return (_b = this.rootElement) === null || _b === void 0 ? void 0 : _b.querySelector(`:scope ${classesToSelector(cssContent)}`);
    }
    return null;
  }
  getInnerAnimatedElements() {
    var _a;
    const cssRoot = this.surveyElement.isPanel ? this.surveyElement.getContainerCss() : this.surveyElement.getRootCss();
    const cssDescription = this.surveyElement.cssDescription;
    const selectorArray = [`:scope > .svc-question__content > *:not(.svc-question__drag-area):not(${classesToSelector(cssRoot)})`];
    if (!this.isTitleLeft && cssDescription) selectorArray.push(`:scope ${classesToSelector(cssDescription)}`);
    const res = [].slice.call((_a = this.rootElement) === null || _a === void 0 ? void 0 : _a.querySelectorAll(selectorArray.join(",")));
    res.push(this.rootElement);
    return res;
  }
  expandWithDragIn() {
    super.expandWithDragIn();
    this.element.dragTypeOverMe = null;
    this.creator.dragDropSurveyElements.dropTarget = null;
  }
  get isDragMe() {
    return this.surveyElement.isDragMe;
  }
  get dragTypeOverMe() {
    return this.element.dragTypeOverMe;
  }
  get isBannerShowing() {
    return this.isUsingCarryForward || this.isUsingRestfull || this.isMessagePanelVisible;
  }
  get isUsingCarryForward() {
    var _a;
    return (_a = this.element) === null || _a === void 0 ? void 0 : _a.isUsingCarryForward;
  }
  get isUsingRestfull() {
    var _a;
    return (_a = this.element) === null || _a === void 0 ? void 0 : _a.isUsingRestful;
  }
  get isMessagePanelVisible() {
    var _a;
    return (_a = this.element) === null || _a === void 0 ? void 0 : _a.getPropertyValue("isMessagePanelVisible");
  }
  get cssCollapsedHiddenHeader() {
    const css = new CssClassBuilder().append(this.element.cssHeader).append("svc-element__header--hidden").append("svc-element__header--lazy", !this.needToRenderContent).toString();
    return css;
  }
  get cssCollapsedHiddenTitle() {
    return this.element.cssTitle + " svc-element__title--hidden";
  }
  createBannerParams() {
    return this.createCarryForwardParams() || this.createUsingRestfulParams() || this.createCustomMessagePanel();
  }
  createCarryForwardParams() {
    var _a;
    if (!this.isUsingCarryForward) return null;
    const name = (_a = this.element) === null || _a === void 0 ? void 0 : _a.choicesFromQuestion;
    if (!name) return null;
    const question = this.creator.survey.getQuestionByName(name);
    if (!question) return null;
    return {
      actionText: question.name,
      text: this.creator.getLocString("ed.carryForwardChoicesCopied"),
      onClick: () => {
        this.creator.selectElement(question);
      }
    };
  }
  createUsingRestfulParams() {
    if (!this.isUsingRestfull) return null;
    return {
      actionText: this.creator.getLocString("ed.choicesLoadedFromWebLinkText"),
      text: this.creator.getLocString("ed.choicesLoadedFromWebText"),
      onClick: () => {
        this.creator.selectElement(this.element, "choicesByUrl");
      }
    };
  }
  createCustomMessagePanel() {
    if (!this.isMessagePanelVisible) return null;
    const res = {
      question: this.element,
      actionText: "",
      messageText: "",
      onClick: () => {
      }
    };
    if (this.creator) {
      this.creator.onCreateCustomMessagePanel.fire(this.creator, res);
    }
    res.text = res.messageText;
    return res;
  }
  detachElement(surveyElement) {
    if (surveyElement) {
      surveyElement.unRegisterFunctionOnPropertyValueChanged("isRequired", "isRequiredAdorner");
      surveyElement.unRegisterFunctionOnPropertiesValueChanged(["inputType", "rateType"], "inputTypeAdorner");
      if (!!surveyElement["setCanShowOptionItemCallback"]) {
        surveyElement.setCanShowOptionItemCallback(void 0);
      }
    }
    super.detachElement(this.element);
  }
  attachElement(surveyElement) {
    super.attachElement(surveyElement);
    if (surveyElement) {
      surveyElement.registerFunctionOnPropertyValueChanged("isRequired", (newValue) => {
        if (this.isActionContainerCreated) {
          const requiredAction = this.actionContainer.getActionById("isrequired");
          this.updateRequiredAction(requiredAction);
        }
      }, "isRequiredAdorner");
    }
  }
  get isDraggable() {
    return true;
  }
  get hoverDelay() {
    if (this.creator["animationEnabled"]) {
      return this.creator.pageHoverDelay;
    }
    return 0;
  }
  hover(event, element) {
    if (!this.surveyElement.isInteractiveDesignElement) {
      return;
    }
    super.hover(event, element);
  }
  createActionContainer() {
    const actionContainer = super.createActionContainer();
    const defaultCssClasses = {
      root: "svc-survey-element-toolbar sv-action-bar",
      item: "svc-survey-element-toolbar__item",
      itemWithTitle: "svc-survey-element-toolbar__item--with-text",
      itemAsIcon: "svc-survey-element-toolbar__item--icon",
      itemActive: "svc-survey-element-toolbar__item--active",
      itemPressed: "svc-survey-element-toolbar__item--pressed",
      itemIcon: "svc-survey-element-toolbar-item__icon",
      itemTitle: "svc-survey-element-toolbar-item__title",
      itemTitleWithIcon: "svc-survey-element-toolbar-item__title--with-icon"
    };
    actionContainer.sizeMode = "small";
    actionContainer.cssClasses = defaultCssClasses;
    actionContainer.dotsItem.css += " svc-survey-element-toolbar__dots-item";
    actionContainer.dotsItem.innerCss += " svc-survey-element-toolbar__item";
    return actionContainer;
  }
  updateActionsPropertiesCore() {
    super.updateActionsPropertiesCore();
    if (this.isActionContainerCreated) {
      this.updateActionsLocations();
    }
  }
  updateActionsVisibility(isTop) {
    super.updateActionsVisibility(isTop);
    if (!isTop) {
      this.updateActionsLocations();
    }
  }
  updateActionsLocations() {
    const actions = this.actionContainer.visibleActions;
    let switchToStartLocation = false;
    for (var i = actions.length - 1; i >= 0; i--) {
      if (actions[i].id === "convertTo") switchToStartLocation = true;
      if (!actions[i].innerItem.location) actions[i].innerItem.location = switchToStartLocation ? "start" : "end";
    }
  }
  updateElementAllowOptions(options, operationsAllow) {
    super.updateElementAllowOptions(options, operationsAllow);
    this.updateActionVisibility("convertTo", operationsAllow && options.allowChangeType);
    this.updateActionVisibilityByProp("isrequired", "isRequired", operationsAllow && options.allowChangeRequired);
    this.updateActionVisibilityByProp("convertInputType", "inputType", options.allowChangeInputType);
    this.updateActionVisibilityByProp("convertInputType", "rateDisplayMode", options.allowChangeInputType);
  }
  updateActionVisibilityByProp(actionName, propName, allow) {
    const prop = Serializer.findProperty(this.surveyElement.getType(), propName);
    if (!prop) return;
    const isPropReadOnly = this.creator.onIsPropertyReadOnlyCallback(this.surveyElement, prop, prop.readOnly, null, null);
    this.updateActionVisibility(actionName, allow && !isPropReadOnly);
  }
  get isEmptyElement() {
    if (this.surveyElement instanceof QuestionHtmlModel) {
      return !this.surveyElement.html;
    }
    if (this.surveyElement instanceof PanelModelBase) {
      const panel = this.surveyElement;
      return !panel.rows || panel.rows.length <= 0 || panel.elements.length === 0;
    }
    return false;
  }
  get isEmptyTemplate() {
    if (this.surveyElement instanceof QuestionPanelDynamicModel) {
      return this.surveyElement.templateElements.length == 0;
    }
    return false;
  }
  get showHiddenTitle() {
    return (!this.element.hasTitle || this.isTitleLeft || !this.needToRenderContent) && this.element.isInteractiveDesignElement;
  }
  get placeholderText() {
    if (this.surveyElement instanceof QuestionHtmlModel) {
      return getLocString("ed.htmlPlaceHolder");
    }
    if (this.creator.isMobileView) return getLocString("ed.panelPlaceHolderMobile");
    return getLocString("ed.panelPlaceHolder");
  }
  get dragDropHelper() {
    return this.creator.dragDropSurveyElements;
  }
  onPointerDown(pointerDownEvent) {
    this.dragOrClickHelper.onPointerDown(pointerDownEvent);
  }
  getConvertToTypes() {
    const availableItems = this.creator.getAvailableToolboxItems(this.element, false);
    const itemNames = [];
    availableItems.forEach((item) => {
      if (itemNames.indexOf(item.typeName) == -1) {
        itemNames.push(item.typeName);
      }
    });
    const convertClasses = QuestionConverter.getConvertToClasses(this.currentType, itemNames, true);
    const res = [];
    convertClasses.forEach((className) => {
      const items = this.creator.toolbox.items.filter((item) => item.name == className);
      if (Array.isArray(items) && items.length > 0) {
        const item = items[0];
        res.push(item);
      }
    });
    return res;
  }
  buildDefaultJsonMap(availableItems) {
    const defaultJsons = {};
    function addItemJson(toolboxItem) {
      var _a;
      const type = ((_a = toolboxItem.json) === null || _a === void 0 ? void 0 : _a.type) || toolboxItem.id;
      if (toolboxItem.json) {
        const json2 = toolboxItem.json;
        if (!defaultJsons[type]) defaultJsons[type] = [];
        defaultJsons[type].push(json2);
      }
    }
    availableItems.forEach((toolboxItem) => {
      addItemJson(toolboxItem);
      (toolboxItem.items || []).forEach((toolboxSubitem) => {
        addItemJson(toolboxSubitem);
      });
    });
    return defaultJsons;
  }
  convertQuestion(questionType2, json2, defaultJsons) {
    const type = (json2 === null || json2 === void 0 ? void 0 : json2.type) || questionType2;
    let newJson = {};
    (defaultJsons[type] || []).forEach((djson) => {
      if (this.jsonIsCorresponded(djson)) {
        newJson = Object.assign({}, json2);
        const objJson = this.element.toJSON();
        const cleanJson = this.cleanDefaultsFromJson(type, djson);
        Object.keys(djson).forEach((p) => {
          if (p != "type" && !newJson[p]) newJson[p] = void 0;
        });
        Object.keys(json2 || {}).forEach((p) => {
          if (p != "type" && !(!objJson[p] || cleanJson[p])) newJson[p] = void 0;
        });
      }
    });
    this.creator.convertCurrentQuestion(type, newJson);
  }
  getConvertToTypesActions() {
    const availableItems = this.getConvertToTypes();
    const defaultJsons = this.buildDefaultJsonMap(availableItems);
    const newItems = [];
    let lastItem = null;
    availableItems.forEach((item) => {
      const needSeparator = lastItem && item.category != lastItem.category;
      const action = this.creator.createIActionBarItemByClass(item, needSeparator, (questionType2, json2) => {
        this.convertQuestion(questionType2, json2, defaultJsons);
      });
      lastItem = item;
      newItems.push(action);
    });
    return newItems;
  }
  get currentType() {
    return this.surveyElement.getType();
  }
  createConvertToAction() {
    const availableItems = this.creator.getAvailableToolboxItems(this.element, false);
    const currItem = availableItems.filter((item) => item.name === this.currentType)[0];
    const actionData = {
      id: "convertTo",
      enabled: true,
      visibleIndex: 0,
      title: !!currItem ? currItem.title : editorLocalization.getString("qt." + this.currentType),
      iconName: "icon-chevron_16x16",
      iconSize: "auto"
    };
    const newAction = this.createDropdownModel({
      actionData,
      items: [],
      updateListModel: (listModel) => {
        this.updateQuestionTypeOrSubtypeListModel(listModel, false);
      }
    });
    newAction.iconName = new ComputedUpdater(() => {
      var _a;
      if (newAction.mode === "small") {
        return (_a = this.creator.toolbox.getItemByName(this.element.getType())) === null || _a === void 0 ? void 0 : _a.iconName;
      }
      return "icon-chevron_16x16";
    });
    newAction.disableHide = true;
    return newAction;
  }
  jsonsAreCompatible(objJson, json2) {
    let jsonIsCorresponded = true;
    Object.keys(json2).forEach((p) => {
      const question = QuestionFactory.Instance.createQuestion(objJson.type, "question") || this.element;
      const propertyValue2 = objJson[p] === void 0 ? question.getDefaultPropertyValue(p) : objJson[p];
      if (p != "type" && !Helpers.isTwoValueEquals(json2[p], propertyValue2)) jsonIsCorresponded = false;
    });
    return jsonIsCorresponded;
  }
  jsonIsCorresponded(json2) {
    return this.jsonsAreCompatible(this.element.toJSON(), json2);
  }
  toolboxItemIsCorresponded(toolboxItem, someItemSelectedAlready) {
    const elementType = this.element.getType();
    const json2 = toolboxItem.json;
    if (toolboxItem.id == elementType || toolboxItem.json.type == elementType) {
      return !someItemSelectedAlready || this.jsonIsCorresponded(json2);
    }
  }
  cleanDefaultsFromJson(type, toolboxItemJson) {
    const question = QuestionFactory.Instance.createQuestion(type, "question");
    if (!question) return toolboxItemJson;
    question.fromJSON(toolboxItemJson);
    const json2 = question.toJSON();
    json2["type"] = type;
    delete json2.name;
    return json2;
  }
  allowExpandCollapseByDblClick(element) {
    return element.classList.contains("svc-question__content") || element.closest(".svc-question__drag-area") && !element.closest(".svc-question__top-actions") || element.closest(".sd-element__header") && !element.closest(".svc-string-editor");
  }
  updateQuestionTypeOrSubtypeListModel(listModel, subtypeOnly) {
    var _a;
    const availableItems = this.getConvertToTypes();
    const defaultJsons = this.buildDefaultJsonMap(availableItems);
    const newItems = [];
    let lastItem;
    let selectedAction;
    let selectedSubaction = void 0;
    let selectedSubactions = void 0;
    availableItems.forEach((item) => {
      var _a2;
      const needSeparator = lastItem && item.category != lastItem.category;
      const action = this.creator.createIActionBarItemByClass(item, needSeparator, (questionType2, json2) => {
        this.convertQuestion(questionType2, json2, defaultJsons);
      });
      if (this.toolboxItemIsCorresponded(item, !!selectedAction)) {
        selectedAction = action;
        selectedSubactions = item.items;
      }
      if (((_a2 = item.items) === null || _a2 === void 0 ? void 0 : _a2.length) > 0 && this.creator.toolbox.showSubitems) {
        const subactions = [];
        let selectedSubactionLocal = void 0;
        let allChildsAreCompatibleToParent = false;
        item.items.forEach((subitem) => {
          const subaction = this.creator.createIActionBarItemByClass(subitem, false, (questionType2, json2) => {
            this.convertQuestion(questionType2, json2, defaultJsons);
          });
          if (this.toolboxItemIsCorresponded(subitem, !!selectedAction)) selectedSubactionLocal = subitem;
          if (this.jsonsAreCompatible(item.json, subitem.json)) allChildsAreCompatibleToParent = true;
          subactions.push(subaction);
        });
        if (!allChildsAreCompatibleToParent && subactions.length > 0) {
          const defaultSubaction = this.creator.createIActionBarItemByClass(item, false, (questionType2, json2) => {
            this.convertQuestion(questionType2, json2, defaultJsons);
          });
          defaultSubaction.id = action.id + "-default";
          defaultSubaction.iconName = void 0;
          defaultSubaction.markerIconName = void 0;
          defaultSubaction.items = [];
          defaultSubaction.component = void 0;
          subactions.unshift(defaultSubaction);
          if (selectedAction == action && !selectedSubactionLocal) selectedSubactionLocal = defaultSubaction;
        }
        action.setSubItems({
          items: subactions,
          cssClasses: listComponentCss
        });
        if (selectedSubactionLocal) {
          selectedAction = action;
          selectedSubaction = selectedSubactionLocal;
          selectedSubactions = subactions;
        }
      }
      lastItem = item;
      newItems.push(action);
    });
    if (subtypeOnly) {
      if (selectedSubactions) {
        listModel.setItems(selectedSubactions);
        listModel.selectedItem = selectedSubaction;
        return !!selectedSubactions;
      }
    } else {
      const _listModel = (_a = selectedAction === null || selectedAction === void 0 ? void 0 : selectedAction.popupModel) === null || _a === void 0 ? void 0 : _a.contentComponentData.model;
      if (_listModel) _listModel.selectedItem = selectedSubaction;
      listModel.setItems(newItems);
      listModel.selectedItem = selectedAction;
    }
  }
  createConvertInputType() {
    var _a;
    if (!this.surveyElement || this.surveyElement.isPanel) {
      return null;
    }
    const listModel = new ListModel({
      items: [],
      cssClasses: listComponentCss
    });
    this.updateQuestionTypeOrSubtypeListModel(listModel, true);
    const propName = QuestionToolbox.getSubTypePropertyName(this.surveyElement.getType());
    if (!listModel.selectedItem && !propName) return null;
    const actionData = {
      id: "convertInputType",
      visibleIndex: 1,
      title: ((_a = listModel.selectedItem) === null || _a === void 0 ? void 0 : _a.title) || editorLocalization.getPropertyValueInEditor(propName, this.surveyElement.getPropertyValue(propName)) || "SUBTYPE",
      disableShrink: true,
      iconName: "icon-chevron_16x16"
    };
    const newAction = this.createDropdownModel({
      actionData,
      items: [],
      updateListModel: (listModel2) => {
        this.updateQuestionTypeOrSubtypeListModel(listModel2, true);
      }
    });
    this.surveyElement.registerFunctionOnPropertiesValueChanged([propName], (newValue) => {
      var _a2;
      const popup = newAction.popupModel;
      const list = popup.contentComponentData.model;
      this.updateQuestionTypeOrSubtypeListModel(list, true);
      newAction.title = ((_a2 = list.selectedItem) === null || _a2 === void 0 ? void 0 : _a2.title) || editorLocalization.getPropertyValueInEditor(propName, newValue) || "SUBTYPE";
    }, "inputTypeAdorner");
    return newAction;
  }
  getSelectedItem(actions, id) {
    const selectedItems = actions.filter((item) => item.id === id);
    return selectedItems.length > 0 ? selectedItems[0] : void 0;
  }
  createDropdownModel(options) {
    const newAction = createDropdownActionModel({
      id: options.actionData.id,
      css: "svc-dropdown-action--convertTo",
      iconName: options.actionData.iconName,
      iconSize: "auto",
      title: options.actionData.title,
      enabled: options.actionData.enabled,
      visibleIndex: options.actionData.visibleIndex,
      disableShrink: options.actionData.disableShrink,
      location: "start",
      action: (newType) => {
      }
    }, {
      items: [],
      allowSelection: true,
      horizontalPosition: "center",
      cssClass: "svc-creator-popup",
      cssClasses: listComponentCss
    });
    newAction.popupModel.onVisibilityChanged.add((_, opt) => {
      if (opt.isVisible) {
        const listModel2 = newAction.popupModel.contentComponentData.model;
        options.updateListModel(listModel2);
      }
    });
    const listModel = newAction.popupModel.contentComponentData.model;
    if (listModel.selectedItem) newAction.title = listModel.selectedItem.title;
    newAction.popupModel.displayMode = this.creator.isTouch ? "overlay" : "popup";
    newAction.data.locOwner = this.creator;
    return newAction;
  }
  updateRequiredAction(requiredAction) {
    var _a;
    if (!requiredAction) return;
    const isRequired = (_a = this.surveyElement) === null || _a === void 0 ? void 0 : _a.isRequired;
    requiredAction.ariaChecked = isRequired;
    requiredAction.active = isRequired;
    requiredAction.innerItem.title = isRequired ? this.creator.getLocString("pe.removeRequiredMark") : this.creator.getLocString("pe.markRequired");
  }
  createRequiredAction() {
    this.surveyElement.isRequired;
    const actionSetup = {
      id: "isrequired",
      ariaRole: "checkbox",
      css: "svc-action-bar-item--right",
      innerCss: "svc-required-action",
      visibleIndex: 20,
      iconName: "icon-required",
      iconSize: "auto",
      action: () => {
        var _a;
        if (this.creator.isCanModifyProperty(this.surveyElement, "isRequired")) {
          this.surveyElement.isRequired = this.getUpdatedPropertyValue("isRequired", !((_a = this.surveyElement) === null || _a === void 0 ? void 0 : _a.isRequired));
        }
      }
    };
    const innerAction = new Action(actionSetup);
    const requiredAction = new Action(actionSetup);
    requiredAction.title = this.creator.getLocString("pe.isRequired");
    requiredAction.innerItem = innerAction;
    this.updateRequiredAction(requiredAction);
    return requiredAction;
  }
  getUpdatedPropertyValue(propName, newValue) {
    const options = {
      obj: this.element,
      propertyName: propName,
      value: this.element[propName],
      newValue,
      doValidation: false
    };
    this.creator.onValueChangingCallback(options);
    return options.newValue;
  }
  buildActions(items) {
    super.buildActions(items);
    let element = this.surveyElement;
    items.push(this.createConvertToAction());
    const inputTypeConverter = this.createConvertInputType();
    if (!!inputTypeConverter) {
      items.push(inputTypeConverter);
    }
    items[items.length - 1].css += " svc-dropdown-action--convertTo-last";
    if (typeof element["isRequired"] !== "undefined" && propertyExists(element, "isRequired") && isPropertyVisible(element, "isRequired")) {
      items.push(this.createRequiredAction());
    }
  }
  duplicate() {
    setTimeout(() => {
      this.creator.copyQuestion(this.surveyElement, true);
    }, 1);
  }
  get addNewQuestionText() {
    if (!this.currentAddQuestionType && this.creator) return this.creator.getLocString("ed.addNewQuestion");
    return !!this.creator ? this.creator.getAddNewQuestionText(this.currentAddQuestionType) : "";
  }
};
__decorate2([property({
  defaultValue: ""
})], QuestionAdornerViewModel.prototype, "currentAddQuestionType", void 0);
var QuestionDropdownAdornerViewModel = class extends QuestionAdornerViewModel {
  constructor(creator, surveyElement, templateData) {
    super(creator, surveyElement, templateData);
    this.switchCollapse = () => {
      this.isCollapsed = !this.isCollapsed;
    };
    this.visibleCount = creator.maxVisibleChoices;
    this.isCollapsed = this.isCollapsed && this.needToCollapse;
  }
  get question() {
    return this.surveyElement;
  }
  get itemComponent() {
    if (this.surveyElement.isDescendantOf("dropdown")) {
      return "survey-radiogroup-item";
    }
    return "survey-checkbox-item";
  }
  get needToCollapse() {
    return this.visibleCount > 0 && this.question.visibleChoices.length > this.visibleCount;
  }
  get isCollapseView() {
    return this.isCollapsed;
  }
  leftFocus() {
    if (!this.creator.isElementSelected(this.surveyElement) && !this.isCollapsed) {
      this.isCollapsed = this.needToCollapse;
    }
  }
  getChoiceCss() {
    return new CssClassBuilder().append("svc-question__dropdown-choice").append("svc-question__dropdown-choice--collapsed", this.isCollapsed && this.needToCollapse).toString();
  }
  getRenderedItems() {
    return this.isCollapsed ? this.question.renderedChoices.slice(0, this.visibleCount) : this.question.renderedChoices;
  }
  getButtonText() {
    return !this.isCollapsed ? editorLocalization.getString("ed.showLessChoices") : editorLocalization.getString("ed.showMoreChoices");
  }
  attachElement(surveyElement) {
    super.attachElement(surveyElement);
    if (!!surveyElement) {
      surveyElement.registerFunctionOnPropertyValueChanged("isSelectedInDesigner", () => {
        this.leftFocus();
      }, "dropdownCollapseChecker");
    }
  }
  detachElement(surveyElement) {
    if (!!surveyElement) {
      surveyElement.unRegisterFunctionOnPropertyValueChanged("isSelectedInDesigner", "dropdownCollapseChecker");
    }
    super.detachElement(surveyElement);
  }
};
__decorate2([property({
  defaultValue: true
})], QuestionDropdownAdornerViewModel.prototype, "isCollapsed", void 0);
__decorate2([property({
  defaultValue: -1
})], QuestionDropdownAdornerViewModel.prototype, "visibleCount", void 0);
var QuestionImageAdornerViewModel = class extends QuestionAdornerViewModel {
  initFilePresentationModel() {
    this.filePresentationModel = Serializer.createClass("file", {
      name: this.question.name
    });
    this.editorSurveyModel = new SurveyModel();
    this.filePresentationModel.setSurveyImpl(this.editorSurveyModel);
    this.filePresentationModel.forceIsInputReadOnly = !this.creator.isCanModifyProperty(this.question, "imageLink");
    this.filePresentationModel.filePlaceholder = this.placeholderText;
    this.filePresentationModel.chooseButtonCaption = this.chooseImageText;
    this.filePresentationModel.acceptedTypes = "image/*";
    this.filePresentationModel.storeDataAsText = false;
    this.filePresentationModel.cssClasses.chooseFileIconId = "icon-choosefile";
    this.editorSurveyModel.onOpenFileChooser.add((s, o) => {
      this.creator.chooseFiles(o.input, o.callback, o.context);
    });
    this.editorSurveyModel.onUploadFiles.add((s, o) => {
      const fileToUpload = o.files[0];
      if (!!fileToUpload) {
        this.isUploading = true;
        this.creator.uploadFiles(o.files, this.question, (status, link) => {
          this.question.imageLink = link;
          o.callback(status, [{
            content: link,
            file: o.files[0]
          }]);
          this.isUploading = false;
        }, {
          element: this.question,
          elementType: this.question.getType(),
          propertyName: "imageLink"
        });
      }
    });
  }
  constructor(creator, surveyElement, templateData) {
    super(creator, surveyElement, templateData);
    this.isEmptyImageLink = !this.question.imageLink;
    this.initFilePresentationModel();
  }
  detachElement(surveyElement) {
    if (surveyElement) {
      surveyElement.unRegisterFunctionOnPropertyValueChanged("imageLink", "imageLinkValueChanged");
      surveyElement.locImageLink.onStringChanged.remove(this.imageLinkValueChangedHandler);
    }
    super.detachElement(this.element);
  }
  attachElement(surveyElement) {
    super.attachElement(surveyElement);
    if (surveyElement) {
      if (!this.imageLinkValueChangedHandler) {
        this.imageLinkValueChangedHandler = () => {
          this.isEmptyImageLink = !this.question.imageLink;
          this.filePresentationModel.value = null;
          this.filePresentationModel.visible = !this.question.imageLink;
        };
      }
      surveyElement.registerFunctionOnPropertyValueChanged("imageLink", this.imageLinkValueChangedHandler, "imageLinkValueChanged");
      surveyElement.locImageLink.onStringChanged.add(this.imageLinkValueChangedHandler);
    }
  }
  chooseFile(model) {
    const fileInput = model.rootElement.getElementsByClassName("svc-choose-file-input")[0];
    this.editorSurveyModel.chooseFiles(fileInput, (files) => {
      model.filePresentationModel.loadFiles(files);
    });
  }
  get acceptedTypes() {
    return getAcceptedTypesByContentMode(this.surveyElement.contentMode);
  }
  get isEmptyElement() {
    return this.isEmptyImageLink;
  }
  get question() {
    return this.surveyElement;
  }
  get placeholderText() {
    if (this.creator.isMobileView) return getLocString("ed.imagePlaceHolderMobile");
    return getLocString("ed.imagePlaceHolder");
  }
  get chooseImageText() {
    return getLocString("ed.imageChooseImage");
  }
  getAnimatedElement() {
    if (this.isEmptyImageLink) {
      const cssClasses = this.filePresentationModel.cssClasses;
      if (cssClasses.root) {
        return this.surveyElement.getWrapperElement().querySelector(`:scope ${classesToSelector(cssClasses.root)}`);
      }
    }
    return super.getAnimatedElement();
  }
  css() {
    return new CssClassBuilder().append(super.css()).append("svc-question__content--loading", this.isUploading).toString();
  }
};
__decorate2([property({
  defaultValue: false
})], QuestionImageAdornerViewModel.prototype, "isUploading", void 0);
__decorate2([property({
  defaultValue: false
})], QuestionImageAdornerViewModel.prototype, "isEmptyImageLink", void 0);
var QuestionRatingAdornerViewModel = class _QuestionRatingAdornerViewModel extends Base {
  constructor(creator, surveyElement, templateData) {
    super();
    this.creator = creator;
    this.surveyElement = surveyElement;
    this.templateData = templateData;
  }
  get element() {
    return getQuestionFromObj(this.surveyElement);
  }
  static useRateValues(element) {
    const el = !!element.contentQuestion ? element.contentQuestion : element;
    return !!el.useRateValues && el.useRateValues();
  }
  addItem(model) {
    if (!model.allowAdd) return;
    if (!model.enableAdd) return;
    if (!_QuestionRatingAdornerViewModel.useRateValues(model.element)) {
      model.element.rateMax += model.element.rateStep;
    } else {
      let nextValue = null;
      const values = model.element.rateValues.map(function(item) {
        return item.value;
      });
      const itemText = model.creator.getChoicesItemBaseTitle();
      nextValue = getNextValue(itemText, values);
      const itemValue = new ItemValue(nextValue);
      itemValue.locOwner = {
        getLocale: () => {
          if (!!model.element["getLocale"]) return model.element.getLocale();
          return "";
        },
        getMarkdownHtml: (text) => {
          return text;
        },
        getProcessedText: (text) => {
          return text;
        }
      };
      model.element.rateValues = model.element.rateValues.concat([itemValue]);
      const rateValues = model.element.rateValues;
      model.creator.onItemValueAddedCallback(model.element, "rateValues", rateValues[rateValues.length - 1], rateValues);
    }
  }
  removeItem(model) {
    if (!model.allowRemove) return;
    if (!model.enableRemove) return;
    const property2 = Serializer.findProperty(model.element.getType(), "rateValues");
    const itemIndex = model.element.rateValues && model.element.rateValues.length - 1;
    const item = model.element.rateValues && model.element.rateValues[itemIndex] || null;
    const allowDelete = model.creator.onCollectionItemDeletingCallback(model.element, property2, model.element.rateValues, item);
    if (allowDelete) {
      const question = model.element;
      if (!_QuestionRatingAdornerViewModel.useRateValues(model.element) && itemIndex === question.rateValues.length - 1) {
        question.rateMax -= question.rateStep;
      } else {
        if (!_QuestionRatingAdornerViewModel.useRateValues(model.element)) {
          question.rateValues = question.rateValues;
        }
        question.rateValues.splice(itemIndex, 1);
      }
    }
  }
  static allowAddForElement(element, maximumRateValues) {
    if ((maximumRateValues < 1 || maximumRateValues > settings.ratingMaximumRateValueCount) && !_QuestionRatingAdornerViewModel.useRateValues(element)) maximumRateValues = settings.ratingMaximumRateValueCount;
    if (element.rateDisplayMode == "smileys" && (maximumRateValues < 1 || maximumRateValues > 10)) maximumRateValues = 10;
    if (maximumRateValues < 1) return true;
    return element.rateCount < maximumRateValues;
  }
  get allowAdd() {
    return this.canAddOrRemove();
  }
  get enableAdd() {
    return this.allowAdd && _QuestionRatingAdornerViewModel.allowAddForElement(this.element, this.creator.maximumRateValues);
  }
  get addClassNames() {
    return new CssClassBuilder().append("svc-item-value-controls__button").append("svc-item-value-controls__button--disabled", !this.enableAdd).append("svc-item-value-controls__add").toString();
  }
  static allowRemoveForElement(element) {
    return element.rateCount > 2;
  }
  canAddOrRemove() {
    return this.creator.isCanModifyProperty(this.element, "rateValues") && this.creator.isCanModifyProperty(this.element, "rateCount") && (!this.element.autoGenerate || this.creator.isCanModifyProperty(this.element, "rateMax"));
  }
  get allowRemove() {
    return this.canAddOrRemove();
  }
  get enableRemove() {
    return this.allowRemove && _QuestionRatingAdornerViewModel.allowRemoveForElement(this.element);
  }
  get removeClassNames() {
    return new CssClassBuilder().append("svc-item-value-controls__button").append("svc-item-value-controls__button--disabled", !this.enableRemove).append("svc-item-value-controls__remove").toString();
  }
  get hasTopLabel() {
    return (this.element.rateDescriptionLocation == "top" || this.element.rateDescriptionLocation == "topBottom") && !!this.element.minRateDescription;
  }
  get controlsClassNames() {
    return new CssClassBuilder().append("svc-rating-question-controls").append("svc-item-value-controls").append("svc-rating-question-controls--labels-top", this.hasTopLabel).toString();
  }
  get addTooltip() {
    return getLocString("pe.addItem");
  }
  get removeTooltip() {
    return getLocString("pe.removeItem");
  }
};
var specificChoices = {
  "noneItem": "showNoneItem",
  "otherItem": "showOtherItem",
  "selectAllItem": "showSelectAllItem",
  "refuseItem": "showRefuseItem",
  "dontKnowItem": "showDontKnowItem"
};
var ItemValueWrapperViewModel = class extends Base {
  constructor(creator, question, item) {
    super();
    this.creator = creator;
    this.question = question;
    this.item = item;
    this.canTouchItems = true;
    this.focusCameFromDown = false;
    this.startDragItemValue = (pointerDownEvent, currentTarget) => {
      this.dragDropHelper.startDrag(pointerDownEvent, this.item, this.question, currentTarget);
    };
    this.handleDragDropGhostPositionChanged = () => {
      this.ghostPosition = this.getGhostPosition(this.item);
      this.isDragDropGhost = this.item === this.dragDropHelper.draggedElement;
      if (this.item === this.dragDropHelper.prevDropTarget) {
        this.isDragDropMoveDown = this.item.isDragDropMoveDown;
        this.isDragDropMoveUp = this.item.isDragDropMoveUp;
      } else {
        this.isDragDropMoveDown = false;
        this.isDragDropMoveUp = false;
      }
    };
    this.updateIsNew(question, item);
    for (let key in specificChoices) {
      this.registerOnPropertyChanged(key, specificChoices[key]);
    }
    if (this.isNew) {
      question.renderedChoicesChangedCallback = () => {
        this.updateNewItemValue();
      };
      this.updateNewItemValue();
    }
    this.dragDropHelper.onGhostPositionChanged.add(this.handleDragDropGhostPositionChanged);
    this.dragOrClickHelper = new DragOrClickHelper(this.startDragItemValue);
    this.allowItemOperations = {
      allowDelete: void 0,
      allowEdit: void 0,
      allowAdd: void 0
    };
    this.collectionProperty = Serializer.findProperty(question.getType(), this.collectionPropertyName);
    this.creator.onCollectionItemAllowingCallback(question.ownerObj || question, this.collectionProperty, question.visibleChoices, this.item, this.allowItemOperations);
    if (this.allowItemOperations.allowDelete === void 0) {
      this.allowItemOperations.allowDelete = true;
    }
    if (this.allowItemOperations.allowAdd === void 0) {
      this.allowItemOperations.allowAdd = true;
    }
    if (!this.allowItemOperations.allowAdd) {
      this.updateIsNewVisibility();
    }
    if (!this.creator.isCanModifyProperty(question, "choices")) {
      this.canTouchItems = false;
    }
  }
  get canBeDragged() {
    return !this.isNew && this.question.choices.indexOf(this.item) > -1;
  }
  isBanStartDrag(pointerDownEvent) {
    if (!this.isDraggable) return true;
    const isContentEditable = pointerDownEvent.target.getAttribute("contenteditable") === "true";
    return isContentEditable || !this.canBeDragged;
  }
  updateNewItemValue() {
    if (!this.creator || !this.question || !this.question.newItem) return;
    this.question.newItem.value = this.creator.getNextItemValue(this.question);
    this.question.newItem.text = getNextItemText(this.question.choices);
  }
  registerOnPropertyChanged(itemName, propertyName) {
    if (this.question[itemName] === this.item) {
      const question = this.question;
      const item = this.item;
      const updateFromProperty = () => {
        this.updateIsNew(question, item);
      };
      question.registerFunctionOnPropertyValueChanged(propertyName, updateFromProperty);
    }
  }
  get collectionPropertyName() {
    return !!this.item.ownerPropertyName ? this.item.ownerPropertyName : "choices";
  }
  onPointerDown(pointerDownEvent) {
    if (this.isBanStartDrag(pointerDownEvent)) return true;
    this.dragOrClickHelper.onPointerDown(pointerDownEvent);
    return false;
  }
  get dragDropHelper() {
    return this.creator.dragDropChoices;
  }
  dispose() {
    super.dispose();
    this.dragDropHelper.onGhostPositionChanged.remove(this.handleDragDropGhostPositionChanged);
  }
  getGhostPosition(item) {
    if (this.dragDropHelper.dropTarget !== item) return null;
    return this.dragDropHelper.isBottom ? "bottom" : "top";
  }
  get isDraggable() {
    return this.isDraggableItem(this.item);
  }
  isDraggableItem(item) {
    if (this.creator.readOnly || !this.canTouchItems) return false;
    return this.question.choices.indexOf(item) !== -1;
  }
  getSpecificProp(model) {
    for (let key in specificChoices) {
      if (model.question[key] === model.item) return specificChoices[key];
    }
    return void 0;
  }
  add(model) {
    const propName = this.getSpecificProp(model);
    if (propName) {
      model.question[propName] = true;
      return;
    }
    this.addNewItem(model.item, model.question, model.creator);
    this.updateIsNew(model.question, model.item);
  }
  addNewItem(item, question, creator) {
    item.value = "newitem";
    const itemValue = creator.createNewItemValue(question);
    this.updateNewItemValue();
    StringEditorConnector.get(itemValue.locText).setAutoFocus();
  }
  remove(model) {
    const propName = this.getSpecificProp(model);
    if (propName) {
      model.question[propName] = false;
      return;
    }
    const choices = model.question.choices;
    var index = choices.indexOf(model.item);
    if (!this.creator.onCollectionItemDeletingCallback(model.question, this.collectionProperty, choices, model.item)) return;
    var indexToFocus = this.findNextElementIndexToRemove(index);
    model.question.choices.splice(index, 1);
    this.focusNextElementToRemove(indexToFocus);
    this.updateIsNew(model.question, model.item);
  }
  onFocusOut(event) {
    this.question["_lastActiveItemValueIndex"] = this.question.choices.indexOf(this.item);
  }
  findNextElementIndexToRemove(index) {
    let indexToFocus = 0;
    if (this.question.choices.length > 0) {
      if (index < this.question["_lastActiveItemValueIndex"]) {
        indexToFocus = index - 1;
      } else {
        indexToFocus = index;
      }
      if (indexToFocus < 0) indexToFocus = 0;
      if (indexToFocus >= this.question.choices.length - 2) indexToFocus = this.question.choices.length - 2;
    }
    return indexToFocus;
  }
  focusNextElementToRemove(index) {
    setTimeout(() => {
      var _a;
      const el = document.getElementById(this.question.id);
      const buttons = el.querySelectorAll(".svc-item-value-controls__remove");
      (_a = buttons[index]) === null || _a === void 0 ? void 0 : _a.focus();
    }, 100);
  }
  updateIsNew(question, item) {
    this.isNew = !question.isItemInList(item) && !this.isAutoGeneratedItem(item);
    this.updateIsNewVisibility();
  }
  updateIsNewVisibility() {
    var _a;
    if (this.isNew) {
      this.item.setIsVisible(!(((_a = this.allowItemOperations) === null || _a === void 0 ? void 0 : _a.allowAdd) === false));
    }
  }
  get allowRemove() {
    const minChoices = this.creator.minimumChoicesCount;
    if (minChoices > 0 && minChoices >= this.question.choices.length) return false;
    const isNew = !this.question.isItemInList(this.item);
    const isAutoGenerated = this.isAutoGeneratedItem(this.item);
    return !this.creator.readOnly && this.canTouchItems && this.allowItemOperations.allowDelete && !isNew && !isAutoGenerated;
  }
  get tooltip() {
    return getLocString(this.isNew ? "pe.addItem" : "pe.removeItem");
  }
  get dragTooltip() {
    return getLocString("pe.dragItem");
  }
  get allowAdd() {
    const isNew = !this.question.isItemInList(this.item);
    const isAutoGenerated = this.isAutoGeneratedItem(this.item);
    return !this.creator.readOnly && this.canTouchItems && this.allowItemOperations.allowAdd && isNew && !isAutoGenerated;
  }
  select(model, event) {
    if (model.question.inMatrixMode) return;
    model.creator.selectElement(model.question, "choices", false);
    event && event.stopPropagation();
  }
  isAutoGeneratedItem(item) {
    const val = item.value;
    if (!Helpers.isNumber(val)) return false;
    const min2 = this.question.choicesMin;
    const max2 = this.question.choicesMax;
    if (!Helpers.isNumber(min2) || !Helpers.isNumber(max2) || min2 === max2 && min2 === 0) return false;
    return val >= min2 && val <= max2;
  }
};
__decorate2([property({
  defaultValue: false
})], ItemValueWrapperViewModel.prototype, "isNew", void 0);
__decorate2([property({
  defaultValue: false
})], ItemValueWrapperViewModel.prototype, "isDragging", void 0);
__decorate2([property({
  defaultValue: false
})], ItemValueWrapperViewModel.prototype, "isDragDropGhost", void 0);
__decorate2([property({
  defaultValue: false
})], ItemValueWrapperViewModel.prototype, "isDragDropMoveDown", void 0);
__decorate2([property({
  defaultValue: false
})], ItemValueWrapperViewModel.prototype, "isDragDropMoveUp", void 0);
__decorate2([property({
  defaultValue: null
})], ItemValueWrapperViewModel.prototype, "ghostPosition", void 0);
var ImageItemValueWrapperViewModel = class extends ItemValueWrapperViewModel {
  constructor(creator, question, item, templateData, itemsRoot) {
    super(creator, question, item);
    this.question = question;
    this.item = item;
    this.templateData = templateData;
    this.itemsRoot = itemsRoot;
    this.isChoosingNewFile = false;
    this.onDragOver = (event) => {
      this.isFileDragging = true;
      event.dataTransfer.dropEffect = "copy";
      event.preventDefault();
    };
    this.onDrop = (event) => {
      this.isFileDragging = false;
      event.preventDefault();
      let input = event.dataTransfer;
      if (!input || !input.files || input.files.length < 1) return;
      let files = [];
      for (let i = 0; i < input.files.length; i++) {
        files.push(input.files[i]);
      }
      this.uploadFiles(files);
    };
    this.onDragLeave = (event) => {
      this.isFileDragging = false;
    };
  }
  getRootCss() {
    return new CssClassBuilder().append("svc-image-item-value-wrapper").append("svc-image-item-value").append("svc-image-item-value--new", this.isNew || this.isUploading).append("svc-image-item-value-wrapper--ghost", this.isDragDropGhost).append("svc-image-item-value--file-dragging", this.isFileDragging).append("svc-image-item-value--single", this.getIsNewItemSingle()).toString();
  }
  getIsNewItemSingle() {
    return this.isNew && this.question.choices.length === 0;
  }
  get canRenderControls() {
    return this.getIsNewItemSingle() || !this.question.renderedImageWidth || this.question.renderedImageWidth > 150;
  }
  get selectFileTitle() {
    return this.creator.getLocString("ed.selectFile");
  }
  get removeFileTitle() {
    return this.creator.getLocString("ed.removeFile");
  }
  get addFileTitle() {
    return this.creator.getLocString("ed.selectFile");
  }
  chooseFile(model) {
    const fileInput = model.itemsRoot.getElementsByClassName("svc-choose-file-input")[0];
    const context = {
      element: model.question,
      item: model.item,
      elementType: model.question.getType(),
      propertyName: "imageLink"
    };
    model.creator.chooseFiles(fileInput, (files) => {
      model.isUploading = true;
      model.creator.uploadFiles(files, model.question, (status, link) => {
        if (status === "success") {
          model.item.imageLink = link;
        }
        model.isUploading = false;
      }, context);
    }, context);
  }
  uploadFiles(files) {
    this.isUploading = true;
    const context = {
      element: this.question,
      item: void 0,
      elementType: this.question.getType(),
      propertyName: "imageLink"
    };
    this.creator.uploadFiles(files, this.question, (status, link) => {
      if (status === "success") {
        this.creator.createNewItemValue(this.question, this.isChoosingNewFile, (res) => {
          res.imageLink = link;
        });
      }
      this.isChoosingNewFile = false;
      this.isUploading = false;
    }, context);
  }
  chooseNewFile(model) {
    const fileInput = model.itemsRoot.getElementsByClassName("svc-choose-file-input")[0];
    model.creator.chooseFiles(fileInput, (files) => {
      this.isChoosingNewFile = true;
      model.uploadFiles(files);
    }, {
      element: model.question,
      item: model.item,
      elementType: model.question.getType(),
      propertyName: "imageLink"
    });
  }
  get acceptedTypes() {
    return getAcceptedTypesByContentMode(this.question.contentMode);
  }
  dispose() {
    this.itemsRoot = void 0;
    super.dispose();
  }
};
__decorate2([property({
  defaultValue: false
})], ImageItemValueWrapperViewModel.prototype, "isFileDragging", void 0);
__decorate2([property({
  defaultValue: false
})], ImageItemValueWrapperViewModel.prototype, "isUploading", void 0);
var MatrixCellWrapperEditSurvey = class {
  constructor(creator, cellQuestion, column, model) {
    this.cellQuestion = cellQuestion;
    this.column = column;
    this.creator = creator;
    let questionJSON = cellQuestion.toJSON();
    questionJSON.type = cellQuestion.getType();
    this.surveyValue = creator.createSurvey({
      questions: [questionJSON]
    }, "modal-question-editor", model, (survey) => {
      survey.css = defaultCss;
      survey.setDesignMode(true);
      survey.isPopupEditorContent = true;
      survey.showQuestionNumbers = "none";
      survey.questionTitleLocation = "hidden";
    });
    this.question.setSurveyImpl(this.survey);
    this.question.inMatrixMode = true;
    this.question.ownerObj = this.column;
  }
  get survey() {
    return this.surveyValue;
  }
  get question() {
    return this.survey.getAllQuestions()[0];
  }
  apply() {
    const matrix = this.cellQuestion.parentQuestion;
    const column = matrix.getColumnByName(this.cellQuestion.name);
    const columnJSON = column.toJSON();
    const prevCellType = columnJSON["cellType"];
    const questionJSON = this.question.toJSON();
    const qType = this.question.getType();
    if (!!prevCellType) {
      questionJSON.cellType = prevCellType;
    }
    if (Helpers.isTwoValueEquals(questionJSON, columnJSON)) return;
    for (let key in columnJSON) {
      if (!!Serializer.findProperty(qType, key) && questionJSON[key] === void 0 && (columnJSON[key] === true || columnJSON[key] === false)) {
        questionJSON[key] = !columnJSON[key];
      }
    }
    if (column.cellType === "default") {
      column.cellType = qType;
    }
    for (let key in questionJSON) {
      if (!Helpers.isTwoValueEquals(questionJSON[key], columnJSON[key])) {
        column[key] = questionJSON[key];
      }
    }
    matrix.onColumnCellTypeChanged(column);
    this.creator.setModified({
      type: "MATRIX_CELL_EDITOR",
      column
    });
  }
};
var MatrixCellWrapperViewModel = class extends Base {
  constructor(creator, templateData, question, row, column) {
    super();
    this.creator = creator;
    this.templateData = templateData;
    this.question = question;
    this.row = row;
    this.column = column;
    this.onSelectionChanged = (sender, options) => {
      if (this.context && this.context.getPropertyValue) {
        this.isSelected = this.creator.isElementSelected(this.context);
      } else {
        this.isSelected = false;
      }
    };
    creator.onElementSelected.add(this.onSelectionChanged);
  }
  editQuestion(model, event) {
    const editSurvey = new MatrixCellWrapperEditSurvey(model.creator, model.question, model.column, this);
    editSurvey.question.cellOwner = model;
    const prevCurrentLocale = surveyLocalization.currentLocale;
    const locale = editorLocalization.currentLocale;
    surveyLocalization.currentLocale = locale;
    const popupModel = settings.showDialog({
      componentName: "svc-question-editor-content",
      data: {
        survey: editSurvey.survey,
        creator: this.creator
      },
      onApply: () => {
        editSurvey.apply();
        return true;
      },
      cssClass: "svc-matrix-cell__popup svc-creator-popup",
      title: model.question.name,
      displayMode: this.creator.isMobileView ? "overlay" : "popup"
    }, model.creator.rootElement);
    popupModel.locale = locale;
    surveyLocalization.currentLocale = prevCurrentLocale;
    event.stopPropagation();
    model.creator.selectElement(model.column);
  }
  get context() {
    return this.row || this.column || this.templateData;
  }
  selectContext(model, event) {
    if (!!model.row) {
      model.creator.selectElement(model.row.data, "rows", false);
      event.stopPropagation();
      return;
    }
    if (typeof model.context.getType !== "function") {
      return;
    }
    const contextType = model.context.getType();
    if (contextType === "itemvalue") {
      model.creator.selectElement(model.context.locOwner, model.context.ownerPropertyName, false);
    } else {
      model.creator.selectElement(model.context);
    }
    event.stopPropagation();
  }
  get isSupportCellEditor() {
    if (!this.question || !this.question.getType) return false;
    return SurveyHelper.isSupportCellEditor(this.question.getType());
  }
  hover(event, element) {
    if (!this.row && this.context && this.context.getPropertyValue && this.context.getType && this.context.getType() !== "itemvalue") {
      toggleHovered(event, element);
    }
  }
  dispose() {
    this.creator.onElementSelected.remove(this.onSelectionChanged);
    super.dispose();
  }
};
__decorate2([property()], MatrixCellWrapperViewModel.prototype, "isSelected", void 0);
var SurveyResultsItemModel = class extends Base {
  constructor(survey, _data, _lvl) {
    super();
    this.survey = survey;
    this._data = _data;
    this._lvl = _lvl;
    this.toggle = () => {
      this.collapsed = !this.collapsed;
    };
    this.markerWidth = 16;
    this.question = survey.getQuestionByName(this.name);
    this.items = addCollapsed(survey, _data.data, _lvl + 1);
    this.lvl = _lvl;
  }
  get data() {
    return this.items;
  }
  get isNode() {
    return this._data.isNode;
  }
  get name() {
    return this._data.name;
  }
  get title() {
    return this._data.title;
  }
  get value() {
    return this._data.value;
  }
  get displayValue() {
    return this._data.displayValue;
  }
  getString(data) {
    return this._data.getString(data);
  }
  get markerMargin() {
    return (1.5 + this.lvl) * this.markerWidth + "px";
  }
  get textMargin() {
    return (2.75 + this.lvl) * this.markerWidth + "px";
  }
};
__decorate2([property({
  defaultValue: true
})], SurveyResultsItemModel.prototype, "collapsed", void 0);
__decorate2([property({
  defaultValue: 0
})], SurveyResultsItemModel.prototype, "lvl", void 0);
__decorate2([property()], SurveyResultsItemModel.prototype, "items", void 0);
function addCollapsed(survey, items = [], initLvl) {
  return items.filter((item) => !!item).map((item) => {
    return new SurveyResultsItemModel(survey, item, initLvl);
  });
}
var SurveyResultsModel = class extends Base {
  constructor(survey) {
    super();
    this.survey = survey;
    this.selectTableClick = () => {
      this.resultViewType = "table";
    };
    this.selectJsonClick = () => {
      this.resultViewType = "text";
    };
    this.resultText = JSON.stringify(survey.data, null, 4);
    var plainData = survey.getPlainData({
      includeEmpty: false,
      includeValues: true
    });
    this.resultData = addCollapsed(survey, plainData, 0);
  }
  getLocString(name) {
    return editorLocalization.getString(name);
  }
  get surveyResultsText() {
    return this.getLocString("ed.surveyResults");
  }
  get surveyResultsTableText() {
    return this.getLocString("ed.surveyResultsTable");
  }
  get surveyResultsJsonText() {
    return this.getLocString("ed.surveyResultsJson");
  }
  get resultsTitle() {
    return this.getLocString("ed.resultsTitle");
  }
  get resultsName() {
    return this.getLocString("ed.resultsName");
  }
  get resultsValue() {
    return this.getLocString("ed.resultsValue");
  }
  get resultsDisplayValue() {
    return this.getLocString("ed.resultsDisplayValue");
  }
  get isTableSelected() {
    return this.resultViewType === "table";
  }
  get isJsonSelected() {
    return this.resultViewType === "text";
  }
};
__decorate2([property({
  defaultValue: "table"
})], SurveyResultsModel.prototype, "resultViewType", void 0);
__decorate2([property({
  defaultValue: ""
})], SurveyResultsModel.prototype, "resultText", void 0);
__decorate2([propertyArray()], SurveyResultsModel.prototype, "resultData", void 0);
var LogoImageViewModel = class extends Base {
  constructor(creator, root) {
    super();
    this.creator = creator;
    this.root = root;
  }
  get allowEdit() {
    const survey = this.creator.survey;
    const property2 = Serializer.findProperty(survey.getType(), "logo");
    return !this.creator.readOnly && (!property2.overridingProperty || !survey[property2.overridingProperty]);
  }
  get containerCss() {
    return new CssClassBuilder().append("svc-logo-image-container").append("svc-logo-image-container--editable", this.allowEdit).toString();
  }
  get survey() {
    return this.creator.survey;
  }
  uploadFile(model, fileInput, files) {
    model.isUploading = true;
    model.creator.uploadFiles(files, void 0, (_, link) => {
      model.creator.survey.logo = link;
      fileInput.value = "";
      model.isUploading = false;
    }, {
      element: model.creator.survey,
      elementType: "survey",
      propertyName: "logo"
    });
  }
  chooseFile(model) {
    if (this.allowEdit) {
      const fileInput = model.root.getElementsByClassName("svc-choose-file-input")[0];
      if (fileInput.files.length === 0) {
        model.creator.chooseFiles(fileInput, (files) => {
          model.uploadFile(model, fileInput, files);
        }, {
          element: this.survey,
          elementType: this.survey.getType(),
          propertyName: "logo"
        });
      } else model.uploadFile(model, fileInput, [fileInput.files[0]]);
    }
  }
  remove(model) {
    model.creator.survey.logo = "";
  }
  get chooseLogoPlaceholder() {
    return this.creator.getLocString("ed.chooseLogoPlaceholder");
  }
  get acceptedTypes() {
    return getAcceptedTypesByContentMode("image");
  }
};
__decorate2([property({
  defaultValue: false
})], LogoImageViewModel.prototype, "isUploading", void 0);
var questionType = "embeddedsurvey";
var QuestionEmbeddedSurveyModel = class extends QuestionNonValue {
  set embeddedSurvey(val) {
    if (val === this.embeddedSurvey) return;
    this.setPropertyValue("embeddedSurvey", val);
    this.onEmbeddedSurveyValueChanged();
  }
  get embeddedSurvey() {
    return this.getPropertyValue("embeddedSurvey");
  }
  constructor(name) {
    super(name);
    this.onEmbeddedSurveyValueChanged = () => {
    };
  }
  getType() {
    return questionType;
  }
};
Serializer.addClass(questionType, [], function() {
  return new QuestionEmbeddedSurveyModel("");
}, "nonvalue");
QuestionFactory.Instance.registerQuestion(questionType, (name) => {
  return new QuestionEmbeddedSurveyModel(name);
}, false);
var QuestionLinkValueModel = class extends Question {
  constructor(name, json2 = null) {
    super(name);
    const linkValueText = json2 && !json2.showValueInLink && editorLocalization.getString("pe.set") + " " + json2.title || null;
    this.linkValueText = linkValueText || editorLocalization.getString("pe.emptyValue");
  }
  onPropertyValueChanged(name, oldValue, newValue) {
    super.onPropertyValueChanged(name, oldValue, newValue);
    if (name === "value") {
      this.updateLinkValueText();
      if (this.allowClear) {
        this.showClear = !Helpers.isValueEmpty(newValue);
      }
      this.updateIsClickable();
    }
  }
  onReadOnlyChanged() {
    this.updateIsClickable();
    super.onReadOnlyChanged();
  }
  updateIsClickable() {
    this.setPropertyValue("isClickable", !this.isReadOnly || !!this.isClickableCallback && this.isClickableCallback());
  }
  get ariaRole() {
    return "button";
  }
  get tooltip() {
    return this.showTooltip ? this.linkValueText : void 0;
  }
  getType() {
    return "linkvalue";
  }
  doLinkClick() {
    if (!!this.linkClickCallback) {
      this.linkClickCallback();
    }
  }
  doClearClick() {
    if (!!this.clearClickCallback) {
      this.clearClickCallback();
    }
  }
  updateLinkValueText() {
    let displayValue2;
    if (this.showValueInLink) {
      displayValue2 = this.isEmpty() ? editorLocalization.getString("pe.emptyValue") : this.getObjDisplayValue();
    } else {
      displayValue2 = editorLocalization.getString(this.isEmpty() ? "pe.set" : "pe.change") + " " + this.title;
    }
    this.linkValueText = displayValue2;
  }
  stringifyValue(val) {
    if (typeof val !== "string") return JSON.stringify(val);
    return val;
  }
  getObjDisplayValue() {
    const obj = this.obj;
    if (!obj || !obj["getDisplayValue"]) return this.stringifyValue(this.value);
    var res = obj["getDisplayValue"](true, this.value);
    if (typeof res !== "string") return JSON.stringify(res);
    return res;
  }
};
__decorate2([property({
  defaultValue: "svc-link__button svc-link-value-button svc-question-link__set-button"
})], QuestionLinkValueModel.prototype, "linkSetButtonCssClasses", void 0);
__decorate2([property({
  defaultValue: "svc-link__button svc-question-link__clear-button"
})], QuestionLinkValueModel.prototype, "linkClearButtonCssClasses", void 0);
__decorate2([property({
  defaultValue: false
})], QuestionLinkValueModel.prototype, "isSelected", void 0);
__decorate2([property()], QuestionLinkValueModel.prototype, "linkValueText", void 0);
__decorate2([property({
  defaultValue: false
})], QuestionLinkValueModel.prototype, "showClear", void 0);
__decorate2([property({
  defaultValue: true
})], QuestionLinkValueModel.prototype, "allowClear", void 0);
__decorate2([property({
  defaultValue: true
})], QuestionLinkValueModel.prototype, "showValueInLink", void 0);
__decorate2([property({
  defaultValue: false
})], QuestionLinkValueModel.prototype, "showTooltip", void 0);
__decorate2([property({
  defaultValue: true
})], QuestionLinkValueModel.prototype, "isClickable", void 0);
__decorate2([property()], QuestionLinkValueModel.prototype, "iconName", void 0);
Serializer.addClass("linkvalue", ["showValueInLink", {
  name: "showTooltip: boolean",
  default: false,
  visible: false
}, "iconName"], function(json2) {
  const viewModel = new QuestionLinkValueModel("", json2);
  return viewModel;
}, "nonvalue");
QuestionFactory.Instance.registerQuestion("linkvalue", (name) => {
  return new QuestionLinkValueModel(name);
}, false);
var ScrollViewModel = class {
  constructor() {
    this._lockScroll = false;
  }
  setRootElement(element) {
    this._containerElementValue = element === null || element === void 0 ? void 0 : element.querySelector(".svc-scroll__scroller");
    this._scrollbarElement = element === null || element === void 0 ? void 0 : element.querySelector(".svc-scroll__scrollbar");
    this._scrollbarSizerElement = element === null || element === void 0 ? void 0 : element.querySelector(".svc-scroll__scrollbar-sizer");
    this._containerBodyElement = element === null || element === void 0 ? void 0 : element.querySelector(".svc-scroll__container");
    if (!element) return;
    this._containerBodyResizeObserver = new ResizeObserver((entries) => {
      for (let entry of entries) {
        const height = entry.contentBoxSize ? entry.contentBoxSize[0].blockSize : entry.contentRect.width;
        this._scrollbarSizerElement.style.height = height + "px";
      }
    });
    this._containerBodyResizeObserver.observe(this._containerBodyElement);
  }
  onScrollContainer() {
    this._lockScroll = true;
    this._scrollbarElement.scrollTop = this._containerElementValue.scrollTop;
  }
  onScrollScrollbar() {
    if (this._lockScroll) {
      this._lockScroll = false;
      return;
    }
    this._containerElementValue.scrollTop = this._scrollbarElement.scrollTop;
  }
  unsubscribeRootElement() {
    if (!!this._containerBodyResizeObserver) {
      this._containerBodyResizeObserver.disconnect();
      this._containerBodyResizeObserver = void 0;
    }
  }
};
var QuestionSpinEditorModel = class extends QuestionTextModel {
  constructor() {
    super(...arguments);
    this._showUnitsInEditor = true;
    this.onUpButtonMouseDown = () => {
      if (!this.changeValueOnPressing) return;
      this.increase();
      this.clearTimers();
      this.increaseTimer = setTimeout(this.onUpButtonMouseDown, 200);
    };
    this.onDownButtonMouseDown = () => {
      if (!this.changeValueOnPressing) return;
      this.decrease();
      this.clearTimers();
      this.decreaseTimer = setTimeout(this.onDownButtonMouseDown, 200);
    };
    this.onUpButtonClick = () => {
      if (!this.changeValueOnPressing) {
        this.increase();
      }
    };
    this.onDownButtonClick = () => {
      if (!this.changeValueOnPressing) {
        this.decrease();
      }
    };
    this.onButtonMouseLeave = () => {
      if (!this.changeValueOnPressing) return;
      this.onButtonMouseUp();
    };
    this.onButtonMouseUp = () => {
      if (!this.changeValueOnPressing) return;
      this.clearTimers();
    };
    this.onKeyDown = (event) => {
      switch (event.key) {
        case "ArrowUp":
          this.increase();
          event.stopPropagation();
          event.preventDefault();
          break;
        case "ArrowDown":
          this.decrease();
          event.stopPropagation();
          event.preventDefault();
          break;
      }
      this.onTextKeyDownHandler(event);
    };
    this.onInputKeyDown = (event) => {
      if (event.key == "ArrowUp" || event.key == "ArrowDown") this["updateValueOnEvent"](event);
    };
    this.onFocus = (event) => {
      if (event.target.tagName == "INPUT") {
        queueMicrotask(() => {
          const inputElement = event.target;
          const selectStart = inputElement.selectionStart;
          const selectEnd = inputElement.selectionEnd;
          const selectDirection = inputElement.selectionDirection;
          this._showUnitsInEditor = false;
          queueMicrotask(() => {
            if (Math.abs(selectEnd - selectStart) > 0) {
              inputElement.setSelectionRange(0, this.renderedValue.length, selectDirection);
            } else {
              inputElement.setSelectionRange(this.renderedValue.length, this.renderedValue.length);
            }
          });
        });
      }
    };
    this.onBlur = (event) => {
      this._showUnitsInEditor = true;
      if (event.target.tagName == "INPUT") {
        this["updateValueOnEvent"](event);
      }
    };
  }
  parseValue(val) {
    const value = parseFloat(val.toString());
    const unit = val.toString().replace(/[^A-Za-z]/g, "");
    return {
      value,
      unit
    };
  }
  changeValue(increase) {
    const parsedValue = this.parseValue(this.renderedValue);
    const step = Number(this.renderedStep || 1);
    let result = parsedValue.value;
    if (increase) {
      result += step;
    } else {
      result -= step;
    }
    this.value = result;
  }
  get showUnitsInEditor() {
    return !!this.unit && this._showUnitsInEditor;
  }
  correctValue(newValue) {
    if (newValue == void 0 || newValue == null) return newValue;
    let renderedMax = Number(this.renderedMax);
    let renderedMin = Number(this.renderedMin);
    newValue = typeof newValue === "string" ? parseFloat(newValue) : newValue;
    if (isNaN(newValue)) {
      newValue = isNaN(renderedMin) ? 0 : renderedMin;
    } else if (newValue > renderedMax) {
      newValue = renderedMax;
    } else if (newValue < renderedMin) {
      newValue = renderedMin;
    }
    newValue = Math.round(newValue * 1e3) / 1e3;
    return newValue;
  }
  setNewValue(newValue) {
    super.setNewValue(this.correctValue(newValue));
  }
  get renderedValue() {
    var _a, _b;
    let renderedValue = ((_b = (_a = this.value) !== null && _a !== void 0 ? _a : this.renderedMin) !== null && _b !== void 0 ? _b : 0).toString();
    if (this.showUnitsInEditor) {
      renderedValue += this.unit;
    }
    return renderedValue;
  }
  increase() {
    this.changeValue(true);
  }
  decrease() {
    this.changeValue(false);
  }
  clearTimers() {
    clearTimeout(this.decreaseTimer);
    clearTimeout(this.increaseTimer);
  }
  onBeforeInput(event) {
    const target = event.target;
    const regex = target.selectionStart == 0 ? /[\d.-]/ : /[\d.]/;
    if (!!event.data && !regex.test(event.data)) {
      event.preventDefault();
    }
  }
  getType() {
    return "spinedit";
  }
  get isInputTextUpdate() {
    return false;
  }
};
__decorate2([property()], QuestionSpinEditorModel.prototype, "unit", void 0);
__decorate2([property()], QuestionSpinEditorModel.prototype, "changeValueOnPressing", void 0);
__decorate2([property()], QuestionSpinEditorModel.prototype, "_showUnitsInEditor", void 0);
Serializer.addClass("spinedit", ["unit", {
  name: "changeValueOnPressing:boolean",
  default: true
}], () => new QuestionSpinEditorModel(""), "text");
QuestionFactory.Instance.registerQuestion("spinedit", (name) => {
  return new QuestionSpinEditorModel(name);
}, false);
var DEFAULT_COLOR = "#000000";
var QuestionColorModel = class extends QuestionTextModel {
  constructor(name) {
    super(name);
    this.allowEmptyValue = false;
    this.createItemValues("choices");
    this.registerFunctionOnPropertyValueChanged("choices", () => {
      this.updateChoices();
    });
  }
  getCorrectedValue(newValue) {
    if (newValue == void 0 || newValue == null || this.allowEmptyValue && !newValue) return newValue;
    newValue = parseColor(newValue !== null && newValue !== void 0 ? newValue : "").color;
    if (newValue.indexOf("#") < 0) {
      newValue = "#" + newValue;
    }
    newValue = (newValue.match(/#([0-9a-fA-F]){1,6}/) || [DEFAULT_COLOR])[0];
    if (newValue.length === 4) {
      let value = newValue.slice(0, 1);
      for (let i = 1; i < 4; i++) {
        value += newValue[i] + newValue[i];
      }
      newValue = value;
    }
    if (newValue.length < 7) {
      const length = newValue.length;
      for (let i = 0; i < 7 - length; i++) {
        newValue += "0";
      }
    }
    return newValue;
  }
  isNewValueEqualsToValue(newValue) {
    if (super.isNewValueEqualsToValue(newValue) || this.isTwoValueEquals(newValue, this.value, true, true)) return true;
    else return false;
  }
  setNewValue(newValue) {
    this.resetRenderedValue();
    super.setNewValue(this.getCorrectedValue(newValue));
    this.updateRenderedValue();
  }
  onBeforeInput(event) {
    if (!!event.data && !/[\d\w(),#]/.test(event.data)) {
      event.preventDefault();
    }
  }
  onColorInputChange(event) {
    this.value = event.target.value;
  }
  getType() {
    return "color";
  }
  resetRenderedValue() {
    this._renderedValue = void 0;
  }
  updateRenderedValue() {
    if (this.value) {
      const color = parseColor(this.value || "");
      this._renderedValue = color.color;
    } else if (this.allowEmptyValue) {
      this._renderedValue = "";
    } else {
      this._renderedValue = DEFAULT_COLOR;
    }
  }
  get renderedValue() {
    if (!this._renderedValue && this._renderedValue !== "") {
      this.updateRenderedValue();
    }
    return this._renderedValue.toUpperCase();
  }
  getSwatchCss() {
    return new CssClassBuilder().append(this.cssClasses.swatch).append(this.cssClasses.swatchDefault, !this.renderedValue).append(this.cssClasses.swatchDisabled, this.isInputReadOnly).toString();
  }
  getSwatchStyle() {
    return {
      backgroundColor: this.renderedValue
    };
  }
  get renderedColorValue() {
    return this.renderedValue || DEFAULT_COLOR;
  }
  get isInputTextUpdate() {
    return false;
  }
  onSurveyValueChanged(newValue) {
    super.onSurveyValueChanged(newValue);
    this.updateRenderedValue();
  }
  get dropdownAction() {
    if (!this._dropdownAction) {
      this._dropdownAction = this.createDropdownAction();
    }
    return this._dropdownAction;
  }
  get choices() {
    return this.getPropertyValue("choices");
  }
  set choices(newValue) {
    this.setPropertyValue("choices", newValue);
  }
  onTextKeyDownHandler(event) {
    const popupModel = this.dropdownAction.popupModel;
    if (event.key === "ArrowDown") {
      this.dropdownAction.action();
    }
    if (!popupModel.isVisible) {
      super.onTextKeyDownHandler(event);
    }
  }
  get showDropdownAction() {
    return !this.isValueEmpty(this.choices);
  }
  createDropdownAction() {
    const action = createDropdownActionModelAdvanced({
      enabled: new ComputedUpdater(() => !this.isInputReadOnly)
    }, {
      onSelectionChanged: (item) => {
        this.value = item.value;
      },
      items: this.choices,
      cssClasses: listComponentCss
    }, {
      showPointer: false,
      verticalPosition: "bottom",
      horizontalPosition: "center",
      cssClass: "svc-creator-popup"
    });
    action.disableTabStop = true;
    const popupModel = action.popupModel;
    const listModel = popupModel.contentComponentData.model;
    popupModel.displayMode = IsTouch ? "overlay" : "popup";
    popupModel.setWidthByTarget = true;
    popupModel.positionMode = "fixed";
    popupModel.getTargetCallback = void 0;
    listModel.isItemSelected = (itemValue) => itemValue.value == this.value;
    return action;
  }
  calcCssClasses(css) {
    const classes = super.calcCssClasses(css);
    const dropdownAction = this.dropdownAction;
    dropdownAction.cssClasses = {
      item: classes.colorDropdown
    };
    dropdownAction.iconName = classes.colorDropdownIcon;
    dropdownAction.iconSize = "auto";
    return classes;
  }
  updateChoices() {
    this.dropdownAction.popupModel.contentComponentData.model.setItems(this.choices);
  }
  get itemComponent() {
    return "color-item";
  }
};
__decorate2([property()], QuestionColorModel.prototype, "allowEmptyValue", void 0);
__decorate2([property()], QuestionColorModel.prototype, "_renderedValue", void 0);
Serializer.addClass("color", [{
  name: "allowEmptyValue:boolean",
  default: false
}, "choices:itemvalue[]"], () => new QuestionColorModel(""), "text");
QuestionFactory.Instance.registerQuestion("color", (name) => {
  return new QuestionColorModel(name);
}, false);
var QuestionFileEditorModel = class extends QuestionFileModel {
  constructor() {
    super(...arguments);
    this._renderedValue = "";
    this.notEmptyValuePlaceholder = "";
    this.onKeyDown = (event) => {
      if (event.target.tagName === "INPUT") {
        this.onTextKeyDownHandler(event);
      }
    };
    this.onFileInputChange = (event) => {
      if (!this.onChooseFilesCallback) {
        this.doChange(event);
        return true;
      }
    };
  }
  onChangeQuestionValue(newValue) {
  }
  setNewValue(newValue) {
    if (typeof newValue === "object") {
      this.stateChanged(this.isEmpty() ? "empty" : "loaded");
      if (!this.isLoadingFromJson) {
        this.loadPreview(newValue);
      }
      this.loadedFilesValue = newValue;
      newValue = this.previewValue[0].content;
    }
    this.updateRenderedValue(newValue);
    super.setNewValue(newValue);
  }
  loadPreview(newValue) {
    if (typeof newValue !== "string") {
      super.loadPreview(newValue);
    }
  }
  get allowMultiple() {
    return false;
  }
  set allowMultiple(val) {
  }
  clear(doneCallback, shouldClearValue = true) {
    if (!this.survey) return;
    const callback = () => {
      if (shouldClearValue) {
        this.value = void 0;
      }
      this.errors = [];
      !!doneCallback && doneCallback();
    };
    if (!!this.loadedFilesValue) {
      this.containsMultiplyFiles = false;
      this.survey.clearFiles(this.loadedFilesValue, this.name, this.previewValue, null, (status, data) => {
        if (status === "success") {
          callback();
        }
      });
    } else {
      callback();
    }
  }
  get renderedPlaceholder() {
    return this.notEmptyValuePlaceholder || this.placeholder;
  }
  updateRenderedValue(value) {
    const matchBase64 = !!value ? value.match(/^data:((?:\w+\/(?:(?!;).)+)?)((?:;[\w\W]*?[^;])*),/) : null;
    if (matchBase64) {
      this.notEmptyValuePlaceholder = matchBase64[0] + "...";
      this._renderedValue = "";
    } else {
      this.notEmptyValuePlaceholder = "";
      this._renderedValue = value;
    }
  }
  get renderedValue() {
    return this._renderedValue;
  }
  updateValueFromInputEvent(event) {
    const value = event.target.value;
    if (!!this.notEmptyValuePlaceholder && !value) return;
    if (!Helpers.isTwoValueEquals(value, this.value)) {
      this.clear(void 0, false);
      this.loadedFilesValue = void 0;
      this.value = event.target.value;
    }
  }
  onSurveyValueChanged(newValue) {
    super.onSurveyValueChanged(newValue);
    this.updateRenderedValue(newValue);
  }
  onInputChange(event) {
    if (event.target !== document.activeElement) {
      this.updateValueFromInputEvent(event);
    }
  }
  onInputBlur(event) {
    this.updateValueFromInputEvent(event);
  }
  getType() {
    return "fileedit";
  }
  getIsClearButtonDisabled() {
    return !this.value || this.isInputReadOnly;
  }
  getChooseButtonCss() {
    return new CssClassBuilder().append(this.cssClasses.chooseButton).append(this.cssClasses.chooseButtonDisabled, this.isInputReadOnly).toString();
  }
  chooseFiles(event) {
    if (this.isInputReadOnly || !this.onChooseFilesCallback) {
      return true;
    } else {
      event.preventDefault();
      event.stopPropagation();
      const input = this["rootElement"].querySelectorAll("input[type='file']")[0];
      this.onChooseFilesCallback(input, (files) => {
        this.loadFiles(files);
      });
    }
  }
};
__decorate2([property()], QuestionFileEditorModel.prototype, "_renderedValue", void 0);
__decorate2([property()], QuestionFileEditorModel.prototype, "notEmptyValuePlaceholder", void 0);
__decorate2([property()], QuestionFileEditorModel.prototype, "placeholder", void 0);
Serializer.addClass("fileedit", ["placeholder:string"], () => new QuestionFileEditorModel(""), "file");
QuestionFactory.Instance.registerQuestion("fileedit", (name) => {
  return new QuestionFileEditorModel(name);
}, false);
var ResetValueAdorner = class extends Base {
  constructor(question) {
    super();
    this.question = question;
  }
  resetValue() {
    if (this.resetValueCallback) {
      this.resetValueCallback();
    }
  }
  get isDisabled() {
    return this.question.isInputReadOnly || !this.allowResetValue;
  }
};
__decorate2([property()], ResetValueAdorner.prototype, "allowResetValue", void 0);
var QuestionTextWithResetModel = class extends QuestionTextModel {
  constructor(name) {
    super(name);
    this.resetValueAdorner = this.createResetValueAdorner();
  }
  createResetValueAdorner() {
    return new ResetValueAdorner(this);
  }
  getType() {
    return "textwithreset";
  }
  getRootClass() {
    return new CssClassBuilder().append(this.cssClasses.root).append(this.cssClasses.onError, this.errors.length > 0).toString();
  }
  getControlClass() {
    return new CssClassBuilder().append(this.cssClasses.control).toString();
  }
  get wrappedQuestionTemplate() {
    return "text";
  }
};
Serializer.addClass("textwithreset", [], () => new QuestionTextWithResetModel(""), "text");
QuestionFactory.Instance.registerQuestion("textwithreset", (name) => {
  return new QuestionTextWithResetModel(name);
}, false);
var QuestionCommentWithResetModel = class extends QuestionCommentModel {
  constructor(name) {
    super(name);
    this.resetValueAdorner = this.createResetValueAdorner();
  }
  createResetValueAdorner() {
    return new ResetValueAdorner(this);
  }
  getType() {
    return "commentwithreset";
  }
  getCssType() {
    return "textwithreset";
  }
  getRootClass() {
    return new CssClassBuilder().append(this.cssClasses.root).append(this.cssClasses.rootMultiline).append(this.cssClasses.onError, this.errors.length > 0).toString();
  }
  getControlClass() {
    return new CssClassBuilder().append(this.cssClasses.control).append(this.cssClasses.controlMultiline).toString();
  }
  get wrappedQuestionTemplate() {
    return "comment";
  }
};
Serializer.addClass("commentwithreset", [{
  name: "allowResize:boolean",
  default: false
}], () => new QuestionCommentWithResetModel(""), "comment");
QuestionFactory.Instance.registerQuestion("commentwithreset", (name) => {
  return new QuestionCommentWithResetModel(name);
}, false);
var PropertyGridEditorExpression = class extends PropertyGridEditor {
  fit(prop) {
    return prop.type == "expression";
  }
  getJSON(obj, prop, options) {
    return {
      type: "comment",
      showOptionsCaption: false,
      rows: 2
    };
  }
  clearPropertyValue(obj, prop, question, options) {
    question.clearValue();
  }
};
var PropertyGridEditorCondition = class extends PropertyGridEditorExpression {
  fit(prop) {
    return prop.type == "condition";
  }
  getJSON(obj, prop, options) {
    return {
      type: "comment",
      showOptionsCaption: false,
      rows: 2
    };
  }
  canClearPropertyValue(obj, prop, question, options) {
    return options.allowEditExpressionsInTextEditor !== false;
  }
  onSetup(obj, question, prop, options) {
    if (options.allowEditExpressionsInTextEditor === false) {
      question.onKeyDownPreprocess = (event) => {
        const allowed = ["Tab", "ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "Home", "End"];
        if (!event.ctrlKey && allowed.indexOf(event.key) < 0) {
          event.preventDefault();
        }
      };
    }
  }
  createPropertyEditorSetup(obj, prop, question, options) {
    return new ConditionEditor(obj.getSurvey(), obj, options, prop.name);
  }
};
PropertyGridEditorCollection.register(new PropertyGridEditorExpression());
PropertyGridEditorCollection.register(new PropertyGridEditorCondition());
var FastEntryEditorBase = class extends PropertyEditorSetupValue {
  constructor(choices, options = null, className = "item", names = []) {
    super(options);
    this.choices = choices;
    this.className = className;
    this.names = names;
    this.commentValue = this.editSurvey.getQuestionByName("question");
    this.setComment();
    this.editSurvey.getQuestionByName("question").placeholder = editorLocalization.getString("pe.fastEntryPlaceholder");
    this.editSurvey.onValidateQuestion.add((sender, options2) => {
      if (options2.errors.length > 0) return;
      const minChoiceCount = this.options.minimumChoicesCount;
      if (minChoiceCount > 0) {
        const choicesCount = this.getChoicesCount();
        if (minChoiceCount > choicesCount) {
          options2.error = editorLocalization.getString("pe.fastEntryChoicesMinCountError")["format"](minChoiceCount);
        }
        return;
      }
      const maxChoicesCount = this.options.maximumChoicesCount;
      if (maxChoicesCount > 0) {
        const choicesCount = this.getChoicesCount();
        if (maxChoicesCount < choicesCount) {
          options2.error = editorLocalization.getString("pe.fastEntryChoicesCountError")["format"](choicesCount, maxChoicesCount);
        }
        return;
      }
      if (!this.isValueUnique) return;
      let uniqueValue = this.getFirstUniqueValue();
      if (!!uniqueValue) {
        options2.error = editorLocalization.getString("pe.fastEntryNonUniqueError")["format"](uniqueValue);
      }
    });
  }
  calcBeforeApplyItemsArray(dest, src, names) {
    if (!src || src.length == 0) {
      dest.splice(0, dest.length);
      return;
    }
    if (dest.length > src.length) {
      dest.splice(src.length, dest.length - src.length);
    }
    if (dest.length < src.length) {
      var insertedArray = [];
      for (var i = dest.length; i < src.length; i++) {
        insertedArray.push(src[i]);
      }
      dest.splice.apply(dest, [dest.length, 0].concat(insertedArray));
    }
  }
  applyItemValueArray(dest, src, names = []) {
    this.calcBeforeApplyItemsArray(dest, src, names);
    for (var i = 0; i < dest.length; i++) {
      names.forEach((name) => {
        dest[i][name] = src[i][name];
      });
    }
  }
  getSurveyJSON() {
    return {
      elements: [{
        type: "comment",
        name: "question",
        titleLocation: "hidden",
        rows: 12
      }]
    };
  }
  getSurveyCreationReason() {
    return "fast-entry";
  }
  apply() {
    if (this.comment.isEmpty()) return false;
    return this.applyCore();
  }
  applyCore() {
    if (this.editSurvey.hasErrors(true)) return false;
    const text = this.comment.value || "";
    const texts = text.split("\n") || [];
    let items = this.convertTextToItemValues(texts);
    items = this.options.onFastEntryCallback(items, texts);
    this.applyItemValueArray(this.choices, items, this.names);
    return true;
  }
  convertTextToItemValues(texts) {
    const items = [];
    for (var i = 0; i < texts.length; i++) {
      if (!texts[i]) continue;
      var elements = texts[i].split(ItemValue.Separator);
      var valueItem = Serializer.createClass(this.className);
      this.names.forEach((name, i2) => {
        valueItem[name] = elements[i2];
      });
      items.push(valueItem);
    }
    return items;
  }
  get comment() {
    return this.commentValue;
  }
  getChoicesCount() {
    var texts = this.comment.value.split("\n");
    var res = 0;
    for (let i = 0; i < texts.length; i++) {
      let str = texts[i];
      if (!!str) res++;
    }
    return res;
  }
  get isValueUnique() {
    return Serializer.findProperty("itemvalue", "value").isUnique === true;
  }
  getFirstUniqueValue() {
    var texts = this.comment.value.split("\n");
    const values = {};
    for (let i = 0; i < texts.length; i++) {
      let str = texts[i];
      if (!str) continue;
      let value = str.split(ItemValue.Separator)[0];
      if (values[value]) return value;
      values[value] = true;
    }
    return void 0;
  }
  setComment() {
    var text = this.convertItemValuesToText();
    this.comment.value = text;
  }
  collectNames(item, type, separatorCounter) {
    let text = "";
    this.names.forEach((name) => {
      if (type === "itemvalues") {
        if (name == "value") return;
        var str = name == "text" ? item.pureText : item[name];
      } else {
        var str = item[name];
      }
      if (!!str) {
        for (var i = 0; i < separatorCounter; i++) {
          text += ItemValue.Separator;
        }
        text += str;
        separatorCounter = 1;
      } else {
        separatorCounter++;
      }
    });
    return text;
  }
  convertItemValuesToText() {
    var text = "";
    this.choices.forEach((item) => {
      if (text) text += "\n";
      text += this.collectNames(item, "", 0);
    });
    return text;
  }
};
var FastEntryEditor = class extends FastEntryEditorBase {
  constructor(choices, options = null, className = "itemvalue", names = ["value", "text"]) {
    super(choices, options, className, names);
    this.choices = choices;
    this.className = className;
    this.names = names;
  }
  apply() {
    return this.applyCore();
  }
  applyItemValueArray(dest, src, names = []) {
    if (!Array.isArray(src)) src = [];
    for (let i = 0; i < src.length; i++) {
      const item = ItemValue.getItemByValue(dest, src[i].value);
      if (item) {
        item.text = src[i].text;
        names.forEach((name) => {
          if (name == "value" || name == "text") return;
          dest[i][name] = src[i][name];
        });
        src.splice(i, 1, item);
      }
    }
    dest.splice.apply(dest, [0, dest.length].concat(src));
  }
  convertItemValuesToText() {
    var text = "";
    this.choices.forEach((item) => {
      if (text) text += "\n";
      text += item.value;
      text += this.collectNames(item, "itemvalues", 1);
    });
    return text;
  }
};
Serializer.addProperty("itemvalue", {
  name: "icon",
  isSerializable: false,
  readOnly: true,
  visibleIndex: 0,
  visibleIf: (obj) => {
    return obj && obj.ownerPropertyName === "rateValues" && obj.locOwner instanceof QuestionRatingModel && obj.locOwner.rateType == "smileys";
  }
});
var PropertyGridEditorMatrix = class _PropertyGridEditorMatrix extends PropertyGridEditor {
  static getNewColumnName(objs, keyPropName, baseName) {
    var arr = [];
    if (Array.isArray(objs)) {
      for (var i = 0; i < objs.length; i++) {
        arr.push(objs[i][keyPropName]);
      }
    }
    return getNextValue(baseName, arr);
  }
  onCreated(obj, question, prop, options, propGridDefinition) {
    question.onGetValueForNewRowCallBack = (sender) => {
      return this.createNewItem(sender, prop);
    };
    this.setupMatrixQuestion(obj, question, prop, propGridDefinition);
  }
  onSetup(obj, question, prop, options) {
    const matrix = question;
    if (matrix.allowRowReorder && matrix.dragDropMatrixRows) {
      matrix.dragDropMatrixRows.onDragStart.add(() => {
        options.startUndoRedoTransaction();
      });
      matrix.dragDropMatrixRows.onDragClear.add(() => {
        options.stopUndoRedoTransaction();
      });
    }
  }
  initializePlaceholder(rowObj, cellQuestion, propertyName) {
    const objType = typeof rowObj.getType === "function" && rowObj.getType();
    if (cellQuestion.getType() === "text" && !!objType) {
      if (propertyName === "text" && objType === "itemvalue") {
        cellQuestion.placeholder = new ComputedUpdater(() => {
          if (!!rowObj.value) return rowObj.value.toString();
          return rowObj.text;
        });
      }
      if (propertyName === "title" && (objType === "matrixdropdowncolumn" || objType === "multipletextitem")) {
        cellQuestion.placeholder = new ComputedUpdater(() => {
          if (!!rowObj.name) return rowObj.name;
          return rowObj.title;
        });
      }
    }
  }
  onMatrixCellCreated(obj, options) {
    const rowObj = options.row.editingObj;
    if (!rowObj) return;
    const q = options.cellQuestion;
    q.obj = rowObj;
    this.initializePlaceholder(rowObj, q, options.columnName);
    q.property = Serializer.findProperty(rowObj.getType(), options.columnName);
    if (q.getType() === "boolean" && q.renderAs === "checkbox") {
      q.titleLocation = "default";
    }
  }
  onGetMatrixRowAction(obj, options, setObjFunc) {
    const question = options.question;
    const row = options.row;
    const actions = options.actions;
    if (this.getEditItemAsStandAlone()) {
      actions.push({
        id: "svd-grid-edit-column",
        iconName: "icon-edit",
        title: editorLocalization.getString("pe.edit"),
        visibleIndex: 0,
        showTitle: false,
        location: "end",
        action: () => {
          var column = options.row.editingObj;
          setObjFunc(column);
        }
      });
    }
    const showDetailAction = actions.filter((item) => item.id === "show-detail")[0];
    updateMatrixRemoveAction(question, actions, row);
    if (!!showDetailAction) {
      showDetailAction.component = "sv-action-bar-item";
      showDetailAction.iconName = this.getShowDetailActionIconName(row);
      showDetailAction.iconSize = "auto";
      showDetailAction.showTitle = false;
      showDetailAction.location = "end";
      showDetailAction.ariaExpanded = row.isDetailPanelShowing;
      showDetailAction.action = () => {
        row.showHideDetailPanelClick();
        showDetailAction.iconName = row.isDetailPanelShowing ? "icon-editing-finish" : "icon-edit";
      };
      showDetailAction.visibleIndex = 0;
      showDetailAction.visible = this.hasPropertiesInDetail;
      row.onDetailPanelShowingChanged = () => {
        showDetailAction.iconName = this.getShowDetailActionIconName(row);
        showDetailAction.ariaExpanded = row.isDetailPanelShowing;
      };
    }
    updateMatixActionsClasses(actions);
  }
  getShowDetailActionIconName(row) {
    return row.isDetailPanelShowing ? "icon-editing-finish" : "icon-edit";
  }
  addItem(creator, obj, question) {
    question.addRow();
  }
  getHasAddButton() {
    return true;
  }
  onGetQuestionTitleActions(obj, options, creator) {
    if (!this.getHasAddButton()) return;
    const question = options.question;
    options.titleActions.push({
      id: "add-item",
      iconName: "icon-add",
      iconSize: "auto",
      title: question.addRowText,
      showTitle: false,
      action: () => this.addItem(creator, obj, question),
      enabled: new ComputedUpdater(() => question.canAddRow)
    });
  }
  createNewItem(matrix, prop) {
    matrix.visibleRows.forEach((row) => row.hideDetailPanel());
    var json2 = {};
    var baseValue = this.getBaseValue(prop);
    var keyPropName = this.getKeyValue();
    if (!baseValue) {
      baseValue = "item";
    }
    var keyValue = null;
    if (!!baseValue && !!keyPropName) {
      var newName = _PropertyGridEditorMatrix.getNewColumnName(matrix.value, keyPropName, baseValue);
      keyValue = newName;
    }
    const obj = matrix.obj;
    var item = Serializer.createClass(this.getDefaultClassName(obj, prop), json2);
    if (!!keyValue) {
      item[keyPropName] = keyValue;
    }
    if (!!this.getObjTypeName()) {
      item[this.getObjTypeName()] = item.getType();
    }
    const arr = obj[prop.name];
    if (Serializer.isDescendantOf(item.getType(), "itemvalue")) {
      item.text = getNextItemText(arr);
    }
    arr.push(item);
    if (arr != matrix.value) {
      matrix.value = arr;
    }
    return item;
  }
  getDefaultClassName(obj, prop) {
    return prop.className;
  }
  getBaseValue(prop) {
    return prop.getBaseValue();
  }
  getKeyValue() {
    return "";
  }
  getColumnNames(obj, prop, options, propGridDefinition) {
    var names = this.getPropertiesNames(obj, prop, options, propGridDefinition);
    if (!!names && names.length > 0) {
      return names;
    }
    return this.getDefaultListProperties(prop);
  }
  getColumnClassName(obj, prop) {
    return prop.className;
  }
  getPropertiesNames(obj, prop, options, propGridDefinition) {
    var res = [];
    var properties = this.getDefinedListProperties(obj, prop, options, propGridDefinition);
    for (var i = 0; i < properties.length; i++) {
      res.push(properties[i].name);
    }
    if (res.length == 0) {
      res = this.getDefaulColumnNames();
    }
    return res;
  }
  getDefinedListProperties(obj, prop, options, propGridDefinition) {
    if (!prop.className) {
      return [];
    }
    var newObj = Serializer.createClass(prop.className);
    if (!newObj) {
      return [];
    }
    var props = new SurveyQuestionProperties(newObj, options, this.getColumnClassName(obj, prop), "list", obj, prop, propGridDefinition);
    if (props.getTabs().length == 0) {
      return [];
    }
    return props.getTabs()[0].properties;
  }
  getDefaultListProperties(prop) {
    var res = [];
    if (!!prop && !!prop.className) {
      var properties = Serializer.getProperties(prop.className);
      for (var i = 0; i < properties.length; i++) {
        if (!this.isPropertyShownInList(properties[i])) {
          continue;
        }
        res.push(properties[i].name);
      }
    }
    return res.length > 0 ? res : this.getDefaulColumnNames();
  }
  getDefaulColumnNames() {
    return [];
  }
  isPropertyShownInList(prop) {
    return prop.visible && prop.showMode !== "form";
  }
  getObjTypeName() {
    return "";
  }
  hasDetailPanel() {
    return !this.getEditItemAsStandAlone();
  }
  setupMatrixQuestion(obj, matrix, prop, propGridDefinition) {
    this.hasPropertiesInDetail = this.hasDetailPanel() && this.calcHasPropertiesInDetail(matrix, prop, propGridDefinition);
    matrix.onHasDetailPanelCallback = (row) => {
      return row.allowEditRow !== false && this.hasPropertiesInDetail;
    };
    matrix.onCreateDetailPanelRenderedRowCallback = (renderedRow) => {
      renderedRow.cells = [renderedRow.cells[1]];
      renderedRow.cells[0].colSpans += 2;
    };
    const q = matrix;
    matrix.onCreateDetailPanelCallback = (row, panel) => {
      new PropertyJSONGenerator(row.editingObj, q.creatorOptions, q.obj, q.property, propGridDefinition).setupObjPanel(panel, true);
    };
    matrix.allowRowReorder = this.getAllowRowDragDrop(prop) && !matrix.isReadOnly;
    if (!!q.creatorOptions) {
      this.setupUsingOptions(obj, matrix, q.creatorOptions, prop);
    }
    if (!!prop.uniquePropertyName) {
      const column = matrix.getColumnByName(prop.uniquePropertyName);
      if (!!column) {
        column.isUnique = true;
      }
    }
  }
  getAllowRowDragDrop(prop) {
    return false;
  }
  calcHasPropertiesInDetail(matrix, prop, propGridDefinition) {
    if (!prop.className) return true;
    var newObj = Serializer.createClass(prop.className);
    if (!newObj) return true;
    var panel = new PanelModel("");
    new PropertyJSONGenerator(newObj, matrix.creatorOptions, matrix.obj, prop, propGridDefinition).setupObjPanel(panel, true);
    return panel.elements.length > 0;
  }
  getJSON(obj, prop, options, propGridDefinition) {
    return this.getMatrixJSON(obj, prop, this.getColumnNames(obj, prop, options, propGridDefinition), options, propGridDefinition);
  }
  getMatrixJSON(obj, prop, propNames, options, propGridDefinition) {
    var className = prop.className;
    if (!className) {
      className = prop.baseClassName;
    }
    const columns = this.getColumnsJSON(obj, prop, propNames, options, propGridDefinition);
    const res = {
      type: "matrixdynamic",
      detailPanelMode: "underRow",
      cellType: "text",
      rowCount: 0,
      keyName: this.getKeyName(prop),
      columns,
      showHeader: columns.length > 1,
      hideColumnsIfEmpty: true,
      addRowText: this.getAddRowText(prop),
      keyDuplicationError: editorLocalization.getString("pe.propertyIsNoUnique"),
      noRowsText: this.getnoRowsText(prop)
    };
    if (this.getShowDetailPanelOnAdding()) {
      res.detailPanelShowOnAdding = true;
    }
    const minRowCount = this.getMinimumRowCount(obj, prop, options);
    const maxRowCount = this.getMaximumRowCount(obj, prop, options);
    if (minRowCount > 0) {
      res.minRowCount = minRowCount;
    }
    if (maxRowCount > 0) {
      res.maxRowCount = maxRowCount;
    }
    return res;
  }
  getnoRowsText(prop) {
    let locName = "pe.listIsEmpty";
    const propLocName = locName + "@" + prop.name;
    if (!!editorLocalization.hasString(propLocName)) {
      locName = propLocName;
    }
    return editorLocalization.getString(locName);
  }
  getMinimumRowCount(obj, prop, options) {
    return -1;
  }
  getMaximumRowCount(obj, prop, options) {
    return -1;
  }
  filterPropertyNames(propNames, options) {
    return propNames;
  }
  getClassNameByProp(prop) {
    return !!prop.className ? prop.className : prop.baseClassName;
  }
  getKeyName(prop) {
    const className = this.getClassNameByProp(prop);
    if (!className) return "";
    const props = Serializer.getProperties(className);
    for (let i = 0; i < props.length; i++) {
      if (props[i].isUnique) return props[i].name;
    }
    return "";
  }
  getColumnsJSON(obj, prop, propNames, options, propGridDefinition) {
    var res = new PropertyJSONGenerator(obj, options, void 0, void 0, propGridDefinition).createColumnsJSON(this.getClassNameByProp(prop), this.filterPropertyNames(propNames, options));
    for (var i = 0; i < res.length; i++) {
      if (res[i].cellType == "comment") {
        res[i].cellType = "text";
      }
    }
    return res;
  }
  getEditItemAsStandAlone() {
    return false;
  }
  getShowDetailPanelOnAdding() {
    return false;
  }
  getAddRowText(prop) {
    var customLocStrName = "pe.addNew@" + prop.name;
    if (editorLocalization.hasString(customLocStrName)) {
      return editorLocalization.getString(customLocStrName);
    }
    return editorLocalization.getString("pe.addNew");
  }
  setupUsingOptions(obj, matrix, options, prop) {
    var evtOptions = {
      allowAddRemoveItems: true,
      allowRemoveAllItems: true,
      showTextView: true,
      allowBatchEdit: true
      // options.itemsEntryType
    };
    options.onSetPropertyEditorOptionsCallback(prop.name, obj, evtOptions);
    if (!evtOptions.allowAddRemoveItems) {
      matrix.allowAddRows = false;
      matrix.allowRemoveRows = false;
    }
    matrix.allowRemoveAllItems = evtOptions.allowRemoveAllItems;
    matrix.showTextView = evtOptions.showTextView;
    matrix.allowBatchEdit = evtOptions.allowBatchEdit;
  }
};
var PropertyGridEditorMatrixItemValues = class extends PropertyGridEditorMatrix {
  fit(prop) {
    return prop.isArray && Serializer.isDescendantOf(prop.className, "itemvalue") && prop.name != "rateValues";
  }
  excludeTextPropertyName(propNames, options) {
    const hideText = options === null || options === void 0 ? void 0 : options.inplaceEditForValues;
    return !!hideText ? propNames.filter((p) => p !== "text") : propNames;
  }
  filterPropertyNames(propNames, options) {
    return this.excludeTextPropertyName(propNames, options).filter((p) => p != "icon");
  }
  isPropertyEditorSetupEnabled(obj, prop, question, options) {
    if (question.showTextView === false) return false;
    var matrix = question;
    var column = matrix.getColumnByName("value");
    var items = question.value;
    return !!column && column.isVisible && !column.readOnly && !this.hasMultipleLanguage(items) && !this.hasVisibleIfOrEnableIf(items);
  }
  getAllowRowDragDrop(prop) {
    return true;
  }
  createPropertyEditorSetup(obj, prop, question, options) {
    var names = question.columns.filter((c) => !c.readOnly).map((c) => c.name);
    return new FastEntryEditor(obj[prop.name], options, prop.className, names);
  }
  canClearPropertyValue(obj, prop, question, options) {
    return question.allowRemoveAllItems !== false;
  }
  clearPropertyValue(obj, prop, question, options) {
    var arr = obj[prop.name];
    if (!Array.isArray(arr)) {
      return;
    }
    arr.splice(0, arr.length);
  }
  getColumnClassName(obj, prop) {
    return obj.getType() + "@" + prop.name;
  }
  getDefaulColumnNames() {
    return ["value", "text"];
  }
  getKeyValue() {
    return "value";
  }
  getMatrixJSON(obj, prop, propNames, options, propGridDefinition) {
    let res = super.getMatrixJSON(obj, prop, propNames, options, propGridDefinition);
    if (prop.name === "rateValues" && res.columns[0].name == "icon") res.showHeader = res.columns > 3;
    return res;
  }
  getMinimumRowCount(obj, prop, options) {
    if (prop.name === "choices") return options.minimumChoicesCount;
    return super.getMaximumRowCount(obj, prop, options);
  }
  getMaximumRowCount(obj, prop, options) {
    if (prop.name === "choices") return options.maximumChoicesCount;
    if (prop.name === "rows") return options.maximumRowsCount;
    if (prop.name === "columns") return options.maximumColumnsCount;
    if (prop.name === "rateValues") return options.maximumRateValues;
    return super.getMaximumRowCount(obj, prop, options);
  }
  hasMultipleLanguage(items) {
    if (!items || !Array.isArray(items)) {
      return false;
    }
    for (var i = 0; i < items.length; i++) {
      if (items[i].locText.hasNonDefaultText()) {
        return true;
      }
    }
    return false;
  }
  hasVisibleIfOrEnableIf(items) {
    if (!items || !Array.isArray(items)) {
      return false;
    }
    for (var i = 0; i < items.length; i++) {
      if (!!items[i].visibleIf || items[i].enableIf) {
        return true;
      }
    }
    return false;
  }
  onMatrixCellCreated(obj, options) {
    super.onMatrixCellCreated(obj, options);
    function updateHtml(question, value) {
      const newValue = renamedIcons[value] || value;
      question.html = '<div class="spg-smiley-icon"><svg><use xlink:href="#icon-' + newValue + '"></use></svg></div>';
    }
    function changeValueCallback(sender, options2) {
      if (options2.name != "value") return;
      updateHtml(sender, options2.newValue);
    }
    if (obj instanceof QuestionRatingModel && options.columnName == "icon") {
      updateHtml(options.cellQuestion, options.cellQuestion.value);
      options.cellQuestion.onPropertyChanged.add(changeValueCallback);
    }
  }
  onMatrixCellValueChanged(obj, options) {
    if (obj instanceof QuestionRatingModel && options.columnName == "icon") {
      options.cellQuestion.html = options.cellQuestion.value;
    }
  }
};
var PropertyGridEditorMatrixRateValues = class extends PropertyGridEditorMatrixItemValues {
  fit(prop) {
    return prop.isArray && Serializer.isDescendantOf(prop.className, "itemvalue") && prop.name == "rateValues";
  }
  updateAllowAddRemove(matrixQuestion, obj) {
    matrixQuestion.allowRemoveRows = QuestionRatingAdornerViewModel.allowRemoveForElement(obj);
    matrixQuestion.allowAddRows = QuestionRatingAdornerViewModel.allowAddForElement(obj, matrixQuestion.maxRowCount);
  }
  onCreated(obj, question, prop, options, propGridDefinition) {
    super.onCreated(obj, question, prop, options, propGridDefinition);
    const matrixQuestion = question;
    const ratingQuestion = getQuestionFromObj(obj);
    this.updateAllowAddRemove(matrixQuestion, ratingQuestion);
    obj.onPropertyChanged.add((sender, options2) => {
      if (options2.name == "rateCount" || options2.name == "rateDisplayMode") {
        this.updateAllowAddRemove(matrixQuestion, ratingQuestion);
      }
    });
  }
  onGetQuestionTitleActions(obj, options, creator) {
    const clearAction = options.titleActions.filter((a) => a.id == "property-grid-clear")[0];
    if (clearAction) clearAction.visible = false;
    super.onGetQuestionTitleActions(obj, options, creator);
  }
  filterPropertyNames(propNames, options) {
    return this.excludeTextPropertyName(propNames, options);
  }
};
var PropertyGridEditorMatrixColumns = class extends PropertyGridEditorMatrix {
  fit(prop) {
    return prop.type == "matrixdropdowncolumns";
  }
  getEditItemAsStandAlone() {
    return true;
  }
  getDefaulColumnNames() {
    return ["name", "title"];
  }
  getKeyValue() {
    return "name";
  }
  getBaseValue(prop) {
    return "column";
  }
  getMaximumRowCount(obj, prop, options) {
    return options.maximumColumnsCount;
  }
  getAllowRowDragDrop(prop) {
    return true;
  }
};
var PropertyGridEditorMatrixLayoutColumns = class extends PropertyGridEditorMatrix {
  fit(prop) {
    return prop.type == "panellayoutcolumns";
  }
  getDefaulColumnNames() {
    return ["width", "questionTitleWidth"];
  }
  onMatrixCellCreated(obj, options) {
    super.onMatrixCellCreated(obj, options);
    const q = options.cellQuestion;
    q.textUpdateMode = "onTyping";
  }
  getHasAddButton() {
    return false;
  }
  onCreated(obj, question, prop, options, propGridDefinition) {
    super.onCreated(obj, question, prop, options, propGridDefinition);
    const matrixQuestion = question;
    matrixQuestion.allowRemoveRows = false;
    matrixQuestion.allowAddRows = false;
  }
};
var PropertyGridEditorMatrixPages = class extends PropertyGridEditorMatrix {
  fit(prop) {
    return prop.type == "surveypages";
  }
  addItem(creator, obj, question) {
    if (creator.canAddPage()) {
      super.addItem(creator, obj, question);
    }
  }
  getColumnClassName(obj, prop) {
    return "page@" + obj.getType();
  }
  getDefaulColumnNames() {
    return ["name", "title"];
  }
  hasDetailPanel() {
    return false;
  }
  getKeyValue() {
    return "name";
  }
  getBaseValue(prop) {
    return "page";
  }
  getAllowRowDragDrop(prop) {
    return true;
  }
};
var PropertyGridEditorMatrixCalculatedValues = class extends PropertyGridEditorMatrix {
  fit(prop) {
    return prop.type == "calculatedvalues";
  }
  getColumnClassName(obj, prop) {
    return "calculatedvalue@items";
  }
  getDefaulColumnNames() {
    return ["name"];
  }
  getKeyValue() {
    return "name";
  }
  getBaseValue(prop) {
    return "var";
  }
  getShowDetailPanelOnAdding() {
    return true;
  }
  setupMatrixQuestion(obj, matrix, prop, propGridDefinition) {
    super.setupMatrixQuestion(obj, matrix, prop, propGridDefinition);
    matrix.useCaseSensitiveComparison = false;
  }
};
var PropertyGridEditorMatrixHtmlConditions = class extends PropertyGridEditorMatrix {
  fit(prop) {
    return prop.type == "htmlconditions";
  }
  getDefaulColumnNames() {
    return ["html"];
  }
  getShowDetailPanelOnAdding() {
    return true;
  }
};
var PropertyGridEditorMatrixUrlConditions = class extends PropertyGridEditorMatrix {
  fit(prop) {
    return prop.type == "urlconditions";
  }
  getDefaulColumnNames() {
    return ["url"];
  }
  getShowDetailPanelOnAdding() {
    return true;
  }
};
var PropertyGridEditorMatrixMutlipleTextItems = class extends PropertyGridEditorMatrix {
  fit(prop) {
    return prop.type == "textitem[]";
  }
  getEditItemAsStandAlone() {
    return true;
  }
  getColumnClassName(obj, prop) {
    return "multipletext@items";
  }
  getDefaulColumnNames() {
    return ["name"];
  }
  getKeyValue() {
    return "name";
  }
  getBaseValue(prop) {
    return "item";
  }
  getAllowRowDragDrop() {
    return true;
  }
  createPropertyEditorSetup(obj, prop, question, options) {
    var names = [];
    question.columns.forEach((col) => {
      names.push(col.name);
    });
    return new FastEntryEditorBase(obj[prop.name], options, prop.className, names);
  }
  onMatrixCellCreated(obj, options) {
    super.onMatrixCellCreated(obj, options);
    const q = options.cellQuestion;
    if (!options.row.editingObj) return;
    const editor = options.row.editingObj.editor;
    if (!!editor && !!q.property) {
      editor.registerFunctionOnPropertyValueChanged(q.property.name, () => {
        q.value = Serializer.getObjPropertyValue(editor, q.property.name);
      });
    }
  }
};
var PropertyGridEditorMatrixMultipleTypes = class extends PropertyGridEditorMatrix {
  getColumnsJSON(obj, prop, propNames, options, propGridDefinition) {
    var res = super.getColumnsJSON(obj, prop, propNames, options, propGridDefinition);
    if (!!this.getObjTypeName()) {
      res.unshift({
        name: this.getObjTypeName(),
        cellType: "dropdown"
      });
    }
    return res;
  }
  onMatrixCellCreated(obj, options) {
    super.onMatrixCellCreated(obj, options);
    if (!options.row.editingObj) return;
    const q = options.cellQuestion;
    if (options.columnName === this.getObjTypeName()) {
      q.showOptionsCaption = false;
      q.choices = this.getChoices(obj);
      q.value = options.row.editingObj.getType();
    }
  }
  onMatrixCellValueChanged(obj, options) {
    if (options.columnName !== this.getObjTypeName()) return;
    var index = options.question.visibleRows.indexOf(options.row);
    if (index < 0) return;
    var isDetailPanelShowing = options.row.isDetailPanelShowing;
    var objJSON = options.row.editingObj.toJSON();
    delete objJSON.type;
    var newItem = Serializer.createClass(options.value);
    newItem.fromJSON(objJSON);
    newItem[this.getObjTypeName()] = newItem.getType();
    options.row.hideDetailPanel(true);
    options.question.value.splice(index, 1, newItem);
    options.row.value = newItem;
    if (isDetailPanelShowing) {
      options.row.showDetailPanel();
    }
  }
  getShowDetailPanelOnAdding() {
    return true;
  }
};
var PropertyGridEditorMatrixValidators = class extends PropertyGridEditorMatrixMultipleTypes {
  fit(prop) {
    return prop.type == "validators";
  }
  getObjTypeName() {
    return "validatorType";
  }
  getDefaultClassName(obj, prop) {
    let res = "expression";
    const question = obj;
    if (!!question.getSupportedValidators) {
      const validators = question.getSupportedValidators();
      if (validators.length > 0 && validators.indexOf(res) < 0) {
        res = validators[0];
      }
    }
    return res + "validator";
  }
  getChoices(obj) {
    var names = this.getSupportedValidators(obj);
    var res = [];
    for (var i = 0; i < names.length; i++) {
      var name = names[i] + "validator";
      res.push({
        value: name,
        text: editorLocalization.getValidatorName(name)
      });
    }
    return res;
  }
  getSupportedValidators(obj) {
    if (!obj) return [];
    if (obj.getSupportedValidators) return obj.getSupportedValidators();
    if (obj.getOriginalObj) return this.getSupportedValidators(obj.getOriginalObj());
    return [];
  }
};
var PropertyGridEditorMatrixTriggers = class extends PropertyGridEditorMatrixMultipleTypes {
  getAvailableTriggers() {
    return Serializer.getChildrenClasses("surveytrigger", true).filter((classObj) => this.isTriggerVisible(classObj.name));
  }
  isTriggerVisible(name) {
    const postfix = "trigger";
    const pureName = name.substring(0, name.length - postfix.length);
    return name !== "visibletrigger" && settings2.logic.invisibleTriggers.indexOf(pureName) < 0;
  }
  fit(prop) {
    return prop.type == "triggers";
  }
  getObjTypeName() {
    return "triggerType";
  }
  getDefaultClassName(obj, prop) {
    const classes = this.getAvailableTriggers().map((tr) => tr.name);
    if (!classes.length) return prop.name;
    if (classes.indexOf("runexpressiontrigger") !== -1) {
      return "runexpressiontrigger";
    } else {
      return classes[0];
    }
  }
  getAllowRowDragDrop(prop) {
    return true;
  }
  getChoices(obj) {
    return this.getAvailableTriggers().map((tr) => {
      return {
        value: tr.name,
        text: editorLocalization.getTriggerName(tr.name)
      };
    });
  }
};
PropertyGridEditorCollection.register(new PropertyGridEditorMatrixItemValues());
PropertyGridEditorCollection.register(new PropertyGridEditorMatrixRateValues());
PropertyGridEditorCollection.register(new PropertyGridEditorMatrixColumns());
PropertyGridEditorCollection.register(new PropertyGridEditorMatrixPages());
PropertyGridEditorCollection.register(new PropertyGridEditorMatrixCalculatedValues());
PropertyGridEditorCollection.register(new PropertyGridEditorMatrixHtmlConditions());
PropertyGridEditorCollection.register(new PropertyGridEditorMatrixUrlConditions());
PropertyGridEditorCollection.register(new PropertyGridEditorMatrixMutlipleTextItems());
PropertyGridEditorCollection.register(new PropertyGridEditorMatrixValidators());
PropertyGridEditorCollection.register(new PropertyGridEditorMatrixTriggers());
PropertyGridEditorCollection.register({
  fit: function(prop) {
    if (prop.name === "icon") {
      return prop.classInfo.name === "itemvalue";
    }
    return false;
  },
  getJSON: function(obj) {
    return {
      "type": "html"
    };
  }
});
PropertyGridEditorCollection.register(new PropertyGridEditorMatrixLayoutColumns());
var json$3 = {
  name: "propertygrid_bindings",
  showInToolbox: false,
  internal: true,
  createElements: function() {
  }
};
if (!ComponentCollection.Instance.getCustomQuestionByName(json$3.name)) {
  ComponentCollection.Instance.add(json$3);
}
var PropertyGridEditorBindings = class extends PropertyGridEditor {
  fit(prop) {
    return prop.type == "bindings";
  }
  getJSON() {
    const res = {
      type: "propertygrid_bindings"
    };
    return res;
  }
  onCreated(obj, question, prop, options) {
    question.contentPanel.fromJSON({
      elements: this.getQuestions(obj, options)
    });
    question.valueFromDataCallback = (value) => {
      if (!value && obj.bindings.getNames().length > 0) {
        const result = {};
        for (const bindingName of obj.bindings.getNames()) {
          result[bindingName] = obj.bindings.getValueNameByPropertyName(bindingName);
        }
        return result;
      }
      return value;
    };
  }
  getQuestions(obj, options) {
    const res = [];
    for (const bindingName of obj.bindings.getNames()) {
      res.push(this.getBindingJSON(bindingName, obj, options));
    }
    return res;
  }
  getBindingJSON(bindingName, obj, options) {
    const prop = new JsonObjectProperty(null, "value");
    prop.type = "questionvalue";
    const json2 = PropertyGridEditorCollection.getJSON(obj, prop, options);
    json2.titleLocation = "left";
    json2.descriptionLocation = "hidden";
    json2.minWidth = "0px";
    json2.name = bindingName;
    json2.title = editorLocalization.getPropertyName(bindingName);
    return json2;
  }
};
PropertyGridEditorCollection.register(new PropertyGridEditorBindings());
var json$2 = {
  name: "propertygrid_restfull",
  showInToolbox: false,
  internal: true,
  createElements: function(panel) {
  }
};
if (!ComponentCollection.Instance.getCustomQuestionByName(json$2.name)) {
  ComponentCollection.Instance.add(json$2);
}
var PropertyGridEditorQuestionRestfull = class extends PropertyGridEditorQuestion {
  fit(prop) {
    return prop.type == "restfull";
  }
  getJSON(obj, prop, options) {
    return {
      type: "propertygrid_restfull",
      titleLocation: "hidden"
    };
  }
  onCreated(obj, question, prop, options, propGridDefinition) {
    const panel = question["contentPanel"];
    const choicesByUrl = obj[prop.name];
    new PropertyJSONGenerator(choicesByUrl, options, obj, prop, propGridDefinition).setupObjPanel(panel, true);
    const test = panel.addNewQuestion("dropdown", "test");
    test.title = editorLocalization.getString("ed.choicesLoadedFromWebPreviewTitle");
    test.choices = [];
    this.updateTestQuestion(test, choicesByUrl);
  }
  onValueChanged(obj, prop, question) {
    if (prop.name !== "choicesByUrl") return;
    const panel = question["contentPanel"];
    const test = panel.getQuestionByName("test");
    this.updateTestQuestion(test, obj[prop.name]);
  }
  updateTestQuestion(test, choicesByUrl) {
    if (!choicesByUrl) return;
    test.visible = !!choicesByUrl.url;
    test.choicesByUrl.setData(choicesByUrl);
  }
};
PropertyGridEditorCollection.register(new PropertyGridEditorQuestionRestfull());
var PropertyGridEditorFontSettings = class extends PropertyGridEditor {
  fit(prop) {
    return prop.type == "font";
  }
  getJSON(obj, prop, options) {
    return {
      type: "font",
      descriptionLocation: "hidden"
    };
  }
  onCreated(obj, question, prop) {
    question.valueFromDataCallback = function(val) {
      return val;
    };
    question.valueToDataCallback = function(val) {
      return val;
    };
  }
};
PropertyGridEditorCollection.register(new PropertyGridEditorFontSettings());
var PropertyGridEditorBackgroundCornerRadius = class extends PropertyGridEditor {
  fit(prop) {
    return prop.type == "backgroundcornerradius";
  }
  getJSON(obj, prop, options) {
    return {
      type: "backgroundcornerradius",
      descriptionLocation: "hidden"
    };
  }
  onCreated(obj, question, prop) {
    question.valueFromDataCallback = function(val) {
      return val;
    };
    question.valueToDataCallback = function(val) {
      return val;
    };
  }
};
PropertyGridEditorCollection.register(new PropertyGridEditorBackgroundCornerRadius());
var PropertyGridEditorShadowEffects = class extends PropertyGridEditor {
  fit(prop) {
    return prop.type == "shadoweffects";
  }
  getJSON(obj, prop, options) {
    return {
      type: "shadoweffects",
      descriptionLocation: "hidden"
    };
  }
};
PropertyGridEditorCollection.register(new PropertyGridEditorShadowEffects());
var CellsEditor = class extends PropertyEditorSetupValue {
  constructor(matrix, options = null) {
    super(options);
    this.matrix = matrix;
    this.editMatrixValue = this.editSurvey.getQuestionByName("question");
    this.buildColumns();
    this.buildRows();
    this.editMatrix.value = this.matrix.cells.getJson();
  }
  getSurveyJSON() {
    return {
      elements: [{
        type: "matrixdropdown",
        name: "question",
        cellType: "comment"
      }]
    };
  }
  getSurveyCreationReason() {
    return "cells-editor";
  }
  get editMatrix() {
    return this.editMatrixValue;
  }
  apply() {
    this.matrix.cells.setJson(this.editMatrix.value);
    return true;
  }
  buildColumns() {
    var columns = this.matrix.columns;
    for (var i = 0; i < columns.length; i++) {
      this.editMatrix.addColumn("" + columns[i].value, columns[i].text);
    }
  }
  buildRows() {
    this.editMatrix.rows.push(new ItemValue("default", editorLocalization.getString("pe.cellsDefaultRow")));
    var rows = this.matrix.rows;
    for (var i = 0; i < rows.length; i++) {
      this.editMatrix.rows.push(new ItemValue(rows[i].value, rows[i].text));
    }
  }
};
var DefaultValueEditor = class extends PropertyEditorSetupValue {
  constructor(editQuestion, propertyName, options = null) {
    super(options, false);
    this.editQuestion = editQuestion;
    this.propertyName = propertyName;
    this.setupSurvey();
    const oldValue = this.getQuestionValue();
    if (oldValue !== void 0) {
      this.question.value = oldValue;
    }
  }
  get question() {
    return this.editSurvey.getQuestionByName("question");
  }
  getSurveyJSON() {
    return {
      elements: [this.getQuestionJSON()]
    };
  }
  getQuestionJSON() {
    var json2 = this.editQuestion.toJSON();
    json2.name = "question";
    json2.title = json2.title || this.editQuestion.name;
    json2.type = this.editQuestion.getType();
    if (json2.type == "expression") {
      json2.type = "text";
    }
    if (!!json2.cellType && json2.type == "matrixdropdowncolumn") {
      json2.type = json2.cellType;
      delete json2["cellType"];
    }
    SurveyHelper.updateQuestionJson(json2);
    return json2;
  }
  getQuestionValue() {
    return this.editQuestion[this.propertyName];
  }
  getEditValue() {
    return this.question.value;
  }
  getSurveyCreationReason() {
    return "default-value";
  }
  apply() {
    this.editQuestion[this.propertyName] = this.getEditValue();
    return true;
  }
};
var DefaultArrayValueEditor = class extends DefaultValueEditor {
  constructor(editQuestion, propertyName, options = null) {
    super(editQuestion, propertyName, options);
    this.editQuestion = editQuestion;
    this.propertyName = propertyName;
  }
  getQuestionValue() {
    var res = super.getQuestionValue();
    if (!res) return res;
    if (!Array.isArray(res)) {
      res = [res];
    }
    return res;
  }
  getEditValue() {
    var res = super.getEditValue();
    if (res && Array.isArray(res)) {
      if (res.length == 0) return null;
      return res[0];
    }
    return res;
  }
};
var DefaultMatrixRowValueEditor = class extends DefaultArrayValueEditor {
  constructor(editQuestion, propertyName, options = null) {
    super(editQuestion, propertyName, options);
    this.editQuestion = editQuestion;
    this.propertyName = propertyName;
  }
  getQuestionJSON() {
    var json2 = super.getQuestionJSON();
    json2.type = "matrixdynamic";
    json2.rowCount = 1;
    json2.minRowCount = 1;
    json2.maxRowCount = 1;
    json2.columnsLocation = "vertical";
    delete json2.defaultValue;
    return json2;
  }
};
var DefaultPanelDynamicPanelValueEditor = class extends DefaultArrayValueEditor {
  constructor(editQuestion, propertyName, options = null) {
    super(editQuestion, propertyName, options);
    this.editQuestion = editQuestion;
    this.propertyName = propertyName;
  }
  getQuestionJSON() {
    var json2 = super.getQuestionJSON();
    json2.panelCount = 1;
    json2.minPanelCount = 1;
    json2.maxPanelCount = 1;
    return json2;
  }
};
var TriggerValueEditor = class extends DefaultValueEditor {
  constructor(editQuestion, editObj, propertyName, options = null) {
    super(editQuestion, propertyName, options);
    this.editQuestion = editQuestion;
    this.editObj = editObj;
    this.propertyName = propertyName;
    this.question.value = this.getQuestionValue();
  }
  getQuestionValue() {
    return !!this.editObj ? this.editObj[this.propertyName] : null;
  }
  apply() {
    this.editObj[this.propertyName] = this.question.value;
    return true;
  }
};
var PropertyGridValueEditorBase = class extends PropertyGridEditor {
  constructor() {
    super(...arguments);
    this.onCreated = (obj, question, prop, options) => {
      const linkQuestion = question;
      linkQuestion.isClickableCallback = () => {
        return !linkQuestion.isReadOnly || !this.isValueEmpty(linkQuestion.value);
      };
      linkQuestion.linkClickCallback = () => {
        this.showModalPropertyEditor(this, prop, question, options, () => linkQuestion.isSelected = false);
        linkQuestion.isSelected = true;
      };
      linkQuestion.clearClickCallback = () => {
        this.clearPropertyValue(
          question.obj,
          prop,
          question,
          null
          /*this.options*/
        );
      };
    };
  }
  getJSON(obj, prop, options) {
    return {
      type: "linkvalue",
      showValueInLink: false,
      titleLocation: "hidden"
    };
  }
  clearPropertyValue(obj, prop, question, options) {
    obj[prop.name] = void 0;
  }
  isValueEmpty(val) {
    return Helpers.isValueEmpty(val);
  }
  isSupportGrouping() {
    return true;
  }
};
var PropertyGridCellsEditor = class extends PropertyGridValueEditorBase {
  fit(prop) {
    return prop.type == "cells";
  }
  createPropertyEditorSetup(obj, prop, question, options) {
    return new CellsEditor(obj, options);
  }
  clearPropertyValue(obj, prop, question, options) {
    obj.cells.setJson(null);
  }
  isValueEmpty(val) {
    if (!val) return true;
    return Helpers.isValueEmpty(val.values);
  }
};
var PropertyGridValueEditor = class extends PropertyGridValueEditorBase {
  fit(prop) {
    return prop.type == "value";
  }
  createPropertyEditorSetup(obj, prop, question, options) {
    return new DefaultValueEditor(obj, prop.name, options);
  }
};
var PropertyGridRowValueEditor = class extends PropertyGridValueEditorBase {
  fit(prop) {
    return prop.type == "rowvalue";
  }
  createPropertyEditorSetup(obj, prop, question, options) {
    return new DefaultMatrixRowValueEditor(obj, prop.name, options);
  }
};
var PropertyGridPanelValueEditor = class extends PropertyGridValueEditorBase {
  fit(prop) {
    return prop.type == "panelvalue";
  }
  createPropertyEditorSetup(obj, prop, question, options) {
    return new DefaultPanelDynamicPanelValueEditor(obj, prop.name, options);
  }
};
var PropertyGridTriggerValueEditor = class extends PropertyGridValueEditorBase {
  fit(prop) {
    return prop.type == "triggervalue";
  }
  createPropertyEditorSetup(obj, prop, question, options) {
    const trigger = question.obj;
    const setQuestion = this.getSetToNameQuestion(trigger);
    return new TriggerValueEditor(setQuestion, trigger, prop.name, options);
  }
  getSetToNameQuestion(obj) {
    let survey = obj.getSurvey();
    if (!survey) {
      survey = obj["owner"];
    }
    if (!obj["setToName"] || !survey) return null;
    return survey.getQuestionByValueName(obj["setToName"]);
  }
};
var PropertyGridTriggerValueInLogicEditor = class extends PropertyGridTriggerValueEditor {
  fit(prop, context) {
    return context === "logic" && prop.type == "triggervalue";
  }
  getJSON(obj, prop, options) {
    const setQuestion = this.getSetToNameQuestion(obj);
    if (!setQuestion) return {
      type: "linkvalue"
    };
    const json2 = setQuestion.toJSON();
    json2.type = setQuestion.getType();
    SurveyHelper.updateQuestionJson(json2);
    return json2;
  }
};
PropertyGridEditorCollection.register(new PropertyGridCellsEditor());
PropertyGridEditorCollection.register(new PropertyGridValueEditor());
PropertyGridEditorCollection.register(new PropertyGridRowValueEditor());
PropertyGridEditorCollection.register(new PropertyGridPanelValueEditor());
PropertyGridEditorCollection.register(new PropertyGridTriggerValueEditor());
PropertyGridEditorCollection.register(new PropertyGridTriggerValueInLogicEditor());
var json$1 = {
  name: "propertygrid_masksettings",
  showInToolbox: false,
  internal: true,
  createElements: function(panel) {
  }
};
if (!ComponentCollection.Instance.getCustomQuestionByName(json$1.name)) {
  ComponentCollection.Instance.add(json$1);
}
var PropertyGridEditorQuestionMaskSettings = class extends PropertyGridEditor {
  fit(prop) {
    return prop.type == "masksettings";
  }
  getJSON(obj, prop, options) {
    return {
      type: "propertygrid_masksettings",
      titleLocation: "hidden"
    };
  }
  onCreated(obj, question, prop, options) {
    const masksettings = obj[prop.name];
    this._propertyGrid = new PropertyJSONGenerator(masksettings, options, obj, prop);
    this._prevMaskType = "";
    const panel = question["contentPanel"];
    this._previewQuestion = panel.addNewQuestion("html", "preview");
    this.updatePanel(obj, question, prop);
  }
  onValueChanged(obj, prop, question) {
    if (prop.name === "maskSettings") {
      this.updatePanel(obj, question, prop);
    }
  }
  updatePanel(obj, question, prop) {
    const panel = question["contentPanel"];
    const masksettings = obj[prop.name];
    if (this._prevMaskType !== obj["maskType"]) {
      this._propertyGrid.obj = masksettings;
      this._propertyGrid.setupObjPanel(panel, true);
      this._prevMaskType = obj["maskType"];
    }
    if (masksettings.getType() == "datetimemask") {
      this.updateDateTimeMinMaxInputType(masksettings, panel);
    }
    this.updatePreviewQuestion(masksettings, panel);
  }
  updateDateTimeMinMaxInputType(masksettings, panel) {
    let inputType = "datetime-local";
    if (!masksettings.hasDatePart) inputType = "time";
    if (!masksettings.hasTimePart) inputType = "date";
    panel.getQuestionByName("min").inputType = inputType;
    panel.getQuestionByName("max").inputType = inputType;
  }
  updatePreviewQuestion(masksettings, panel) {
    this._previewQuestion.visible = masksettings.getType() === "masksettings";
    if (!panel.getElementByName(this._previewQuestion.name)) {
      panel.addElement(this._previewQuestion);
    }
  }
};
PropertyGridEditorCollection.register(new PropertyGridEditorQuestionMaskSettings());
var json = {
  name: "propertygrid_header",
  showInToolbox: false,
  internal: true,
  createElements: function(panel) {
  }
};
if (!ComponentCollection.Instance.getCustomQuestionByName(json.name)) {
  ComponentCollection.Instance.add(json);
}
var PropertyGridEditorQuestionHeader = class extends PropertyGridEditor {
  fit(prop) {
    return prop.type == "header";
  }
  getJSON(obj, prop, options) {
    return {
      type: "propertygrid_header",
      titleLocation: "hidden"
    };
  }
  onCreated(obj, question, prop, options, propGridDefinition) {
    const panel = question["contentPanel"];
    const header = obj[prop.name];
    const propertyGenerator = new PropertyJSONGenerator(header, options, obj, prop, themeModelPropertyGridDefinition);
    propertyGenerator.setupObjPanel(panel, true);
    let settingsPanel;
    var questions = panel.elements;
    for (var i = 0; i < questions.length; i++) {
      if (questions[i].name == "settings") {
        settingsPanel = questions[i];
      }
    }
    settingsPanel.state = void 0;
    settingsPanel.title = "";
    settingsPanel.elements.forEach((el) => {
      el.title = "";
      el.state = void 0;
    });
  }
};
PropertyGridEditorCollection.register(new PropertyGridEditorQuestionHeader());
var CreatorPresetBase = class {
  constructor() {
    this.onApplied = new EventBase();
    this.children = [];
    this.setupPresets();
  }
  setJson(json2) {
    if (!json2 && this.applyEmptyJson()) json2 = {};
    this.json = json2;
    this.children.forEach((item) => item.setJson(this.json && item.getPath() ? this.json[item.getPath()] : this.json));
  }
  apply(creator) {
    if (!this.json) return;
    if (!!creator) {
      this.applyCore(creator);
      this.children.forEach((item) => item.apply(creator));
    }
    this.onApplied.fire(this, {});
  }
  applyEmptyJson() {
    return false;
  }
  applyCore(creator) {
  }
  createPresets() {
    return [];
  }
  setupPresets() {
    this.addPresets(this.createPresets());
  }
  addPreset(preset) {
    this.children.push(preset);
  }
  addPresets(presets) {
    presets.forEach((preset) => this.addPreset(preset));
  }
};
var CreatorPresetToolboxDefinition = class extends CreatorPresetBase {
  getPath() {
    return "definition";
  }
  applyCore(creator) {
    super.applyCore(creator);
    this.applyDefinition(creator, this.json);
  }
  applyDefinition(creator, definition) {
    const toolbox = creator.toolbox;
    toolbox.presetDefaultItems = this.getPresetDefaultItems(definition);
    if (Array.isArray(definition)) {
      definition.forEach((item) => {
        const tItem = toolbox.getActionById(item.name);
        if (tItem) {
          ["iconName", "title", "tooltip", "json"].forEach((propName) => {
            if (item[propName]) {
              tItem[propName] = item[propName];
            }
          });
        }
      });
    }
  }
  getPresetDefaultItems(defintion) {
    if (!Array.isArray(defintion)) return void 0;
    const def = JSON.parse(JSON.stringify(defintion));
    const res = new Array();
    def.forEach((item) => {
      if (typeof item === "object" && !!item.name) {
        res.push(item);
      }
    });
    return res;
  }
};
var CreatorPresetToolboxConfigurator = class extends CreatorPresetBase {
  getPath() {
    return "";
  }
  applyCore(creator) {
    if (!this.json) return;
    super.applyCore(creator);
    creator.toolbox.showCategoryTitles = this.json.showCategoryTitles;
    this.applyItems(creator, this.json["items"]);
    this.applyCategories(creator, this.json["categories"]);
  }
  applyItems(creator, items) {
    if (!Array.isArray(items)) return;
    creator.toolbox.hasCategories = false;
    creator.toolbox.defineCategories([{
      category: "general",
      items
    }]);
  }
  applyCategories(creator, categories) {
    if (!Array.isArray(categories)) return;
    creator.toolbox.hasCategories = true;
    creator.toolbox.defineCategories(categories);
  }
};
var CreatorPresetToolbox = class extends CreatorPresetBase {
  getPath() {
    return "toolbox";
  }
  createPresets() {
    return [new CreatorPresetToolboxDefinition(), new CreatorPresetToolboxConfigurator()];
  }
};
var CreatorPresetLanguages = class extends CreatorPresetBase {
  getPath() {
    return "languages";
  }
  applyEmptyJson() {
    return true;
  }
  applyCore(creator) {
    var _a, _b, _c;
    super.applyCore(creator);
    const locale = ((_a = this.json) === null || _a === void 0 ? void 0 : _a.creator) || "";
    const supportedLocales = ((_b = this.json) === null || _b === void 0 ? void 0 : _b.surveyLocales) || [];
    const useEnglishNames = (_c = this.json) === null || _c === void 0 ? void 0 : _c.useEnglishNames;
    creator.locale = locale;
    surveyLocalization.supportedLocales = supportedLocales;
    surveyLocalization.showNamesInEnglish = useEnglishNames === true;
  }
};
var CreatorPresetTabs = class extends CreatorPresetBase {
  getPath() {
    return "tabs";
  }
  applyCore(creator) {
    super.applyCore(creator);
    const items = this.json["items"] || [];
    let tab = this.json.activeTab || (items.length > 0 ? items[0] : "");
    if (items.length > 0 && items.indexOf(tab) < 0) {
      tab = items[0];
    }
    if (!!tab && creator.activeTab !== tab) {
      const activePlugin = creator.getPlugin(creator.activeTab);
      if (!!(activePlugin === null || activePlugin === void 0 ? void 0 : activePlugin.deactivate)) {
        activePlugin.deactivate();
      }
    }
    this.applyTabs(creator, items);
    if (tab) {
      creator.activeTab = tab;
    }
  }
  applyTabs(creator, items) {
    if (!Array.isArray(items)) return;
    creator.setTabs(items);
  }
};
var CreatorPresetPropertyGridDefinition = class extends CreatorPresetBase {
  getPath() {
    return "definition";
  }
  applyCore(creator) {
    creator.setPropertyGridDefinition(this.json);
  }
};
var CreatorPresetPropertyGrid = class extends CreatorPresetBase {
  getPath() {
    return "propertyGrid";
  }
  createPresets() {
    return [new CreatorPresetPropertyGridDefinition()];
  }
};
var CreatorPreset = class extends CreatorPresetBase {
  constructor(json2) {
    super();
    this.setJson(json2);
  }
  getPath() {
    return "";
  }
  getJson() {
    return this.json;
  }
  apply(creator) {
    super.apply(creator);
    this.applyLocalization();
    if (!!creator) {
      creator.updateLocalizedStrings();
    }
  }
  applyLocalization() {
    var _a;
    const strs = (_a = this.json) === null || _a === void 0 ? void 0 : _a.localization;
    if (!!strs) {
      editorLocalization.presetStrings = JSON.parse(JSON.stringify(strs));
    } else {
      editorLocalization.presetStrings = void 0;
    }
  }
  createPresets() {
    return [new CreatorPresetLanguages(), new CreatorPresetTabs(), new CreatorPresetToolbox(), new CreatorPresetPropertyGrid()];
  }
};
var Version2;
Version2 = `${"2.0.0"}`;
checkLibraryVersion(`${"2.0.0"}`, "survey-creator-core");

export {
  Helpers,
  ResponsivityManager,
  VerticalResponsivityManager,
  getActionDropdownButtonTarget,
  ActionDropdownViewModel,
  LocalizableString,
  createSvg,
  doKey2ClickBlur,
  doKey2ClickUp,
  doKey2ClickDown,
  settings,
  RendererFactory,
  ProgressButtonsResponsivityManager,
  SurveyModel,
  DropdownListModel,
  DropdownMultiSelectListModel,
  SurveyProgressModel,
  PopupSurveyModel,
  createPopupModalViewModel,
  createPopupViewModel,
  ButtonGroupItemModel,
  SvgRegistry,
  addIconsToThemeSet,
  enStrings,
  roundTo2Decimals,
  clearNewLines,
  copyObject,
  copyCssClasses,
  capitalize,
  notShortCircuitAnd,
  imageMimeTypes,
  getAcceptedTypesByContentMode,
  trimEmptyFields,
  assign,
  getOS,
  EditorLocalization,
  editorLocalization,
  getLocString,
  defaultStrings,
  setupLocale,
  QuestionConvertMode,
  settings2,
  EmptySurveyCreatorOptions,
  SurveyJSON5,
  QuestionConverter,
  getNextItemValue,
  getNextItemText,
  getNextValue,
  propertyExists,
  isPropertyVisible,
  getQuestionFromObj,
  scrollElementIntoView,
  assignDefaultClasses,
  wrapTextByCurlyBraces,
  ObjType,
  SurveyHelper,
  SurveyTextWorkerError,
  SurveyTextWorkerParserError,
  SurveyTextWorkerJsonError,
  SurveyTextWorker,
  JsonDuplicateNameError,
  SearchManager,
  SearchManagerToolbox,
  listComponentCss,
  QuestionToolboxCategory,
  QuestionToolboxItem,
  QuestionToolbox,
  getFirstNonTextElement,
  findParentNode,
  getNodesFromKoComponentInfo,
  toggleHovered,
  select,
  saveToFileHandler,
  focusFirstControl,
  JsonEditorBaseModel,
  TabJsonEditorBasePlugin,
  AceJsonEditorModel,
  TabJsonEditorAcePlugin,
  TextareaJsonEditorModel,
  TabJsonEditorTextareaPlugin,
  SurveySimulatorModel,
  DEFAULT_MONITOR_DPI,
  simulatorDevices,
  Themes,
  PredefinedThemes,
  defaultThemesOrder,
  PredefinedColors,
  PredefinedBackgroundColors,
  getPredefinedColorsItemValues,
  getPredefinedBackgoundColorsChoices,
  DefaultFonts,
  updateFontSettingsJSON,
  fontsettingsToCssVariable,
  fontsettingsFromCssVariable,
  updateBackgroundCornerRadiusJSON,
  backgroundCornerRadiusToCssVariable,
  backgroundCornerRadiusFromCssVariable,
  updateShadowEffectsJSON,
  createBoxShadow,
  createBoxShadowReset,
  parseBoxShadow,
  trimBoxShadowValue,
  ColorCalculator,
  HueColorCalculator,
  ingectAlpha,
  convertRgbaToString,
  parseRgbaFromString,
  getRGBaChannelValues,
  parseColor,
  HEXToRGB,
  HSBToRGB,
  RGBToHSB,
  colorsAreEqual,
  UndoRedoManager,
  Transaction,
  UndoRedoAction,
  UndoRedoArrayAction,
  updatecoloralphaJSON,
  createColor,
  registerSurveyTheme,
  TestSurveyTabViewModel,
  TabTestPlugin,
  initLogicOperator,
  LogicEvent,
  SurveyLogic,
  propertyGridCss,
  defaultPropertyGridDefinition,
  SurveyQuestionEditorDefinition,
  SurveyQuestionEditorPropertyDefinition,
  SurveyQuestionEditorTabDefinition,
  SurveyQuestionProperties,
  setSurveyJSONForPropertyGrid,
  PropertyEditorSetupValue,
  PropertyGridEditorCollection,
  PropertyGridTitleActionsCreator,
  PropertyJSONGenerator,
  PropertyGridModel,
  PropertyGridEditor,
  PropertyGridEditorBoolean,
  PropertyGridEditorSwitchToggle,
  PropertyGridEditorUndefinedBoolean,
  PropertyGridEditorStringBase,
  PropertyGridEditorString,
  PropertyGridEditorDateTime,
  PropertyGridLinkEditor,
  PropertyGridEditorColor,
  PropertyGridEditorColorWithAlpha,
  PropertyGridEditorNumber,
  PropertyGridEditorSpinEdit,
  PropertyGridEditorImageSize,
  PropertyGridEditorText,
  PropertyGridEditorHtml,
  PropertyGridEditorStringArray,
  PropertyGridEditorDropdown,
  PropertyGridEditorSet,
  PropertyGridEditorPage,
  PropertyGridEditorQuestion,
  PropertyGridEditorQuestionSelectBase,
  PropertyGridEditorQuestionCarryForward,
  PropertyGridEditorQuestionValue,
  translationCss,
  MenuButton,
  calculateIsEdge,
  calculateIsSide,
  calculateDragOverLocation,
  isPanelDynamic,
  DragDropSurveyElements,
  TranslationItemBase,
  TranslationItemString,
  TranslationItem,
  TranslationGroup,
  Translation,
  TranslationForEditor,
  TranslationEditor,
  createImportCSVAction,
  createExportCSVAction,
  TabControlModel,
  TabTranslationPlugin,
  logicCss,
  SurveyLogicUI,
  TabLogicPlugin,
  UndoRedoPlugin,
  undoRedoTransaction,
  ignoreUndoRedo,
  ObjectSelectorItem,
  ObjectSelector,
  ObjectSelectorModel,
  SearchManagerPropertyGrid,
  PropertyGridViewModel,
  PagesController,
  initialSettingsAllowShowEmptyTitleInDesignMode,
  TabDesignerViewModel,
  creatorThemeModelPropertyGridDefinition,
  creatorThemeModelEditorDefinition,
  PredefinedCreatorThemes,
  defaultCreatorThemesOrder,
  registerCreatorTheme,
  CreatorThemes,
  CreatorThemeModel,
  TabDesignerPlugin,
  CreatorResponsivityManager,
  SidebarPageModel,
  SidebarHeaderModel,
  ResizeManager,
  SidebarModel,
  StringItemsNavigatorBase,
  StringEditorConnector,
  StringEditorViewModelBase,
  ThemeTabViewModel,
  Switcher,
  themeModelPropertyGridDefinition,
  ThemeModelEditorDefinition,
  ThemeTabPlugin,
  TabbedMenuItem,
  TabbedMenuContainer,
  svgBundle,
  iconsV1,
  iconsV2,
  CreatorAction,
  FooterToolbarActionContainer,
  ToolbarActionContainer,
  CreatorEvent,
  SurveyCreatorModel,
  CreatorBase,
  initializeDesignTimeSurveyModel,
  editableStringRendererName,
  getElementWrapperComponentName,
  getQuestionContentWrapperComponentName,
  getElementWrapperComponentData,
  getItemValueWrapperComponentName,
  getItemValueWrapperComponentData,
  isStringEditable,
  isTextInput,
  registerAdorner,
  removeAdorners,
  ToolboxToolViewModel,
  PageNavigatorViewModel,
  PageAdorner,
  RowViewModel,
  QuestionAdornerViewModel,
  QuestionDropdownAdornerViewModel,
  QuestionImageAdornerViewModel,
  QuestionRatingAdornerViewModel,
  ItemValueWrapperViewModel,
  ImageItemValueWrapperViewModel,
  MatrixCellWrapperEditSurvey,
  MatrixCellWrapperViewModel,
  SurveyResultsItemModel,
  SurveyResultsModel,
  LogoImageViewModel,
  QuestionEmbeddedSurveyModel,
  QuestionLinkValueModel,
  ScrollViewModel,
  QuestionSpinEditorModel,
  QuestionColorModel,
  QuestionFileEditorModel,
  ResetValueAdorner,
  QuestionTextWithResetModel,
  QuestionCommentWithResetModel,
  PropertyGridEditorExpression,
  PropertyGridEditorCondition,
  PropertyGridEditorMatrix,
  PropertyGridEditorMatrixItemValues,
  PropertyGridEditorMatrixRateValues,
  PropertyGridEditorMatrixColumns,
  PropertyGridEditorMatrixLayoutColumns,
  PropertyGridEditorMatrixPages,
  PropertyGridEditorMatrixCalculatedValues,
  PropertyGridEditorMatrixHtmlConditions,
  PropertyGridEditorMatrixUrlConditions,
  PropertyGridEditorMatrixMutlipleTextItems,
  PropertyGridEditorMatrixMultipleTypes,
  PropertyGridEditorMatrixValidators,
  PropertyGridEditorMatrixTriggers,
  PropertyGridEditorBindings,
  PropertyGridEditorQuestionRestfull,
  PropertyGridEditorFontSettings,
  PropertyGridEditorBackgroundCornerRadius,
  PropertyGridEditorShadowEffects,
  PropertyGridValueEditorBase,
  PropertyGridCellsEditor,
  PropertyGridValueEditor,
  PropertyGridRowValueEditor,
  PropertyGridPanelValueEditor,
  PropertyGridTriggerValueEditor,
  PropertyGridTriggerValueInLogicEditor,
  PropertyGridEditorQuestionMaskSettings,
  PropertyGridEditorQuestionHeader,
  CreatorPresetBase,
  CreatorPresetToolboxDefinition,
  CreatorPresetToolboxConfigurator,
  CreatorPresetToolbox,
  CreatorPresetTabs,
  CreatorPresetPropertyGridDefinition,
  CreatorPresetPropertyGrid,
  CreatorPreset,
  Version2 as Version
};
/*! Bundled license information:

survey-core/fesm/survey-core.js:
  (*!
   * surveyjs - Survey JavaScript library v2.0.0
   * Copyright (c) 2015-2025 Devsoft Baltic O  - http://surveyjs.io/
   * License: MIT (http://www.opensource.org/licenses/mit-license.php)
   *)

survey-core/fesm/survey-core.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

survey-core/fesm/survey-core.js:
  (*!
   * Signature Pad v4.2.0 | https://github.com/szimek/signature_pad
   * (c) 2024 Szymon Nowak | Released under the MIT license
   *)

survey-creator-core/fesm/survey-creator-core.js:
  (*!
   * SurveyJS Creator v2.0.0
   * (c) 2015-2025 Devsoft Baltic O - http://surveyjs.io/
   * Github: https://github.com/surveyjs/survey-creator
   * License: https://surveyjs.io/Licenses#SurveyCreator
   *)

survey-creator-core/fesm/survey-creator-core.js:
  (* @license
  Papa Parse
  v5.5.2
  https://github.com/mholt/PapaParse
  License: MIT
  *)
*/
//# sourceMappingURL=chunk-KQPURX2Q.js.map
